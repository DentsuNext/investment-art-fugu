/******/ (() => { // webpackBootstrap
/******/ 	// runtime can't be in strict mode because a global variable is assign and maybe created.
/******/ 	var __webpack_modules__ = ({

/***/ 823:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ARRAY_TYPE: () => (/* binding */ ARRAY_TYPE),
/* harmony export */   EPSILON: () => (/* binding */ EPSILON),
/* harmony export */   RANDOM: () => (/* binding */ RANDOM),
/* harmony export */   equals: () => (/* binding */ equals),
/* harmony export */   setMatrixArrayType: () => (/* binding */ setMatrixArrayType),
/* harmony export */   toRadian: () => (/* binding */ toRadian)
/* harmony export */ });
/**
 * Common utilities
 * @module glMatrix
 */
// Configuration Constants
var EPSILON = 0.000001;
var ARRAY_TYPE = typeof Float32Array !== 'undefined' ? Float32Array : Array;
var RANDOM = Math.random;
/**
 * Sets the type of array used when creating new vectors and matrices
 *
 * @param {Type} type Array type, such as Float32Array or Array
 */

function setMatrixArrayType(type) {
  ARRAY_TYPE = type;
}
var degree = Math.PI / 180;
/**
 * Convert Degree To Radian
 *
 * @param {Number} a Angle in Degrees
 */

function toRadian(a) {
  return a * degree;
}
/**
 * Tests whether or not the arguments have approximately the same value, within an absolute
 * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less
 * than or equal to 1.0, and a relative tolerance is used for larger values)
 *
 * @param {Number} a The first number to test.
 * @param {Number} b The second number to test.
 * @returns {Boolean} True if the numbers are approximately equal, false otherwise.
 */

function equals(a, b) {
  return Math.abs(a - b) <= EPSILON * Math.max(1.0, Math.abs(a), Math.abs(b));
}
if (!Math.hypot) Math.hypot = function () {
  var y = 0,
      i = arguments.length;

  while (i--) {
    y += arguments[i] * arguments[i];
  }

  return Math.sqrt(y);
};

/***/ }),

/***/ 522:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LDU: () => (/* binding */ LDU),
/* harmony export */   add: () => (/* binding */ add),
/* harmony export */   adjoint: () => (/* binding */ adjoint),
/* harmony export */   clone: () => (/* binding */ clone),
/* harmony export */   copy: () => (/* binding */ copy),
/* harmony export */   create: () => (/* binding */ create),
/* harmony export */   determinant: () => (/* binding */ determinant),
/* harmony export */   equals: () => (/* binding */ equals),
/* harmony export */   exactEquals: () => (/* binding */ exactEquals),
/* harmony export */   frob: () => (/* binding */ frob),
/* harmony export */   fromRotation: () => (/* binding */ fromRotation),
/* harmony export */   fromScaling: () => (/* binding */ fromScaling),
/* harmony export */   fromValues: () => (/* binding */ fromValues),
/* harmony export */   identity: () => (/* binding */ identity),
/* harmony export */   invert: () => (/* binding */ invert),
/* harmony export */   mul: () => (/* binding */ mul),
/* harmony export */   multiply: () => (/* binding */ multiply),
/* harmony export */   multiplyScalar: () => (/* binding */ multiplyScalar),
/* harmony export */   multiplyScalarAndAdd: () => (/* binding */ multiplyScalarAndAdd),
/* harmony export */   rotate: () => (/* binding */ rotate),
/* harmony export */   scale: () => (/* binding */ scale),
/* harmony export */   set: () => (/* binding */ set),
/* harmony export */   str: () => (/* binding */ str),
/* harmony export */   sub: () => (/* binding */ sub),
/* harmony export */   subtract: () => (/* binding */ subtract),
/* harmony export */   transpose: () => (/* binding */ transpose)
/* harmony export */ });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(823);

/**
 * 2x2 Matrix
 * @module mat2
 */

/**
 * Creates a new identity mat2
 *
 * @returns {mat2} a new 2x2 matrix
 */

function create() {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(4);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
  }

  out[0] = 1;
  out[3] = 1;
  return out;
}
/**
 * Creates a new mat2 initialized with values from an existing matrix
 *
 * @param {mat2} a matrix to clone
 * @returns {mat2} a new 2x2 matrix
 */

function clone(a) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(4);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
/**
 * Copy the values from one mat2 to another
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
/**
 * Set a mat2 to the identity matrix
 *
 * @param {mat2} out the receiving matrix
 * @returns {mat2} out
 */

function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}
/**
 * Create a new mat2 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m10 Component in column 1, row 0 position (index 2)
 * @param {Number} m11 Component in column 1, row 1 position (index 3)
 * @returns {mat2} out A new 2x2 matrix
 */

function fromValues(m00, m01, m10, m11) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(4);
  out[0] = m00;
  out[1] = m01;
  out[2] = m10;
  out[3] = m11;
  return out;
}
/**
 * Set the components of a mat2 to the given values
 *
 * @param {mat2} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m10 Component in column 1, row 0 position (index 2)
 * @param {Number} m11 Component in column 1, row 1 position (index 3)
 * @returns {mat2} out
 */

function set(out, m00, m01, m10, m11) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m10;
  out[3] = m11;
  return out;
}
/**
 * Transpose the values of a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */

function transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache
  // some values
  if (out === a) {
    var a1 = a[1];
    out[1] = a[2];
    out[2] = a1;
  } else {
    out[0] = a[0];
    out[1] = a[2];
    out[2] = a[1];
    out[3] = a[3];
  }

  return out;
}
/**
 * Inverts a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */

function invert(out, a) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3]; // Calculate the determinant

  var det = a0 * a3 - a2 * a1;

  if (!det) {
    return null;
  }

  det = 1.0 / det;
  out[0] = a3 * det;
  out[1] = -a1 * det;
  out[2] = -a2 * det;
  out[3] = a0 * det;
  return out;
}
/**
 * Calculates the adjugate of a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */

function adjoint(out, a) {
  // Caching this value is nessecary if out == a
  var a0 = a[0];
  out[0] = a[3];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = a0;
  return out;
}
/**
 * Calculates the determinant of a mat2
 *
 * @param {mat2} a the source matrix
 * @returns {Number} determinant of a
 */

function determinant(a) {
  return a[0] * a[3] - a[2] * a[1];
}
/**
 * Multiplies two mat2's
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @returns {mat2} out
 */

function multiply(out, a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  out[0] = a0 * b0 + a2 * b1;
  out[1] = a1 * b0 + a3 * b1;
  out[2] = a0 * b2 + a2 * b3;
  out[3] = a1 * b2 + a3 * b3;
  return out;
}
/**
 * Rotates a mat2 by the given angle
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2} out
 */

function rotate(out, a, rad) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  out[0] = a0 * c + a2 * s;
  out[1] = a1 * c + a3 * s;
  out[2] = a0 * -s + a2 * c;
  out[3] = a1 * -s + a3 * c;
  return out;
}
/**
 * Scales the mat2 by the dimensions in the given vec2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to rotate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat2} out
 **/

function scale(out, a, v) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var v0 = v[0],
      v1 = v[1];
  out[0] = a0 * v0;
  out[1] = a1 * v0;
  out[2] = a2 * v1;
  out[3] = a3 * v1;
  return out;
}
/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat2.identity(dest);
 *     mat2.rotate(dest, dest, rad);
 *
 * @param {mat2} out mat2 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2} out
 */

function fromRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  out[0] = c;
  out[1] = s;
  out[2] = -s;
  out[3] = c;
  return out;
}
/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat2.identity(dest);
 *     mat2.scale(dest, dest, vec);
 *
 * @param {mat2} out mat2 receiving operation result
 * @param {vec2} v Scaling vector
 * @returns {mat2} out
 */

function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = v[1];
  return out;
}
/**
 * Returns a string representation of a mat2
 *
 * @param {mat2} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */

function str(a) {
  return 'mat2(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
}
/**
 * Returns Frobenius norm of a mat2
 *
 * @param {mat2} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */

function frob(a) {
  return Math.hypot(a[0], a[1], a[2], a[3]);
}
/**
 * Returns L, D and U matrices (Lower triangular, Diagonal and Upper triangular) by factorizing the input matrix
 * @param {mat2} L the lower triangular matrix
 * @param {mat2} D the diagonal matrix
 * @param {mat2} U the upper triangular matrix
 * @param {mat2} a the input matrix to factorize
 */

function LDU(L, D, U, a) {
  L[2] = a[2] / a[0];
  U[0] = a[0];
  U[1] = a[1];
  U[3] = a[3] - L[2] * U[1];
  return [L, D, U];
}
/**
 * Adds two mat2's
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @returns {mat2} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  return out;
}
/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @returns {mat2} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  return out;
}
/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat2} a The first matrix.
 * @param {mat2} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
}
/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat2} a The first matrix.
 * @param {mat2} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3));
}
/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat2} out
 */

function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  return out;
}
/**
 * Adds two mat2's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat2} out the receiving vector
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat2} out
 */

function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  return out;
}
/**
 * Alias for {@link mat2.multiply}
 * @function
 */

var mul = multiply;
/**
 * Alias for {@link mat2.subtract}
 * @function
 */

var sub = subtract;

/***/ }),

/***/ 964:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   add: () => (/* binding */ add),
/* harmony export */   clone: () => (/* binding */ clone),
/* harmony export */   copy: () => (/* binding */ copy),
/* harmony export */   create: () => (/* binding */ create),
/* harmony export */   determinant: () => (/* binding */ determinant),
/* harmony export */   equals: () => (/* binding */ equals),
/* harmony export */   exactEquals: () => (/* binding */ exactEquals),
/* harmony export */   frob: () => (/* binding */ frob),
/* harmony export */   fromRotation: () => (/* binding */ fromRotation),
/* harmony export */   fromScaling: () => (/* binding */ fromScaling),
/* harmony export */   fromTranslation: () => (/* binding */ fromTranslation),
/* harmony export */   fromValues: () => (/* binding */ fromValues),
/* harmony export */   identity: () => (/* binding */ identity),
/* harmony export */   invert: () => (/* binding */ invert),
/* harmony export */   mul: () => (/* binding */ mul),
/* harmony export */   multiply: () => (/* binding */ multiply),
/* harmony export */   multiplyScalar: () => (/* binding */ multiplyScalar),
/* harmony export */   multiplyScalarAndAdd: () => (/* binding */ multiplyScalarAndAdd),
/* harmony export */   rotate: () => (/* binding */ rotate),
/* harmony export */   scale: () => (/* binding */ scale),
/* harmony export */   set: () => (/* binding */ set),
/* harmony export */   str: () => (/* binding */ str),
/* harmony export */   sub: () => (/* binding */ sub),
/* harmony export */   subtract: () => (/* binding */ subtract),
/* harmony export */   translate: () => (/* binding */ translate)
/* harmony export */ });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(823);

/**
 * 2x3 Matrix
 * @module mat2d
 *
 * @description
 * A mat2d contains six elements defined as:
 * <pre>
 * [a, b, c,
 *  d, tx, ty]
 * </pre>
 * This is a short form for the 3x3 matrix:
 * <pre>
 * [a, b, 0,
 *  c, d, 0,
 *  tx, ty, 1]
 * </pre>
 * The last column is ignored so the array is shorter and operations are faster.
 */

/**
 * Creates a new identity mat2d
 *
 * @returns {mat2d} a new 2x3 matrix
 */

function create() {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(6);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[4] = 0;
    out[5] = 0;
  }

  out[0] = 1;
  out[3] = 1;
  return out;
}
/**
 * Creates a new mat2d initialized with values from an existing matrix
 *
 * @param {mat2d} a matrix to clone
 * @returns {mat2d} a new 2x3 matrix
 */

function clone(a) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(6);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  return out;
}
/**
 * Copy the values from one mat2d to another
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the source matrix
 * @returns {mat2d} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  return out;
}
/**
 * Set a mat2d to the identity matrix
 *
 * @param {mat2d} out the receiving matrix
 * @returns {mat2d} out
 */

function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  out[4] = 0;
  out[5] = 0;
  return out;
}
/**
 * Create a new mat2d with the given values
 *
 * @param {Number} a Component A (index 0)
 * @param {Number} b Component B (index 1)
 * @param {Number} c Component C (index 2)
 * @param {Number} d Component D (index 3)
 * @param {Number} tx Component TX (index 4)
 * @param {Number} ty Component TY (index 5)
 * @returns {mat2d} A new mat2d
 */

function fromValues(a, b, c, d, tx, ty) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(6);
  out[0] = a;
  out[1] = b;
  out[2] = c;
  out[3] = d;
  out[4] = tx;
  out[5] = ty;
  return out;
}
/**
 * Set the components of a mat2d to the given values
 *
 * @param {mat2d} out the receiving matrix
 * @param {Number} a Component A (index 0)
 * @param {Number} b Component B (index 1)
 * @param {Number} c Component C (index 2)
 * @param {Number} d Component D (index 3)
 * @param {Number} tx Component TX (index 4)
 * @param {Number} ty Component TY (index 5)
 * @returns {mat2d} out
 */

function set(out, a, b, c, d, tx, ty) {
  out[0] = a;
  out[1] = b;
  out[2] = c;
  out[3] = d;
  out[4] = tx;
  out[5] = ty;
  return out;
}
/**
 * Inverts a mat2d
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the source matrix
 * @returns {mat2d} out
 */

function invert(out, a) {
  var aa = a[0],
      ab = a[1],
      ac = a[2],
      ad = a[3];
  var atx = a[4],
      aty = a[5];
  var det = aa * ad - ab * ac;

  if (!det) {
    return null;
  }

  det = 1.0 / det;
  out[0] = ad * det;
  out[1] = -ab * det;
  out[2] = -ac * det;
  out[3] = aa * det;
  out[4] = (ac * aty - ad * atx) * det;
  out[5] = (ab * atx - aa * aty) * det;
  return out;
}
/**
 * Calculates the determinant of a mat2d
 *
 * @param {mat2d} a the source matrix
 * @returns {Number} determinant of a
 */

function determinant(a) {
  return a[0] * a[3] - a[1] * a[2];
}
/**
 * Multiplies two mat2d's
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @returns {mat2d} out
 */

function multiply(out, a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3],
      b4 = b[4],
      b5 = b[5];
  out[0] = a0 * b0 + a2 * b1;
  out[1] = a1 * b0 + a3 * b1;
  out[2] = a0 * b2 + a2 * b3;
  out[3] = a1 * b2 + a3 * b3;
  out[4] = a0 * b4 + a2 * b5 + a4;
  out[5] = a1 * b4 + a3 * b5 + a5;
  return out;
}
/**
 * Rotates a mat2d by the given angle
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2d} out
 */

function rotate(out, a, rad) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5];
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  out[0] = a0 * c + a2 * s;
  out[1] = a1 * c + a3 * s;
  out[2] = a0 * -s + a2 * c;
  out[3] = a1 * -s + a3 * c;
  out[4] = a4;
  out[5] = a5;
  return out;
}
/**
 * Scales the mat2d by the dimensions in the given vec2
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to translate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat2d} out
 **/

function scale(out, a, v) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5];
  var v0 = v[0],
      v1 = v[1];
  out[0] = a0 * v0;
  out[1] = a1 * v0;
  out[2] = a2 * v1;
  out[3] = a3 * v1;
  out[4] = a4;
  out[5] = a5;
  return out;
}
/**
 * Translates the mat2d by the dimensions in the given vec2
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to translate
 * @param {vec2} v the vec2 to translate the matrix by
 * @returns {mat2d} out
 **/

function translate(out, a, v) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5];
  var v0 = v[0],
      v1 = v[1];
  out[0] = a0;
  out[1] = a1;
  out[2] = a2;
  out[3] = a3;
  out[4] = a0 * v0 + a2 * v1 + a4;
  out[5] = a1 * v0 + a3 * v1 + a5;
  return out;
}
/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.rotate(dest, dest, rad);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2d} out
 */

function fromRotation(out, rad) {
  var s = Math.sin(rad),
      c = Math.cos(rad);
  out[0] = c;
  out[1] = s;
  out[2] = -s;
  out[3] = c;
  out[4] = 0;
  out[5] = 0;
  return out;
}
/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.scale(dest, dest, vec);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {vec2} v Scaling vector
 * @returns {mat2d} out
 */

function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = v[1];
  out[4] = 0;
  out[5] = 0;
  return out;
}
/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.translate(dest, dest, vec);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {vec2} v Translation vector
 * @returns {mat2d} out
 */

function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  out[4] = v[0];
  out[5] = v[1];
  return out;
}
/**
 * Returns a string representation of a mat2d
 *
 * @param {mat2d} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */

function str(a) {
  return 'mat2d(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' + a[4] + ', ' + a[5] + ')';
}
/**
 * Returns Frobenius norm of a mat2d
 *
 * @param {mat2d} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */

function frob(a) {
  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], 1);
}
/**
 * Adds two mat2d's
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @returns {mat2d} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  return out;
}
/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @returns {mat2d} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  return out;
}
/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat2d} out
 */

function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  return out;
}
/**
 * Adds two mat2d's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat2d} out the receiving vector
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat2d} out
 */

function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  out[4] = a[4] + b[4] * scale;
  out[5] = a[5] + b[5] * scale;
  return out;
}
/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat2d} a The first matrix.
 * @param {mat2d} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5];
}
/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat2d} a The first matrix.
 * @param {mat2d} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3],
      b4 = b[4],
      b5 = b[5];
  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5));
}
/**
 * Alias for {@link mat2d.multiply}
 * @function
 */

var mul = multiply;
/**
 * Alias for {@link mat2d.subtract}
 * @function
 */

var sub = subtract;

/***/ }),

/***/ 409:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   add: () => (/* binding */ add),
/* harmony export */   adjoint: () => (/* binding */ adjoint),
/* harmony export */   clone: () => (/* binding */ clone),
/* harmony export */   copy: () => (/* binding */ copy),
/* harmony export */   create: () => (/* binding */ create),
/* harmony export */   determinant: () => (/* binding */ determinant),
/* harmony export */   equals: () => (/* binding */ equals),
/* harmony export */   exactEquals: () => (/* binding */ exactEquals),
/* harmony export */   frob: () => (/* binding */ frob),
/* harmony export */   fromMat2d: () => (/* binding */ fromMat2d),
/* harmony export */   fromMat4: () => (/* binding */ fromMat4),
/* harmony export */   fromQuat: () => (/* binding */ fromQuat),
/* harmony export */   fromRotation: () => (/* binding */ fromRotation),
/* harmony export */   fromScaling: () => (/* binding */ fromScaling),
/* harmony export */   fromTranslation: () => (/* binding */ fromTranslation),
/* harmony export */   fromValues: () => (/* binding */ fromValues),
/* harmony export */   identity: () => (/* binding */ identity),
/* harmony export */   invert: () => (/* binding */ invert),
/* harmony export */   mul: () => (/* binding */ mul),
/* harmony export */   multiply: () => (/* binding */ multiply),
/* harmony export */   multiplyScalar: () => (/* binding */ multiplyScalar),
/* harmony export */   multiplyScalarAndAdd: () => (/* binding */ multiplyScalarAndAdd),
/* harmony export */   normalFromMat4: () => (/* binding */ normalFromMat4),
/* harmony export */   projection: () => (/* binding */ projection),
/* harmony export */   rotate: () => (/* binding */ rotate),
/* harmony export */   scale: () => (/* binding */ scale),
/* harmony export */   set: () => (/* binding */ set),
/* harmony export */   str: () => (/* binding */ str),
/* harmony export */   sub: () => (/* binding */ sub),
/* harmony export */   subtract: () => (/* binding */ subtract),
/* harmony export */   translate: () => (/* binding */ translate),
/* harmony export */   transpose: () => (/* binding */ transpose)
/* harmony export */ });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(823);

/**
 * 3x3 Matrix
 * @module mat3
 */

/**
 * Creates a new identity mat3
 *
 * @returns {mat3} a new 3x3 matrix
 */

function create() {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(9);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
  }

  out[0] = 1;
  out[4] = 1;
  out[8] = 1;
  return out;
}
/**
 * Copies the upper-left 3x3 values into the given mat3.
 *
 * @param {mat3} out the receiving 3x3 matrix
 * @param {mat4} a   the source 4x4 matrix
 * @returns {mat3} out
 */

function fromMat4(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[4];
  out[4] = a[5];
  out[5] = a[6];
  out[6] = a[8];
  out[7] = a[9];
  out[8] = a[10];
  return out;
}
/**
 * Creates a new mat3 initialized with values from an existing matrix
 *
 * @param {mat3} a matrix to clone
 * @returns {mat3} a new 3x3 matrix
 */

function clone(a) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(9);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}
/**
 * Copy the values from one mat3 to another
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}
/**
 * Create a new mat3 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m10 Component in column 1, row 0 position (index 3)
 * @param {Number} m11 Component in column 1, row 1 position (index 4)
 * @param {Number} m12 Component in column 1, row 2 position (index 5)
 * @param {Number} m20 Component in column 2, row 0 position (index 6)
 * @param {Number} m21 Component in column 2, row 1 position (index 7)
 * @param {Number} m22 Component in column 2, row 2 position (index 8)
 * @returns {mat3} A new mat3
 */

function fromValues(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(9);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}
/**
 * Set the components of a mat3 to the given values
 *
 * @param {mat3} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m10 Component in column 1, row 0 position (index 3)
 * @param {Number} m11 Component in column 1, row 1 position (index 4)
 * @param {Number} m12 Component in column 1, row 2 position (index 5)
 * @param {Number} m20 Component in column 2, row 0 position (index 6)
 * @param {Number} m21 Component in column 2, row 1 position (index 7)
 * @param {Number} m22 Component in column 2, row 2 position (index 8)
 * @returns {mat3} out
 */

function set(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}
/**
 * Set a mat3 to the identity matrix
 *
 * @param {mat3} out the receiving matrix
 * @returns {mat3} out
 */

function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
/**
 * Transpose the values of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */

function transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache some values
  if (out === a) {
    var a01 = a[1],
        a02 = a[2],
        a12 = a[5];
    out[1] = a[3];
    out[2] = a[6];
    out[3] = a01;
    out[5] = a[7];
    out[6] = a02;
    out[7] = a12;
  } else {
    out[0] = a[0];
    out[1] = a[3];
    out[2] = a[6];
    out[3] = a[1];
    out[4] = a[4];
    out[5] = a[7];
    out[6] = a[2];
    out[7] = a[5];
    out[8] = a[8];
  }

  return out;
}
/**
 * Inverts a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */

function invert(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];
  var b01 = a22 * a11 - a12 * a21;
  var b11 = -a22 * a10 + a12 * a20;
  var b21 = a21 * a10 - a11 * a20; // Calculate the determinant

  var det = a00 * b01 + a01 * b11 + a02 * b21;

  if (!det) {
    return null;
  }

  det = 1.0 / det;
  out[0] = b01 * det;
  out[1] = (-a22 * a01 + a02 * a21) * det;
  out[2] = (a12 * a01 - a02 * a11) * det;
  out[3] = b11 * det;
  out[4] = (a22 * a00 - a02 * a20) * det;
  out[5] = (-a12 * a00 + a02 * a10) * det;
  out[6] = b21 * det;
  out[7] = (-a21 * a00 + a01 * a20) * det;
  out[8] = (a11 * a00 - a01 * a10) * det;
  return out;
}
/**
 * Calculates the adjugate of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */

function adjoint(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];
  out[0] = a11 * a22 - a12 * a21;
  out[1] = a02 * a21 - a01 * a22;
  out[2] = a01 * a12 - a02 * a11;
  out[3] = a12 * a20 - a10 * a22;
  out[4] = a00 * a22 - a02 * a20;
  out[5] = a02 * a10 - a00 * a12;
  out[6] = a10 * a21 - a11 * a20;
  out[7] = a01 * a20 - a00 * a21;
  out[8] = a00 * a11 - a01 * a10;
  return out;
}
/**
 * Calculates the determinant of a mat3
 *
 * @param {mat3} a the source matrix
 * @returns {Number} determinant of a
 */

function determinant(a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];
  return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
}
/**
 * Multiplies two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */

function multiply(out, a, b) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];
  var b00 = b[0],
      b01 = b[1],
      b02 = b[2];
  var b10 = b[3],
      b11 = b[4],
      b12 = b[5];
  var b20 = b[6],
      b21 = b[7],
      b22 = b[8];
  out[0] = b00 * a00 + b01 * a10 + b02 * a20;
  out[1] = b00 * a01 + b01 * a11 + b02 * a21;
  out[2] = b00 * a02 + b01 * a12 + b02 * a22;
  out[3] = b10 * a00 + b11 * a10 + b12 * a20;
  out[4] = b10 * a01 + b11 * a11 + b12 * a21;
  out[5] = b10 * a02 + b11 * a12 + b12 * a22;
  out[6] = b20 * a00 + b21 * a10 + b22 * a20;
  out[7] = b20 * a01 + b21 * a11 + b22 * a21;
  out[8] = b20 * a02 + b21 * a12 + b22 * a22;
  return out;
}
/**
 * Translate a mat3 by the given vector
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to translate
 * @param {vec2} v vector to translate by
 * @returns {mat3} out
 */

function translate(out, a, v) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a10 = a[3],
      a11 = a[4],
      a12 = a[5],
      a20 = a[6],
      a21 = a[7],
      a22 = a[8],
      x = v[0],
      y = v[1];
  out[0] = a00;
  out[1] = a01;
  out[2] = a02;
  out[3] = a10;
  out[4] = a11;
  out[5] = a12;
  out[6] = x * a00 + y * a10 + a20;
  out[7] = x * a01 + y * a11 + a21;
  out[8] = x * a02 + y * a12 + a22;
  return out;
}
/**
 * Rotates a mat3 by the given angle
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */

function rotate(out, a, rad) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a10 = a[3],
      a11 = a[4],
      a12 = a[5],
      a20 = a[6],
      a21 = a[7],
      a22 = a[8],
      s = Math.sin(rad),
      c = Math.cos(rad);
  out[0] = c * a00 + s * a10;
  out[1] = c * a01 + s * a11;
  out[2] = c * a02 + s * a12;
  out[3] = c * a10 - s * a00;
  out[4] = c * a11 - s * a01;
  out[5] = c * a12 - s * a02;
  out[6] = a20;
  out[7] = a21;
  out[8] = a22;
  return out;
}
;
/**
 * Scales the mat3 by the dimensions in the given vec2
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to rotate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat3} out
 **/

function scale(out, a, v) {
  var x = v[0],
      y = v[1];
  out[0] = x * a[0];
  out[1] = x * a[1];
  out[2] = x * a[2];
  out[3] = y * a[3];
  out[4] = y * a[4];
  out[5] = y * a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}
/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.translate(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {vec2} v Translation vector
 * @returns {mat3} out
 */

function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = v[0];
  out[7] = v[1];
  out[8] = 1;
  return out;
}
/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.rotate(dest, dest, rad);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */

function fromRotation(out, rad) {
  var s = Math.sin(rad),
      c = Math.cos(rad);
  out[0] = c;
  out[1] = s;
  out[2] = 0;
  out[3] = -s;
  out[4] = c;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.scale(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {vec2} v Scaling vector
 * @returns {mat3} out
 */

function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = v[1];
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
/**
 * Copies the values from a mat2d into a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat2d} a the matrix to copy
 * @returns {mat3} out
 **/

function fromMat2d(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = 0;
  out[3] = a[2];
  out[4] = a[3];
  out[5] = 0;
  out[6] = a[4];
  out[7] = a[5];
  out[8] = 1;
  return out;
}
/**
* Calculates a 3x3 matrix from the given quaternion
*
* @param {mat3} out mat3 receiving operation result
* @param {quat} q Quaternion to create matrix from
*
* @returns {mat3} out
*/

function fromQuat(out, q) {
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var yx = y * x2;
  var yy = y * y2;
  var zx = z * x2;
  var zy = z * y2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - yy - zz;
  out[3] = yx - wz;
  out[6] = zx + wy;
  out[1] = yx + wz;
  out[4] = 1 - xx - zz;
  out[7] = zy - wx;
  out[2] = zx - wy;
  out[5] = zy + wx;
  out[8] = 1 - xx - yy;
  return out;
}
/**
* Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix
*
* @param {mat3} out mat3 receiving operation result
* @param {mat4} a Mat4 to derive the normal matrix from
*
* @returns {mat3} out
*/

function normalFromMat4(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant

  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

  if (!det) {
    return null;
  }

  det = 1.0 / det;
  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  return out;
}
/**
 * Generates a 2D projection matrix with the given bounds
 *
 * @param {mat3} out mat3 frustum matrix will be written into
 * @param {number} width Width of your gl context
 * @param {number} height Height of gl context
 * @returns {mat3} out
 */

function projection(out, width, height) {
  out[0] = 2 / width;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = -2 / height;
  out[5] = 0;
  out[6] = -1;
  out[7] = 1;
  out[8] = 1;
  return out;
}
/**
 * Returns a string representation of a mat3
 *
 * @param {mat3} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */

function str(a) {
  return 'mat3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' + a[8] + ')';
}
/**
 * Returns Frobenius norm of a mat3
 *
 * @param {mat3} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */

function frob(a) {
  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8]);
}
/**
 * Adds two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  out[8] = a[8] + b[8];
  return out;
}
/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  out[6] = a[6] - b[6];
  out[7] = a[7] - b[7];
  out[8] = a[8] - b[8];
  return out;
}
/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat3} out
 */

function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  out[8] = a[8] * b;
  return out;
}
/**
 * Adds two mat3's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat3} out the receiving vector
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat3} out
 */

function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  out[4] = a[4] + b[4] * scale;
  out[5] = a[5] + b[5] * scale;
  out[6] = a[6] + b[6] * scale;
  out[7] = a[7] + b[7] * scale;
  out[8] = a[8] + b[8] * scale;
  return out;
}
/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat3} a The first matrix.
 * @param {mat3} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8];
}
/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat3} a The first matrix.
 * @param {mat3} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5],
      a6 = a[6],
      a7 = a[7],
      a8 = a[8];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3],
      b4 = b[4],
      b5 = b[5],
      b6 = b[6],
      b7 = b[7],
      b8 = b[8];
  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a8), Math.abs(b8));
}
/**
 * Alias for {@link mat3.multiply}
 * @function
 */

var mul = multiply;
/**
 * Alias for {@link mat3.subtract}
 * @function
 */

var sub = subtract;

/***/ }),

/***/ 684:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   add: () => (/* binding */ add),
/* harmony export */   adjoint: () => (/* binding */ adjoint),
/* harmony export */   clone: () => (/* binding */ clone),
/* harmony export */   copy: () => (/* binding */ copy),
/* harmony export */   create: () => (/* binding */ create),
/* harmony export */   determinant: () => (/* binding */ determinant),
/* harmony export */   equals: () => (/* binding */ equals),
/* harmony export */   exactEquals: () => (/* binding */ exactEquals),
/* harmony export */   frob: () => (/* binding */ frob),
/* harmony export */   fromQuat: () => (/* binding */ fromQuat),
/* harmony export */   fromQuat2: () => (/* binding */ fromQuat2),
/* harmony export */   fromRotation: () => (/* binding */ fromRotation),
/* harmony export */   fromRotationTranslation: () => (/* binding */ fromRotationTranslation),
/* harmony export */   fromRotationTranslationScale: () => (/* binding */ fromRotationTranslationScale),
/* harmony export */   fromRotationTranslationScaleOrigin: () => (/* binding */ fromRotationTranslationScaleOrigin),
/* harmony export */   fromScaling: () => (/* binding */ fromScaling),
/* harmony export */   fromTranslation: () => (/* binding */ fromTranslation),
/* harmony export */   fromValues: () => (/* binding */ fromValues),
/* harmony export */   fromXRotation: () => (/* binding */ fromXRotation),
/* harmony export */   fromYRotation: () => (/* binding */ fromYRotation),
/* harmony export */   fromZRotation: () => (/* binding */ fromZRotation),
/* harmony export */   frustum: () => (/* binding */ frustum),
/* harmony export */   getRotation: () => (/* binding */ getRotation),
/* harmony export */   getScaling: () => (/* binding */ getScaling),
/* harmony export */   getTranslation: () => (/* binding */ getTranslation),
/* harmony export */   identity: () => (/* binding */ identity),
/* harmony export */   invert: () => (/* binding */ invert),
/* harmony export */   lookAt: () => (/* binding */ lookAt),
/* harmony export */   mul: () => (/* binding */ mul),
/* harmony export */   multiply: () => (/* binding */ multiply),
/* harmony export */   multiplyScalar: () => (/* binding */ multiplyScalar),
/* harmony export */   multiplyScalarAndAdd: () => (/* binding */ multiplyScalarAndAdd),
/* harmony export */   ortho: () => (/* binding */ ortho),
/* harmony export */   perspective: () => (/* binding */ perspective),
/* harmony export */   perspectiveFromFieldOfView: () => (/* binding */ perspectiveFromFieldOfView),
/* harmony export */   rotate: () => (/* binding */ rotate),
/* harmony export */   rotateX: () => (/* binding */ rotateX),
/* harmony export */   rotateY: () => (/* binding */ rotateY),
/* harmony export */   rotateZ: () => (/* binding */ rotateZ),
/* harmony export */   scale: () => (/* binding */ scale),
/* harmony export */   set: () => (/* binding */ set),
/* harmony export */   str: () => (/* binding */ str),
/* harmony export */   sub: () => (/* binding */ sub),
/* harmony export */   subtract: () => (/* binding */ subtract),
/* harmony export */   targetTo: () => (/* binding */ targetTo),
/* harmony export */   translate: () => (/* binding */ translate),
/* harmony export */   transpose: () => (/* binding */ transpose)
/* harmony export */ });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(823);

/**
 * 4x4 Matrix<br>Format: column-major, when typed out it looks like row-major<br>The matrices are being post multiplied.
 * @module mat4
 */

/**
 * Creates a new identity mat4
 *
 * @returns {mat4} a new 4x4 matrix
 */

function create() {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(16);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
  }

  out[0] = 1;
  out[5] = 1;
  out[10] = 1;
  out[15] = 1;
  return out;
}
/**
 * Creates a new mat4 initialized with values from an existing matrix
 *
 * @param {mat4} a matrix to clone
 * @returns {mat4} a new 4x4 matrix
 */

function clone(a) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(16);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  out[9] = a[9];
  out[10] = a[10];
  out[11] = a[11];
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
/**
 * Copy the values from one mat4 to another
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  out[9] = a[9];
  out[10] = a[10];
  out[11] = a[11];
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
/**
 * Create a new mat4 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m03 Component in column 0, row 3 position (index 3)
 * @param {Number} m10 Component in column 1, row 0 position (index 4)
 * @param {Number} m11 Component in column 1, row 1 position (index 5)
 * @param {Number} m12 Component in column 1, row 2 position (index 6)
 * @param {Number} m13 Component in column 1, row 3 position (index 7)
 * @param {Number} m20 Component in column 2, row 0 position (index 8)
 * @param {Number} m21 Component in column 2, row 1 position (index 9)
 * @param {Number} m22 Component in column 2, row 2 position (index 10)
 * @param {Number} m23 Component in column 2, row 3 position (index 11)
 * @param {Number} m30 Component in column 3, row 0 position (index 12)
 * @param {Number} m31 Component in column 3, row 1 position (index 13)
 * @param {Number} m32 Component in column 3, row 2 position (index 14)
 * @param {Number} m33 Component in column 3, row 3 position (index 15)
 * @returns {mat4} A new mat4
 */

function fromValues(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(16);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}
/**
 * Set the components of a mat4 to the given values
 *
 * @param {mat4} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m03 Component in column 0, row 3 position (index 3)
 * @param {Number} m10 Component in column 1, row 0 position (index 4)
 * @param {Number} m11 Component in column 1, row 1 position (index 5)
 * @param {Number} m12 Component in column 1, row 2 position (index 6)
 * @param {Number} m13 Component in column 1, row 3 position (index 7)
 * @param {Number} m20 Component in column 2, row 0 position (index 8)
 * @param {Number} m21 Component in column 2, row 1 position (index 9)
 * @param {Number} m22 Component in column 2, row 2 position (index 10)
 * @param {Number} m23 Component in column 2, row 3 position (index 11)
 * @param {Number} m30 Component in column 3, row 0 position (index 12)
 * @param {Number} m31 Component in column 3, row 1 position (index 13)
 * @param {Number} m32 Component in column 3, row 2 position (index 14)
 * @param {Number} m33 Component in column 3, row 3 position (index 15)
 * @returns {mat4} out
 */

function set(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}
/**
 * Set a mat4 to the identity matrix
 *
 * @param {mat4} out the receiving matrix
 * @returns {mat4} out
 */

function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Transpose the values of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */

function transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache some values
  if (out === a) {
    var a01 = a[1],
        a02 = a[2],
        a03 = a[3];
    var a12 = a[6],
        a13 = a[7];
    var a23 = a[11];
    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a01;
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a02;
    out[9] = a12;
    out[11] = a[14];
    out[12] = a03;
    out[13] = a13;
    out[14] = a23;
  } else {
    out[0] = a[0];
    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a[1];
    out[5] = a[5];
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a[2];
    out[9] = a[6];
    out[10] = a[10];
    out[11] = a[14];
    out[12] = a[3];
    out[13] = a[7];
    out[14] = a[11];
    out[15] = a[15];
  }

  return out;
}
/**
 * Inverts a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */

function invert(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant

  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

  if (!det) {
    return null;
  }

  det = 1.0 / det;
  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
  out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
  out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
  out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
  out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
  out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
  out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
  return out;
}
/**
 * Calculates the adjugate of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */

function adjoint(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];
  out[0] = a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22);
  out[1] = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
  out[2] = a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12);
  out[3] = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
  out[4] = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
  out[5] = a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22);
  out[6] = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
  out[7] = a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12);
  out[8] = a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21);
  out[9] = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
  out[10] = a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11);
  out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
  out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
  out[13] = a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21);
  out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
  out[15] = a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11);
  return out;
}
/**
 * Calculates the determinant of a mat4
 *
 * @param {mat4} a the source matrix
 * @returns {Number} determinant of a
 */

function determinant(a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant

  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
}
/**
 * Multiplies two mat4s
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */

function multiply(out, a, b) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15]; // Cache only the current line of the second matrix

  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[4];
  b1 = b[5];
  b2 = b[6];
  b3 = b[7];
  out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[8];
  b1 = b[9];
  b2 = b[10];
  b3 = b[11];
  out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[12];
  b1 = b[13];
  b2 = b[14];
  b3 = b[15];
  out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  return out;
}
/**
 * Translate a mat4 by the given vector
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to translate
 * @param {vec3} v vector to translate by
 * @returns {mat4} out
 */

function translate(out, a, v) {
  var x = v[0],
      y = v[1],
      z = v[2];
  var a00, a01, a02, a03;
  var a10, a11, a12, a13;
  var a20, a21, a22, a23;

  if (a === out) {
    out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
    out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
    out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
    out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
  } else {
    a00 = a[0];
    a01 = a[1];
    a02 = a[2];
    a03 = a[3];
    a10 = a[4];
    a11 = a[5];
    a12 = a[6];
    a13 = a[7];
    a20 = a[8];
    a21 = a[9];
    a22 = a[10];
    a23 = a[11];
    out[0] = a00;
    out[1] = a01;
    out[2] = a02;
    out[3] = a03;
    out[4] = a10;
    out[5] = a11;
    out[6] = a12;
    out[7] = a13;
    out[8] = a20;
    out[9] = a21;
    out[10] = a22;
    out[11] = a23;
    out[12] = a00 * x + a10 * y + a20 * z + a[12];
    out[13] = a01 * x + a11 * y + a21 * z + a[13];
    out[14] = a02 * x + a12 * y + a22 * z + a[14];
    out[15] = a03 * x + a13 * y + a23 * z + a[15];
  }

  return out;
}
/**
 * Scales the mat4 by the dimensions in the given vec3 not using vectorization
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to scale
 * @param {vec3} v the vec3 to scale the matrix by
 * @returns {mat4} out
 **/

function scale(out, a, v) {
  var x = v[0],
      y = v[1],
      z = v[2];
  out[0] = a[0] * x;
  out[1] = a[1] * x;
  out[2] = a[2] * x;
  out[3] = a[3] * x;
  out[4] = a[4] * y;
  out[5] = a[5] * y;
  out[6] = a[6] * y;
  out[7] = a[7] * y;
  out[8] = a[8] * z;
  out[9] = a[9] * z;
  out[10] = a[10] * z;
  out[11] = a[11] * z;
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
/**
 * Rotates a mat4 by the given angle around the given axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @param {vec3} axis the axis to rotate around
 * @returns {mat4} out
 */

function rotate(out, a, rad, axis) {
  var x = axis[0],
      y = axis[1],
      z = axis[2];
  var len = Math.hypot(x, y, z);
  var s, c, t;
  var a00, a01, a02, a03;
  var a10, a11, a12, a13;
  var a20, a21, a22, a23;
  var b00, b01, b02;
  var b10, b11, b12;
  var b20, b21, b22;

  if (len < _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON) {
    return null;
  }

  len = 1 / len;
  x *= len;
  y *= len;
  z *= len;
  s = Math.sin(rad);
  c = Math.cos(rad);
  t = 1 - c;
  a00 = a[0];
  a01 = a[1];
  a02 = a[2];
  a03 = a[3];
  a10 = a[4];
  a11 = a[5];
  a12 = a[6];
  a13 = a[7];
  a20 = a[8];
  a21 = a[9];
  a22 = a[10];
  a23 = a[11]; // Construct the elements of the rotation matrix

  b00 = x * x * t + c;
  b01 = y * x * t + z * s;
  b02 = z * x * t - y * s;
  b10 = x * y * t - z * s;
  b11 = y * y * t + c;
  b12 = z * y * t + x * s;
  b20 = x * z * t + y * s;
  b21 = y * z * t - x * s;
  b22 = z * z * t + c; // Perform rotation-specific matrix multiplication

  out[0] = a00 * b00 + a10 * b01 + a20 * b02;
  out[1] = a01 * b00 + a11 * b01 + a21 * b02;
  out[2] = a02 * b00 + a12 * b01 + a22 * b02;
  out[3] = a03 * b00 + a13 * b01 + a23 * b02;
  out[4] = a00 * b10 + a10 * b11 + a20 * b12;
  out[5] = a01 * b10 + a11 * b11 + a21 * b12;
  out[6] = a02 * b10 + a12 * b11 + a22 * b12;
  out[7] = a03 * b10 + a13 * b11 + a23 * b12;
  out[8] = a00 * b20 + a10 * b21 + a20 * b22;
  out[9] = a01 * b20 + a11 * b21 + a21 * b22;
  out[10] = a02 * b20 + a12 * b21 + a22 * b22;
  out[11] = a03 * b20 + a13 * b21 + a23 * b22;

  if (a !== out) {
    // If the source and destination differ, copy the unchanged last row
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }

  return out;
}
/**
 * Rotates a matrix by the given angle around the X axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function rotateX(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a10 = a[4];
  var a11 = a[5];
  var a12 = a[6];
  var a13 = a[7];
  var a20 = a[8];
  var a21 = a[9];
  var a22 = a[10];
  var a23 = a[11];

  if (a !== out) {
    // If the source and destination differ, copy the unchanged rows
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  } // Perform axis-specific matrix multiplication


  out[4] = a10 * c + a20 * s;
  out[5] = a11 * c + a21 * s;
  out[6] = a12 * c + a22 * s;
  out[7] = a13 * c + a23 * s;
  out[8] = a20 * c - a10 * s;
  out[9] = a21 * c - a11 * s;
  out[10] = a22 * c - a12 * s;
  out[11] = a23 * c - a13 * s;
  return out;
}
/**
 * Rotates a matrix by the given angle around the Y axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function rotateY(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a03 = a[3];
  var a20 = a[8];
  var a21 = a[9];
  var a22 = a[10];
  var a23 = a[11];

  if (a !== out) {
    // If the source and destination differ, copy the unchanged rows
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  } // Perform axis-specific matrix multiplication


  out[0] = a00 * c - a20 * s;
  out[1] = a01 * c - a21 * s;
  out[2] = a02 * c - a22 * s;
  out[3] = a03 * c - a23 * s;
  out[8] = a00 * s + a20 * c;
  out[9] = a01 * s + a21 * c;
  out[10] = a02 * s + a22 * c;
  out[11] = a03 * s + a23 * c;
  return out;
}
/**
 * Rotates a matrix by the given angle around the Z axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function rotateZ(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a03 = a[3];
  var a10 = a[4];
  var a11 = a[5];
  var a12 = a[6];
  var a13 = a[7];

  if (a !== out) {
    // If the source and destination differ, copy the unchanged last row
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  } // Perform axis-specific matrix multiplication


  out[0] = a00 * c + a10 * s;
  out[1] = a01 * c + a11 * s;
  out[2] = a02 * c + a12 * s;
  out[3] = a03 * c + a13 * s;
  out[4] = a10 * c - a00 * s;
  out[5] = a11 * c - a01 * s;
  out[6] = a12 * c - a02 * s;
  out[7] = a13 * c - a03 * s;
  return out;
}
/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {vec3} v Translation vector
 * @returns {mat4} out
 */

function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.scale(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {vec3} v Scaling vector
 * @returns {mat4} out
 */

function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = v[1];
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = v[2];
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from a given angle around a given axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotate(dest, dest, rad, axis);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @param {vec3} axis the axis to rotate around
 * @returns {mat4} out
 */

function fromRotation(out, rad, axis) {
  var x = axis[0],
      y = axis[1],
      z = axis[2];
  var len = Math.hypot(x, y, z);
  var s, c, t;

  if (len < _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON) {
    return null;
  }

  len = 1 / len;
  x *= len;
  y *= len;
  z *= len;
  s = Math.sin(rad);
  c = Math.cos(rad);
  t = 1 - c; // Perform rotation-specific matrix multiplication

  out[0] = x * x * t + c;
  out[1] = y * x * t + z * s;
  out[2] = z * x * t - y * s;
  out[3] = 0;
  out[4] = x * y * t - z * s;
  out[5] = y * y * t + c;
  out[6] = z * y * t + x * s;
  out[7] = 0;
  out[8] = x * z * t + y * s;
  out[9] = y * z * t - x * s;
  out[10] = z * z * t + c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from the given angle around the X axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateX(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function fromXRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad); // Perform axis-specific matrix multiplication

  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = c;
  out[6] = s;
  out[7] = 0;
  out[8] = 0;
  out[9] = -s;
  out[10] = c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from the given angle around the Y axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateY(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function fromYRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad); // Perform axis-specific matrix multiplication

  out[0] = c;
  out[1] = 0;
  out[2] = -s;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = s;
  out[9] = 0;
  out[10] = c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from the given angle around the Z axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateZ(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function fromZRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad); // Perform axis-specific matrix multiplication

  out[0] = c;
  out[1] = s;
  out[2] = 0;
  out[3] = 0;
  out[4] = -s;
  out[5] = c;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from a quaternion rotation and vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @returns {mat4} out
 */

function fromRotationTranslation(out, q, v) {
  // Quaternion math
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - (yy + zz);
  out[1] = xy + wz;
  out[2] = xz - wy;
  out[3] = 0;
  out[4] = xy - wz;
  out[5] = 1 - (xx + zz);
  out[6] = yz + wx;
  out[7] = 0;
  out[8] = xz + wy;
  out[9] = yz - wx;
  out[10] = 1 - (xx + yy);
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
/**
 * Creates a new mat4 from a dual quat.
 *
 * @param {mat4} out Matrix
 * @param {quat2} a Dual Quaternion
 * @returns {mat4} mat4 receiving operation result
 */

function fromQuat2(out, a) {
  var translation = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(3);
  var bx = -a[0],
      by = -a[1],
      bz = -a[2],
      bw = a[3],
      ax = a[4],
      ay = a[5],
      az = a[6],
      aw = a[7];
  var magnitude = bx * bx + by * by + bz * bz + bw * bw; //Only scale if it makes sense

  if (magnitude > 0) {
    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2 / magnitude;
    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2 / magnitude;
    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2 / magnitude;
  } else {
    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;
    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;
    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;
  }

  fromRotationTranslation(out, a, translation);
  return out;
}
/**
 * Returns the translation vector component of a transformation
 *  matrix. If a matrix is built with fromRotationTranslation,
 *  the returned vector will be the same as the translation vector
 *  originally supplied.
 * @param  {vec3} out Vector to receive translation component
 * @param  {mat4} mat Matrix to be decomposed (input)
 * @return {vec3} out
 */

function getTranslation(out, mat) {
  out[0] = mat[12];
  out[1] = mat[13];
  out[2] = mat[14];
  return out;
}
/**
 * Returns the scaling factor component of a transformation
 *  matrix. If a matrix is built with fromRotationTranslationScale
 *  with a normalized Quaternion paramter, the returned vector will be
 *  the same as the scaling vector
 *  originally supplied.
 * @param  {vec3} out Vector to receive scaling factor component
 * @param  {mat4} mat Matrix to be decomposed (input)
 * @return {vec3} out
 */

function getScaling(out, mat) {
  var m11 = mat[0];
  var m12 = mat[1];
  var m13 = mat[2];
  var m21 = mat[4];
  var m22 = mat[5];
  var m23 = mat[6];
  var m31 = mat[8];
  var m32 = mat[9];
  var m33 = mat[10];
  out[0] = Math.hypot(m11, m12, m13);
  out[1] = Math.hypot(m21, m22, m23);
  out[2] = Math.hypot(m31, m32, m33);
  return out;
}
/**
 * Returns a quaternion representing the rotational component
 *  of a transformation matrix. If a matrix is built with
 *  fromRotationTranslation, the returned quaternion will be the
 *  same as the quaternion originally supplied.
 * @param {quat} out Quaternion to receive the rotation component
 * @param {mat4} mat Matrix to be decomposed (input)
 * @return {quat} out
 */

function getRotation(out, mat) {
  var scaling = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(3);
  getScaling(scaling, mat);
  var is1 = 1 / scaling[0];
  var is2 = 1 / scaling[1];
  var is3 = 1 / scaling[2];
  var sm11 = mat[0] * is1;
  var sm12 = mat[1] * is2;
  var sm13 = mat[2] * is3;
  var sm21 = mat[4] * is1;
  var sm22 = mat[5] * is2;
  var sm23 = mat[6] * is3;
  var sm31 = mat[8] * is1;
  var sm32 = mat[9] * is2;
  var sm33 = mat[10] * is3;
  var trace = sm11 + sm22 + sm33;
  var S = 0;

  if (trace > 0) {
    S = Math.sqrt(trace + 1.0) * 2;
    out[3] = 0.25 * S;
    out[0] = (sm23 - sm32) / S;
    out[1] = (sm31 - sm13) / S;
    out[2] = (sm12 - sm21) / S;
  } else if (sm11 > sm22 && sm11 > sm33) {
    S = Math.sqrt(1.0 + sm11 - sm22 - sm33) * 2;
    out[3] = (sm23 - sm32) / S;
    out[0] = 0.25 * S;
    out[1] = (sm12 + sm21) / S;
    out[2] = (sm31 + sm13) / S;
  } else if (sm22 > sm33) {
    S = Math.sqrt(1.0 + sm22 - sm11 - sm33) * 2;
    out[3] = (sm31 - sm13) / S;
    out[0] = (sm12 + sm21) / S;
    out[1] = 0.25 * S;
    out[2] = (sm23 + sm32) / S;
  } else {
    S = Math.sqrt(1.0 + sm33 - sm11 - sm22) * 2;
    out[3] = (sm12 - sm21) / S;
    out[0] = (sm31 + sm13) / S;
    out[1] = (sm23 + sm32) / S;
    out[2] = 0.25 * S;
  }

  return out;
}
/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @param {vec3} s Scaling vector
 * @returns {mat4} out
 */

function fromRotationTranslationScale(out, q, v, s) {
  // Quaternion math
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  var sx = s[0];
  var sy = s[1];
  var sz = s[2];
  out[0] = (1 - (yy + zz)) * sx;
  out[1] = (xy + wz) * sx;
  out[2] = (xz - wy) * sx;
  out[3] = 0;
  out[4] = (xy - wz) * sy;
  out[5] = (1 - (xx + zz)) * sy;
  out[6] = (yz + wx) * sy;
  out[7] = 0;
  out[8] = (xz + wy) * sz;
  out[9] = (yz - wx) * sz;
  out[10] = (1 - (xx + yy)) * sz;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the given origin
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     mat4.translate(dest, origin);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *     mat4.translate(dest, negativeOrigin);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @param {vec3} s Scaling vector
 * @param {vec3} o The origin vector around which to scale and rotate
 * @returns {mat4} out
 */

function fromRotationTranslationScaleOrigin(out, q, v, s, o) {
  // Quaternion math
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  var sx = s[0];
  var sy = s[1];
  var sz = s[2];
  var ox = o[0];
  var oy = o[1];
  var oz = o[2];
  var out0 = (1 - (yy + zz)) * sx;
  var out1 = (xy + wz) * sx;
  var out2 = (xz - wy) * sx;
  var out4 = (xy - wz) * sy;
  var out5 = (1 - (xx + zz)) * sy;
  var out6 = (yz + wx) * sy;
  var out8 = (xz + wy) * sz;
  var out9 = (yz - wx) * sz;
  var out10 = (1 - (xx + yy)) * sz;
  out[0] = out0;
  out[1] = out1;
  out[2] = out2;
  out[3] = 0;
  out[4] = out4;
  out[5] = out5;
  out[6] = out6;
  out[7] = 0;
  out[8] = out8;
  out[9] = out9;
  out[10] = out10;
  out[11] = 0;
  out[12] = v[0] + ox - (out0 * ox + out4 * oy + out8 * oz);
  out[13] = v[1] + oy - (out1 * ox + out5 * oy + out9 * oz);
  out[14] = v[2] + oz - (out2 * ox + out6 * oy + out10 * oz);
  out[15] = 1;
  return out;
}
/**
 * Calculates a 4x4 matrix from the given quaternion
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat} q Quaternion to create matrix from
 *
 * @returns {mat4} out
 */

function fromQuat(out, q) {
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var yx = y * x2;
  var yy = y * y2;
  var zx = z * x2;
  var zy = z * y2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - yy - zz;
  out[1] = yx + wz;
  out[2] = zx - wy;
  out[3] = 0;
  out[4] = yx - wz;
  out[5] = 1 - xx - zz;
  out[6] = zy + wx;
  out[7] = 0;
  out[8] = zx + wy;
  out[9] = zy - wx;
  out[10] = 1 - xx - yy;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Generates a frustum matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Number} left Left bound of the frustum
 * @param {Number} right Right bound of the frustum
 * @param {Number} bottom Bottom bound of the frustum
 * @param {Number} top Top bound of the frustum
 * @param {Number} near Near bound of the frustum
 * @param {Number} far Far bound of the frustum
 * @returns {mat4} out
 */

function frustum(out, left, right, bottom, top, near, far) {
  var rl = 1 / (right - left);
  var tb = 1 / (top - bottom);
  var nf = 1 / (near - far);
  out[0] = near * 2 * rl;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = near * 2 * tb;
  out[6] = 0;
  out[7] = 0;
  out[8] = (right + left) * rl;
  out[9] = (top + bottom) * tb;
  out[10] = (far + near) * nf;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[14] = far * near * 2 * nf;
  out[15] = 0;
  return out;
}
/**
 * Generates a perspective projection matrix with the given bounds.
 * Passing null/undefined/no value for far will generate infinite projection matrix.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} fovy Vertical field of view in radians
 * @param {number} aspect Aspect ratio. typically viewport width/height
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum, can be null or Infinity
 * @returns {mat4} out
 */

function perspective(out, fovy, aspect, near, far) {
  var f = 1.0 / Math.tan(fovy / 2),
      nf;
  out[0] = f / aspect;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = f;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[15] = 0;

  if (far != null && far !== Infinity) {
    nf = 1 / (near - far);
    out[10] = (far + near) * nf;
    out[14] = 2 * far * near * nf;
  } else {
    out[10] = -1;
    out[14] = -2 * near;
  }

  return out;
}
/**
 * Generates a perspective projection matrix with the given field of view.
 * This is primarily useful for generating projection matrices to be used
 * with the still experiemental WebVR API.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Object} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */

function perspectiveFromFieldOfView(out, fov, near, far) {
  var upTan = Math.tan(fov.upDegrees * Math.PI / 180.0);
  var downTan = Math.tan(fov.downDegrees * Math.PI / 180.0);
  var leftTan = Math.tan(fov.leftDegrees * Math.PI / 180.0);
  var rightTan = Math.tan(fov.rightDegrees * Math.PI / 180.0);
  var xScale = 2.0 / (leftTan + rightTan);
  var yScale = 2.0 / (upTan + downTan);
  out[0] = xScale;
  out[1] = 0.0;
  out[2] = 0.0;
  out[3] = 0.0;
  out[4] = 0.0;
  out[5] = yScale;
  out[6] = 0.0;
  out[7] = 0.0;
  out[8] = -((leftTan - rightTan) * xScale * 0.5);
  out[9] = (upTan - downTan) * yScale * 0.5;
  out[10] = far / (near - far);
  out[11] = -1.0;
  out[12] = 0.0;
  out[13] = 0.0;
  out[14] = far * near / (near - far);
  out[15] = 0.0;
  return out;
}
/**
 * Generates a orthogonal projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} left Left bound of the frustum
 * @param {number} right Right bound of the frustum
 * @param {number} bottom Bottom bound of the frustum
 * @param {number} top Top bound of the frustum
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */

function ortho(out, left, right, bottom, top, near, far) {
  var lr = 1 / (left - right);
  var bt = 1 / (bottom - top);
  var nf = 1 / (near - far);
  out[0] = -2 * lr;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = -2 * bt;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 2 * nf;
  out[11] = 0;
  out[12] = (left + right) * lr;
  out[13] = (top + bottom) * bt;
  out[14] = (far + near) * nf;
  out[15] = 1;
  return out;
}
/**
 * Generates a look-at matrix with the given eye position, focal point, and up axis.
 * If you want a matrix that actually makes an object look at another object, you should use targetTo instead.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {vec3} eye Position of the viewer
 * @param {vec3} center Point the viewer is looking at
 * @param {vec3} up vec3 pointing up
 * @returns {mat4} out
 */

function lookAt(out, eye, center, up) {
  var x0, x1, x2, y0, y1, y2, z0, z1, z2, len;
  var eyex = eye[0];
  var eyey = eye[1];
  var eyez = eye[2];
  var upx = up[0];
  var upy = up[1];
  var upz = up[2];
  var centerx = center[0];
  var centery = center[1];
  var centerz = center[2];

  if (Math.abs(eyex - centerx) < _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON && Math.abs(eyey - centery) < _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON && Math.abs(eyez - centerz) < _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON) {
    return identity(out);
  }

  z0 = eyex - centerx;
  z1 = eyey - centery;
  z2 = eyez - centerz;
  len = 1 / Math.hypot(z0, z1, z2);
  z0 *= len;
  z1 *= len;
  z2 *= len;
  x0 = upy * z2 - upz * z1;
  x1 = upz * z0 - upx * z2;
  x2 = upx * z1 - upy * z0;
  len = Math.hypot(x0, x1, x2);

  if (!len) {
    x0 = 0;
    x1 = 0;
    x2 = 0;
  } else {
    len = 1 / len;
    x0 *= len;
    x1 *= len;
    x2 *= len;
  }

  y0 = z1 * x2 - z2 * x1;
  y1 = z2 * x0 - z0 * x2;
  y2 = z0 * x1 - z1 * x0;
  len = Math.hypot(y0, y1, y2);

  if (!len) {
    y0 = 0;
    y1 = 0;
    y2 = 0;
  } else {
    len = 1 / len;
    y0 *= len;
    y1 *= len;
    y2 *= len;
  }

  out[0] = x0;
  out[1] = y0;
  out[2] = z0;
  out[3] = 0;
  out[4] = x1;
  out[5] = y1;
  out[6] = z1;
  out[7] = 0;
  out[8] = x2;
  out[9] = y2;
  out[10] = z2;
  out[11] = 0;
  out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
  out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
  out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
  out[15] = 1;
  return out;
}
/**
 * Generates a matrix that makes something look at something else.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {vec3} eye Position of the viewer
 * @param {vec3} center Point the viewer is looking at
 * @param {vec3} up vec3 pointing up
 * @returns {mat4} out
 */

function targetTo(out, eye, target, up) {
  var eyex = eye[0],
      eyey = eye[1],
      eyez = eye[2],
      upx = up[0],
      upy = up[1],
      upz = up[2];
  var z0 = eyex - target[0],
      z1 = eyey - target[1],
      z2 = eyez - target[2];
  var len = z0 * z0 + z1 * z1 + z2 * z2;

  if (len > 0) {
    len = 1 / Math.sqrt(len);
    z0 *= len;
    z1 *= len;
    z2 *= len;
  }

  var x0 = upy * z2 - upz * z1,
      x1 = upz * z0 - upx * z2,
      x2 = upx * z1 - upy * z0;
  len = x0 * x0 + x1 * x1 + x2 * x2;

  if (len > 0) {
    len = 1 / Math.sqrt(len);
    x0 *= len;
    x1 *= len;
    x2 *= len;
  }

  out[0] = x0;
  out[1] = x1;
  out[2] = x2;
  out[3] = 0;
  out[4] = z1 * x2 - z2 * x1;
  out[5] = z2 * x0 - z0 * x2;
  out[6] = z0 * x1 - z1 * x0;
  out[7] = 0;
  out[8] = z0;
  out[9] = z1;
  out[10] = z2;
  out[11] = 0;
  out[12] = eyex;
  out[13] = eyey;
  out[14] = eyez;
  out[15] = 1;
  return out;
}
;
/**
 * Returns a string representation of a mat4
 *
 * @param {mat4} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */

function str(a) {
  return 'mat4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' + a[8] + ', ' + a[9] + ', ' + a[10] + ', ' + a[11] + ', ' + a[12] + ', ' + a[13] + ', ' + a[14] + ', ' + a[15] + ')';
}
/**
 * Returns Frobenius norm of a mat4
 *
 * @param {mat4} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */

function frob(a) {
  return Math.hypot(a[0], a[1], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15]);
}
/**
 * Adds two mat4's
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  out[8] = a[8] + b[8];
  out[9] = a[9] + b[9];
  out[10] = a[10] + b[10];
  out[11] = a[11] + b[11];
  out[12] = a[12] + b[12];
  out[13] = a[13] + b[13];
  out[14] = a[14] + b[14];
  out[15] = a[15] + b[15];
  return out;
}
/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  out[6] = a[6] - b[6];
  out[7] = a[7] - b[7];
  out[8] = a[8] - b[8];
  out[9] = a[9] - b[9];
  out[10] = a[10] - b[10];
  out[11] = a[11] - b[11];
  out[12] = a[12] - b[12];
  out[13] = a[13] - b[13];
  out[14] = a[14] - b[14];
  out[15] = a[15] - b[15];
  return out;
}
/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat4} out
 */

function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  out[8] = a[8] * b;
  out[9] = a[9] * b;
  out[10] = a[10] * b;
  out[11] = a[11] * b;
  out[12] = a[12] * b;
  out[13] = a[13] * b;
  out[14] = a[14] * b;
  out[15] = a[15] * b;
  return out;
}
/**
 * Adds two mat4's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat4} out the receiving vector
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat4} out
 */

function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  out[4] = a[4] + b[4] * scale;
  out[5] = a[5] + b[5] * scale;
  out[6] = a[6] + b[6] * scale;
  out[7] = a[7] + b[7] * scale;
  out[8] = a[8] + b[8] * scale;
  out[9] = a[9] + b[9] * scale;
  out[10] = a[10] + b[10] * scale;
  out[11] = a[11] + b[11] * scale;
  out[12] = a[12] + b[12] * scale;
  out[13] = a[13] + b[13] * scale;
  out[14] = a[14] + b[14] * scale;
  out[15] = a[15] + b[15] * scale;
  return out;
}
/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat4} a The first matrix.
 * @param {mat4} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] && a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];
}
/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat4} a The first matrix.
 * @param {mat4} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var a4 = a[4],
      a5 = a[5],
      a6 = a[6],
      a7 = a[7];
  var a8 = a[8],
      a9 = a[9],
      a10 = a[10],
      a11 = a[11];
  var a12 = a[12],
      a13 = a[13],
      a14 = a[14],
      a15 = a[15];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  var b4 = b[4],
      b5 = b[5],
      b6 = b[6],
      b7 = b[7];
  var b8 = b[8],
      b9 = b[9],
      b10 = b[10],
      b11 = b[11];
  var b12 = b[12],
      b13 = b[13],
      b14 = b[14],
      b15 = b[15];
  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a8), Math.abs(b8)) && Math.abs(a9 - b9) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a9), Math.abs(b9)) && Math.abs(a10 - b10) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a10), Math.abs(b10)) && Math.abs(a11 - b11) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a11), Math.abs(b11)) && Math.abs(a12 - b12) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a12), Math.abs(b12)) && Math.abs(a13 - b13) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a13), Math.abs(b13)) && Math.abs(a14 - b14) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a14), Math.abs(b14)) && Math.abs(a15 - b15) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a15), Math.abs(b15));
}
/**
 * Alias for {@link mat4.multiply}
 * @function
 */

var mul = multiply;
/**
 * Alias for {@link mat4.subtract}
 * @function
 */

var sub = subtract;

/***/ }),

/***/ 221:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   add: () => (/* binding */ add),
/* harmony export */   calculateW: () => (/* binding */ calculateW),
/* harmony export */   clone: () => (/* binding */ clone),
/* harmony export */   conjugate: () => (/* binding */ conjugate),
/* harmony export */   copy: () => (/* binding */ copy),
/* harmony export */   create: () => (/* binding */ create),
/* harmony export */   dot: () => (/* binding */ dot),
/* harmony export */   equals: () => (/* binding */ equals),
/* harmony export */   exactEquals: () => (/* binding */ exactEquals),
/* harmony export */   exp: () => (/* binding */ exp),
/* harmony export */   fromEuler: () => (/* binding */ fromEuler),
/* harmony export */   fromMat3: () => (/* binding */ fromMat3),
/* harmony export */   fromValues: () => (/* binding */ fromValues),
/* harmony export */   getAngle: () => (/* binding */ getAngle),
/* harmony export */   getAxisAngle: () => (/* binding */ getAxisAngle),
/* harmony export */   identity: () => (/* binding */ identity),
/* harmony export */   invert: () => (/* binding */ invert),
/* harmony export */   len: () => (/* binding */ len),
/* harmony export */   length: () => (/* binding */ length),
/* harmony export */   lerp: () => (/* binding */ lerp),
/* harmony export */   ln: () => (/* binding */ ln),
/* harmony export */   mul: () => (/* binding */ mul),
/* harmony export */   multiply: () => (/* binding */ multiply),
/* harmony export */   normalize: () => (/* binding */ normalize),
/* harmony export */   pow: () => (/* binding */ pow),
/* harmony export */   random: () => (/* binding */ random),
/* harmony export */   rotateX: () => (/* binding */ rotateX),
/* harmony export */   rotateY: () => (/* binding */ rotateY),
/* harmony export */   rotateZ: () => (/* binding */ rotateZ),
/* harmony export */   rotationTo: () => (/* binding */ rotationTo),
/* harmony export */   scale: () => (/* binding */ scale),
/* harmony export */   set: () => (/* binding */ set),
/* harmony export */   setAxes: () => (/* binding */ setAxes),
/* harmony export */   setAxisAngle: () => (/* binding */ setAxisAngle),
/* harmony export */   slerp: () => (/* binding */ slerp),
/* harmony export */   sqlerp: () => (/* binding */ sqlerp),
/* harmony export */   sqrLen: () => (/* binding */ sqrLen),
/* harmony export */   squaredLength: () => (/* binding */ squaredLength),
/* harmony export */   str: () => (/* binding */ str)
/* harmony export */ });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(823);
/* harmony import */ var _mat3_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(409);
/* harmony import */ var _vec3_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(329);
/* harmony import */ var _vec4_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(796);




/**
 * Quaternion
 * @module quat
 */

/**
 * Creates a new identity quat
 *
 * @returns {quat} a new quaternion
 */

function create() {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(4);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }

  out[3] = 1;
  return out;
}
/**
 * Set a quat to the identity quaternion
 *
 * @param {quat} out the receiving quaternion
 * @returns {quat} out
 */

function identity(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}
/**
 * Sets a quat from the given angle and rotation axis,
 * then returns it.
 *
 * @param {quat} out the receiving quaternion
 * @param {vec3} axis the axis around which to rotate
 * @param {Number} rad the angle in radians
 * @returns {quat} out
 **/

function setAxisAngle(out, axis, rad) {
  rad = rad * 0.5;
  var s = Math.sin(rad);
  out[0] = s * axis[0];
  out[1] = s * axis[1];
  out[2] = s * axis[2];
  out[3] = Math.cos(rad);
  return out;
}
/**
 * Gets the rotation axis and angle for a given
 *  quaternion. If a quaternion is created with
 *  setAxisAngle, this method will return the same
 *  values as providied in the original parameter list
 *  OR functionally equivalent values.
 * Example: The quaternion formed by axis [0, 0, 1] and
 *  angle -90 is the same as the quaternion formed by
 *  [0, 0, 1] and 270. This method favors the latter.
 * @param  {vec3} out_axis  Vector receiving the axis of rotation
 * @param  {quat} q     Quaternion to be decomposed
 * @return {Number}     Angle, in radians, of the rotation
 */

function getAxisAngle(out_axis, q) {
  var rad = Math.acos(q[3]) * 2.0;
  var s = Math.sin(rad / 2.0);

  if (s > _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON) {
    out_axis[0] = q[0] / s;
    out_axis[1] = q[1] / s;
    out_axis[2] = q[2] / s;
  } else {
    // If s is zero, return any axis (no rotation - axis does not matter)
    out_axis[0] = 1;
    out_axis[1] = 0;
    out_axis[2] = 0;
  }

  return rad;
}
/**
 * Gets the angular distance between two unit quaternions
 *
 * @param  {quat} a     Origin unit quaternion 
 * @param  {quat} b     Destination unit quaternion
 * @return {Number}     Angle, in radians, between the two quaternions
 */

function getAngle(a, b) {
  var dotproduct = dot(a, b);
  return Math.acos(2 * dotproduct * dotproduct - 1);
}
/**
 * Multiplies two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {quat} out
 */

function multiply(out, a, b) {
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var bx = b[0],
      by = b[1],
      bz = b[2],
      bw = b[3];
  out[0] = ax * bw + aw * bx + ay * bz - az * by;
  out[1] = ay * bw + aw * by + az * bx - ax * bz;
  out[2] = az * bw + aw * bz + ax * by - ay * bx;
  out[3] = aw * bw - ax * bx - ay * by - az * bz;
  return out;
}
/**
 * Rotates a quaternion by the given angle about the X axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */

function rotateX(out, a, rad) {
  rad *= 0.5;
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var bx = Math.sin(rad),
      bw = Math.cos(rad);
  out[0] = ax * bw + aw * bx;
  out[1] = ay * bw + az * bx;
  out[2] = az * bw - ay * bx;
  out[3] = aw * bw - ax * bx;
  return out;
}
/**
 * Rotates a quaternion by the given angle about the Y axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */

function rotateY(out, a, rad) {
  rad *= 0.5;
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var by = Math.sin(rad),
      bw = Math.cos(rad);
  out[0] = ax * bw - az * by;
  out[1] = ay * bw + aw * by;
  out[2] = az * bw + ax * by;
  out[3] = aw * bw - ay * by;
  return out;
}
/**
 * Rotates a quaternion by the given angle about the Z axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */

function rotateZ(out, a, rad) {
  rad *= 0.5;
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var bz = Math.sin(rad),
      bw = Math.cos(rad);
  out[0] = ax * bw + ay * bz;
  out[1] = ay * bw - ax * bz;
  out[2] = az * bw + aw * bz;
  out[3] = aw * bw - az * bz;
  return out;
}
/**
 * Calculates the W component of a quat from the X, Y, and Z components.
 * Assumes that quaternion is 1 unit in length.
 * Any existing W component will be ignored.
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate W component of
 * @returns {quat} out
 */

function calculateW(out, a) {
  var x = a[0],
      y = a[1],
      z = a[2];
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));
  return out;
}
/**
 * Calculate the exponential of a unit quaternion.
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate the exponential of
 * @returns {quat} out
 */

function exp(out, a) {
  var x = a[0],
      y = a[1],
      z = a[2],
      w = a[3];
  var r = Math.sqrt(x * x + y * y + z * z);
  var et = Math.exp(w);
  var s = r > 0 ? et * Math.sin(r) / r : 0;
  out[0] = x * s;
  out[1] = y * s;
  out[2] = z * s;
  out[3] = et * Math.cos(r);
  return out;
}
/**
 * Calculate the natural logarithm of a unit quaternion.
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate the exponential of
 * @returns {quat} out
 */

function ln(out, a) {
  var x = a[0],
      y = a[1],
      z = a[2],
      w = a[3];
  var r = Math.sqrt(x * x + y * y + z * z);
  var t = r > 0 ? Math.atan2(r, w) / r : 0;
  out[0] = x * t;
  out[1] = y * t;
  out[2] = z * t;
  out[3] = 0.5 * Math.log(x * x + y * y + z * z + w * w);
  return out;
}
/**
 * Calculate the scalar power of a unit quaternion.
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate the exponential of
 * @param {Number} b amount to scale the quaternion by
 * @returns {quat} out
 */

function pow(out, a, b) {
  ln(out, a);
  scale(out, out, b);
  exp(out, out);
  return out;
}
/**
 * Performs a spherical linear interpolation between two quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat} out
 */

function slerp(out, a, b, t) {
  // benchmarks:
  //    http://jsperf.com/quaternion-slerp-implementations
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var bx = b[0],
      by = b[1],
      bz = b[2],
      bw = b[3];
  var omega, cosom, sinom, scale0, scale1; // calc cosine

  cosom = ax * bx + ay * by + az * bz + aw * bw; // adjust signs (if necessary)

  if (cosom < 0.0) {
    cosom = -cosom;
    bx = -bx;
    by = -by;
    bz = -bz;
    bw = -bw;
  } // calculate coefficients


  if (1.0 - cosom > _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON) {
    // standard case (slerp)
    omega = Math.acos(cosom);
    sinom = Math.sin(omega);
    scale0 = Math.sin((1.0 - t) * omega) / sinom;
    scale1 = Math.sin(t * omega) / sinom;
  } else {
    // "from" and "to" quaternions are very close
    //  ... so we can do a linear interpolation
    scale0 = 1.0 - t;
    scale1 = t;
  } // calculate final values


  out[0] = scale0 * ax + scale1 * bx;
  out[1] = scale0 * ay + scale1 * by;
  out[2] = scale0 * az + scale1 * bz;
  out[3] = scale0 * aw + scale1 * bw;
  return out;
}
/**
 * Generates a random unit quaternion
 * 
 * @param {quat} out the receiving quaternion
 * @returns {quat} out
 */

function random(out) {
  // Implementation of http://planning.cs.uiuc.edu/node198.html
  // TODO: Calling random 3 times is probably not the fastest solution
  var u1 = _common_js__WEBPACK_IMPORTED_MODULE_0__.RANDOM();
  var u2 = _common_js__WEBPACK_IMPORTED_MODULE_0__.RANDOM();
  var u3 = _common_js__WEBPACK_IMPORTED_MODULE_0__.RANDOM();
  var sqrt1MinusU1 = Math.sqrt(1 - u1);
  var sqrtU1 = Math.sqrt(u1);
  out[0] = sqrt1MinusU1 * Math.sin(2.0 * Math.PI * u2);
  out[1] = sqrt1MinusU1 * Math.cos(2.0 * Math.PI * u2);
  out[2] = sqrtU1 * Math.sin(2.0 * Math.PI * u3);
  out[3] = sqrtU1 * Math.cos(2.0 * Math.PI * u3);
  return out;
}
/**
 * Calculates the inverse of a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate inverse of
 * @returns {quat} out
 */

function invert(out, a) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var dot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;
  var invDot = dot ? 1.0 / dot : 0; // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0

  out[0] = -a0 * invDot;
  out[1] = -a1 * invDot;
  out[2] = -a2 * invDot;
  out[3] = a3 * invDot;
  return out;
}
/**
 * Calculates the conjugate of a quat
 * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate conjugate of
 * @returns {quat} out
 */

function conjugate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = a[3];
  return out;
}
/**
 * Creates a quaternion from the given 3x3 rotation matrix.
 *
 * NOTE: The resultant quaternion is not normalized, so you should be sure
 * to renormalize the quaternion yourself where necessary.
 *
 * @param {quat} out the receiving quaternion
 * @param {mat3} m rotation matrix
 * @returns {quat} out
 * @function
 */

function fromMat3(out, m) {
  // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
  // article "Quaternion Calculus and Fast Animation".
  var fTrace = m[0] + m[4] + m[8];
  var fRoot;

  if (fTrace > 0.0) {
    // |w| > 1/2, may as well choose w > 1/2
    fRoot = Math.sqrt(fTrace + 1.0); // 2w

    out[3] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot; // 1/(4w)

    out[0] = (m[5] - m[7]) * fRoot;
    out[1] = (m[6] - m[2]) * fRoot;
    out[2] = (m[1] - m[3]) * fRoot;
  } else {
    // |w| <= 1/2
    var i = 0;
    if (m[4] > m[0]) i = 1;
    if (m[8] > m[i * 3 + i]) i = 2;
    var j = (i + 1) % 3;
    var k = (i + 2) % 3;
    fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1.0);
    out[i] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot;
    out[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot;
    out[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;
    out[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;
  }

  return out;
}
/**
 * Creates a quaternion from the given euler angle x, y, z.
 *
 * @param {quat} out the receiving quaternion
 * @param {x} Angle to rotate around X axis in degrees.
 * @param {y} Angle to rotate around Y axis in degrees.
 * @param {z} Angle to rotate around Z axis in degrees.
 * @returns {quat} out
 * @function
 */

function fromEuler(out, x, y, z) {
  var halfToRad = 0.5 * Math.PI / 180.0;
  x *= halfToRad;
  y *= halfToRad;
  z *= halfToRad;
  var sx = Math.sin(x);
  var cx = Math.cos(x);
  var sy = Math.sin(y);
  var cy = Math.cos(y);
  var sz = Math.sin(z);
  var cz = Math.cos(z);
  out[0] = sx * cy * cz - cx * sy * sz;
  out[1] = cx * sy * cz + sx * cy * sz;
  out[2] = cx * cy * sz - sx * sy * cz;
  out[3] = cx * cy * cz + sx * sy * sz;
  return out;
}
/**
 * Returns a string representation of a quatenion
 *
 * @param {quat} a vector to represent as a string
 * @returns {String} string representation of the vector
 */

function str(a) {
  return 'quat(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
}
/**
 * Creates a new quat initialized with values from an existing quaternion
 *
 * @param {quat} a quaternion to clone
 * @returns {quat} a new quaternion
 * @function
 */

var clone = _vec4_js__WEBPACK_IMPORTED_MODULE_1__.clone;
/**
 * Creates a new quat initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} a new quaternion
 * @function
 */

var fromValues = _vec4_js__WEBPACK_IMPORTED_MODULE_1__.fromValues;
/**
 * Copy the values from one quat to another
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the source quaternion
 * @returns {quat} out
 * @function
 */

var copy = _vec4_js__WEBPACK_IMPORTED_MODULE_1__.copy;
/**
 * Set the components of a quat to the given values
 *
 * @param {quat} out the receiving quaternion
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} out
 * @function
 */

var set = _vec4_js__WEBPACK_IMPORTED_MODULE_1__.set;
/**
 * Adds two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {quat} out
 * @function
 */

var add = _vec4_js__WEBPACK_IMPORTED_MODULE_1__.add;
/**
 * Alias for {@link quat.multiply}
 * @function
 */

var mul = multiply;
/**
 * Scales a quat by a scalar number
 *
 * @param {quat} out the receiving vector
 * @param {quat} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {quat} out
 * @function
 */

var scale = _vec4_js__WEBPACK_IMPORTED_MODULE_1__.scale;
/**
 * Calculates the dot product of two quat's
 *
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {Number} dot product of a and b
 * @function
 */

var dot = _vec4_js__WEBPACK_IMPORTED_MODULE_1__.dot;
/**
 * Performs a linear interpolation between two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat} out
 * @function
 */

var lerp = _vec4_js__WEBPACK_IMPORTED_MODULE_1__.lerp;
/**
 * Calculates the length of a quat
 *
 * @param {quat} a vector to calculate length of
 * @returns {Number} length of a
 */

var length = _vec4_js__WEBPACK_IMPORTED_MODULE_1__.length;
/**
 * Alias for {@link quat.length}
 * @function
 */

var len = length;
/**
 * Calculates the squared length of a quat
 *
 * @param {quat} a vector to calculate squared length of
 * @returns {Number} squared length of a
 * @function
 */

var squaredLength = _vec4_js__WEBPACK_IMPORTED_MODULE_1__.squaredLength;
/**
 * Alias for {@link quat.squaredLength}
 * @function
 */

var sqrLen = squaredLength;
/**
 * Normalize a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quaternion to normalize
 * @returns {quat} out
 * @function
 */

var normalize = _vec4_js__WEBPACK_IMPORTED_MODULE_1__.normalize;
/**
 * Returns whether or not the quaternions have exactly the same elements in the same position (when compared with ===)
 *
 * @param {quat} a The first quaternion.
 * @param {quat} b The second quaternion.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

var exactEquals = _vec4_js__WEBPACK_IMPORTED_MODULE_1__.exactEquals;
/**
 * Returns whether or not the quaternions have approximately the same elements in the same position.
 *
 * @param {quat} a The first vector.
 * @param {quat} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

var equals = _vec4_js__WEBPACK_IMPORTED_MODULE_1__.equals;
/**
 * Sets a quaternion to represent the shortest rotation from one
 * vector to another.
 *
 * Both vectors are assumed to be unit length.
 *
 * @param {quat} out the receiving quaternion.
 * @param {vec3} a the initial vector
 * @param {vec3} b the destination vector
 * @returns {quat} out
 */

var rotationTo = function () {
  var tmpvec3 = _vec3_js__WEBPACK_IMPORTED_MODULE_2__.create();
  var xUnitVec3 = _vec3_js__WEBPACK_IMPORTED_MODULE_2__.fromValues(1, 0, 0);
  var yUnitVec3 = _vec3_js__WEBPACK_IMPORTED_MODULE_2__.fromValues(0, 1, 0);
  return function (out, a, b) {
    var dot = _vec3_js__WEBPACK_IMPORTED_MODULE_2__.dot(a, b);

    if (dot < -0.999999) {
      _vec3_js__WEBPACK_IMPORTED_MODULE_2__.cross(tmpvec3, xUnitVec3, a);
      if (_vec3_js__WEBPACK_IMPORTED_MODULE_2__.len(tmpvec3) < 0.000001) _vec3_js__WEBPACK_IMPORTED_MODULE_2__.cross(tmpvec3, yUnitVec3, a);
      _vec3_js__WEBPACK_IMPORTED_MODULE_2__.normalize(tmpvec3, tmpvec3);
      setAxisAngle(out, tmpvec3, Math.PI);
      return out;
    } else if (dot > 0.999999) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
      out[3] = 1;
      return out;
    } else {
      _vec3_js__WEBPACK_IMPORTED_MODULE_2__.cross(tmpvec3, a, b);
      out[0] = tmpvec3[0];
      out[1] = tmpvec3[1];
      out[2] = tmpvec3[2];
      out[3] = 1 + dot;
      return normalize(out, out);
    }
  };
}();
/**
 * Performs a spherical linear interpolation with two control points
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {quat} c the third operand
 * @param {quat} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat} out
 */

var sqlerp = function () {
  var temp1 = create();
  var temp2 = create();
  return function (out, a, b, c, d, t) {
    slerp(temp1, a, d, t);
    slerp(temp2, b, c, t);
    slerp(out, temp1, temp2, 2 * t * (1 - t));
    return out;
  };
}();
/**
 * Sets the specified quaternion with values corresponding to the given
 * axes. Each axis is a vec3 and is expected to be unit length and
 * perpendicular to all other specified axes.
 *
 * @param {vec3} view  the vector representing the viewing direction
 * @param {vec3} right the vector representing the local "right" direction
 * @param {vec3} up    the vector representing the local "up" direction
 * @returns {quat} out
 */

var setAxes = function () {
  var matr = _mat3_js__WEBPACK_IMPORTED_MODULE_3__.create();
  return function (out, view, right, up) {
    matr[0] = right[0];
    matr[3] = right[1];
    matr[6] = right[2];
    matr[1] = up[0];
    matr[4] = up[1];
    matr[7] = up[2];
    matr[2] = -view[0];
    matr[5] = -view[1];
    matr[8] = -view[2];
    return normalize(out, fromMat3(out, matr));
  };
}();

/***/ }),

/***/ 991:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   add: () => (/* binding */ add),
/* harmony export */   clone: () => (/* binding */ clone),
/* harmony export */   conjugate: () => (/* binding */ conjugate),
/* harmony export */   copy: () => (/* binding */ copy),
/* harmony export */   create: () => (/* binding */ create),
/* harmony export */   dot: () => (/* binding */ dot),
/* harmony export */   equals: () => (/* binding */ equals),
/* harmony export */   exactEquals: () => (/* binding */ exactEquals),
/* harmony export */   fromMat4: () => (/* binding */ fromMat4),
/* harmony export */   fromRotation: () => (/* binding */ fromRotation),
/* harmony export */   fromRotationTranslation: () => (/* binding */ fromRotationTranslation),
/* harmony export */   fromRotationTranslationValues: () => (/* binding */ fromRotationTranslationValues),
/* harmony export */   fromTranslation: () => (/* binding */ fromTranslation),
/* harmony export */   fromValues: () => (/* binding */ fromValues),
/* harmony export */   getDual: () => (/* binding */ getDual),
/* harmony export */   getReal: () => (/* binding */ getReal),
/* harmony export */   getTranslation: () => (/* binding */ getTranslation),
/* harmony export */   identity: () => (/* binding */ identity),
/* harmony export */   invert: () => (/* binding */ invert),
/* harmony export */   len: () => (/* binding */ len),
/* harmony export */   length: () => (/* binding */ length),
/* harmony export */   lerp: () => (/* binding */ lerp),
/* harmony export */   mul: () => (/* binding */ mul),
/* harmony export */   multiply: () => (/* binding */ multiply),
/* harmony export */   normalize: () => (/* binding */ normalize),
/* harmony export */   rotateAroundAxis: () => (/* binding */ rotateAroundAxis),
/* harmony export */   rotateByQuatAppend: () => (/* binding */ rotateByQuatAppend),
/* harmony export */   rotateByQuatPrepend: () => (/* binding */ rotateByQuatPrepend),
/* harmony export */   rotateX: () => (/* binding */ rotateX),
/* harmony export */   rotateY: () => (/* binding */ rotateY),
/* harmony export */   rotateZ: () => (/* binding */ rotateZ),
/* harmony export */   scale: () => (/* binding */ scale),
/* harmony export */   set: () => (/* binding */ set),
/* harmony export */   setDual: () => (/* binding */ setDual),
/* harmony export */   setReal: () => (/* binding */ setReal),
/* harmony export */   sqrLen: () => (/* binding */ sqrLen),
/* harmony export */   squaredLength: () => (/* binding */ squaredLength),
/* harmony export */   str: () => (/* binding */ str),
/* harmony export */   translate: () => (/* binding */ translate)
/* harmony export */ });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(823);
/* harmony import */ var _quat_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(221);
/* harmony import */ var _mat4_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(684);



/**
 * Dual Quaternion<br>
 * Format: [real, dual]<br>
 * Quaternion format: XYZW<br>
 * Make sure to have normalized dual quaternions, otherwise the functions may not work as intended.<br>
 * @module quat2
 */

/**
 * Creates a new identity dual quat
 *
 * @returns {quat2} a new dual quaternion [real -> rotation, dual -> translation]
 */

function create() {
  var dq = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(8);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE != Float32Array) {
    dq[0] = 0;
    dq[1] = 0;
    dq[2] = 0;
    dq[4] = 0;
    dq[5] = 0;
    dq[6] = 0;
    dq[7] = 0;
  }

  dq[3] = 1;
  return dq;
}
/**
 * Creates a new quat initialized with values from an existing quaternion
 *
 * @param {quat2} a dual quaternion to clone
 * @returns {quat2} new dual quaternion
 * @function
 */

function clone(a) {
  var dq = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(8);
  dq[0] = a[0];
  dq[1] = a[1];
  dq[2] = a[2];
  dq[3] = a[3];
  dq[4] = a[4];
  dq[5] = a[5];
  dq[6] = a[6];
  dq[7] = a[7];
  return dq;
}
/**
 * Creates a new dual quat initialized with the given values
 *
 * @param {Number} x1 X component
 * @param {Number} y1 Y component
 * @param {Number} z1 Z component
 * @param {Number} w1 W component
 * @param {Number} x2 X component
 * @param {Number} y2 Y component
 * @param {Number} z2 Z component
 * @param {Number} w2 W component
 * @returns {quat2} new dual quaternion
 * @function
 */

function fromValues(x1, y1, z1, w1, x2, y2, z2, w2) {
  var dq = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(8);
  dq[0] = x1;
  dq[1] = y1;
  dq[2] = z1;
  dq[3] = w1;
  dq[4] = x2;
  dq[5] = y2;
  dq[6] = z2;
  dq[7] = w2;
  return dq;
}
/**
 * Creates a new dual quat from the given values (quat and translation)
 *
 * @param {Number} x1 X component
 * @param {Number} y1 Y component
 * @param {Number} z1 Z component
 * @param {Number} w1 W component
 * @param {Number} x2 X component (translation)
 * @param {Number} y2 Y component (translation)
 * @param {Number} z2 Z component (translation)
 * @returns {quat2} new dual quaternion
 * @function
 */

function fromRotationTranslationValues(x1, y1, z1, w1, x2, y2, z2) {
  var dq = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(8);
  dq[0] = x1;
  dq[1] = y1;
  dq[2] = z1;
  dq[3] = w1;
  var ax = x2 * 0.5,
      ay = y2 * 0.5,
      az = z2 * 0.5;
  dq[4] = ax * w1 + ay * z1 - az * y1;
  dq[5] = ay * w1 + az * x1 - ax * z1;
  dq[6] = az * w1 + ax * y1 - ay * x1;
  dq[7] = -ax * x1 - ay * y1 - az * z1;
  return dq;
}
/**
 * Creates a dual quat from a quaternion and a translation
 *
 * @param {quat2} dual quaternion receiving operation result
 * @param {quat} q a normalized quaternion
 * @param {vec3} t tranlation vector
 * @returns {quat2} dual quaternion receiving operation result
 * @function
 */

function fromRotationTranslation(out, q, t) {
  var ax = t[0] * 0.5,
      ay = t[1] * 0.5,
      az = t[2] * 0.5,
      bx = q[0],
      by = q[1],
      bz = q[2],
      bw = q[3];
  out[0] = bx;
  out[1] = by;
  out[2] = bz;
  out[3] = bw;
  out[4] = ax * bw + ay * bz - az * by;
  out[5] = ay * bw + az * bx - ax * bz;
  out[6] = az * bw + ax * by - ay * bx;
  out[7] = -ax * bx - ay * by - az * bz;
  return out;
}
/**
 * Creates a dual quat from a translation
 *
 * @param {quat2} dual quaternion receiving operation result
 * @param {vec3} t translation vector
 * @returns {quat2} dual quaternion receiving operation result
 * @function
 */

function fromTranslation(out, t) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  out[4] = t[0] * 0.5;
  out[5] = t[1] * 0.5;
  out[6] = t[2] * 0.5;
  out[7] = 0;
  return out;
}
/**
 * Creates a dual quat from a quaternion
 *
 * @param {quat2} dual quaternion receiving operation result
 * @param {quat} q the quaternion
 * @returns {quat2} dual quaternion receiving operation result
 * @function
 */

function fromRotation(out, q) {
  out[0] = q[0];
  out[1] = q[1];
  out[2] = q[2];
  out[3] = q[3];
  out[4] = 0;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  return out;
}
/**
 * Creates a new dual quat from a matrix (4x4)
 *
 * @param {quat2} out the dual quaternion
 * @param {mat4} a the matrix
 * @returns {quat2} dual quat receiving operation result
 * @function
 */

function fromMat4(out, a) {
  //TODO Optimize this
  var outer = _quat_js__WEBPACK_IMPORTED_MODULE_1__.create();
  _mat4_js__WEBPACK_IMPORTED_MODULE_2__.getRotation(outer, a);
  var t = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(3);
  _mat4_js__WEBPACK_IMPORTED_MODULE_2__.getTranslation(t, a);
  fromRotationTranslation(out, outer, t);
  return out;
}
/**
 * Copy the values from one dual quat to another
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {quat2} a the source dual quaternion
 * @returns {quat2} out
 * @function
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  return out;
}
/**
 * Set a dual quat to the identity dual quaternion
 *
 * @param {quat2} out the receiving quaternion
 * @returns {quat2} out
 */

function identity(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  out[4] = 0;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  return out;
}
/**
 * Set the components of a dual quat to the given values
 *
 * @param {quat2} out the receiving quaternion
 * @param {Number} x1 X component
 * @param {Number} y1 Y component
 * @param {Number} z1 Z component
 * @param {Number} w1 W component
 * @param {Number} x2 X component
 * @param {Number} y2 Y component
 * @param {Number} z2 Z component
 * @param {Number} w2 W component
 * @returns {quat2} out
 * @function
 */

function set(out, x1, y1, z1, w1, x2, y2, z2, w2) {
  out[0] = x1;
  out[1] = y1;
  out[2] = z1;
  out[3] = w1;
  out[4] = x2;
  out[5] = y2;
  out[6] = z2;
  out[7] = w2;
  return out;
}
/**
 * Gets the real part of a dual quat
 * @param  {quat} out real part
 * @param  {quat2} a Dual Quaternion
 * @return {quat} real part
 */

var getReal = _quat_js__WEBPACK_IMPORTED_MODULE_1__.copy;
/**
 * Gets the dual part of a dual quat
 * @param  {quat} out dual part
 * @param  {quat2} a Dual Quaternion
 * @return {quat} dual part
 */

function getDual(out, a) {
  out[0] = a[4];
  out[1] = a[5];
  out[2] = a[6];
  out[3] = a[7];
  return out;
}
/**
 * Set the real component of a dual quat to the given quaternion
 *
 * @param {quat2} out the receiving quaternion
 * @param {quat} q a quaternion representing the real part
 * @returns {quat2} out
 * @function
 */

var setReal = _quat_js__WEBPACK_IMPORTED_MODULE_1__.copy;
/**
 * Set the dual component of a dual quat to the given quaternion
 *
 * @param {quat2} out the receiving quaternion
 * @param {quat} q a quaternion representing the dual part
 * @returns {quat2} out
 * @function
 */

function setDual(out, q) {
  out[4] = q[0];
  out[5] = q[1];
  out[6] = q[2];
  out[7] = q[3];
  return out;
}
/**
 * Gets the translation of a normalized dual quat
 * @param  {vec3} out translation
 * @param  {quat2} a Dual Quaternion to be decomposed
 * @return {vec3} translation
 */

function getTranslation(out, a) {
  var ax = a[4],
      ay = a[5],
      az = a[6],
      aw = a[7],
      bx = -a[0],
      by = -a[1],
      bz = -a[2],
      bw = a[3];
  out[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;
  out[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;
  out[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;
  return out;
}
/**
 * Translates a dual quat by the given vector
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {quat2} a the dual quaternion to translate
 * @param {vec3} v vector to translate by
 * @returns {quat2} out
 */

function translate(out, a, v) {
  var ax1 = a[0],
      ay1 = a[1],
      az1 = a[2],
      aw1 = a[3],
      bx1 = v[0] * 0.5,
      by1 = v[1] * 0.5,
      bz1 = v[2] * 0.5,
      ax2 = a[4],
      ay2 = a[5],
      az2 = a[6],
      aw2 = a[7];
  out[0] = ax1;
  out[1] = ay1;
  out[2] = az1;
  out[3] = aw1;
  out[4] = aw1 * bx1 + ay1 * bz1 - az1 * by1 + ax2;
  out[5] = aw1 * by1 + az1 * bx1 - ax1 * bz1 + ay2;
  out[6] = aw1 * bz1 + ax1 * by1 - ay1 * bx1 + az2;
  out[7] = -ax1 * bx1 - ay1 * by1 - az1 * bz1 + aw2;
  return out;
}
/**
 * Rotates a dual quat around the X axis
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {quat2} a the dual quaternion to rotate
 * @param {number} rad how far should the rotation be
 * @returns {quat2} out
 */

function rotateX(out, a, rad) {
  var bx = -a[0],
      by = -a[1],
      bz = -a[2],
      bw = a[3],
      ax = a[4],
      ay = a[5],
      az = a[6],
      aw = a[7],
      ax1 = ax * bw + aw * bx + ay * bz - az * by,
      ay1 = ay * bw + aw * by + az * bx - ax * bz,
      az1 = az * bw + aw * bz + ax * by - ay * bx,
      aw1 = aw * bw - ax * bx - ay * by - az * bz;
  _quat_js__WEBPACK_IMPORTED_MODULE_1__.rotateX(out, a, rad);
  bx = out[0];
  by = out[1];
  bz = out[2];
  bw = out[3];
  out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
  out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
  out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
  out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
  return out;
}
/**
 * Rotates a dual quat around the Y axis
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {quat2} a the dual quaternion to rotate
 * @param {number} rad how far should the rotation be
 * @returns {quat2} out
 */

function rotateY(out, a, rad) {
  var bx = -a[0],
      by = -a[1],
      bz = -a[2],
      bw = a[3],
      ax = a[4],
      ay = a[5],
      az = a[6],
      aw = a[7],
      ax1 = ax * bw + aw * bx + ay * bz - az * by,
      ay1 = ay * bw + aw * by + az * bx - ax * bz,
      az1 = az * bw + aw * bz + ax * by - ay * bx,
      aw1 = aw * bw - ax * bx - ay * by - az * bz;
  _quat_js__WEBPACK_IMPORTED_MODULE_1__.rotateY(out, a, rad);
  bx = out[0];
  by = out[1];
  bz = out[2];
  bw = out[3];
  out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
  out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
  out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
  out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
  return out;
}
/**
 * Rotates a dual quat around the Z axis
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {quat2} a the dual quaternion to rotate
 * @param {number} rad how far should the rotation be
 * @returns {quat2} out
 */

function rotateZ(out, a, rad) {
  var bx = -a[0],
      by = -a[1],
      bz = -a[2],
      bw = a[3],
      ax = a[4],
      ay = a[5],
      az = a[6],
      aw = a[7],
      ax1 = ax * bw + aw * bx + ay * bz - az * by,
      ay1 = ay * bw + aw * by + az * bx - ax * bz,
      az1 = az * bw + aw * bz + ax * by - ay * bx,
      aw1 = aw * bw - ax * bx - ay * by - az * bz;
  _quat_js__WEBPACK_IMPORTED_MODULE_1__.rotateZ(out, a, rad);
  bx = out[0];
  by = out[1];
  bz = out[2];
  bw = out[3];
  out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
  out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
  out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
  out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
  return out;
}
/**
 * Rotates a dual quat by a given quaternion (a * q)
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {quat2} a the dual quaternion to rotate
 * @param {quat} q quaternion to rotate by
 * @returns {quat2} out
 */

function rotateByQuatAppend(out, a, q) {
  var qx = q[0],
      qy = q[1],
      qz = q[2],
      qw = q[3],
      ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  out[0] = ax * qw + aw * qx + ay * qz - az * qy;
  out[1] = ay * qw + aw * qy + az * qx - ax * qz;
  out[2] = az * qw + aw * qz + ax * qy - ay * qx;
  out[3] = aw * qw - ax * qx - ay * qy - az * qz;
  ax = a[4];
  ay = a[5];
  az = a[6];
  aw = a[7];
  out[4] = ax * qw + aw * qx + ay * qz - az * qy;
  out[5] = ay * qw + aw * qy + az * qx - ax * qz;
  out[6] = az * qw + aw * qz + ax * qy - ay * qx;
  out[7] = aw * qw - ax * qx - ay * qy - az * qz;
  return out;
}
/**
 * Rotates a dual quat by a given quaternion (q * a)
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {quat} q quaternion to rotate by
 * @param {quat2} a the dual quaternion to rotate
 * @returns {quat2} out
 */

function rotateByQuatPrepend(out, q, a) {
  var qx = q[0],
      qy = q[1],
      qz = q[2],
      qw = q[3],
      bx = a[0],
      by = a[1],
      bz = a[2],
      bw = a[3];
  out[0] = qx * bw + qw * bx + qy * bz - qz * by;
  out[1] = qy * bw + qw * by + qz * bx - qx * bz;
  out[2] = qz * bw + qw * bz + qx * by - qy * bx;
  out[3] = qw * bw - qx * bx - qy * by - qz * bz;
  bx = a[4];
  by = a[5];
  bz = a[6];
  bw = a[7];
  out[4] = qx * bw + qw * bx + qy * bz - qz * by;
  out[5] = qy * bw + qw * by + qz * bx - qx * bz;
  out[6] = qz * bw + qw * bz + qx * by - qy * bx;
  out[7] = qw * bw - qx * bx - qy * by - qz * bz;
  return out;
}
/**
 * Rotates a dual quat around a given axis. Does the normalisation automatically
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {quat2} a the dual quaternion to rotate
 * @param {vec3} axis the axis to rotate around
 * @param {Number} rad how far the rotation should be
 * @returns {quat2} out
 */

function rotateAroundAxis(out, a, axis, rad) {
  //Special case for rad = 0
  if (Math.abs(rad) < _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON) {
    return copy(out, a);
  }

  var axisLength = Math.hypot(axis[0], axis[1], axis[2]);
  rad = rad * 0.5;
  var s = Math.sin(rad);
  var bx = s * axis[0] / axisLength;
  var by = s * axis[1] / axisLength;
  var bz = s * axis[2] / axisLength;
  var bw = Math.cos(rad);
  var ax1 = a[0],
      ay1 = a[1],
      az1 = a[2],
      aw1 = a[3];
  out[0] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
  out[1] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
  out[2] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
  out[3] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
  var ax = a[4],
      ay = a[5],
      az = a[6],
      aw = a[7];
  out[4] = ax * bw + aw * bx + ay * bz - az * by;
  out[5] = ay * bw + aw * by + az * bx - ax * bz;
  out[6] = az * bw + aw * bz + ax * by - ay * bx;
  out[7] = aw * bw - ax * bx - ay * by - az * bz;
  return out;
}
/**
 * Adds two dual quat's
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {quat2} a the first operand
 * @param {quat2} b the second operand
 * @returns {quat2} out
 * @function
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  return out;
}
/**
 * Multiplies two dual quat's
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {quat2} a the first operand
 * @param {quat2} b the second operand
 * @returns {quat2} out
 */

function multiply(out, a, b) {
  var ax0 = a[0],
      ay0 = a[1],
      az0 = a[2],
      aw0 = a[3],
      bx1 = b[4],
      by1 = b[5],
      bz1 = b[6],
      bw1 = b[7],
      ax1 = a[4],
      ay1 = a[5],
      az1 = a[6],
      aw1 = a[7],
      bx0 = b[0],
      by0 = b[1],
      bz0 = b[2],
      bw0 = b[3];
  out[0] = ax0 * bw0 + aw0 * bx0 + ay0 * bz0 - az0 * by0;
  out[1] = ay0 * bw0 + aw0 * by0 + az0 * bx0 - ax0 * bz0;
  out[2] = az0 * bw0 + aw0 * bz0 + ax0 * by0 - ay0 * bx0;
  out[3] = aw0 * bw0 - ax0 * bx0 - ay0 * by0 - az0 * bz0;
  out[4] = ax0 * bw1 + aw0 * bx1 + ay0 * bz1 - az0 * by1 + ax1 * bw0 + aw1 * bx0 + ay1 * bz0 - az1 * by0;
  out[5] = ay0 * bw1 + aw0 * by1 + az0 * bx1 - ax0 * bz1 + ay1 * bw0 + aw1 * by0 + az1 * bx0 - ax1 * bz0;
  out[6] = az0 * bw1 + aw0 * bz1 + ax0 * by1 - ay0 * bx1 + az1 * bw0 + aw1 * bz0 + ax1 * by0 - ay1 * bx0;
  out[7] = aw0 * bw1 - ax0 * bx1 - ay0 * by1 - az0 * bz1 + aw1 * bw0 - ax1 * bx0 - ay1 * by0 - az1 * bz0;
  return out;
}
/**
 * Alias for {@link quat2.multiply}
 * @function
 */

var mul = multiply;
/**
 * Scales a dual quat by a scalar number
 *
 * @param {quat2} out the receiving dual quat
 * @param {quat2} a the dual quat to scale
 * @param {Number} b amount to scale the dual quat by
 * @returns {quat2} out
 * @function
 */

function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  return out;
}
/**
 * Calculates the dot product of two dual quat's (The dot product of the real parts)
 *
 * @param {quat2} a the first operand
 * @param {quat2} b the second operand
 * @returns {Number} dot product of a and b
 * @function
 */

var dot = _quat_js__WEBPACK_IMPORTED_MODULE_1__.dot;
/**
 * Performs a linear interpolation between two dual quats's
 * NOTE: The resulting dual quaternions won't always be normalized (The error is most noticeable when t = 0.5)
 *
 * @param {quat2} out the receiving dual quat
 * @param {quat2} a the first operand
 * @param {quat2} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat2} out
 */

function lerp(out, a, b, t) {
  var mt = 1 - t;
  if (dot(a, b) < 0) t = -t;
  out[0] = a[0] * mt + b[0] * t;
  out[1] = a[1] * mt + b[1] * t;
  out[2] = a[2] * mt + b[2] * t;
  out[3] = a[3] * mt + b[3] * t;
  out[4] = a[4] * mt + b[4] * t;
  out[5] = a[5] * mt + b[5] * t;
  out[6] = a[6] * mt + b[6] * t;
  out[7] = a[7] * mt + b[7] * t;
  return out;
}
/**
 * Calculates the inverse of a dual quat. If they are normalized, conjugate is cheaper
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {quat2} a dual quat to calculate inverse of
 * @returns {quat2} out
 */

function invert(out, a) {
  var sqlen = squaredLength(a);
  out[0] = -a[0] / sqlen;
  out[1] = -a[1] / sqlen;
  out[2] = -a[2] / sqlen;
  out[3] = a[3] / sqlen;
  out[4] = -a[4] / sqlen;
  out[5] = -a[5] / sqlen;
  out[6] = -a[6] / sqlen;
  out[7] = a[7] / sqlen;
  return out;
}
/**
 * Calculates the conjugate of a dual quat
 * If the dual quaternion is normalized, this function is faster than quat2.inverse and produces the same result.
 *
 * @param {quat2} out the receiving quaternion
 * @param {quat2} a quat to calculate conjugate of
 * @returns {quat2} out
 */

function conjugate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = a[3];
  out[4] = -a[4];
  out[5] = -a[5];
  out[6] = -a[6];
  out[7] = a[7];
  return out;
}
/**
 * Calculates the length of a dual quat
 *
 * @param {quat2} a dual quat to calculate length of
 * @returns {Number} length of a
 * @function
 */

var length = _quat_js__WEBPACK_IMPORTED_MODULE_1__.length;
/**
 * Alias for {@link quat2.length}
 * @function
 */

var len = length;
/**
 * Calculates the squared length of a dual quat
 *
 * @param {quat2} a dual quat to calculate squared length of
 * @returns {Number} squared length of a
 * @function
 */

var squaredLength = _quat_js__WEBPACK_IMPORTED_MODULE_1__.squaredLength;
/**
 * Alias for {@link quat2.squaredLength}
 * @function
 */

var sqrLen = squaredLength;
/**
 * Normalize a dual quat
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {quat2} a dual quaternion to normalize
 * @returns {quat2} out
 * @function
 */

function normalize(out, a) {
  var magnitude = squaredLength(a);

  if (magnitude > 0) {
    magnitude = Math.sqrt(magnitude);
    var a0 = a[0] / magnitude;
    var a1 = a[1] / magnitude;
    var a2 = a[2] / magnitude;
    var a3 = a[3] / magnitude;
    var b0 = a[4];
    var b1 = a[5];
    var b2 = a[6];
    var b3 = a[7];
    var a_dot_b = a0 * b0 + a1 * b1 + a2 * b2 + a3 * b3;
    out[0] = a0;
    out[1] = a1;
    out[2] = a2;
    out[3] = a3;
    out[4] = (b0 - a0 * a_dot_b) / magnitude;
    out[5] = (b1 - a1 * a_dot_b) / magnitude;
    out[6] = (b2 - a2 * a_dot_b) / magnitude;
    out[7] = (b3 - a3 * a_dot_b) / magnitude;
  }

  return out;
}
/**
 * Returns a string representation of a dual quatenion
 *
 * @param {quat2} a dual quaternion to represent as a string
 * @returns {String} string representation of the dual quat
 */

function str(a) {
  return 'quat2(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ')';
}
/**
 * Returns whether or not the dual quaternions have exactly the same elements in the same position (when compared with ===)
 *
 * @param {quat2} a the first dual quaternion.
 * @param {quat2} b the second dual quaternion.
 * @returns {Boolean} true if the dual quaternions are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7];
}
/**
 * Returns whether or not the dual quaternions have approximately the same elements in the same position.
 *
 * @param {quat2} a the first dual quat.
 * @param {quat2} b the second dual quat.
 * @returns {Boolean} true if the dual quats are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5],
      a6 = a[6],
      a7 = a[7];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3],
      b4 = b[4],
      b5 = b[5],
      b6 = b[6],
      b7 = b[7];
  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7));
}

/***/ }),

/***/ 842:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   add: () => (/* binding */ add),
/* harmony export */   angle: () => (/* binding */ angle),
/* harmony export */   ceil: () => (/* binding */ ceil),
/* harmony export */   clone: () => (/* binding */ clone),
/* harmony export */   copy: () => (/* binding */ copy),
/* harmony export */   create: () => (/* binding */ create),
/* harmony export */   cross: () => (/* binding */ cross),
/* harmony export */   dist: () => (/* binding */ dist),
/* harmony export */   distance: () => (/* binding */ distance),
/* harmony export */   div: () => (/* binding */ div),
/* harmony export */   divide: () => (/* binding */ divide),
/* harmony export */   dot: () => (/* binding */ dot),
/* harmony export */   equals: () => (/* binding */ equals),
/* harmony export */   exactEquals: () => (/* binding */ exactEquals),
/* harmony export */   floor: () => (/* binding */ floor),
/* harmony export */   forEach: () => (/* binding */ forEach),
/* harmony export */   fromValues: () => (/* binding */ fromValues),
/* harmony export */   inverse: () => (/* binding */ inverse),
/* harmony export */   len: () => (/* binding */ len),
/* harmony export */   length: () => (/* binding */ length),
/* harmony export */   lerp: () => (/* binding */ lerp),
/* harmony export */   max: () => (/* binding */ max),
/* harmony export */   min: () => (/* binding */ min),
/* harmony export */   mul: () => (/* binding */ mul),
/* harmony export */   multiply: () => (/* binding */ multiply),
/* harmony export */   negate: () => (/* binding */ negate),
/* harmony export */   normalize: () => (/* binding */ normalize),
/* harmony export */   random: () => (/* binding */ random),
/* harmony export */   rotate: () => (/* binding */ rotate),
/* harmony export */   round: () => (/* binding */ round),
/* harmony export */   scale: () => (/* binding */ scale),
/* harmony export */   scaleAndAdd: () => (/* binding */ scaleAndAdd),
/* harmony export */   set: () => (/* binding */ set),
/* harmony export */   sqrDist: () => (/* binding */ sqrDist),
/* harmony export */   sqrLen: () => (/* binding */ sqrLen),
/* harmony export */   squaredDistance: () => (/* binding */ squaredDistance),
/* harmony export */   squaredLength: () => (/* binding */ squaredLength),
/* harmony export */   str: () => (/* binding */ str),
/* harmony export */   sub: () => (/* binding */ sub),
/* harmony export */   subtract: () => (/* binding */ subtract),
/* harmony export */   transformMat2: () => (/* binding */ transformMat2),
/* harmony export */   transformMat2d: () => (/* binding */ transformMat2d),
/* harmony export */   transformMat3: () => (/* binding */ transformMat3),
/* harmony export */   transformMat4: () => (/* binding */ transformMat4),
/* harmony export */   zero: () => (/* binding */ zero)
/* harmony export */ });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(823);

/**
 * 2 Dimensional Vector
 * @module vec2
 */

/**
 * Creates a new, empty vec2
 *
 * @returns {vec2} a new 2D vector
 */

function create() {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(2);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
  }

  return out;
}
/**
 * Creates a new vec2 initialized with values from an existing vector
 *
 * @param {vec2} a vector to clone
 * @returns {vec2} a new 2D vector
 */

function clone(a) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(2);
  out[0] = a[0];
  out[1] = a[1];
  return out;
}
/**
 * Creates a new vec2 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} a new 2D vector
 */

function fromValues(x, y) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(2);
  out[0] = x;
  out[1] = y;
  return out;
}
/**
 * Copy the values from one vec2 to another
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the source vector
 * @returns {vec2} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  return out;
}
/**
 * Set the components of a vec2 to the given values
 *
 * @param {vec2} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} out
 */

function set(out, x, y) {
  out[0] = x;
  out[1] = y;
  return out;
}
/**
 * Adds two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  return out;
}
/**
 * Subtracts vector b from vector a
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  return out;
}
/**
 * Multiplies two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */

function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  return out;
}
/**
 * Divides two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */

function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  return out;
}
/**
 * Math.ceil the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to ceil
 * @returns {vec2} out
 */

function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  return out;
}
/**
 * Math.floor the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to floor
 * @returns {vec2} out
 */

function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  return out;
}
/**
 * Returns the minimum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */

function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  return out;
}
/**
 * Returns the maximum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */

function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  return out;
}
/**
 * Math.round the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to round
 * @returns {vec2} out
 */

function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  return out;
}
/**
 * Scales a vec2 by a scalar number
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec2} out
 */

function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  return out;
}
/**
 * Adds two vec2's after scaling the second operand by a scalar value
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec2} out
 */

function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  return out;
}
/**
 * Calculates the euclidian distance between two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} distance between a and b
 */

function distance(a, b) {
  var x = b[0] - a[0],
      y = b[1] - a[1];
  return Math.hypot(x, y);
}
/**
 * Calculates the squared euclidian distance between two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} squared distance between a and b
 */

function squaredDistance(a, b) {
  var x = b[0] - a[0],
      y = b[1] - a[1];
  return x * x + y * y;
}
/**
 * Calculates the length of a vec2
 *
 * @param {vec2} a vector to calculate length of
 * @returns {Number} length of a
 */

function length(a) {
  var x = a[0],
      y = a[1];
  return Math.hypot(x, y);
}
/**
 * Calculates the squared length of a vec2
 *
 * @param {vec2} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */

function squaredLength(a) {
  var x = a[0],
      y = a[1];
  return x * x + y * y;
}
/**
 * Negates the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to negate
 * @returns {vec2} out
 */

function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  return out;
}
/**
 * Returns the inverse of the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to invert
 * @returns {vec2} out
 */

function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  return out;
}
/**
 * Normalize a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to normalize
 * @returns {vec2} out
 */

function normalize(out, a) {
  var x = a[0],
      y = a[1];
  var len = x * x + y * y;

  if (len > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len = 1 / Math.sqrt(len);
  }

  out[0] = a[0] * len;
  out[1] = a[1] * len;
  return out;
}
/**
 * Calculates the dot product of two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} dot product of a and b
 */

function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1];
}
/**
 * Computes the cross product of two vec2's
 * Note that the cross product must by definition produce a 3D vector
 *
 * @param {vec3} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec3} out
 */

function cross(out, a, b) {
  var z = a[0] * b[1] - a[1] * b[0];
  out[0] = out[1] = 0;
  out[2] = z;
  return out;
}
/**
 * Performs a linear interpolation between two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec2} out
 */

function lerp(out, a, b, t) {
  var ax = a[0],
      ay = a[1];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  return out;
}
/**
 * Generates a random vector with the given scale
 *
 * @param {vec2} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec2} out
 */

function random(out, scale) {
  scale = scale || 1.0;
  var r = _common_js__WEBPACK_IMPORTED_MODULE_0__.RANDOM() * 2.0 * Math.PI;
  out[0] = Math.cos(r) * scale;
  out[1] = Math.sin(r) * scale;
  return out;
}
/**
 * Transforms the vec2 with a mat2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat2} m matrix to transform with
 * @returns {vec2} out
 */

function transformMat2(out, a, m) {
  var x = a[0],
      y = a[1];
  out[0] = m[0] * x + m[2] * y;
  out[1] = m[1] * x + m[3] * y;
  return out;
}
/**
 * Transforms the vec2 with a mat2d
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat2d} m matrix to transform with
 * @returns {vec2} out
 */

function transformMat2d(out, a, m) {
  var x = a[0],
      y = a[1];
  out[0] = m[0] * x + m[2] * y + m[4];
  out[1] = m[1] * x + m[3] * y + m[5];
  return out;
}
/**
 * Transforms the vec2 with a mat3
 * 3rd vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat3} m matrix to transform with
 * @returns {vec2} out
 */

function transformMat3(out, a, m) {
  var x = a[0],
      y = a[1];
  out[0] = m[0] * x + m[3] * y + m[6];
  out[1] = m[1] * x + m[4] * y + m[7];
  return out;
}
/**
 * Transforms the vec2 with a mat4
 * 3rd vector component is implicitly '0'
 * 4th vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec2} out
 */

function transformMat4(out, a, m) {
  var x = a[0];
  var y = a[1];
  out[0] = m[0] * x + m[4] * y + m[12];
  out[1] = m[1] * x + m[5] * y + m[13];
  return out;
}
/**
 * Rotate a 2D vector
 * @param {vec2} out The receiving vec2
 * @param {vec2} a The vec2 point to rotate
 * @param {vec2} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec2} out
 */

function rotate(out, a, b, c) {
  //Translate point to the origin
  var p0 = a[0] - b[0],
      p1 = a[1] - b[1],
      sinC = Math.sin(c),
      cosC = Math.cos(c); //perform rotation and translate to correct position

  out[0] = p0 * cosC - p1 * sinC + b[0];
  out[1] = p0 * sinC + p1 * cosC + b[1];
  return out;
}
/**
 * Get the angle between two 2D vectors
 * @param {vec2} a The first operand
 * @param {vec2} b The second operand
 * @returns {Number} The angle in radians
 */

function angle(a, b) {
  var x1 = a[0],
      y1 = a[1],
      x2 = b[0],
      y2 = b[1];
  var len1 = x1 * x1 + y1 * y1;

  if (len1 > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len1 = 1 / Math.sqrt(len1);
  }

  var len2 = x2 * x2 + y2 * y2;

  if (len2 > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len2 = 1 / Math.sqrt(len2);
  }

  var cosine = (x1 * x2 + y1 * y2) * len1 * len2;

  if (cosine > 1.0) {
    return 0;
  } else if (cosine < -1.0) {
    return Math.PI;
  } else {
    return Math.acos(cosine);
  }
}
/**
 * Set the components of a vec2 to zero
 *
 * @param {vec2} out the receiving vector
 * @returns {vec2} out
 */

function zero(out) {
  out[0] = 0.0;
  out[1] = 0.0;
  return out;
}
/**
 * Returns a string representation of a vector
 *
 * @param {vec2} a vector to represent as a string
 * @returns {String} string representation of the vector
 */

function str(a) {
  return 'vec2(' + a[0] + ', ' + a[1] + ')';
}
/**
 * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)
 *
 * @param {vec2} a The first vector.
 * @param {vec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1];
}
/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec2} a The first vector.
 * @param {vec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
      a1 = a[1];
  var b0 = b[0],
      b1 = b[1];
  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1));
}
/**
 * Alias for {@link vec2.length}
 * @function
 */

var len = length;
/**
 * Alias for {@link vec2.subtract}
 * @function
 */

var sub = subtract;
/**
 * Alias for {@link vec2.multiply}
 * @function
 */

var mul = multiply;
/**
 * Alias for {@link vec2.divide}
 * @function
 */

var div = divide;
/**
 * Alias for {@link vec2.distance}
 * @function
 */

var dist = distance;
/**
 * Alias for {@link vec2.squaredDistance}
 * @function
 */

var sqrDist = squaredDistance;
/**
 * Alias for {@link vec2.squaredLength}
 * @function
 */

var sqrLen = squaredLength;
/**
 * Perform some operation over an array of vec2s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */

var forEach = function () {
  var vec = create();
  return function (a, stride, offset, count, fn, arg) {
    var i, l;

    if (!stride) {
      stride = 2;
    }

    if (!offset) {
      offset = 0;
    }

    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }

    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
    }

    return a;
  };
}();

/***/ }),

/***/ 329:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   add: () => (/* binding */ add),
/* harmony export */   angle: () => (/* binding */ angle),
/* harmony export */   bezier: () => (/* binding */ bezier),
/* harmony export */   ceil: () => (/* binding */ ceil),
/* harmony export */   clone: () => (/* binding */ clone),
/* harmony export */   copy: () => (/* binding */ copy),
/* harmony export */   create: () => (/* binding */ create),
/* harmony export */   cross: () => (/* binding */ cross),
/* harmony export */   dist: () => (/* binding */ dist),
/* harmony export */   distance: () => (/* binding */ distance),
/* harmony export */   div: () => (/* binding */ div),
/* harmony export */   divide: () => (/* binding */ divide),
/* harmony export */   dot: () => (/* binding */ dot),
/* harmony export */   equals: () => (/* binding */ equals),
/* harmony export */   exactEquals: () => (/* binding */ exactEquals),
/* harmony export */   floor: () => (/* binding */ floor),
/* harmony export */   forEach: () => (/* binding */ forEach),
/* harmony export */   fromValues: () => (/* binding */ fromValues),
/* harmony export */   hermite: () => (/* binding */ hermite),
/* harmony export */   inverse: () => (/* binding */ inverse),
/* harmony export */   len: () => (/* binding */ len),
/* harmony export */   length: () => (/* binding */ length),
/* harmony export */   lerp: () => (/* binding */ lerp),
/* harmony export */   max: () => (/* binding */ max),
/* harmony export */   min: () => (/* binding */ min),
/* harmony export */   mul: () => (/* binding */ mul),
/* harmony export */   multiply: () => (/* binding */ multiply),
/* harmony export */   negate: () => (/* binding */ negate),
/* harmony export */   normalize: () => (/* binding */ normalize),
/* harmony export */   random: () => (/* binding */ random),
/* harmony export */   rotateX: () => (/* binding */ rotateX),
/* harmony export */   rotateY: () => (/* binding */ rotateY),
/* harmony export */   rotateZ: () => (/* binding */ rotateZ),
/* harmony export */   round: () => (/* binding */ round),
/* harmony export */   scale: () => (/* binding */ scale),
/* harmony export */   scaleAndAdd: () => (/* binding */ scaleAndAdd),
/* harmony export */   set: () => (/* binding */ set),
/* harmony export */   sqrDist: () => (/* binding */ sqrDist),
/* harmony export */   sqrLen: () => (/* binding */ sqrLen),
/* harmony export */   squaredDistance: () => (/* binding */ squaredDistance),
/* harmony export */   squaredLength: () => (/* binding */ squaredLength),
/* harmony export */   str: () => (/* binding */ str),
/* harmony export */   sub: () => (/* binding */ sub),
/* harmony export */   subtract: () => (/* binding */ subtract),
/* harmony export */   transformMat3: () => (/* binding */ transformMat3),
/* harmony export */   transformMat4: () => (/* binding */ transformMat4),
/* harmony export */   transformQuat: () => (/* binding */ transformQuat),
/* harmony export */   zero: () => (/* binding */ zero)
/* harmony export */ });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(823);

/**
 * 3 Dimensional Vector
 * @module vec3
 */

/**
 * Creates a new, empty vec3
 *
 * @returns {vec3} a new 3D vector
 */

function create() {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(3);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }

  return out;
}
/**
 * Creates a new vec3 initialized with values from an existing vector
 *
 * @param {vec3} a vector to clone
 * @returns {vec3} a new 3D vector
 */

function clone(a) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(3);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}
/**
 * Calculates the length of a vec3
 *
 * @param {vec3} a vector to calculate length of
 * @returns {Number} length of a
 */

function length(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return Math.hypot(x, y, z);
}
/**
 * Creates a new vec3 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} a new 3D vector
 */

function fromValues(x, y, z) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(3);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}
/**
 * Copy the values from one vec3 to another
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the source vector
 * @returns {vec3} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}
/**
 * Set the components of a vec3 to the given values
 *
 * @param {vec3} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} out
 */

function set(out, x, y, z) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}
/**
 * Adds two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  return out;
}
/**
 * Subtracts vector b from vector a
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  return out;
}
/**
 * Multiplies two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */

function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  return out;
}
/**
 * Divides two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */

function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  return out;
}
/**
 * Math.ceil the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to ceil
 * @returns {vec3} out
 */

function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  return out;
}
/**
 * Math.floor the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to floor
 * @returns {vec3} out
 */

function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  return out;
}
/**
 * Returns the minimum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */

function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  return out;
}
/**
 * Returns the maximum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */

function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  return out;
}
/**
 * Math.round the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to round
 * @returns {vec3} out
 */

function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  out[2] = Math.round(a[2]);
  return out;
}
/**
 * Scales a vec3 by a scalar number
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec3} out
 */

function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  return out;
}
/**
 * Adds two vec3's after scaling the second operand by a scalar value
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec3} out
 */

function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  return out;
}
/**
 * Calculates the euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} distance between a and b
 */

function distance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  return Math.hypot(x, y, z);
}
/**
 * Calculates the squared euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} squared distance between a and b
 */

function squaredDistance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  return x * x + y * y + z * z;
}
/**
 * Calculates the squared length of a vec3
 *
 * @param {vec3} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */

function squaredLength(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return x * x + y * y + z * z;
}
/**
 * Negates the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to negate
 * @returns {vec3} out
 */

function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  return out;
}
/**
 * Returns the inverse of the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to invert
 * @returns {vec3} out
 */

function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  return out;
}
/**
 * Normalize a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to normalize
 * @returns {vec3} out
 */

function normalize(out, a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var len = x * x + y * y + z * z;

  if (len > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len = 1 / Math.sqrt(len);
  }

  out[0] = a[0] * len;
  out[1] = a[1] * len;
  out[2] = a[2] * len;
  return out;
}
/**
 * Calculates the dot product of two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} dot product of a and b
 */

function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}
/**
 * Computes the cross product of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */

function cross(out, a, b) {
  var ax = a[0],
      ay = a[1],
      az = a[2];
  var bx = b[0],
      by = b[1],
      bz = b[2];
  out[0] = ay * bz - az * by;
  out[1] = az * bx - ax * bz;
  out[2] = ax * by - ay * bx;
  return out;
}
/**
 * Performs a linear interpolation between two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */

function lerp(out, a, b, t) {
  var ax = a[0];
  var ay = a[1];
  var az = a[2];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  return out;
}
/**
 * Performs a hermite interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {vec3} c the third operand
 * @param {vec3} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */

function hermite(out, a, b, c, d, t) {
  var factorTimes2 = t * t;
  var factor1 = factorTimes2 * (2 * t - 3) + 1;
  var factor2 = factorTimes2 * (t - 2) + t;
  var factor3 = factorTimes2 * (t - 1);
  var factor4 = factorTimes2 * (3 - 2 * t);
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  return out;
}
/**
 * Performs a bezier interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {vec3} c the third operand
 * @param {vec3} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */

function bezier(out, a, b, c, d, t) {
  var inverseFactor = 1 - t;
  var inverseFactorTimesTwo = inverseFactor * inverseFactor;
  var factorTimes2 = t * t;
  var factor1 = inverseFactorTimesTwo * inverseFactor;
  var factor2 = 3 * t * inverseFactorTimesTwo;
  var factor3 = 3 * factorTimes2 * inverseFactor;
  var factor4 = factorTimes2 * t;
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  return out;
}
/**
 * Generates a random vector with the given scale
 *
 * @param {vec3} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec3} out
 */

function random(out, scale) {
  scale = scale || 1.0;
  var r = _common_js__WEBPACK_IMPORTED_MODULE_0__.RANDOM() * 2.0 * Math.PI;
  var z = _common_js__WEBPACK_IMPORTED_MODULE_0__.RANDOM() * 2.0 - 1.0;
  var zScale = Math.sqrt(1.0 - z * z) * scale;
  out[0] = Math.cos(r) * zScale;
  out[1] = Math.sin(r) * zScale;
  out[2] = z * scale;
  return out;
}
/**
 * Transforms the vec3 with a mat4.
 * 4th vector component is implicitly '1'
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec3} out
 */

function transformMat4(out, a, m) {
  var x = a[0],
      y = a[1],
      z = a[2];
  var w = m[3] * x + m[7] * y + m[11] * z + m[15];
  w = w || 1.0;
  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
  return out;
}
/**
 * Transforms the vec3 with a mat3.
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat3} m the 3x3 matrix to transform with
 * @returns {vec3} out
 */

function transformMat3(out, a, m) {
  var x = a[0],
      y = a[1],
      z = a[2];
  out[0] = x * m[0] + y * m[3] + z * m[6];
  out[1] = x * m[1] + y * m[4] + z * m[7];
  out[2] = x * m[2] + y * m[5] + z * m[8];
  return out;
}
/**
 * Transforms the vec3 with a quat
 * Can also be used for dual quaternions. (Multiply it with the real part)
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {quat} q quaternion to transform with
 * @returns {vec3} out
 */

function transformQuat(out, a, q) {
  // benchmarks: https://jsperf.com/quaternion-transform-vec3-implementations-fixed
  var qx = q[0],
      qy = q[1],
      qz = q[2],
      qw = q[3];
  var x = a[0],
      y = a[1],
      z = a[2]; // var qvec = [qx, qy, qz];
  // var uv = vec3.cross([], qvec, a);

  var uvx = qy * z - qz * y,
      uvy = qz * x - qx * z,
      uvz = qx * y - qy * x; // var uuv = vec3.cross([], qvec, uv);

  var uuvx = qy * uvz - qz * uvy,
      uuvy = qz * uvx - qx * uvz,
      uuvz = qx * uvy - qy * uvx; // vec3.scale(uv, uv, 2 * w);

  var w2 = qw * 2;
  uvx *= w2;
  uvy *= w2;
  uvz *= w2; // vec3.scale(uuv, uuv, 2);

  uuvx *= 2;
  uuvy *= 2;
  uuvz *= 2; // return vec3.add(out, a, vec3.add(out, uv, uuv));

  out[0] = x + uvx + uuvx;
  out[1] = y + uvy + uuvy;
  out[2] = z + uvz + uuvz;
  return out;
}
/**
 * Rotate a 3D vector around the x-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */

function rotateX(out, a, b, c) {
  var p = [],
      r = []; //Translate point to the origin

  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2]; //perform rotation

  r[0] = p[0];
  r[1] = p[1] * Math.cos(c) - p[2] * Math.sin(c);
  r[2] = p[1] * Math.sin(c) + p[2] * Math.cos(c); //translate to correct position

  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
/**
 * Rotate a 3D vector around the y-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */

function rotateY(out, a, b, c) {
  var p = [],
      r = []; //Translate point to the origin

  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2]; //perform rotation

  r[0] = p[2] * Math.sin(c) + p[0] * Math.cos(c);
  r[1] = p[1];
  r[2] = p[2] * Math.cos(c) - p[0] * Math.sin(c); //translate to correct position

  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
/**
 * Rotate a 3D vector around the z-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */

function rotateZ(out, a, b, c) {
  var p = [],
      r = []; //Translate point to the origin

  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2]; //perform rotation

  r[0] = p[0] * Math.cos(c) - p[1] * Math.sin(c);
  r[1] = p[0] * Math.sin(c) + p[1] * Math.cos(c);
  r[2] = p[2]; //translate to correct position

  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
/**
 * Get the angle between two 3D vectors
 * @param {vec3} a The first operand
 * @param {vec3} b The second operand
 * @returns {Number} The angle in radians
 */

function angle(a, b) {
  var tempA = fromValues(a[0], a[1], a[2]);
  var tempB = fromValues(b[0], b[1], b[2]);
  normalize(tempA, tempA);
  normalize(tempB, tempB);
  var cosine = dot(tempA, tempB);

  if (cosine > 1.0) {
    return 0;
  } else if (cosine < -1.0) {
    return Math.PI;
  } else {
    return Math.acos(cosine);
  }
}
/**
 * Set the components of a vec3 to zero
 *
 * @param {vec3} out the receiving vector
 * @returns {vec3} out
 */

function zero(out) {
  out[0] = 0.0;
  out[1] = 0.0;
  out[2] = 0.0;
  return out;
}
/**
 * Returns a string representation of a vector
 *
 * @param {vec3} a vector to represent as a string
 * @returns {String} string representation of the vector
 */

function str(a) {
  return 'vec3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ')';
}
/**
 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
 *
 * @param {vec3} a The first vector.
 * @param {vec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];
}
/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec3} a The first vector.
 * @param {vec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2];
  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2));
}
/**
 * Alias for {@link vec3.subtract}
 * @function
 */

var sub = subtract;
/**
 * Alias for {@link vec3.multiply}
 * @function
 */

var mul = multiply;
/**
 * Alias for {@link vec3.divide}
 * @function
 */

var div = divide;
/**
 * Alias for {@link vec3.distance}
 * @function
 */

var dist = distance;
/**
 * Alias for {@link vec3.squaredDistance}
 * @function
 */

var sqrDist = squaredDistance;
/**
 * Alias for {@link vec3.length}
 * @function
 */

var len = length;
/**
 * Alias for {@link vec3.squaredLength}
 * @function
 */

var sqrLen = squaredLength;
/**
 * Perform some operation over an array of vec3s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */

var forEach = function () {
  var vec = create();
  return function (a, stride, offset, count, fn, arg) {
    var i, l;

    if (!stride) {
      stride = 3;
    }

    if (!offset) {
      offset = 0;
    }

    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }

    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
    }

    return a;
  };
}();

/***/ }),

/***/ 796:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   add: () => (/* binding */ add),
/* harmony export */   ceil: () => (/* binding */ ceil),
/* harmony export */   clone: () => (/* binding */ clone),
/* harmony export */   copy: () => (/* binding */ copy),
/* harmony export */   create: () => (/* binding */ create),
/* harmony export */   cross: () => (/* binding */ cross),
/* harmony export */   dist: () => (/* binding */ dist),
/* harmony export */   distance: () => (/* binding */ distance),
/* harmony export */   div: () => (/* binding */ div),
/* harmony export */   divide: () => (/* binding */ divide),
/* harmony export */   dot: () => (/* binding */ dot),
/* harmony export */   equals: () => (/* binding */ equals),
/* harmony export */   exactEquals: () => (/* binding */ exactEquals),
/* harmony export */   floor: () => (/* binding */ floor),
/* harmony export */   forEach: () => (/* binding */ forEach),
/* harmony export */   fromValues: () => (/* binding */ fromValues),
/* harmony export */   inverse: () => (/* binding */ inverse),
/* harmony export */   len: () => (/* binding */ len),
/* harmony export */   length: () => (/* binding */ length),
/* harmony export */   lerp: () => (/* binding */ lerp),
/* harmony export */   max: () => (/* binding */ max),
/* harmony export */   min: () => (/* binding */ min),
/* harmony export */   mul: () => (/* binding */ mul),
/* harmony export */   multiply: () => (/* binding */ multiply),
/* harmony export */   negate: () => (/* binding */ negate),
/* harmony export */   normalize: () => (/* binding */ normalize),
/* harmony export */   random: () => (/* binding */ random),
/* harmony export */   round: () => (/* binding */ round),
/* harmony export */   scale: () => (/* binding */ scale),
/* harmony export */   scaleAndAdd: () => (/* binding */ scaleAndAdd),
/* harmony export */   set: () => (/* binding */ set),
/* harmony export */   sqrDist: () => (/* binding */ sqrDist),
/* harmony export */   sqrLen: () => (/* binding */ sqrLen),
/* harmony export */   squaredDistance: () => (/* binding */ squaredDistance),
/* harmony export */   squaredLength: () => (/* binding */ squaredLength),
/* harmony export */   str: () => (/* binding */ str),
/* harmony export */   sub: () => (/* binding */ sub),
/* harmony export */   subtract: () => (/* binding */ subtract),
/* harmony export */   transformMat4: () => (/* binding */ transformMat4),
/* harmony export */   transformQuat: () => (/* binding */ transformQuat),
/* harmony export */   zero: () => (/* binding */ zero)
/* harmony export */ });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(823);

/**
 * 4 Dimensional Vector
 * @module vec4
 */

/**
 * Creates a new, empty vec4
 *
 * @returns {vec4} a new 4D vector
 */

function create() {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(4);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
  }

  return out;
}
/**
 * Creates a new vec4 initialized with values from an existing vector
 *
 * @param {vec4} a vector to clone
 * @returns {vec4} a new 4D vector
 */

function clone(a) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(4);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
/**
 * Creates a new vec4 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} a new 4D vector
 */

function fromValues(x, y, z, w) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(4);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = w;
  return out;
}
/**
 * Copy the values from one vec4 to another
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the source vector
 * @returns {vec4} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
/**
 * Set the components of a vec4 to the given values
 *
 * @param {vec4} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} out
 */

function set(out, x, y, z, w) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = w;
  return out;
}
/**
 * Adds two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  return out;
}
/**
 * Subtracts vector b from vector a
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  return out;
}
/**
 * Multiplies two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */

function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  out[3] = a[3] * b[3];
  return out;
}
/**
 * Divides two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */

function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  out[3] = a[3] / b[3];
  return out;
}
/**
 * Math.ceil the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to ceil
 * @returns {vec4} out
 */

function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  out[3] = Math.ceil(a[3]);
  return out;
}
/**
 * Math.floor the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to floor
 * @returns {vec4} out
 */

function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  out[3] = Math.floor(a[3]);
  return out;
}
/**
 * Returns the minimum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */

function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  out[3] = Math.min(a[3], b[3]);
  return out;
}
/**
 * Returns the maximum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */

function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  out[3] = Math.max(a[3], b[3]);
  return out;
}
/**
 * Math.round the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to round
 * @returns {vec4} out
 */

function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  out[2] = Math.round(a[2]);
  out[3] = Math.round(a[3]);
  return out;
}
/**
 * Scales a vec4 by a scalar number
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec4} out
 */

function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  return out;
}
/**
 * Adds two vec4's after scaling the second operand by a scalar value
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec4} out
 */

function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  return out;
}
/**
 * Calculates the euclidian distance between two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} distance between a and b
 */

function distance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  var w = b[3] - a[3];
  return Math.hypot(x, y, z, w);
}
/**
 * Calculates the squared euclidian distance between two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} squared distance between a and b
 */

function squaredDistance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  var w = b[3] - a[3];
  return x * x + y * y + z * z + w * w;
}
/**
 * Calculates the length of a vec4
 *
 * @param {vec4} a vector to calculate length of
 * @returns {Number} length of a
 */

function length(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  return Math.hypot(x, y, z, w);
}
/**
 * Calculates the squared length of a vec4
 *
 * @param {vec4} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */

function squaredLength(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  return x * x + y * y + z * z + w * w;
}
/**
 * Negates the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to negate
 * @returns {vec4} out
 */

function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = -a[3];
  return out;
}
/**
 * Returns the inverse of the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to invert
 * @returns {vec4} out
 */

function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  out[3] = 1.0 / a[3];
  return out;
}
/**
 * Normalize a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to normalize
 * @returns {vec4} out
 */

function normalize(out, a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  var len = x * x + y * y + z * z + w * w;

  if (len > 0) {
    len = 1 / Math.sqrt(len);
  }

  out[0] = x * len;
  out[1] = y * len;
  out[2] = z * len;
  out[3] = w * len;
  return out;
}
/**
 * Calculates the dot product of two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} dot product of a and b
 */

function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
}
/**
 * Returns the cross-product of three vectors in a 4-dimensional space
 *
 * @param {vec4} result the receiving vector
 * @param {vec4} U the first vector
 * @param {vec4} V the second vector
 * @param {vec4} W the third vector
 * @returns {vec4} result
 */

function cross(out, u, v, w) {
  var A = v[0] * w[1] - v[1] * w[0],
      B = v[0] * w[2] - v[2] * w[0],
      C = v[0] * w[3] - v[3] * w[0],
      D = v[1] * w[2] - v[2] * w[1],
      E = v[1] * w[3] - v[3] * w[1],
      F = v[2] * w[3] - v[3] * w[2];
  var G = u[0];
  var H = u[1];
  var I = u[2];
  var J = u[3];
  out[0] = H * F - I * E + J * D;
  out[1] = -(G * F) + I * C - J * B;
  out[2] = G * E - H * C + J * A;
  out[3] = -(G * D) + H * B - I * A;
  return out;
}
;
/**
 * Performs a linear interpolation between two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec4} out
 */

function lerp(out, a, b, t) {
  var ax = a[0];
  var ay = a[1];
  var az = a[2];
  var aw = a[3];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  out[3] = aw + t * (b[3] - aw);
  return out;
}
/**
 * Generates a random vector with the given scale
 *
 * @param {vec4} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec4} out
 */

function random(out, scale) {
  scale = scale || 1.0; // Marsaglia, George. Choosing a Point from the Surface of a
  // Sphere. Ann. Math. Statist. 43 (1972), no. 2, 645--646.
  // http://projecteuclid.org/euclid.aoms/1177692644;

  var v1, v2, v3, v4;
  var s1, s2;

  do {
    v1 = _common_js__WEBPACK_IMPORTED_MODULE_0__.RANDOM() * 2 - 1;
    v2 = _common_js__WEBPACK_IMPORTED_MODULE_0__.RANDOM() * 2 - 1;
    s1 = v1 * v1 + v2 * v2;
  } while (s1 >= 1);

  do {
    v3 = _common_js__WEBPACK_IMPORTED_MODULE_0__.RANDOM() * 2 - 1;
    v4 = _common_js__WEBPACK_IMPORTED_MODULE_0__.RANDOM() * 2 - 1;
    s2 = v3 * v3 + v4 * v4;
  } while (s2 >= 1);

  var d = Math.sqrt((1 - s1) / s2);
  out[0] = scale * v1;
  out[1] = scale * v2;
  out[2] = scale * v3 * d;
  out[3] = scale * v4 * d;
  return out;
}
/**
 * Transforms the vec4 with a mat4.
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec4} out
 */

function transformMat4(out, a, m) {
  var x = a[0],
      y = a[1],
      z = a[2],
      w = a[3];
  out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
  out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
  out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
  out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
  return out;
}
/**
 * Transforms the vec4 with a quat
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to transform
 * @param {quat} q quaternion to transform with
 * @returns {vec4} out
 */

function transformQuat(out, a, q) {
  var x = a[0],
      y = a[1],
      z = a[2];
  var qx = q[0],
      qy = q[1],
      qz = q[2],
      qw = q[3]; // calculate quat * vec

  var ix = qw * x + qy * z - qz * y;
  var iy = qw * y + qz * x - qx * z;
  var iz = qw * z + qx * y - qy * x;
  var iw = -qx * x - qy * y - qz * z; // calculate result * inverse quat

  out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
  out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
  out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
  out[3] = a[3];
  return out;
}
/**
 * Set the components of a vec4 to zero
 *
 * @param {vec4} out the receiving vector
 * @returns {vec4} out
 */

function zero(out) {
  out[0] = 0.0;
  out[1] = 0.0;
  out[2] = 0.0;
  out[3] = 0.0;
  return out;
}
/**
 * Returns a string representation of a vector
 *
 * @param {vec4} a vector to represent as a string
 * @returns {String} string representation of the vector
 */

function str(a) {
  return 'vec4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
}
/**
 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
 *
 * @param {vec4} a The first vector.
 * @param {vec4} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
}
/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec4} a The first vector.
 * @param {vec4} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3));
}
/**
 * Alias for {@link vec4.subtract}
 * @function
 */

var sub = subtract;
/**
 * Alias for {@link vec4.multiply}
 * @function
 */

var mul = multiply;
/**
 * Alias for {@link vec4.divide}
 * @function
 */

var div = divide;
/**
 * Alias for {@link vec4.distance}
 * @function
 */

var dist = distance;
/**
 * Alias for {@link vec4.squaredDistance}
 * @function
 */

var sqrDist = squaredDistance;
/**
 * Alias for {@link vec4.length}
 * @function
 */

var len = length;
/**
 * Alias for {@link vec4.squaredLength}
 * @function
 */

var sqrLen = squaredLength;
/**
 * Perform some operation over an array of vec4s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec4s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */

var forEach = function () {
  var vec = create();
  return function (a, stride, offset, count, fn, arg) {
    var i, l;

    if (!stride) {
      stride = 4;
    }

    if (!offset) {
      offset = 0;
    }

    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }

    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      vec[3] = a[i + 3];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
      a[i + 3] = vec[3];
    }

    return a;
  };
}();

/***/ }),

/***/ 344:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   k: () => (/* binding */ Anim)
/* harmony export */ });
/* harmony import */ var cables_shared_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(125);
/* harmony import */ var cables_shared_client__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(849);
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(562);
/* harmony import */ var _anim_key_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(963);






/**
 * Keyframed interpolated animation.
 *
 * @class
 * @param cfg
 * @example
 * var anim=new CABLES.Anim();
 * anim.setValue(0,0);  // set value 0 at 0 seconds
 * anim.setValue(10,1); // set value 1 at 10 seconds
 * anim.getValue(5);    // get value at 5 seconds - this returns 0.5
 */

class Anim extends cables_shared_client__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A
{
    static EVENT_KEY_DELETE = "keyDelete";
    static EVENT_CHANGE = "onChange";
    static EVENT_UIATTRIB_CHANGE = "uiattrchange";

    static LOOP_OFF = 0;
    static LOOP_REPEAT = 1;
    static LOOP_MIRROR = 2;
    static LOOP_OFFSET = 3;

    static EASING_LINEAR = 0;
    static EASING_ABSOLUTE = 1;
    static EASING_SMOOTHSTEP = 2;
    static EASING_SMOOTHERSTEP = 3;
    static EASING_CUBICSPLINE = 4;

    static EASING_CUBIC_IN = 5;
    static EASING_CUBIC_OUT = 6;
    static EASING_CUBIC_INOUT = 7;

    static EASING_EXPO_IN = 8;
    static EASING_EXPO_OUT = 9;
    static EASING_EXPO_INOUT = 10;

    static EASING_SIN_IN = 11;
    static EASING_SIN_OUT = 12;
    static EASING_SIN_INOUT = 13;

    static EASING_BACK_IN = 14;
    static EASING_BACK_OUT = 15;
    static EASING_BACK_INOUT = 16;

    static EASING_ELASTIC_IN = 17;
    static EASING_ELASTIC_OUT = 18;

    static EASING_BOUNCE_IN = 19;
    static EASING_BOUNCE_OUT = 21;

    static EASING_QUART_IN = 22;
    static EASING_QUART_OUT = 23;
    static EASING_QUART_INOUT = 24;

    static EASING_QUINT_IN = 25;
    static EASING_QUINT_OUT = 26;
    static EASING_QUINT_INOUT = 27;

    static EASINGNAMES = ["linear", "absolute", "smoothstep", "smootherstep", "Cubic In", "Cubic Out", "Cubic In Out", "Expo In", "Expo Out", "Expo In Out", "Sin In", "Sin Out", "Sin In Out", "Quart In", "Quart Out", "Quart In Out", "Quint In", "Quint Out", "Quint In Out", "Back In", "Back Out", "Back In Out", "Elastic In", "Elastic Out", "Bounce In", "Bounce Out"];

    #tlActive = true;
    uiAttribs = {};

    /**
     * @param {AnimCfg} [cfg]
     */
    constructor(cfg = {})
    {
        super();
        cfg = cfg || {};
        this.id = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.uuid)();

        /** @type {AnimKey[]} */
        this.keys = [];
        this.onChange = null;
        this.stayInTimeline = false;

        this.loop = 0;
        this._log = new cables_shared_client__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A("Anim");
        this._cachedIndex = 0;
        this.name = cfg.name || null;

        /** @type {Number} */
        this.defaultEasing = cfg.defaultEasing || Anim.EASING_LINEAR;
        this.onLooped = null;

        this._timesLooped = 0;
        this._needsSort = false;
    }

    forceChangeCallback()
    {
        if (this.onChange !== null) this.onChange();
        this.emitEvent(Anim.EVENT_CHANGE, this);
    }

    forceChangeCallbackSoon()
    {
        // clearTimeout(this.forcecbto);
        if (!this.forcecbto)
            this.forcecbto = setTimeout(() =>
            {
                this.forceChangeCallback();
                this.forcecbto = null;
            },
            50);
    }

    getLoop()
    {
        return this.loop;
    }

    /**
     * @param {number} loopType
     */
    setLoop(loopType)
    {
        if (loopType === false)loopType = 0;
        if (loopType === true)loopType = 1;

        this.loop = loopType;
        this.emitEvent(Anim.EVENT_CHANGE, this);
    }

    /**
     * returns true if animation has ended at @time
     * checks if last key time is < time
     * @param {Number} time
     * @returns {Boolean}
     * @memberof Anim
     * @instance
     * @function
     */
    hasEnded(time)
    {
        if (this._needsSort) this.sortKeys();
        if (this.keys.length === 0) return true;
        if (this.keys[this.keys.length - 1].time <= time) return true;
        return false;
    }

    /**
     * @param {number} time
     */
    isRising(time)
    {
        if (this._needsSort) this.sortKeys();
        if (this.hasEnded(time)) return false;
        const ki = this.getKeyIndex(time);
        if (this.keys[ki].value < this.keys[ki + 1].value) return true;
        return false;
    }

    /**
     * remove all keys from animation before time
     * @param {Number} time
     * @memberof Anim
     * @instance
     * @function
     */
    clearBefore(time)
    {
        if (this._needsSort) this.sortKeys();
        const v = this.getValue(time);
        const ki = this.getKeyIndex(time);

        this.setValue(time, v);

        if (ki > 1)
        {
            this.keys.splice(0, ki);
            this._needsSort = true;
        }
    }

    /**
     * remove all keys from animation
     * @param {Number} [time=0] set a new key at time with the old value at time
     * @memberof Anim
     * @instance
     * @function
     */
    clear(time)
    {
        if (this._needsSort) this.sortKeys();
        let v = 0;
        if (time) v = this.getValue(time);

        for (let i = 0; i < this.keys.length; i++)
            this.emitEvent(Anim.EVENT_KEY_DELETE, this.keys[i]);

        this.keys.length = 0;
        if (time) this.setValue(time, v);
        this._needsSort = true;
        if (this.onChange !== null) this.onChange();
        this.emitEvent(Anim.EVENT_CHANGE, this);
    }

    checkIsSorted()
    {
        let isSorted = true;
        for (let i = 0; i < this.keys.length - 1; i++)
            if (this.keys[i].time > this.keys[i + 1].time)
            {
                isSorted = false;
                break;
            }

        return isSorted;
    }

    sortKeys()
    {
        if (!this.checkIsSorted())
        {
            this.keys.sort((a, b) => { return a.time - b.time; });
            this._needsSort = false;
            if (this.keys.length > 999 && this.keys.length % 1000 == 0)console.log(this.name, this.keys.length);

            this.emitEvent(Anim.EVENT_CHANGE);
        }
    }

    hasDuplicates()
    {
        const test = {};
        let count = 0;
        for (let i = 0; i < this.keys.length; i++)
        {
            test[this.keys[i].time] = 1;
            count++;
        }

        const keys = Object.keys(test);
        if (keys.length != count)
        {
            return true;
        }
        return false;
    }

    removeDuplicates()
    {
        if (this.hasDuplicates())
        {
            if (this._needsSort) this.sortKeys();
            let count = 0;

            while (this.hasDuplicates())
            {
                for (let i = 0; i < this.keys.length - 1; i++)
                {
                    if (this.keys[i].time == this.keys[i + 1].time) this.keys.splice(i, 1);
                    count++;
                }
            }
            this._needsSort = true;
        }
    }

    getLengthLoop()
    {
        if (this._needsSort) this.sortKeys();
        if (this.keys.length < 2) return 0;
        return this.lastKey.time - this.firstKey.time;
    }

    getLength()
    {
        if (this._needsSort) this.sortKeys();
        if (this.keys.length === 0) return 0;
        return this.lastKey.time;
    }

    /**
     * @param {number} time
     */
    getKeyIndex(time)
    {
        if (this._needsSort) this.sortKeys();
        let index = 0;
        let start = 0;
        if (this._cachedIndex && this.keys.length > this._cachedIndex && time >= this.keys[this._cachedIndex].time) start = this._cachedIndex;
        for (let i = start; i < this.keys.length; i++)
        {
            if (time >= this.keys[i].time) index = i;
            if (this.keys[i].time > time)
            {
                if (time != 0) this._cachedIndex = index;
                return index;
            }
        }

        return index;
    }

    /**
     * set value at time
     * @param {Number} time
     * @param {Number} value
     * @param {Function} cb callback
     */
    setValue(time, value, cb = null)
    {
        if (this._needsSort) this.sortKeys();
        let found = null;

        if (this.keys.length == 0 || time <= this.lastKey.time)
            for (let i = 0; i < this.keys.length; i++)
                if (this.keys[i].time == time)
                {
                    found = this.keys[i];
                    this.keys[i].setValue(value);
                    this.keys[i].cb = cb;
                    break;
                }

        if (!found)
        {
            found = new _anim_key_js__WEBPACK_IMPORTED_MODULE_3__/* .AnimKey */ .rA(
                {
                    "time": time,
                    "value": value,
                    "e": this.defaultEasing,
                    "cb": cb,
                    "anim": this
                });
            this.keys.push(found);

            // if (this.keys.length % 1000 == 0)console.log(this.name, this.keys.length);
        }

        if (this.onChange) this.onChange();
        this.emitEvent(Anim.EVENT_CHANGE, this);
        this._needsSort = true;
        return found;
    }

    /**
     * @param {number} index
     * @param {number} easing
     */
    setKeyEasing(index, easing)
    {
        if (this.keys[index])
        {
            this.keys[index].setEasing(easing);
            this.emitEvent(Anim.EVENT_CHANGE, this);
        }
    }

    /**
     * @param {object} obj
     */
    deserialize(obj)
    {

        if (obj.loop) this.loop = obj.loop;
        if (obj.tlActive) this.#tlActive = obj.tlActive;
        for (const ani in obj.keys)
        {
            this.keys.push(new _anim_key_js__WEBPACK_IMPORTED_MODULE_3__/* .AnimKey */ .rA(obj.keys[ani], this));
        }
        this.sortKeys();
    }

    /**
     * @returns {SerializedAnim}
     */
    getSerialized()
    {

        /** @type {SerializedAnim} */
        const obj = {};
        obj.keys = [];
        obj.loop = this.loop;
        if (this.#tlActive)obj.tlActive = this.tlActive;

        for (let i = 0; i < this.keys.length; i++)
            obj.keys.push(this.keys[i].getSerialized());

        return obj;
    }

    /**
     * @param {number} time
     */
    getKey(time)
    {
        if (this._needsSort) this.sortKeys();
        const index = this.getKeyIndex(time);
        return this.keys[index];
    }

    /**
     * @param {number} time
     */
    getNextKey(time)
    {
        if (this._needsSort) this.sortKeys();
        let index = this.getKeyIndex(time) + 1;
        if (index >= this.keys.length) return null;

        return this.keys[index];
    }

    /**
     * @param {number} time
     */
    getPrevKey(time)
    {
        if (this._needsSort) this.sortKeys();
        let index = this.getKeyIndex(time) - 1;
        if (index < 0) return null;

        return this.keys[index];
    }

    /**
     * @param {number} time
     */
    isFinished(time)
    {
        if (this._needsSort) this.sortKeys();
        if (this.keys.length <= 0) return true;
        return time > this.lastKey.time;
    }

    /**
     * @param {number} time
     */
    isStarted(time)
    {
        if (this._needsSort) this.sortKeys();
        if (this.keys.length <= 0) return false;
        return time >= this.firstKey.time;
    }

    /**
     * @param {AnimKey} k
     */
    remove(k, events)
    {
        for (let i = 0; i < this.keys.length; i++)
        {
            if (this.keys[i] == k)
            {
                this.emitEvent(Anim.EVENT_KEY_DELETE, this.keys[i]);
                this.keys.splice(i, 1);
                this._needsSort = true;
                if (events === undefined)
                {
                    this.emitEvent(Anim.EVENT_CHANGE, this);
                }
                return;
            }
        }
    }

    get lastKey()
    {
        if (this._needsSort) this.sortKeys();
        return this.keys[this.keys.length - 1];
    }

    get firstKey()
    {
        if (this._needsSort) this.sortKeys();
        return this.keys[0];
    }

    /**
     * @param {number} time
     */
    getLoopIndex(time)
    {
        if (this._needsSort) this.sortKeys();
        if (this.keys.length < 2) return 0;
        return (time - this.firstKey.time) / this.getLengthLoop();
    }

    /**
     * get value at time
     * @function getValue
     * @memberof Anim
     * @instance
     * @param {Number} [time] time
     * @returns {Number} interpolated value at time
     */
    getValue(time)
    {
        let valAdd = 0;
        if (this.keys.length === 0) return 0;
        if (this._needsSort) this.sortKeys();

        if (!this.loop && time > this.keys[this.keys.length - 1].time)
        {
            if (this.lastKey.cb && !this.lastKey.cbTriggered) this.lastKey.trigger();

            return this.lastKey.value;
        }

        if (time < this.firstKey.time) return this.keys[0].value;

        if (this.loop && this.keys.length > 1 && time > this.lastKey.time)
        {
            const currentLoop = this.getLoopIndex(time);
            if (currentLoop > this._timesLooped)
            {
                this._timesLooped++;
                if (this.onLooped) this.onLooped();
            }

            time = (time - this.firstKey.time) % (this.getLengthLoop());

            if (this.loop == Anim.LOOP_REPEAT) { }
            else if (this.loop == Anim.LOOP_MIRROR)
            {
                if (Math.floor(currentLoop) % 2 == 1)time = this.getLengthLoop() - time;
            }
            else if (this.loop == Anim.LOOP_OFFSET)
            {
                valAdd = (this.lastKey.value - this.keys[0].value) * Math.floor(currentLoop);
            }

            time += this.firstKey.time;
        }

        const index = this.getKeyIndex(time);
        if (index >= this.keys.length - 1)
        {
            if (this.lastKey.cb && !this.lastKey.cbTriggered) this.lastKey.trigger();
            return this.lastKey.value;
        }

        const index2 = index + 1;
        const key1 = this.keys[index];
        const key2 = this.keys[index2];

        if (key1.cb && !key1.cbTriggered) key1.trigger();

        if (!key2) return -1;

        const perc = (time - key1.time) / (key2.time - key1.time);

        return key1.ease(perc, key2) + valAdd;
    }

    /**
     * @param {AnimKey} k
     */
    addKey(k)
    {
        if (k.time === undefined)
        {
            this._log.warn("key time undefined, ignoring!");
        }
        else
        {
            this.keys.push(k);
            if (this.onChange !== null) this.onChange();
            this.emitEvent(Anim.EVENT_CHANGE, this);
            this._needsSort = true;
        }
    }

    sortSoon()
    {
        this._needsSort = true;
    }

    /**
     * @param {string} str
     */
    easingFromString(str)
    {
        // todo smarter way to map ?
        if (str == "linear") return Anim.EASING_LINEAR;
        if (str == "absolute") return Anim.EASING_ABSOLUTE;
        if (str == "smoothstep") return Anim.EASING_SMOOTHSTEP;
        if (str == "smootherstep") return Anim.EASING_SMOOTHERSTEP;

        if (str == "Cubic In") return Anim.EASING_CUBIC_IN;
        if (str == "Cubic Out") return Anim.EASING_CUBIC_OUT;
        if (str == "Cubic In Out") return Anim.EASING_CUBIC_INOUT;

        if (str == "Expo In") return Anim.EASING_EXPO_IN;
        if (str == "Expo Out") return Anim.EASING_EXPO_OUT;
        if (str == "Expo In Out") return Anim.EASING_EXPO_INOUT;

        if (str == "Sin In") return Anim.EASING_SIN_IN;
        if (str == "Sin Out") return Anim.EASING_SIN_OUT;
        if (str == "Sin In Out") return Anim.EASING_SIN_INOUT;

        if (str == "Back In") return Anim.EASING_BACK_IN;
        if (str == "Back Out") return Anim.EASING_BACK_OUT;
        if (str == "Back In Out") return Anim.EASING_BACK_INOUT;

        if (str == "Elastic In") return Anim.EASING_ELASTIC_IN;
        if (str == "Elastic Out") return Anim.EASING_ELASTIC_OUT;

        if (str == "Bounce In") return Anim.EASING_BOUNCE_IN;
        if (str == "Bounce Out") return Anim.EASING_BOUNCE_OUT;

        if (str == "Quart Out") return Anim.EASING_QUART_OUT;
        if (str == "Quart In") return Anim.EASING_QUART_IN;
        if (str == "Quart In Out") return Anim.EASING_QUART_INOUT;

        if (str == "Quint Out") return Anim.EASING_QUINT_OUT;
        if (str == "Quint In") return Anim.EASING_QUINT_IN;
        if (str == "Quint In Out") return Anim.EASING_QUINT_INOUT;

        console.log("unknown anim easing?", str);
    }

    /**
     * @param {Op} op
     * @param {string} title
     * @param {function} cb
     * @returns {Port}
     */
    createPort(op, title, cb)
    {
        const port = op.inDropDown(title, Anim.EASINGNAMES, "linear");
        port.set("linear");
        port.defaultValue = "linear";

        port.onChange = () =>
        {
            this.defaultEasing = this.easingFromString(port.get());
            this.emitEvent("onChangeDefaultEasing", this);

            if (cb) cb();
        };

        return port;
    }

    get tlActive()
    {
        return this.#tlActive;
    }

    set tlActive(b)
    {
        if (CABLES.UI)
        {
            this.#tlActive = b;
            window.gui.emitEvent("tlActiveChanged", this);
            this.forceChangeCallbackSoon();
        }
    }

    /**
     * @param {Object} o
     */
    setUiAttribs(o)
    {
        for (const i in o)
        {
            this.uiAttribs[i] = o[i];
            if (o[i] === null) delete this.uiAttribs[i];
        }

        this.emitEvent(Anim.EVENT_UIATTRIB_CHANGE);
    }

    /**
     * @param {number} t
     * @param {number} t2
     */
    hasKeyframesBetween(t, t2)
    {
        return this.getKeyIndex(t) != this.getKeyIndex(t2);
    }
}

// ------------------------------


/***/ }),

/***/ 963:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   rA: () => (/* binding */ AnimKey)
/* harmony export */ });
/* unused harmony exports easeExpoIn, easeExpoOut, easeExpoInOut, easeCubicIn, easeCubicOut, easeCubicInOut */
/* harmony import */ var _anim_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(344);


class AnimKey
{

    /** @type {Anim} */
    anim = null;
    id = CABLES.shortId();
    time = 0.0;
    value = 0.0;
    selected = false;
    onChange = null;
    _easing = 0;
    bezCp1 = null;
    bezCp2 = null;
    bezAn = null;
    cb = null;
    cbTriggered = false;
    temp = {};
    uiAttribs = {};

    /**
     * @param {SerializedKey} obj
     * @param {Anim} [an]
     */
    constructor(obj, an)
    {
        this.anim = obj.anim || an || null;

        this.setEasing(_anim_js__WEBPACK_IMPORTED_MODULE_0__/* .Anim */ .k.EASING_LINEAR);
        this.set(obj);
    }

    emitChange()
    {
        if (!this.anim) return;
        this.bezAn = null;
        if (this.onChange !== null) this.onChange();
        this.anim.forceChangeCallbackSoon();
        for (let i = 0; i < this.anim.keys.length; i++)
            this.anim.keys[i].bezAn = null;

    }

    delete()
    {
        if (this.anim) this.anim.remove(this);
        else console.log("animkey without anim...");
    }

    /**
     * @param {Object} o
     */
    setUiAttribs(o)
    {
        for (const i in o)
        {
            this.uiAttribs[i] = o[i];
            if (o[i] === null) delete this.uiAttribs[i];
        }
        if (this.anim) this.anim.emitEvent(_anim_js__WEBPACK_IMPORTED_MODULE_0__/* .Anim */ .k.EVENT_CHANGE);
    }

    /**
     * @param {Number} e
     */
    setEasing(e)
    {
        let changed = false;
        if (this._easing != e)changed = true;
        this._easing = e;

        if (this._easing == _anim_js__WEBPACK_IMPORTED_MODULE_0__/* .Anim */ .k.EASING_LINEAR) this.ease = this.easeLinear;
        else if (this._easing == _anim_js__WEBPACK_IMPORTED_MODULE_0__/* .Anim */ .k.EASING_ABSOLUTE) this.ease = this.easeAbsolute;
        else if (this._easing == _anim_js__WEBPACK_IMPORTED_MODULE_0__/* .Anim */ .k.EASING_SMOOTHSTEP) this.ease = AnimKey.easeSmoothStep;
        else if (this._easing == _anim_js__WEBPACK_IMPORTED_MODULE_0__/* .Anim */ .k.EASING_SMOOTHERSTEP) this.ease = AnimKey.easeSmootherStep;
        else if (this._easing == _anim_js__WEBPACK_IMPORTED_MODULE_0__/* .Anim */ .k.EASING_CUBIC_IN) this.ease = AnimKey.easeCubicIn;
        else if (this._easing == _anim_js__WEBPACK_IMPORTED_MODULE_0__/* .Anim */ .k.EASING_CUBIC_OUT) this.ease = AnimKey.easeCubicOut;
        else if (this._easing == _anim_js__WEBPACK_IMPORTED_MODULE_0__/* .Anim */ .k.EASING_CUBIC_INOUT) this.ease = AnimKey.easeCubicInOut;
        else if (this._easing == _anim_js__WEBPACK_IMPORTED_MODULE_0__/* .Anim */ .k.EASING_EXPO_IN) this.ease = AnimKey.easeExpoIn;
        else if (this._easing == _anim_js__WEBPACK_IMPORTED_MODULE_0__/* .Anim */ .k.EASING_EXPO_OUT) this.ease = AnimKey.easeExpoOut;
        else if (this._easing == _anim_js__WEBPACK_IMPORTED_MODULE_0__/* .Anim */ .k.EASING_EXPO_INOUT) this.ease = AnimKey.easeExpoInOut;
        else if (this._easing == _anim_js__WEBPACK_IMPORTED_MODULE_0__/* .Anim */ .k.EASING_SIN_IN) this.ease = AnimKey.easeSinIn;
        else if (this._easing == _anim_js__WEBPACK_IMPORTED_MODULE_0__/* .Anim */ .k.EASING_SIN_OUT) this.ease = AnimKey.easeSinOut;
        else if (this._easing == _anim_js__WEBPACK_IMPORTED_MODULE_0__/* .Anim */ .k.EASING_SIN_INOUT) this.ease = AnimKey.easeSinInOut;
        else if (this._easing == _anim_js__WEBPACK_IMPORTED_MODULE_0__/* .Anim */ .k.EASING_BACK_OUT) this.ease = AnimKey.easeOutBack;
        else if (this._easing == _anim_js__WEBPACK_IMPORTED_MODULE_0__/* .Anim */ .k.EASING_BACK_IN) this.ease = AnimKey.easeInBack;
        else if (this._easing == _anim_js__WEBPACK_IMPORTED_MODULE_0__/* .Anim */ .k.EASING_BACK_INOUT) this.ease = AnimKey.easeInOutBack;
        else if (this._easing == _anim_js__WEBPACK_IMPORTED_MODULE_0__/* .Anim */ .k.EASING_ELASTIC_IN) this.ease = AnimKey.easeInElastic;
        else if (this._easing == _anim_js__WEBPACK_IMPORTED_MODULE_0__/* .Anim */ .k.EASING_ELASTIC_OUT) this.ease = AnimKey.easeOutElastic;
        // else if (this._easing == Anim.EASING_ELASTIC_INOUT) this.ease = AnimKey.easeElasticInOut;
        else if (this._easing == _anim_js__WEBPACK_IMPORTED_MODULE_0__/* .Anim */ .k.EASING_BOUNCE_IN) this.ease = AnimKey.easeInBounce;
        else if (this._easing == _anim_js__WEBPACK_IMPORTED_MODULE_0__/* .Anim */ .k.EASING_BOUNCE_OUT) this.ease = AnimKey.easeOutBounce;
        else if (this._easing == _anim_js__WEBPACK_IMPORTED_MODULE_0__/* .Anim */ .k.EASING_QUART_OUT) this.ease = AnimKey.easeOutQuart;
        else if (this._easing == _anim_js__WEBPACK_IMPORTED_MODULE_0__/* .Anim */ .k.EASING_QUART_IN) this.ease = AnimKey.easeInQuart;
        else if (this._easing == _anim_js__WEBPACK_IMPORTED_MODULE_0__/* .Anim */ .k.EASING_QUART_INOUT) this.ease = AnimKey.easeInOutQuart;
        else if (this._easing == _anim_js__WEBPACK_IMPORTED_MODULE_0__/* .Anim */ .k.EASING_QUINT_OUT) this.ease = AnimKey.easeOutQuint;
        else if (this._easing == _anim_js__WEBPACK_IMPORTED_MODULE_0__/* .Anim */ .k.EASING_QUINT_IN) this.ease = AnimKey.easeInQuint;
        else if (this._easing == _anim_js__WEBPACK_IMPORTED_MODULE_0__/* .Anim */ .k.EASING_QUINT_INOUT) this.ease = AnimKey.easeInOutQuint;
        else if (this._easing == _anim_js__WEBPACK_IMPORTED_MODULE_0__/* .Anim */ .k.EASING_CUBICSPLINE)
        {
            if (this.ease != this.easeCubicSpline)
            {
                this.ease = this.easeCubicSpline;
                this.bezReset();
            }

            this.bezAn = null;
        }
        else
        {
            this._easing = _anim_js__WEBPACK_IMPORTED_MODULE_0__/* .Anim */ .k.EASING_LINEAR;
            this.ease = this.easeLinear;
        }
        if (changed) this.emitChange();
    }

    bezReset()
    {

        let xx = 0.5;
        const pk = this.anim.getPrevKey(this.time);
        if (pk)xx = (this.time - pk.time) / 2;

        let x2 = 0.5;
        const nk = this.anim.getNextKey(this.time);
        if (nk)x2 = (nk.time - this.time) / 2;

        this.bezCp1 = [-Math.min(xx, x2), 0];
        this.bezCp2 = [Math.min(xx, x2), 0];
        this.emitChange();
    }

    trigger()
    {
        this.cb();
        this.cbTriggered = true;
    }

    /**
     * @param {number} v
     */
    setValue(v)
    {
        this.value = v;
        this.emitChange();
    }

    /**
     * @param {number} t
     * @param {number} v
     */
    setBezCp1(t, v)
    {
        this.bezCp1 = [t, v];
        this.emitChange();
    }

    /**
     * @param {number} t
     * @param {number} v
     */
    setBezCp2(t, v)
    {
        this.bezCp2 = [t, v];
        this.emitChange();
    }

    /**
     * @param {SerializedKey} obj
     */
    set(obj)
    {
        if (obj)
        {
            if (obj.hasOwnProperty("e")) this.setEasing(obj.e);
            if (obj.cb)
            {
                this.cb = obj.cb;
                this.cbTriggered = false;
            }

            if (obj.hasOwnProperty("cp1"))
            {
                this.bezCp1 = obj.cp1;
                this.bezCp2 = obj.cp2;
            }

            if (obj.hasOwnProperty("t")) this.time = obj.t;
            if (obj.hasOwnProperty("time")) this.time = obj.time;
            if (obj.hasOwnProperty("v")) this.value = obj.v;
            else if (obj.hasOwnProperty("value")) this.value = obj.value;

            if (obj.hasOwnProperty("uiAttribs")) this.setUiAttribs(obj.uiAttribs);
        }
        this.emitChange();
    }

    /**
   * @returns {Object}
   */
    getSerialized()
    {
        const obj = {};
        obj.t = this.time;
        obj.v = this.value;
        obj.e = this._easing;
        obj.uiAttribs = this.uiAttribs;

        if (this._easing === _anim_js__WEBPACK_IMPORTED_MODULE_0__/* .Anim */ .k.EASING_CUBICSPLINE)
        {
            obj.cp1 = this.bezCp1;
            obj.cp2 = this.bezCp2;
        }

        return obj;
    }

    getEasing()
    {
        return this._easing;
    }

    /**
     * @param {number} perc
     * @param {AnimKey} key2
     */
    easeCubicSpline(perc, key2)
    {
        if (!this.bezAn)
        {
            const samples = 30;

            // const prevKey = this.anim.getPrevKey(this.time);
            this.bezAn = new _anim_js__WEBPACK_IMPORTED_MODULE_0__/* .Anim */ .k();
            for (let i = 0; i <= samples + 1; i++)
            {
                const c = AnimKey.cubicSpline(i / samples, this, key2);
                this.bezAn.setValue(c[0], c[1]);
            }
        }

        return this.bezAn.getValue(this.time + perc * (key2.time - this.time));
        // return AnimKey.cubicSpline(perc, this, key2);
    }

    /**
     * @param {number} perc
     * @param {AnimKey} key2
     */
    easeLinear(perc, key2)
    {
        return AnimKey.linear(perc, this, key2);
    }

    easeAbsolute()
    {
        return this.value;
    }
}

AnimKey.cubicSpline = function (t, key1, key2)
{
    const tInv = 1 - t;
    const tInvSq = tInv * tInv;
    const tSq = t * t;

    const c0 = tInvSq * tInv;
    const c1 = 3 * tInvSq * t;
    const c2 = 3 * tInv * tSq;
    const c3 = tSq * t;

    key1.bezCp1 = key1.bezCp1 || [-0.5, 0];
    key1.bezCp2 = key1.bezCp2 || [0.5, 0];
    key2.bezCp1 = key2.bezCp1 || [-0.5, 0];
    key2.bezCp2 = key2.bezCp2 || [0.5, 0];

    const x1 = Math.min(key2.time, key1.bezCp2[0] + key1.time);
    const xp = Math.max(key1.time, key2.bezCp1[0] + key2.time);
    // const xp = key2.bezCp1[0] + key2.time;
    // console.log("textjjjj", key2.time, key0.time);

    // const x = c0 + c1 * (key1.bezCp2[0]) + c2 * (key2.bezCp1[0]) + c3;
    const x = c0 * key1.time + c1 * (x1) + c2 * (xp) + c3 * (key2.time);
    const y = c0 * key1.value + c1 * (key1.bezCp2[1] + key1.value) + c2 * (key2.bezCp1[1] + key2.value) + c3 * (key2.value);

    return [x, y];
};

AnimKey.linear = function (perc, key1, key2)
{
    return (key1.value) + (key2.value - key1.value) * perc;
};

const easeExpoIn = function (t)
{
    return (t = 2 ** (10 * (t - 1)));
};

AnimKey.easeExpoIn = function (t, key2)
{
    t = easeExpoIn(t);
    return AnimKey.linear(t, this, key2);
};

const easeExpoOut = function (t)
{
    t = -(2 ** (-10 * t)) + 1;
    return t;
};

AnimKey.easeExpoOut = function (t, key2)
{
    t = easeExpoOut(t);
    return AnimKey.linear(t, this, key2);
};

const easeExpoInOut = function (t)
{
    t *= 2;
    if (t < 1)
    {
        t = 0.5 * 2 ** (10 * (t - 1));
    }
    else
    {
        t--;
        t = 0.5 * (-(2 ** (-10 * t)) + 2);
    }
    return t;
};

AnimKey.easeExpoInOut = function (t, key2)
{
    t = easeExpoInOut(t);
    return AnimKey.linear(t, this, key2);
};

AnimKey.easeSinIn = function (t, key2)
{
    t = -1 * Math.cos((t * Math.PI) / 2) + 1;
    return AnimKey.linear(t, this, key2);
};

AnimKey.easeSinOut = function (t, key2)
{
    t = Math.sin((t * Math.PI) / 2);
    return AnimKey.linear(t, this, key2);
};

AnimKey.easeSinInOut = function (t, key2)
{
    t = -0.5 * (Math.cos(Math.PI * t) - 1.0);
    return AnimKey.linear(t, this, key2);
};

const easeCubicIn = function (t)
{
    t = t * t * t;
    return t;
};

AnimKey.easeCubicIn = function (t, key2)
{
    t = easeCubicIn(t);
    return AnimKey.linear(t, this, key2);
};

// b 0
// c 1/2 or 1
// d always 1
// easeOutCubic: function (x, t, b, c, d) {
//     return c*((t=t/d-1)*t*t + 1) + b;

AnimKey.easeInQuint = function (t, key2)
{
    t = t * t * t * t * t;
    return AnimKey.linear(t, this, key2);
};
AnimKey.easeOutQuint = function (t, key2)
{
    t = (t -= 1) * t * t * t * t + 1;
    return AnimKey.linear(t, this, key2);
};
AnimKey.easeInOutQuint = function (t, key2)
{
    if ((t /= 0.5) < 1) t = 0.5 * t * t * t * t * t;
    else t = 0.5 * ((t -= 2) * t * t * t * t + 2);
    return AnimKey.linear(t, this, key2);
};

AnimKey.easeInQuart = function (t, key2)
{
    t = t * t * t * t;
    return AnimKey.linear(t, this, key2);
};

AnimKey.easeOutQuart = function (t, key2)
{
    // return -c * ((t=t/d-1)*t*t*t - 1) + b;
    t = -1 * ((t -= 1) * t * t * t - 1);
    return AnimKey.linear(t, this, key2);
};

AnimKey.easeInOutQuart = function (t, key2)
{
    if ((t /= 0.5) < 1) t = 0.5 * t * t * t * t;
    else t = -0.5 * ((t -= 2) * t * t * t - 2);
    return AnimKey.linear(t, this, key2);
};

AnimKey.bounce = function (t)
{
    if ((t /= 1) < 1 / 2.75) t = 7.5625 * t * t;
    else if (t < 2 / 2.75) t = 7.5625 * (t -= 1.5 / 2.75) * t + 0.75;
    else if (t < 2.5 / 2.75) t = 7.5625 * (t -= 2.25 / 2.75) * t + 0.9375;
    else t = 7.5625 * (t -= 2.625 / 2.75) * t + 0.984375;
    return t;
};

AnimKey.easeInBounce = function (t, key2)
{
    return AnimKey.linear(AnimKey.bounce(t), this, key2);
    // return c - jQuery.easing.easeOutBounce (x, d-t, 0, c, d);
};

AnimKey.easeOutBounce = function (t, key2)
{
    return AnimKey.linear(AnimKey.bounce(t), this, key2);
};

AnimKey.easeInElastic = function (t, key2)
{
    let s = 1.70158;
    let p = 0;
    let a = 1;

    const b = 0;
    const d = 1;
    const c = 1;

    if (t === 0) t = b;
    else if ((t /= d) == 1) t = b + c;
    else
    {
        if (!p) p = d * 0.3;
        if (a < Math.abs(c))
        {
            a = c;
            s = p / 4;
        }
        else s = (p / (2 * Math.PI)) * Math.asin(c / a);
        t = -(a * 2 ** (10 * (t -= 1)) * Math.sin(((t * d - s) * (2 * Math.PI)) / p)) + b;
    }

    return AnimKey.linear(t, this, key2);
};

AnimKey.easeOutElastic = function (t, key2)
{
    let s = 1.70158;
    let p = 0;
    let a = 1;

    const b = 0;
    const d = 1;
    const c = 1;

    if (t === 0) t = b;
    else if ((t /= d) == 1) t = b + c;
    else
    {
        if (!p) p = d * 0.3;
        if (a < Math.abs(c))
        {
            a = c;
            s = p / 4;
        }
        else s = (p / (2 * Math.PI)) * Math.asin(c / a);
        t = a * 2 ** (-10 * t) * Math.sin(((t * d - s) * (2 * Math.PI)) / p) + c + b;
    }

    return AnimKey.linear(t, this, key2);
};

AnimKey.easeInBack = function (t, key2)
{
    const s = 1.70158;
    t = t * t * ((s + 1) * t - s);

    return AnimKey.linear(t, this, key2);
};

AnimKey.easeOutBack = function (t, key2)
{
    const s = 1.70158;
    t = (t = t / 1 - 1) * t * ((s + 1) * t + s) + 1;

    return AnimKey.linear(t, this, key2);
};

AnimKey.easeInOutBack = function (t, key2)
{
    let s = 1.70158;
    const c = 1 / 2;
    if ((t /= 1 / 2) < 1) t = c * (t * t * (((s *= 1.525) + 1) * t - s));
    else t = c * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2);

    return AnimKey.linear(t, this, key2);
};

const easeCubicOut = function (t)
{
    t--;
    t = t * t * t + 1;
    return t;
};

AnimKey.easeCubicOut = function (t, key2)
{
    t = easeCubicOut(t);
    return AnimKey.linear(t, this, key2);
};

const easeCubicInOut = function (t)
{
    t *= 2;
    if (t < 1) t = 0.5 * t * t * t;
    else
    {
        t -= 2;
        t = 0.5 * (t * t * t + 2);
    }
    return t;
};

AnimKey.easeCubicInOut = function (t, key2)
{
    t = easeCubicInOut(t);
    return AnimKey.linear(t, this, key2);
};

AnimKey.easeSmoothStep = function (perc, key2)
{
    // var x = Math.max(0, Math.min(1, (perc-0)/(1-0)));
    const x = Math.max(0, Math.min(1, perc));
    perc = x * x * (3 - 2 * x); // smoothstep
    return AnimKey.linear(perc, this, key2);
};

AnimKey.easeSmootherStep = function (perc, key2)
{
    const x = Math.max(0, Math.min(1, (perc - 0) / (1 - 0)));
    perc = x * x * x * (x * (x * 6 - 15) + 10); // smootherstep
    return AnimKey.linear(perc, this, key2);
};


/***/ }),

/***/ 440:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ CONSTANTS)
/* harmony export */ });
/* harmony import */ var _anim_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(344);


const CONSTANTS = {
    "ANIM": {
        "EASINGS": _anim_js__WEBPACK_IMPORTED_MODULE_0__/* .Anim */ .k.EASINGNAMES,
        "EASING_LINEAR": 0,
        "EASING_ABSOLUTE": 1,
        "EASING_SMOOTHSTEP": 2,
        "EASING_SMOOTHERSTEP": 3,
        "EASING_CUBICSPLINE": 4,

        "EASING_CUBIC_IN": 5,
        "EASING_CUBIC_OUT": 6,
        "EASING_CUBIC_INOUT": 7,

        "EASING_EXPO_IN": 8,
        "EASING_EXPO_OUT": 9,
        "EASING_EXPO_INOUT": 10,

        "EASING_SIN_IN": 11,
        "EASING_SIN_OUT": 12,
        "EASING_SIN_INOUT": 13,

        "EASING_BACK_IN": 14,
        "EASING_BACK_OUT": 15,
        "EASING_BACK_INOUT": 16,

        "EASING_ELASTIC_IN": 17,
        "EASING_ELASTIC_OUT": 18,

        "EASING_BOUNCE_IN": 19,
        "EASING_BOUNCE_OUT": 21,

        "EASING_QUART_IN": 22,
        "EASING_QUART_OUT": 23,
        "EASING_QUART_INOUT": 24,

        "EASING_QUINT_IN": 25,
        "EASING_QUINT_OUT": 26,
        "EASING_QUINT_INOUT": 27,
    },

    "OP": {
        "OP_PORT_TYPE_VALUE": 0,
        "OP_PORT_TYPE_NUMBER": 0,
        "OP_PORT_TYPE_FUNCTION": 1,
        "OP_PORT_TYPE_TRIGGER": 1,
        "OP_PORT_TYPE_OBJECT": 2,
        "OP_PORT_TYPE_TEXTURE": 2,
        "OP_PORT_TYPE_ARRAY": 3,
        "OP_PORT_TYPE_DYNAMIC": 4,
        "OP_PORT_TYPE_STRING": 5,

        "OP_VERSION_PREFIX": "_v",
    },

    "PORT": {
        "PORT_DIR_IN": 0,
        "PORT_DIR_OUT": 1,
    },

    "PACO": {
        "PACO_CLEAR": 0,
        "PACO_VALUECHANGE": 1,
        "PACO_OP_DELETE": 2,
        "PACO_UNLINK": 3,
        "PACO_LINK": 4,
        "PACO_LOAD": 5,
        "PACO_OP_CREATE": 6,
        "PACO_OP_ENABLE": 7,
        "PACO_OP_DISABLE": 8,
        "PACO_UIATTRIBS": 9,
        "PACO_VARIABLES": 10,
        "PACO_TRIGGERS": 11,
        "PACO_PORT_SETVARIABLE": 12,
        "PACO_PORT_SETANIMATED": 13,
        "PACO_PORT_ANIM_UPDATED": 14,
        "PACO_DESERIALIZE": 15,
        "PACO_OP_RELOAD": 16
    },
};


/***/ }),

/***/ 50:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   I: () => (/* binding */ Port)
/* harmony export */ });
/* harmony import */ var cables_shared_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(125);
/* harmony import */ var cables_shared_client__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(849);
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(440);
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(562);
/* harmony import */ var _anim_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(344);








/**
 * @typedef PortUiAttribs
 * @property  {String} [title] overwrite title of port (by default this is portname)
 * @property  {String} [display] how the port is displayed and interacted in the paramerer panel
 * @property  {Boolean} [greyout] port paramater will appear greyed out, can not be
 * @property  {Boolean} [hidePort] port will be hidden from op
 * @property  {Boolean} [hideParam] port params will be hidden from parameter panel
 * @property  {Boolean} [showIndex] only for dropdowns - show value index (e.g. `0 - normal` )
 * @property  {String} [editorSyntax] set syntax highlighting theme for editor port
 * @property  {Boolean} [ignoreObjTypeErrors] do not auto check object types
 * @property  {string} [group] do not set manually - group ports, usually set by op.setPortGroup...
 * @property  {Boolean} [isAnimated] internal: do not set manually
 * @property  {Boolean} [useVariable] internal: do not set manually
 * @property  {string} [variableName] internal: do not set manually
 * @property  {Number} [order] internal: do not set manually
 * @property  {Number} [stride] internal: do not set manually
 * @property  {Boolean} [expose] internal: do not set manually
 * @property  {Boolean} [multiPortManual] internal: do not set manually
 * @property  {String} [increment] internal: do not set manually
 * @property  {Number} [multiPortNum] internal: do not set manually
 * @property  {String} [display] internal: do not set manually
 * @property  {String} [axis] internal: do not set manually
 * @property  {String} [type] internal: do not set manually
 * @property  {String} [objType] internal: do not set manually
 * @property  {String} [filter] internal: do not set manually
 * @property  {boolean} [hideFormatButton] internal: do not set manually
 * @property  {boolean} [editShortcut] internal: do not set manually
 * @property  {String} [filter] internal: do not set manually
 * @property  {boolean} [preview] internal: do not set manually
 * @property  {boolean} [colorPick] internal: do not set manually
 * @property  {Array<String>} [values] internal: do not set manually
 * @property  {boolean} [boundToVar] internal: do not set manually
 * @property  {boolean} [addPort] internal: do not set manually
 * @property  {boolean} [notWorking] internal: do not set manually
 * @property  {number} [glPortIndex] internal: do not set manually
 * @property  {boolean} [readOnly] internal: do not set manually
 *
 */

/**
 * data is coming into and out of ops through input and output ports
 * @namespace external:CABLES#Port
 * @module Port
 * @class
 * @example
 * const myPort=op.inString("String Port");
 */
class Port extends cables_shared_client__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A
{
    static DIR_IN = 0;
    static DIR_OUT = 1;

    static TYPE_VALUE = 0;
    static TYPE_NUMBER = 0;
    static TYPE_FUNCTION = 1;
    static TYPE_TRIGGER = 1;
    static TYPE_OBJECT = 2;
    static TYPE_TEXTURE = 2;
    static TYPE_ARRAY = 3;
    static TYPE_DYNAMIC = 4;
    static TYPE_STRING = 5;

    static EVENT_UIATTRCHANGE = "onUiAttrChange";
    static EVENT_VALUE_CHANGE = "change";

    #oldAnimVal = -5711;

    animMuted = false;

    lastAnimTime = 0;
    #uiActiveState = true;
    #valueBeforeLink = null;
    // #lastAnimFrame = -1;
    #animated = false;
    // #tempLastUiValue = null;
    #useVariableName = null;

    /**
     * @param {Op} ___op
     * @param {string} name
     * @param {number} type
     * @param {PortUiAttribs} uiAttribs
     */
    constructor(___op, name, type, uiAttribs = {})
    {
        super();
        this.data = {}; // UNUSED, DEPRECATED, only left in for backwards compatibility with userops
        this._log = new cables_shared_client__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A("core_port");

        /**
         * @type {Number}
         * @name direction
         * @instance
         * @memberof Port
         * @description direction of port (input(0) or output(1))
         */
        this.direction = Port.DIR_IN;
        this.id = String(CABLES.simpleId());

        /** @type {Op|UiOp} */
        this._op = ___op;

        /** @type {Array<Link>} */
        this.links = [];

        /** @type {any} */
        this.value = 0.0;

        this.name = name;

        /** @type {number} */
        this.type = type || Port.TYPE_VALUE;

        /** @type {PortUiAttribs} */
        this.uiAttribs = uiAttribs || {};

        /** @type {Anim} */
        this.anim = null;

        this.defaultValue = null;

        this.ignoreValueSerialize = false;
        this.onLinkChanged = null;
        this.crashed = false;

        this.onValueChanged = null;
        this.onTriggered = null;
        this.changeAlways = false;
        this.forceRefChange = false;

        this.activityCounter = 0;
        this.apf = 0;
        this.activityCounterStartFrame = 0;

        this.canLink = null; // function can be overwritten
        this.preserveLinks = null;
        this.indexPort = null;
    }

    get parent()
    {
        this._log.stack("use port.op, not .parent");
        return this.op;
    }

    get title()
    {
        return this.uiAttribs.title || this.name;
    }

    get op()
    {
        return this._op;
    }

    get val()
    {
        return this.get();
    }

    set val(v)
    {
        this.setValue(v);
    }

    /**
     * copy over a uiattrib from an external connected port to another port
     * @function copyLinkedUiAttrib
     * @memberof Port
     * @param {string} which attrib name
     * @param {Port} port source port
     * @instance
     * @example
     *
     *  inArray.onLinkChanged=()=>
     *  {
     *      if(inArray) inArray.copyLinkedUiAttrib("stride", outArray);
     *  };
     *
     */
    copyLinkedUiAttrib(which, port)
    {
        if (!CABLES.UI) return;
        if (!this.isLinked()) return;

        const attr = {};
        attr[which] = this.links[0].getOtherPort(this).getUiAttrib(which);
        port.setUiAttribs(attr);
    }

    /*
     * TODO make extend class for ports, like for ops only for ui
     */
    getValueForDisplay()
    {
        let str = this.value;

        if (typeof this.value === "string" || this.value instanceof String)
        {
            if (str.length > 1000)
            {
                str = str.substring(0, 999);
                str += "...";
            }
            if (this.uiAttribs && (this.uiAttribs.display == "boolnum"))
            {
                str += " - ";

                if (!this.value) str += "false";
                else str += "true";
            }

            str = str.replace(/[\u00A0-\u9999<>\&]/g, function (/** @type {String} */ i)
            {
                return "&#" + i.charCodeAt(0) + ";";
            });

            if (str.length > 100) str = str.substring(0, 100);
        }
        else
        {
            str = String(this.value);
        }
        // if (this.type == Port.TYPE_NUMBER)
        // {
        //     if (isNaN(this.value)) return "NaN";

        // }
        return str;
    }

    /**
     * change listener for input value ports, overwrite to react to changes
     * @function onChange
     * @memberof Port
     * @instance
     * @example
     * const myPort=op.inString("MyPort");
     * myPort.onChange=function()
     * {
     *   console.log("was changed to: ",myPort.get());
     * }
     *
     */
    onAnimToggle() {}

    _onAnimToggle()
    {
        this.onAnimToggle();
    }

    /**
     * @function remove
     * @memberof Port
     * @instance
     * @description remove port
     */
    remove()
    {
        this.removeLinks();
        this._op.removePort(this);
    }

    /**
     * set ui attributes
     * @function setUiAttribs
     * @memberof Port
     * @instance
     * @param {PortUiAttribs} newAttribs

     * @example
     * myPort.setUiAttribs({greyout:true});
     */
    setUiAttribs(newAttribs)
    {
        let changed = false;
        if (!this.uiAttribs) this.uiAttribs = {};

        for (const p in newAttribs)
        {
            if (newAttribs[p] === undefined)
            {
                delete this.uiAttribs[p];
                continue;
            }
            if (this.uiAttribs[p] != newAttribs[p]) changed = true;
            this.uiAttribs[p] = newAttribs[p];

            if (p == "group" && this.indexPort) this.indexPort.setUiAttribs({ "group": newAttribs[p] });
        }

        if (newAttribs.hasOwnProperty("expose")) this._op.patch.emitEvent("subpatchExpose", this._op.uiAttribs.subPatch);

        if (changed) this.emitEvent(Port.EVENT_UIATTRCHANGE, newAttribs, this);
    }

    /**
     * get ui attributes
     * @function getUiAttribs
     * @memberof Port
     * @example
     * myPort.getUiAttribs();
     */
    getUiAttribs()
    {
        return this.uiAttribs;
    }

    /**
     * get ui attribute
     * @function getUiAttrib
     * @memberof Port
     * @instance
     * @param {String} attribName
     * <pre>
     * attribName - return value of the ui-attribute, or null on unknown attribute
     * </pre>
     * @example
     * myPort.setUiAttribs("values");
     */
    getUiAttrib(attribName)
    {
        if (!this.uiAttribs || !this.uiAttribs.hasOwnProperty(attribName)) return null;
        return this.uiAttribs[attribName];
    }

    /**
     * @function get
     * @memberof Port
     * @instance
     * @description get value of port
     */
    get()
    {
        if (CABLES.UI && this.#animated && this.lastAnimTime == this._op.patch.timer.getTime() && !CABLES.UI.keyframeAutoCreate)
        {
            return this.value;
        }
        if (!this.animMuted && this.#animated && this.lastAnimFrame != this._op.patch.getFrameNum())
        {
            this.lastAnimTime = this._op.patch.timer.getTime();
            this.lastAnimFrame = this._op.patch.getFrameNum();

            let animval = this.anim.getValue(this._op.patch.timer.getTime());

            if (this.value != animval)
            {
                this.value = animval;
                this.#oldAnimVal = this.value;
                this.forceChange();
            }
        }

        return this.value;
    }

    /**
     * @param {object|array} v
     */
    setRef(v)
    {
        this.forceRefChange = true;
        this.set(v);
    }

    /**
     * @function setValue
     * @memberof Port
     * @instance
     * @description set value of port / will send value to all linked ports (only for output ports)
     * @param {string | number | boolean | any[]} v
     */
    set(v)
    {

        this.setValue(v);
    }

    /**
     * @param {string|boolean|number} v
     */
    setValue(v)
    {
        if (v === undefined) v = null;

        if (CABLES.UI && CABLES.UI.showDevInfos)
            if (this.direction == _constants_js__WEBPACK_IMPORTED_MODULE_2__/* .CONSTANTS */ .a.PORT.PORT_DIR_OUT && this.type == Port.TYPE_OBJECT && v && !this.forceRefChange)
                this._log.warn("object port [" + this.name + "] uses .set [" + this.op.objName + "]");

        if (this._op.enabled && !this.crashed)
        {
            if (v !== this.value || this.changeAlways || this.type == Port.TYPE_TEXTURE || this.type == Port.TYPE_ARRAY)
            {
                if (CABLES.UI && this.#animated)
                {
                    CABLES.UI.PREVISKEYVAL = null;
                    if (!CABLES.UI.keyframeAutoCreate) CABLES.UI.PREVISKEYVAL = v;
                }

                if (CABLES.UI && this.#animated && CABLES.UI.keyframeAutoCreate)
                {
                    let t = this._op.patch.timer.getTime();
                    if (CABLES.UI && window.gui.glTimeline) window.gui.glTimeline.createKey(this.anim, t, v);
                    else this.anim.setValue(t, v);
                }
                else
                {
                    try
                    {
                        this.value = v;
                        this.forceChange();
                    }
                    catch (ex)
                    {
                        this.crashed = true;

                        this.setValue = function (_v) {};
                        this.onTriggered = function (a) {};

                        this._log.error("exception in ", this._op);
                        this._log.error(ex);

                        this._op.patch.emitEvent("exception", ex, this._op);
                    }

                    if (this._op && this._op.patch && this._op.patch.isEditorMode() && this.type == Port.TYPE_TEXTURE) gui.texturePreview().updateTexturePort(this);
                }

                if (this.direction == _constants_js__WEBPACK_IMPORTED_MODULE_2__/* .CONSTANTS */ .a.PORT.PORT_DIR_OUT) for (let i = 0; i < this.links.length; ++i) this.links[i].setValue();
            }
        }
    }

    updateAnim()
    {
        if (!this.#animated || this.animMuted) return;
        this.value = this.get();

        if (this.#oldAnimVal != this.value || this.changeAlways)
        {
            this.#oldAnimVal = this.value;
            this.forceChange();
        }
        this.#oldAnimVal = this.value;

    }

    forceChange()
    {
        if (this.onValueChanged || this.onChange)
        {

        /*
         * very temporary: deprecated warning!!!!!!!!!
         * if(params.length>0) this._log.warn('TOM: port has onchange params!',this._op.objName,this.name);
         */
        }
        this._activity();
        this.emitEvent(Port.EVENT_VALUE_CHANGE, this.value, this);

        if (this.onChange) this.onChange(this, this.value);
        else if (this.onValueChanged) this.onValueChanged(this, this.value); // deprecated
    }

    /**
     * @function getTypeString
     * @memberof Port
     * @instance
     * @description get port type as string, e.g. "Function","Value"...
     * @return {String} type
     */
    getTypeString()
    {
        if (this.type == Port.TYPE_VALUE) return "Number";
        if (this.type == Port.TYPE_FUNCTION) return "Trigger";
        if (this.type == Port.TYPE_OBJECT) return "Object";
        if (this.type == Port.TYPE_DYNAMIC) return "Dynamic";
        if (this.type == Port.TYPE_ARRAY) return "Array";
        if (this.type == Port.TYPE_STRING) return "String";
        return "Unknown";
    }

    /**
     * @param {Object} objPort
     */
    deSerializeSettings(objPort)
    {
        if (!objPort) return;
        if (objPort.animated) this.setAnimated(objPort.animated);
        if (objPort.useVariable) this.setVariableName(objPort.useVariable);
        if (objPort.title) this.setUiAttribs({ "title": objPort.title });
        if (objPort.expose) this.setUiAttribs({ "expose": true });
        if (objPort.order) this.setUiAttribs({ "order": objPort.order });

        if (objPort.multiPortManual) this.setUiAttribs({ "multiPortManual": objPort.multiPortManual });
        if (objPort.multiPortNum) this.setUiAttribs({ "multiPortNum": objPort.multiPortNum });

        if (objPort.anim)
        {
            if (!this.anim) this.anim = new _anim_js__WEBPACK_IMPORTED_MODULE_3__/* .Anim */ .k({ "name": "port " + this.name });
            this._op.hasAnimPort = true;
            this.anim.on(_anim_js__WEBPACK_IMPORTED_MODULE_3__/* .Anim */ .k.EVENT_CHANGE, () =>
            {
                this._op.patch.emitEvent("portAnimUpdated", this._op, this, this.anim);
            });
            this.anim.deserialize(objPort.anim);
            this._op.patch.emitEvent("portAnimUpdated", this._op, this, this.anim);

            this.anim.sortKeys();
        }
    }

    /**
     * @param {any} v
     */
    setInitialValue(v)
    {
        if (this.op.preservedPortLinks[this.name])
        {
            for (let i = 0; i < this.op.preservedPortLinks[this.name].length; i++)
            {
                const lobj = this.op.preservedPortLinks[this.name][i];
                this.op.patch._addLink(
                    lobj.objIn,
                    lobj.objOut,
                    lobj.portIn,
                    lobj.portOut);
            }
        }

        if (this.op.preservedPortValues && this.op.preservedPortValues.hasOwnProperty(this.name) && this.op.preservedPortValues[this.name] !== undefined)
        {
            this.set(this.op.preservedPortValues[this.name]);
        }
        else
        if (v !== undefined) this.set(v);
        if (v !== undefined) this.defaultValue = v;
    }

    getSerialized()
    {
        let obj = { "name": this.getName() };

        if (!this.ignoreValueSerialize && this.links.length === 0)
        {
            if (this.type == Port.TYPE_OBJECT && this.value && this.value.tex) {}
            else obj.value = this.value;
        }
        if (this.#useVariableName) obj.useVariable = this.#useVariableName;
        if (this.#animated) obj.animated = true;
        if (this.anim) obj.anim = this.anim.getSerialized();
        if (this.uiAttribs.multiPortNum) obj.multiPortNum = this.uiAttribs.multiPortNum;
        if (this.uiAttribs.multiPortManual) obj.multiPortManual = this.uiAttribs.multiPortManual;

        if (this.uiAttribs.display == "file") obj.display = this.uiAttribs.display;
        if (this.uiAttribs.expose)
        {
            obj.expose = true;
            if (this.uiAttribs.hasOwnProperty("order")) obj.order = this.uiAttribs.order;
        }
        if (this.uiAttribs.title) obj.title = this.uiAttribs.title;
        if ((this.preserveLinks || this.direction == _constants_js__WEBPACK_IMPORTED_MODULE_2__/* .CONSTANTS */ .a.PORT.PORT_DIR_OUT) && this.links.length > 0)
        {
            obj.links = [];
            for (const i in this.links)
            {
                if (!this.links[i].ignoreInSerialize && (this.links[i].portIn && this.links[i].portOut)) obj.links.push(this.links[i].getSerialized());
            }
        }

        if (this.direction == Port.DIR_IN && this.links.length > 0)
        {
            for (const i in this.links)
            {
                if (!this.links[i].portIn || !this.links[i].portOut) continue;

                const otherp = this.links[i].getOtherPort(this);
                // check if functions exist, are defined in core_extend_ops code in ui
                if (otherp.op.isInBlueprint2 && this.op.isInBlueprint2)
                {
                    if (otherp.op.isInBlueprint2() && !this.op.isInBlueprint2())
                    {
                        obj.links = obj.links || [];
                        obj.links.push(this.links[i].getSerialized());
                    }
                }
            }
        }

        if (obj.links && obj.links.length == 0) delete obj.links;
        if (this.type === Port.TYPE_FUNCTION) delete obj.value;
        if (this.type === Port.TYPE_FUNCTION && this.links.length == 0) obj = null;
        if (obj && Object.keys(obj).length == 1 && obj.name)obj = null; // obj is null if there is no real information other than name

        (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.cleanJson)(obj);

        return obj;
    }

    /**
     * will be overwritten in ui
     * @param {Port} port1
     * @param {Port} port2
     * @returns {boolean}
     */
    shouldLink(port1, port2)
    {
        return !!(port1 && port2);
    }

    /**
     * @function removeLinks
     * @memberof Port
     * @instance
     * @description remove all links from port
     */
    removeLinks()
    {
        let count = 0;
        while (this.links.length > 0)
        {
            count++;
            if (count > 5000)
            {
                this._log.warn("could not delete links... / infinite loop");
                this.links.length = 0;
                break;
            }
            this.links[0].remove();
        }
    }

    /**
     * @function removeLink
     * @memberof Port
     * @instance
     * @description remove all link from port
     * @param {Link} link
     */
    removeLink(link)
    {
        for (let i = 0; i < this.links.length; i++)
            if (this.links[i] == link)
                this.links.splice(i, 1);

        if (this.direction == Port.DIR_IN)
        {
            if (this.type == Port.TYPE_VALUE) this.setValue(this.#valueBeforeLink || 0);
            else this.setValue(this.#valueBeforeLink || null);
        }

        if (CABLES.UI && this._op.checkLinkTimeWarnings) this._op.checkLinkTimeWarnings();

        try
        {
            if (this.onLinkChanged) this.onLinkChanged();
            this.emitEvent("onLinkChanged");
            this.emitEvent("onLinkRemoved");
            this._op.emitEvent("onLinkChanged");
        }
        catch (e)
        {
            this._log.error(e);
        }
    }

    /**
     * @function getName
     * @memberof Port
     * @instance
     * @description return port name
     */
    getName()
    {
        return this.name;
    }

    /**
     * @function getTitle
     * @memberof Port
     * @instance
     * @description return port name or title
     */
    getTitle()
    {
        if (this.uiAttribs.title) return this.uiAttribs.title;
        return this.name;
    }

    /**
     * @param {Link} l
     */
    addLink(l)
    {
        this.#valueBeforeLink = this.value;
        this.links.push(l);
        if (CABLES.UI && this._op.checkLinkTimeWarnings) this._op.checkLinkTimeWarnings();

        try
        {
            if (this.onLinkChanged) this.onLinkChanged();
            this.emitEvent("onLinkChanged");
            this._op.emitEvent("onLinkChanged");
        }
        catch (e)
        {
            this._log.error(e);
        }
    }

    /**
     * @function getLinkTo
     * @memberof Port
     * @instance
     * @param {Port} p2 otherPort
     * @description return link, which is linked to otherPort
     */
    getLinkTo(p2)
    {
        for (const i in this.links) if (this.links[i].portIn == p2 || this.links[i].portOut == p2) return this.links[i];
    }

    /**
     * @function removeLinkTo
     * @memberof Port
     * @instance
     * @param {Port} p2 otherPort
     * @description removes link, which is linked to otherPort
     */
    removeLinkTo(p2)
    {
        for (const i in this.links)
        {
            if (this.links[i].portIn == p2 || this.links[i].portOut == p2)
            {
                this.links[i].remove();
                if (CABLES.UI && this._op.checkLinkTimeWarnings) this._op.checkLinkTimeWarnings();

                if (this.onLinkChanged) this.onLinkChanged();
                this.emitEvent("onLinkChanged");
                this.emitEvent("onLinkRemoved");
                return;
            }
        }
    }

    /**
     * @function isLinkedTo
     * @memberof Port
     * @instance
     * @param {Port} p2 otherPort
     * @description returns true if port is linked to otherPort
     */
    isLinkedTo(p2)
    {
        for (const i in this.links) if (this.links[i].portIn == p2 || this.links[i].portOut == p2) return true;

        return false;
    }

    _activity()
    {
        this.activityCounter++;
    }

    /**
     * @function trigger
     * @memberof Port
     * @instance
     * @description trigger the linked port (usually invoked on an output function port)
     */
    trigger()
    {
        const linksLength = this.links.length;

        this._activity();
        if (linksLength === 0) return;
        if (!this._op.enabled) return;

        let portTriggered = null;
        try
        {
            for (let i = 0; i < linksLength; ++i)
            {
                if (this.links[i].portIn)
                {
                    portTriggered = this.links[i].portIn;

                    portTriggered.op.patch.pushTriggerStack(portTriggered);
                    if (!portTriggered._onTriggered)
                    {
                        console.log(portTriggered, portTriggered._onTriggered);
                    }
                    portTriggered._onTriggered(null);

                    portTriggered.op.patch.popTriggerStack();
                }
                if (this.links[i]) this.links[i].activity();
            }
        }
        catch (ex)
        {
            portTriggered.op.enabled = false;

            if (this._op.patch.isEditorMode())
            {
                if (portTriggered.op.onError) portTriggered.op.onError(ex);
            }
            this._log.error("exception in port: ", portTriggered.name, portTriggered.op.name, portTriggered.op.id);
            this._log.error(ex);
        }
    }

    call()
    {
        this._log.warn("call deprecated - use trigger() ");
        this.trigger();
    }

    execute()
    {
    }

    /**
     * @param {string} n
     */
    setVariableName(n)
    {
        this.#useVariableName = n;

        this._op.patch.on("variableRename", (oldname, newname) =>
        {
            if (oldname != this.#useVariableName) return;
            this.#useVariableName = newname;
        });
    }

    getVariableName()
    {
        return this.#useVariableName;
    }

    /**
     * @param {String} v
     */
    setVariable(v)
    {
        this.setAnimated(false);
        const attr = { "useVariable": false };

        if (this._variableIn && this._varChangeListenerId)
        {
            this._variableIn.off(this._varChangeListenerId);
            this._variableIn = null;
        }

        if (v)
        {
            this._variableIn = this._op.patch.getVar(v);

            if (!this._variableIn)
            {
                // this._log.warn("PORT VAR NOT FOUND!!!", v);
            }
            else
            {
                if (this.type == Port.TYPE_OBJECT)
                {
                    this._varChangeListenerId = this._variableIn.on("change", () => { this.set(null); this.set(this._variableIn.getValue()); });
                }
                else
                {
                    this._varChangeListenerId = this._variableIn.on("change", this.set.bind(this));
                }

                this.set(this._variableIn.getValue());
            }
            this.#useVariableName = v;
            attr.useVariable = true;
            attr.variableName = this.#useVariableName;
        }
        else
        {
            attr.variableName = this.#useVariableName = null;
            attr.useVariable = false;
        }

        this.setUiAttribs(attr);
        this._op.patch.emitEvent("portSetVariable", this._op, this, v);
    }

    /**
     * @param {boolean} a
     */
    _handleNoTriggerOpAnimUpdates(a)
    {
        let hasTriggerPort = false;
        // for (let i = 0; i < this._op.portsIn.length; i++)
        // {
        //     if (this._op.portsIn[i].type == Port.TYPE_FUNCTION)
        //     {
        //         hasTriggerPort = true;
        //         break;
        //     }
        // }

        if (!hasTriggerPort)
        {
            if (a) this._notriggerAnimUpdate = this._op.patch.on("onRenderFrame", () =>
            {
                this.updateAnim();
            });
            else if (this._notriggerAnimUpdate) this._notriggerAnimUpdate = this._op.patch.off(this._notriggerAnimUpdate);
        }
    }

    /**
     * @param {boolean} a
     */
    setAnimated(a)
    {
        if (this.#animated != a)
        {
            this.#animated = a;
            this._op.hasAnimPort = true;

            if (this.#animated && !this.anim)
            {
                this.anim = new _anim_js__WEBPACK_IMPORTED_MODULE_3__/* .Anim */ .k({ "name": "port " + this.name });
                this.anim.on(_anim_js__WEBPACK_IMPORTED_MODULE_3__/* .Anim */ .k.EVENT_CHANGE, () =>
                {
                    this._op.patch.emitEvent("portAnimUpdated", this._op, this, this.anim);
                });
                // this.anim.setValue(this._op.patch.timer.getTime(), this.get());
            }
            this._onAnimToggle();
        }

        this._handleNoTriggerOpAnimUpdates(a);
        if (!a)
        {
            this.anim = null;
        }

        this._op.patch.emitEvent("portAnimToggle", this._op, this, this.anim);

        this.setUiAttribs({ "isAnimated": this.#animated });
    }

    toggleAnim()
    {
        this.#animated = !this.#animated;
        if (this.#animated && !this.anim)
        {
            this.anim = new _anim_js__WEBPACK_IMPORTED_MODULE_3__/* .Anim */ .k({ "name": "port " + this.name });
            this.anim.on(_anim_js__WEBPACK_IMPORTED_MODULE_3__/* .Anim */ .k.EVENT_CHANGE, () =>
            {
                this._op.patch.emitEvent("portAnimUpdated", this._op, this, this.anim);
            });
        }
        this.setAnimated(this.#animated);
        this._onAnimToggle();
        this.setUiAttribs({ "isAnimated": this.#animated });
        this._op.patch.emitEvent("portAnimUpdated", this._op, this, this.anim);
    }

    /**
     * <pre>
     * CABLES.Port.TYPE_VALUE = 0;
     * CABLES.Port.TYPE_FUNCTION = 1;
     * CABLES.Port.TYPE_OBJECT = 2;
     * CABLES.Port.TYPE_TEXTURE = 2;
     * CABLES.Port.TYPE_ARRAY = 3;
     * CABLES.Port.TYPE_DYNAMIC = 4;
     * CABLES.Port.TYPE_STRING = 5;
     * </pre>
     * @function getType
     * @memberof Port
     * @instance
     * @return {Number} type of port
     */
    getType()
    {
        return this.type;
    }

    /**
     * @function isLinked
     * @memberof Port
     * @instance
     * @return {Boolean} true if port is linked
     */
    isLinked()
    {
        return this.links.length > 0 || this.#animated || this.#useVariableName != null;
    }

    isBoundToVar()
    {
        const b = this.#useVariableName != null;
        this.uiAttribs.boundToVar = b;
        return b;
    }

    /**
     * @return {Boolean} true if port is animated
     */
    isAnimated()
    {
        return this.#animated;
    }

    /**
     * @function isHidden
     * @memberof Port
     * @instance
     * @return {Boolean} true if port is hidden
     */
    isHidden()
    {
        return this.uiAttribs.hidePort;
    }

    /**
     * @function onTriggered
     * @memberof Port
     * @instance
     * @param {function} a onTriggeredCallback
     * @description set callback, which will be executed when port was triggered (usually output port)
     */
    _onTriggered(a)
    {
        this._activity();
        this._op.updateAnims();
        if (this._op.enabled && this.onTriggered) this.onTriggered(a);

        if (this._op.enabled) this.emitEvent("trigger");
    }

    /**
     * @param {any} v
     */
    _onSetProfiling(v) // used in editor: profiler tab
    {
        this._op.patch.profiler.add("port", this);
        this.setValue(v);
        this._op.patch.profiler.add("port", null);
    }

    _onTriggeredProfiling() // used in editor: profiler tab
    {
        if (this._op.enabled && this.onTriggered)
        {
            this._op.patch.profiler.add("port", this);
            this.onTriggered();
            this._op.patch.profiler.add("port", null);
        }
    }

    /**
     * @deprecated
     * @param {function} cb
     */
    onValueChange(cb)
    {
        this.onChange = cb;
    }

    /**
     * @deprecated
     */
    hidePort() {}

    /**
     * Returns the port type string, e.g. "value" based on the port type number
     * @function portTypeNumberToString
     * @instance
     * @memberof Port
     * @param {Number} type - The port type number
     * @returns {String} - The port type as string
     */
    static portTypeNumberToString(type)
    {
        if (type == Port.TYPE_VALUE) return "value";
        if (type == Port.TYPE_FUNCTION) return "function";
        if (type == Port.TYPE_OBJECT) return "object";
        if (type == Port.TYPE_ARRAY) return "array";
        if (type == Port.TYPE_STRING) return "string";
        if (type == Port.TYPE_DYNAMIC) return "dynamic";
        return "unknown";
    }
}


/***/ }),

/***/ 606:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  Anim: () => (/* reexport */ anim/* Anim */.k),
  AnimKey: () => (/* reexport */ anim_key/* AnimKey */.rA),
  CONSTANTS: () => (/* reexport */ constants/* CONSTANTS */.a),
  EMBED: () => (/* reexport */ EMBED),
  Link: () => (/* reexport */ Link),
  LoadingStatus: () => (/* reexport */ LoadingStatus),
  Op: () => (/* reexport */ Op),
  Patch: () => (/* reexport */ Patch),
  PatchVariable: () => (/* reexport */ PatchVariable),
  Port: () => (/* reexport */ core_port/* Port */.I),
  Profiler: () => (/* reexport */ Profiler),
  Timer: () => (/* reexport */ timer/* Timer */.M4),
  "default": () => (/* binding */ core),
  now: () => (/* reexport */ timer/* now */.tB),
  utils: () => (/* reexport */ utils)
});

// NAMESPACE OBJECT: ./node_modules/gl-matrix/esm/index.js
var esm_namespaceObject = {};
__webpack_require__.r(esm_namespaceObject);
__webpack_require__.d(esm_namespaceObject, {
  glMatrix: () => (common),
  mat2: () => (mat2),
  mat2d: () => (mat2d),
  mat3: () => (mat3),
  mat4: () => (mat4),
  quat: () => (quat),
  quat2: () => (quat2),
  vec2: () => (vec2),
  vec3: () => (vec3),
  vec4: () => (vec4)
});

// EXTERNAL MODULE: ./node_modules/gl-matrix/esm/common.js
var common = __webpack_require__(823);
// EXTERNAL MODULE: ./node_modules/gl-matrix/esm/mat2.js
var mat2 = __webpack_require__(522);
// EXTERNAL MODULE: ./node_modules/gl-matrix/esm/mat2d.js
var mat2d = __webpack_require__(964);
// EXTERNAL MODULE: ./node_modules/gl-matrix/esm/mat3.js
var mat3 = __webpack_require__(409);
// EXTERNAL MODULE: ./node_modules/gl-matrix/esm/mat4.js
var mat4 = __webpack_require__(684);
// EXTERNAL MODULE: ./node_modules/gl-matrix/esm/quat.js
var quat = __webpack_require__(221);
// EXTERNAL MODULE: ./node_modules/gl-matrix/esm/quat2.js
var quat2 = __webpack_require__(991);
// EXTERNAL MODULE: ./node_modules/gl-matrix/esm/vec2.js
var vec2 = __webpack_require__(842);
// EXTERNAL MODULE: ./node_modules/gl-matrix/esm/vec3.js
var vec3 = __webpack_require__(329);
// EXTERNAL MODULE: ./node_modules/gl-matrix/esm/vec4.js
var vec4 = __webpack_require__(796);
;// CONCATENATED MODULE: ./node_modules/gl-matrix/esm/index.js











// EXTERNAL MODULE: ../shared/client/src/eventtarget.js + 2 modules
var eventtarget = __webpack_require__(125);
// EXTERNAL MODULE: ../shared/client/src/logger.js
var logger = __webpack_require__(849);
// EXTERNAL MODULE: ./src/core/utils.js + 1 modules
var utils = __webpack_require__(562);
// EXTERNAL MODULE: ./src/core/anim.js
var anim = __webpack_require__(344);
// EXTERNAL MODULE: ./src/core/core_port.js
var core_port = __webpack_require__(50);
;// CONCATENATED MODULE: ./src/core/core_link.js




/**
 * @namespace external:CABLES#Link
 * @description a link is a connection between two ops/ports -> one input and one output port
 * @hideconstructor
 * @class
 */
class Link extends eventtarget/* default */.A
{

    /**
     * @param {Patch} p
     */
    constructor(p)
    {
        super();

        this.id = CABLES.simpleId();

        /**
         * @type {Port}
         */
        this.portIn = null;

        /**
         * @type {Port}
         */
        this.portOut = null;

        /**
         * @type {Patch}
         */
        this._patch = p;
        this.activityCounter = 0;
        this.ignoreInSerialize = false;
    }

    /**
     * @param {any} v
     */
    setValue(v)
    {
        if (v === undefined) this._setValue();
        else this.portIn.set(v);
    }

    activity()
    {
        this.activityCounter++;
    }

    _setValue()
    {
        if (!this.portOut)
        {
            this.remove();
            return;
        }
        const v = this.portOut.get();

        if (v == v) // NaN is the only JavaScript value that is treated as unequal to itself
        {
            if (this.portIn.type != core_port/* Port */.I.TYPE_FUNCTION) this.activity();

            if (this.portIn.get() !== v)
            {
                this.portIn.set(v);
            }
            else
            {
                if (this.portIn.changeAlways) this.portIn.set(v);
                if (this.portOut.forceRefChange) this.portIn.forceChange();
            }
        }
    }

    /**
     * @function getOtherPort
     * @memberof Link
     * @instance
     * @param {Port} p port
     * @description returns the port of the link, which is not port
     */
    getOtherPort(p)
    {
        if (p == this.portIn) return this.portOut;
        return this.portIn;
    }

    /**
     * @function remove
     * @memberof Link
     * @instance
     * @description unlink/remove this link from all ports
     */
    remove()
    {
        if (this.portIn) this.portIn.removeLink(this);
        if (this.portOut) this.portOut.removeLink(this);
        if (this._patch)
        {
            this._patch.emitEvent("onUnLink", this.portIn, this.portOut, this);
        }

        if (this.portIn && (this.portIn.type == core_port/* Port */.I.TYPE_OBJECT || this.portIn.type == core_port/* Port */.I.TYPE_ARRAY))
        {
            this.portIn.set(null);
            if (this.portIn.links.length > 0) this.portIn.set(this.portIn.links[0].getOtherPort(this.portIn).get());
        }

        if (this.portIn) this.portIn.op._checkLinksNeededToWork();
        if (this.portOut) this.portOut.op._checkLinksNeededToWork();

        this.portIn = null;
        this.portOut = null;
        this._patch = null;
    }

    /**
     * @function link
     * @memberof Link
     * @instance
     * @description link those two ports
     * @param {Port} p1 port1
     * @param {Port} p2 port2
     */
    link(p1, p2)
    {
        if (!Link.canLink(p1, p2))
        {
            console.warn("[core_link] cannot link ports!", p1, p2);
            return false;
        }

        if (p1.direction == core_port/* Port */.I.DIR_IN)
        {
            this.portIn = p1;
            this.portOut = p2;
        }
        else
        {
            this.portIn = p2;
            this.portOut = p1;
        }

        p1.addLink(this);
        p2.addLink(this);

        this.setValue();

        p1.op._checkLinksNeededToWork();
        p2.op._checkLinksNeededToWork();
    }

    getSerialized()
    {
        const obj = {};

        obj.portIn = this.portIn.getName();
        obj.portOut = this.portOut.getName();
        obj.objIn = this.portIn.op.id;
        obj.objOut = this.portOut.op.id;

        return obj;
    }

    /**
     * return a text message with human readable reason if ports can not be linked, or can be
     *
     * @param {Port} p1 port1
     * @param {Port} p2 port2
     */
    static canLinkText(p1, p2)
    {
        if (p1.direction == p2.direction)
        {
            let txt = "(out)";
            if (p2.direction == core_port/* Port */.I.DIR_IN) txt = "(in)";
            return "can not link: same direction " + txt;
        }
        if (p1.op == p2.op) return "can not link: same op";
        if (p1.type != core_port/* Port */.I.TYPE_DYNAMIC && p2.type != core_port/* Port */.I.TYPE_DYNAMIC)
        {
            if (p1.type != p2.type) return "can not link: different type";
        }

        if (CABLES.UI && p1.type == core_port/* Port */.I.TYPE_OBJECT && p2.type == core_port/* Port */.I.TYPE_OBJECT)
        {
            if (p1.uiAttribs.objType && p2.uiAttribs.objType)
                if (p1.uiAttribs.objType != p2.uiAttribs.objType)
                    return "incompatible objects";
        }

        if (!p1) return "can not link: port 1 invalid";
        if (!p2) return "can not link: port 2 invalid";

        if (p1.direction == core_port/* Port */.I.DIR_IN && p1.isAnimated()) return "can not link: is animated";
        if (p2.direction == core_port/* Port */.I.DIR_IN && p2.isAnimated()) return "can not link: is animated";

        if (p1.isLinkedTo(p2)) return "ports already linked";

        if ((p1.canLink && !p1.canLink(p2)) || (p2.canLink && !p2.canLink(p1))) return "Incompatible";

        return "can link";
    }

    /**
     * return true if ports can be linked
     *
     * @param {Port} p1 port1
     * @param {Port} p2 port2
     * @returns {Boolean}
     */
    static canLink(p1, p2)
    {
        if (!p1) return false;
        if (!p2) return false;
        if (p1.direction == core_port/* Port */.I.DIR_IN && p1.isAnimated()) return false;
        if (p2.direction == core_port/* Port */.I.DIR_IN && p2.isAnimated()) return false;

        if (p1.isHidden() || p2.isHidden()) return false;

        if (p1.isLinkedTo(p2)) return false;

        if (p1.direction == p2.direction) return false;

        if (CABLES.UI && p1.type == core_port/* Port */.I.TYPE_OBJECT && p2.type == core_port/* Port */.I.TYPE_OBJECT)
        {
            if (p1.uiAttribs.objType && p2.uiAttribs.objType)
            {
                if (p1.uiAttribs.objType.indexOf("sg_") == 0 && p2.uiAttribs.objType.indexOf("sg_") == 0) return true;
                if (p1.uiAttribs.objType != p2.uiAttribs.objType)
                    return false;
            }
        }

        if (p1.type != p2.type && (p1.type != core_port/* Port */.I.TYPE_DYNAMIC && p2.type != core_port/* Port */.I.TYPE_DYNAMIC)) return false;
        if (p1.type == core_port/* Port */.I.TYPE_DYNAMIC || p2.type == core_port/* Port */.I.TYPE_DYNAMIC) return true;

        if (p1.op == p2.op) return false;

        if (p1.canLink && !p1.canLink(p2)) return false;
        if (p2.canLink && !p2.canLink(p1)) return false;

        return true;
    }
}

// --------------------------------------------

// EXTERNAL MODULE: ./src/corelibs/cgl/index.js + 4 modules
var cgl = __webpack_require__(772);
// EXTERNAL MODULE: ./src/corelibs/cgl/cgl_state.js
var cgl_state = __webpack_require__(308);
// EXTERNAL MODULE: ./src/core/constants.js
var constants = __webpack_require__(440);
;// CONCATENATED MODULE: ./src/core/core_port_switch.js


class SwitchPort extends core_port/* Port */.I
{
    constructor(__parent, name, type, uiAttribs, indexPort)
    {
        super(__parent, name, type, uiAttribs);

        this.get = () =>
        {
            let s = super.get();

            if (CABLES.UI)
            {
                if (
                    s === "" ||
                    s === null ||
                    s === undefined ||
                    (uiAttribs.values && uiAttribs.values.indexOf(String(s)) === -1)
                )
                {
                    this.op.setUiError("invalidswitch", "Invalid Value [" + this.name + "]: \"" + s + "\"", 1);
                }
                else this.op.setUiError("invalidswitch", null);
            }

            if (s === null || s === undefined)s = "";

            return s;
        };

        this.indexPort = indexPort;
        this.indexPort.set = (value) =>
        {
            const values = uiAttribs.values;

            if (!values)
            {
                // console.log("switch port has no values", this);
                return;
            }

            let intValue = Math.floor(value);

            intValue = Math.min(intValue, values.length - 1);
            intValue = Math.max(intValue, 0);

            this.indexPort.setValue(intValue);
            this.set(values[intValue]);

            if (this.op.patch.isEditorMode() && performance.now() - (this.lastTime || 0) > 100 && window.gui && gui.patchView.isCurrentOp(this.op))
            {
                gui.opParams.show(this.op);
                this.lastTime = performance.now();
            }
        };
    }

    setUiAttribs(attribs)
    {
        const hidePort = attribs.hidePort;
        attribs.hidePort = true;
        super.setUiAttribs(attribs);
        if (typeof hidePort !== "undefined")
        {
            this.indexPort.setUiAttribs({ hidePort });
        }
    }
}

;// CONCATENATED MODULE: ./src/core/core_port_select.js


class ValueSelectPort extends SwitchPort
{
    setUiAttribs(newAttribs)
    {
        // never unhide valuePort when indexPort is linked
        if (this.indexPort.isLinked())
        {
            for (const p in newAttribs)
            {
                if (p == "greyout" && !newAttribs[p]) newAttribs[p] = "true";
            }
        }
        super.setUiAttribs(newAttribs);
    }
}

;// CONCATENATED MODULE: ./src/core/core_port_multi.js



const MIN_NUM_PORTS = 2;

class MultiPort extends core_port/* Port */.I
{
    constructor(__parent, name, type, dir, uiAttribs, uiAttribsPorts)
    {
        super(__parent, name, core_port/* Port */.I.TYPE_ARRAY, uiAttribs);

        this.setUiAttribs({ "multiPort": true, "group": this.name, "order": -1 });
        this.ports = [];
        this.direction = dir;
        this._uiAttribsPorts = uiAttribsPorts;

        const updateArray = () =>
        {
            const arr = [];

            let ll = 1;
            if (this.uiAttribs.multiPortManual)ll = 0;

            for (let i = 0; i < this.ports.length - ll; i++)
                arr[i] = this.ports[i];

            this.setRef(arr);
        };

        const updateUi = () =>
        {
            let grey = !this.uiAttribs.multiPortManual || false;

            if (this.direction == constants/* CONSTANTS */.a.PORT.PORT_DIR_OUT)grey = false;

            for (let i = 0; i < this.ports.length; i++)
            {
                let lp; // undefined to remove/not set it
                // let opacity;// undefined to remove/not set it
                // let grey;// undefined to remove/not set it
                let addPort = false;
                let title;
                let o = {};

                // console.log("this.op.preservedPortTitles", this.op.preservedPortTitles, this.op.preservedPortTitles[po.name], po.name);
                if (this.op.preservedPortTitles && this.op.preservedPortTitles[this.ports[i].name]) title = this.op.preservedPortTitles[this.ports[i].name];

                // if (!this.uiAttribs.multiPortManual)grey = true;
                if (i == 0) lp = this.ports.length;

                if (!this.uiAttribs.multiPortManual)
                    if (i == this.ports.length - 1)
                    {
                        title = "add port";
                        addPort = true;
                        grey = true;
                    }

                for (const attin in this._uiAttribsPorts)
                {
                    o[attin] = this._uiAttribsPorts[attin];
                }

                o.addPort = addPort;
                o.longPort = lp;
                o.title = title;
                o.greyout = grey;
                o.group = this.name;

                this.ports[i].setUiAttribs(o);
            }
        };

        this.removeInvalidPorts = () =>
        {
            for (let i = 0; i < this.ports.length; i++)
            {
                if (!this.ports[i]) this.ports.splice(i, 1);
            }

            if (!this.uiAttribs.multiPortManual)
            {
                if (this.ports.length > MIN_NUM_PORTS)

                    for (let i = this.ports.length - 1; i > 1; i--)
                    {
                        if (!this.ports[i].isLinked()) this.uiAttribs.multiPortNum = i;
                        else break;
                    }
            }

            updateArray();
        };

        this.countPorts = () =>
        {
            if (CABLES.UI && !gui.isRemoteClient && gui.patchView && gui.patchView.patchRenderer && gui.patchView.patchRenderer.isDraggingPort())
            {
                clearTimeout(this.retryTo);
                this.retryTo = setTimeout(this.countPorts.bind(this));
                return;
            }
            this.retryTo = null;

            let redo = false;
            this.removeListeners();
            this.removeInvalidPorts();

            for (let i = 0; i < this.ports.length; i++)
            {
                if (this.ports[i] && this.ports[i].links.length > 1)
                {
                    const po = this.ports[i + 1];
                    const otherPort = this.ports[i].links[0].getOtherPort(this.ports[i]);

                    if (!po || !otherPort)
                    {
                        this._log.warn("no port found?");
                    }
                    else
                    {
                        this.ports[i].links[0].remove();
                        this.op.patch.link(this.op, po.name, otherPort.op, otherPort.name);
                        redo = true;
                    }
                    break;
                }
            }

            if (!this.uiAttribs.multiPortManual)
            {
                let foundHole = true;
                while (foundHole)
                {
                    // console.log("search holes...");
                    foundHole = false;

                    for (let i = this.ports.length - 1; i > 1; i--)
                    {
                        if (this.ports[i] && this.ports[i].links.length > 0 && this.ports[i - 1].links.length == 0)
                        {
                            // console.log("found hole!");

                            // found hole
                            const otherPort = this.ports[i].links[0].getOtherPort(this.ports[i]);
                            this.ports[i].links[0].remove();

                            const po = this.ports[i - 1];

                            if (po && this.ports[i])
                            {
                                // console.log("move ", this.ports[i].name, "to", po.name);
                                this.op.patch.link(this.op, po.name, otherPort.op, otherPort.name);
                                foundHole = true;
                                redo = true;
                                break;
                            }
                        }
                    }

                    // this.checkNum();
                }

                // this.removeInvalidPorts();
            }

            if (!this.uiAttribs.multiPortManual) // if auto
            {
                while (this.ports.length > MIN_NUM_PORTS && !this.ports[this.ports.length - 1].isLinked() && !this.ports[this.ports.length - 2].isLinked())
                {
                    let i = this.ports.length - 1;
                    if (!this.ports[i].isLinked() && this.ports[i - 1] && !this.ports[i - 1].isLinked())
                    {
                        this.ports[i].setUiAttribs({ "removed": true });
                        this.ports[i].remove();
                        // this.ports[i] = null;
                        this.ports.splice(i, 1);
                    }
                }
            }

            this.removeInvalidPorts();

            if (!this.uiAttribs.multiPortManual && this.ports.length > 0 && this.ports[this.ports.length - 1].isLinked()) this.newPort();

            updateArray();
            updateUi();

            if (redo) this.countPorts();
            else this.addListeners();
        };

        this.removeListeners = () =>
        {
            for (let i = 0; i < this.ports.length; i++)
            {
                const po = this.ports[i];
                if (po.multiPortChangeListener) po.multiPortChangeListener = po.off(po.multiPortChangeListener);
                if (po.multiLinkChangeListener) po.multiLinkChangeListener = po.off(po.multiLinkChangeListener);
            }
        };

        this.addListeners = () =>
        {
            for (let i = 0; i < this.ports.length; i++)
            {
                const po = this.ports[i];
                const idx = i;

                if (po.multiPortChangeListener)po.multiPortChangeListener = po.off(po.multiPortChangeListener);
                po.multiPortChangeListener = po.on("change", updateArray.bind(this));

                if (po.multiPortTriggerListener)po.multiPortTriggerListener = po.off(po.multiPortTriggerListener);
                po.multiPortTriggerListener = po.on("trigger", () => { this._onTriggered(idx); });

                if (po.multiLinkChangeListener)po.multiLinkChangeListener = po.off(po.multiLinkChangeListener);
                po.multiLinkChangeListener = po.on("onLinkChanged", () =>
                {
                    this.countPorts();
                    this.emitEvent("onLinkChanged");
                });

                if (po.multiLinkRemoveListener)po.multiLinkRemoveListener = po.off(po.multiLinkRemoveListener);
                po.multiLinkRemoveListener = po.on("onLinkRemoved", () =>
                {
                    // this.removeInvalidPorts();
                    // this.checkNum();
                    // this.countPorts();
                    updateUi();
                    this.emitEvent("onLinkChanged");
                    // this.countPorts.bind(this);
                });
            }
        };

        this.newPort = () =>
        {
            const attrs = {};
            // if (type == CABLES.OP_PORT_TYPE_STRING) attrs.type = "string";
            attrs.type = type;
            const po = new core_port/* Port */.I(this.op, name + "_" + this.ports.length, type, attrs);

            po.direction = dir;
            this.ports.push(po);
            // console.log("CONSTANTS.PORT_DIR_OUT", CONSTANTS.PORT.PORT_DIR_OUT, this.direction);
            if (this.direction == constants/* CONSTANTS */.a.PORT.PORT_DIR_OUT) this.op.addOutPort(po);
            else this.op.addInPort(po);

            if (type == core_port/* Port */.I.TYPE_NUMBER) po.setInitialValue(0);
            else if (type == core_port/* Port */.I.TYPE_STRING) po.setInitialValue("");

            this.addListeners();

            updateUi();
            updateArray();
            this.emitEvent("onLinkChanged");
            // console.log("this.op.preservedPortTitles", this.op.preservedPortTitles, this.op.preservedPortTitles[po.name], po.name);
            if (this.op.preservedPortTitles && this.op.preservedPortTitles[po.name]) po.setUiAttribs({ "title": this.op.preservedPortTitles[po.name] });

            return po;
        };

        this.initPorts = () =>
        {
            for (let i = 0; i < MIN_NUM_PORTS; i++) this.newPort();
            updateArray();
            updateUi();
        };

        this.checkNum = () =>
        {
            this.uiAttribs.multiPortNum = Math.max(MIN_NUM_PORTS, this.uiAttribs.multiPortNum);

            while (this.ports.length < this.uiAttribs.multiPortNum) this.newPort();
            while (this.ports.length > this.uiAttribs.multiPortNum) if (this.ports[this.ports.length - 1]) this.ports.pop().remove();

            this.removeInvalidPorts();
        };

        this.incDec = (incDir) =>
        {
            this.uiAttribs.multiPortNum = this.uiAttribs.multiPortNum || MIN_NUM_PORTS;
            // console.log("this.uiAttribs.multiPortNum", this.uiAttribs.multiPortNum, this.uiAttribs.multiPortNum + incDir);
            this.setUiAttribs({ "multiPortNum": this.uiAttribs.multiPortNum + incDir });
            this.checkNum();

            updateUi();
        };

        this.toggleManual = () =>
        {
            this.setUiAttribs({ "multiPortManual": !this.uiAttribs.multiPortManual });
            this.op.refreshParams();
        };

        this.on("onUiAttrChange", (attribs) =>
        {
            if (attribs.hasOwnProperty("multiPortManual"))
            {
                updateUi();
                this.removeInvalidPorts();
                this.checkNum();
                this.countPorts();
                updateUi();
            }
        });

        this.on("onUiAttrChange", this.checkNum.bind(this));
        this.checkNum();
        this.countPorts();
        this.removeInvalidPorts();
        updateUi();
    }
}

;// CONCATENATED MODULE: ./src/core/core_op.js











/**
 * @typedef Translation
 * @property {number} [x]
 * @property {number} [y]
 */

/**
 * configuration object for loading a patch
 * @typedef OpUiAttribs
 * @property {string} [title] overwrite op title
 * @property {string} [hidePort] hidePort
 * @property {string} [title] overwrite op title
 * @property {String} [title=''] overwrite title of port (by default this is portname)
 * @property {string} [extendTitle] extended op title, shown in grey next to op name
 * @property {object} [storage]
 * @property {boolean} [working]
 * @property {boolean} [bookmarked]
 * @property {boolean} [selected]
 * @property {boolean} [disabled]
 * @property {boolean} [loading]
 * @property {boolean} [resizable]
 * @property {boolean} [hidden]
 * @property {object} [uierrors]
 * @property {string} [color]
 * @property {object} [area]
 * @property {string} [comment]
 * @property {number} [height]
 * @property {number} [width]
 * @property {Translation} [translate]
 * @property {string|number} [subPatch]
 * @property {string} [comment_title]
 */

/**
 * @typedef CorePatch
 * @type Patch
 */

/**
 * @template {CorePatch} Patch
 */
class Op extends eventtarget/* default */.A
{
    static OP_VERSION_PREFIX = "_v";
    static EVENT_INIT = "init";
    static EVENT_UIATTR_CHANGE = "onUiAttribsChange";

    #objName = "";
    _log = new logger/* default */.A("core_op");
    //    #name = "";
    #shortOpName = "";

    opId = ""; // unique op id

    /** @type {Array<Port>} */
    portsOut = [];

    /** @type {Patch} */
    patch = null;

    data = {}; // UNUSED, DEPRECATED, only left in for backwards compatibility with userops
    storage = {}; // op-specific data to be included in export

    /** @type {Array<Port>} */
    portsIn = [];
    portsInData = []; // original loaded patch data

    /** @type {OpUiAttribs} */
    uiAttribs = {};
    enabled = true;

    onAnimFrame = null;

    preservedPortTitles = {};
    preservedPortValues = {};
    preservedPortLinks = {};

    linkTimeRules = {
        "needsLinkedToWork": [],
        "needsStringToWork": [],
        "needsParentOp": null
    };

    shouldWork = {};
    hasUiErrors = 0;

    /** @type {Object} */
    uiErrors = {};
    hasAnimPort = false;

    /** @type {Port} */
    patchId = null; // will be defined by subpatchops

    /**
     * @param {Patch} _patch
     * @param {String} _objName
     * @param {String} _id=null
    */
    constructor(_patch, _objName, _id = null)
    {
        super();

        // this.#name = _objName;
        this.opId = _id;
        this.#objName = _objName;
        this.patch = _patch;

        this.#shortOpName = CABLES.getShortOpName(_objName);
        this.getTitle();

        this.id = _id || (0,utils.shortId)(); // instance id
        this.onAddPort = null;
        this.onCreate = null;
        this.onResize = null;
        this.onLoaded = null;
        this.onDelete = null;
        this.onError = null;

        this._instances = null;

        /**
         * overwrite this to prerender shader and meshes / will be called by op `loadingStatus`
         */
        this.preRender = null;

        /**
         * overwrite this to initialize your op
         */
        this.init = null;

        /**
         * Implement to render 2d canvas based graphics from in an op - optionaly defined in op instance
         * @param {CanvasRenderingContext2D} context of canvas 2d
         * @param {Object} layer info
         * @param {number} layer.x x position on canvas
         * @param {number} layer.y y position on canvas
         * @param {number} layer.width width of canvas
         * @param {number} layer.height height of canvas
         * @param {number} layer.scale current scaling of patchfield view
         */
    }

    isInBlueprint2() // will be overwritten in ui
    {
        return false;
    }

    get name()
    {
        return this.getTitle();
    }

    set name(n)
    {
        this.setTitle(n);
    }

    /**
     * @param {string} on
     */
    set _objName(on)
    {
        this.#objName = on;
        this._log = new logger/* default */.A("op " + on);
    }

    get objName()
    {
        return this.#objName;
    }

    get shortName()
    {
        return this.#shortOpName;
    }

    /**
     * op.require
     *
     * @param {String} _name - module name
     * @returns {Object}
     */
    require(_name)
    {
        if (CABLES.platform && CABLES.StandaloneElectron && !CABLES.platform.frontendOptions.isElectron)
            this.setUiError("notstandalone", "This op will only work in cables standalone version", 3);

        return null;
    }

    checkMainloopExists()
    {
        if (!CABLES.UI) return;
        if (!this.patch.tempData.mainloopOp) this.setUiError("nomainloop", "patch should have a mainloop to use this op");
        else this.setUiError("nomainloop", null);
    }

    /** @returns {string} */
    getTitle()
    {
        if (!this.uiAttribs) return "nouiattribs" + this.shortName;

        /*
         * if ((this.uiAttribs.title === undefined || this.uiAttribs.title === "") && this.objName.indexOf("Ops.Ui.") == -1)
         *     this.uiAttribs.title = this._shortOpName;
         */

        return this.uiAttribs.title || this.#shortOpName;
    }

    /**
     * @param {string} title
     */
    setTitle(title)
    {

        /*
         * this._log.log("settitle", title);
         * this._log.log(
         *     (new Error()).stack
         * );
         */

        if (title != this.getTitle()) this._setUiAttrib({ "title": title });
    }

    /**
     * @param {Object} newAttribs
     */
    setStorage(newAttribs)
    {
        if (!newAttribs) return;
        this.storage = this.storage || {};

        let changed = false;
        for (const p in newAttribs)
        {
            if (this.storage[p] != newAttribs[p]) changed = true;
            this.storage[p] = newAttribs[p];
        }

        if (changed) this.emitEvent("onStorageChange", newAttribs);
    }

    isSubPatchOp()
    {
        if (this.patchId && this.storage) return (this.storage.subPatchVer || this.storage.blueprintVer || 0);
        return false;
    }

    /**
     * setUiAttrib
     * possible values:
     * <pre>
     * warning - warning message - showing up in op parameter panel
     * error - error message - showing up in op parameter panel
     * extendTitle - op title extension, e.g. [ + ]
     * </pre>
     // * @param {OpUiAttribs} newAttribs, e.g. {"attrib":value}
     * @example
     * op.setUiAttrib({"extendTitle":str});
     */
    setUiAttrib(newAttribs)
    {
        this._setUiAttrib(newAttribs);
    }

    /**
     * @param {OpUiAttribs} a
     */
    setUiAttribs(a)
    {
        this._setUiAttrib(a);
    }

    /**
     * @deprecated
     * @param {OpUiAttribs} a
     */
    uiAttr(a)
    {
        this._setUiAttrib(a);
    }

    /**
     * @param {OpUiAttribs} newAttribs
     */
    _setUiAttrib(newAttribs)
    {
        if (!newAttribs) return;

        if (typeof newAttribs != "object") this._log.error("op.uiAttrib attribs are not of type object");
        if (!this.uiAttribs) this.uiAttribs = {};

        let changed = false;
        let emitMove = false;
        if (
            CABLES.UI &&
            newAttribs.hasOwnProperty("translate") &&
            (
                !this.uiAttribs.translate ||
                this.uiAttribs.translate.x != newAttribs.translate.x ||
                this.uiAttribs.translate.y != newAttribs.translate.y
            )) emitMove = true;

        if (newAttribs.hasOwnProperty("title") && newAttribs.title != this.uiAttribs.title)
        {
            this.uiAttribs.title = newAttribs.title;
            changed = true;
        }

        if (newAttribs.hasOwnProperty("disabled"))
        {
            changed = true;
            this.setEnabled(!newAttribs.disabled);
        }

        for (const p in newAttribs)
        {
            if (this.uiAttribs[p] != newAttribs[p]) changed = true;
            this.uiAttribs[p] = newAttribs[p];
        }

        if (this.uiAttribs.hasOwnProperty("selected") && this.uiAttribs.selected == false) delete this.uiAttribs.selected;
        if (this.uiAttribs.hasOwnProperty("selected")) changed = true;

        if (changed)
        {
            this.emitEvent(Op.EVENT_UIATTR_CHANGE, newAttribs);
            this.patch.emitEvent("onUiAttribsChange", this, newAttribs);
        }

        if (emitMove) this.emitEvent("move");
    }

    getName()
    {
        return this.#shortOpName;
    }

    /**
     * @param {Port} p
     */
    addOutPort(p)
    {
        p.direction = constants/* CONSTANTS */.a.PORT.PORT_DIR_OUT;
        p._op = this;
        this.portsOut.push(p);
        this.emitEvent("onPortAdd", p);
        return p;
    }

    hasDynamicPort()
    {
        let i = 0;
        for (i = 0; i < this.portsIn.length; i++)
        {
            if (this.portsIn[i].type == core_port/* Port */.I.TYPE_DYNAMIC) return true;
            if (this.portsIn[i].getName() == "dyn") return true;
        }
        for (i = 0; i < this.portsOut.length; i++)
        {
            if (this.portsOut[i].type == core_port/* Port */.I.TYPE_DYNAMIC) return true;
            if (this.portsOut[i].getName() == "dyn") return true;
        }

        return false;
    }

    /**
     * @param {any|Port | MultiPort} p
     */
    addInPort(p)
    {
        p.direction = core_port/* Port */.I.DIR_IN;
        p._op = this;

        this.portsIn.push(p);
        this.emitEvent("onPortAdd", p);

        return p;
    }

    /**
     *
     * @param {string} name
     * @param {string} v
     */
    inFunction(name, v)
    {
        return this.inTrigger(name, v);
    }

    /**
     * create a trigger input port
     * @param {String} name
     * @param {String} v
     * @return {Port} created port
     *
     */
    inTrigger(name, v)
    {
        const p = this.addInPort(new core_port/* Port */.I(this, name, core_port/* Port */.I.TYPE_FUNCTION));
        if (v !== undefined) p.set(v);
        return p;
    }

    /**
     * create multiple UI trigger buttons
     * @param {String} name
     * @param {Array} v
     * @return {Port} created port
     */
    inTriggerButton(name, v)
    {
        const p = this.addInPort(
            new core_port/* Port */.I(this, name, core_port/* Port */.I.TYPE_FUNCTION, {
                "display": "button"
            })
        );
        if (v !== undefined) p.set(v);
        return p;
    }

    /**
     * @param {string} name
     * @param {any} v
     */
    inUiTriggerButtons(name, v)
    {
        const p = this.addInPort(
            new core_port/* Port */.I(this, name, core_port/* Port */.I.TYPE_FUNCTION, {
                "display": "buttons"
            })
        );
        if (v !== undefined) p.set(v);
        return p;
    }

    /**
     * @deprecated
     */
    inValueFloat(name, v)
    {
        return this.inFloat(name, v);
    }

    /**
     * @deprecated
     */
    inValue(name, v)
    {
        return this.inFloat(name, v);
    }

    /**
     * create a number value input port
     * @param {String} name
     * @param {Number} v
     * @return {Port} created port
     */
    inFloat(name, v)
    {
        const p = this.addInPort(new core_port/* Port */.I(this, name, core_port/* Port */.I.TYPE_VALUE));

        p.setInitialValue(v);

        return p;
    }

    /**
     * @deprecated
     */
    inValueBool(name, v)
    {
        return this.inBool(name, v);
    }

    /**
     * create a boolean input port, displayed as a checkbox
     * @param {String} name
     * @param {Boolean|number} v
     * @return {Port} created port
     */
    inBool(name, v)
    {
        const p = this.addInPort(
            new core_port/* Port */.I(this, name, core_port/* Port */.I.TYPE_NUMBER, {
                "display": "bool"
            })
        );

        if (v === true)v = 1;
        if (v === false)v = 0;
        p.setInitialValue(v);

        return p;
    }

    /**
     * @param {string} name
     * @param {number} type
     */
    inMultiPort(name, type)
    {
        const p = new MultiPort(
            this,
            name,
            type,
            core_port/* Port */.I.DIR_IN,
            {
                "addPort": true,
                "hidePort": true
            }
        );
        p.ignoreValueSerialize = true;

        this.addInPort(p);
        p.initPorts();

        return p;
    }

    /**
     * @param {string} name
     * @param {number} type
     */
    outMultiPort(name, type, uiAttribsPort = {})
    {
        const p = new MultiPort(
            this,
            name,
            type,
            constants/* CONSTANTS */.a.PORT.PORT_DIR_OUT,
            {
                "display": "multiport",
                "hidePort": true
            },
            uiAttribsPort
        );
        p.ignoreValueSerialize = true;

        this.addOutPort(p);
        p.initPorts();

        return p;
    }

    /**
     * @param {string} name
     * @param {string} v
     */
    inValueString(name, v)
    {
        const p = this.addInPort(
            new core_port/* Port */.I(this, name, core_port/* Port */.I.TYPE_VALUE, {
                "type": "string"
            })
        );
        p.value = "";

        p.setInitialValue(v);
        return p;
    }

    /**
     * create a String value input port
     * @param {String} name
     * @param {String} v default value
     * @return {Port} created port
     */
    inString(name, v)
    {
        const p = this.addInPort(
            new core_port/* Port */.I(this, name, core_port/* Port */.I.TYPE_STRING, {
                "type": "string"
            })
        );
        v = v || "";

        p.setInitialValue(v);
        return p;
    }

    // /**
    //  * create a String value input port displayed as TextArea
    //  * @memberof Op
    //  * @param {String} name
    //  * @param {String} v default value
    //  * @return {Port} created port
    //  */
    // inValueText(name, v)
    // {
    //     const p = this.addInPort(
    //         new Port(this, name, Port.TYPE_VALUE, {
    //             "type": "string",
    //             "display": "text"
    //         })
    //     );
    //     p.value = "";

    //     p.setInitialValue(v);

    //     /*
    //      * if (v !== undefined)
    //      * {
    //      *     p.set(v);
    //      *     p.defaultValue = v;
    //      * }
    //      */
    //     return p;
    // }

    /**
     * @param {string} name
     * @param {string} v
     */
    inTextarea(name, v)
    {
        const p = this.addInPort(
            new core_port/* Port */.I(this, name, core_port/* Port */.I.TYPE_STRING, {
                "type": "string",
                "display": "text"
            })
        );
        p.value = "";
        if (v !== undefined)
        {
            p.set(v);
            p.defaultValue = v;
        }
        return p;
    }

    /**
     * create a String value input port displayed as editor
     * @param {String} name
     * @param {String} v default value
     * @param {String} syntax language
     * @param {Boolean} hideFormatButton
     * @return {Port} created port
     */
    inStringEditor(name, v, syntax, hideFormatButton = true)
    {
        const p = this.addInPort(
            new core_port/* Port */.I(this, name, core_port/* Port */.I.TYPE_STRING, {
                "type": "string",
                "display": "editor",
                "editShortcut": true,
                "editorSyntax": syntax,
                "hideFormatButton": hideFormatButton
            }));

        p.value = "";
        if (v !== undefined)
        {
            p.set(v);
            p.defaultValue = v;
        }
        return p;
    }

    /**
     *
     * @param {string} name
     * @param {String} v
     * @param {String} syntax
     */
    inValueEditor(name, v, syntax, hideFormatButton = true)
    {
        const p = this.addInPort(
            new core_port/* Port */.I(this, name, core_port/* Port */.I.TYPE_NUMBER, {
                "type": "string",
                "display": "editor",
                "editorSyntax": syntax,
                "hideFormatButton": hideFormatButton
            })
        );
        p.value = "";
        if (v !== undefined)
        {
            p.set(v);
            p.defaultValue = v;
        }
        return p;
    }

    /**
     * @deprecated
     * @param {string} name
     * @param {any[]} values
     * @param {string} v
     * @param {boolean} noindex
     */
    inValueSelect(name, values, v, noindex)
    {
        return this.inDropDown(name, values, v, noindex);
    }

    /**
     * create a string select box
     * @param {String} name
     * @param {Array} values
     * @param {String} v default value
     * @return {Port} created port
     * @param {boolean} [noindex]
     */
    inDropDown(name, values, v, noindex)
    {
        let p = null;
        if (!noindex)
        {
            const indexPort = new core_port/* Port */.I(this, name + " index", core_port/* Port */.I.TYPE_NUMBER, {
                "increment": "integer",
                "hideParam": true
            });
            const n = this.addInPort(indexPort);

            if (values) for (let i = 0; i < values.length; i++) values[i] = String(values[i]);

            const valuePort = new ValueSelectPort(
                this,
                name,
                core_port/* Port */.I.TYPE_NUMBER,
                {
                    "display": "dropdown",
                    "hidePort": true,
                    "type": "string",
                    "values": values
                },
                n
            );

            valuePort.indexPort = indexPort;

            valuePort.on("change", (/** @type {any} */ val, /** @type {Port} */ thePort) =>
            {
                if (!thePort.indexPort.isLinked() && thePort.uiAttribs.values)
                {
                    const idx = thePort.uiAttribs.values.indexOf(val);
                    if (idx > -1) thePort.indexPort.set(idx);
                }
            });

            indexPort.onLinkChanged = () =>
            {
                valuePort.setUiAttribs({ "greyout": indexPort.isLinked() });
            };

            p = this.addInPort(valuePort);

            if (v !== undefined)
            {
                p.set(v);
                const index = values.findIndex((item) => { return item == v; });
                n.setValue(index);
                p.defaultValue = v;
                n.defaultValue = index;
            }
        }
        else
        {
            const valuePort = new core_port/* Port */.I(this, name, core_port/* Port */.I.TYPE_VALUE, {
                "display": "dropdown",
                "hidePort": true,
                "type": "string",
                "values": values
            });

            p = this.addInPort(valuePort);
        }

        return p;
    }

    /**
     * create a string switch box
     * @param {String} name
     * @param {Array} values
     * @param {String} v default value
     * @param {boolean} noindex
     * @return {Port} created port
     */
    inSwitch(name, values, v, noindex)
    {
        let p = null;
        if (!noindex)
        {
            if (!v)v = values[0];
            const indexPort = new core_port/* Port */.I(this, name + " index", core_port/* Port */.I.TYPE_VALUE, {
                "increment": "integer",
                "values": values,
                "hideParam": true
            });
            const n = this.addInPort(indexPort);

            if (values) for (let i = 0; i < values.length; i++) values[i] = String(values[i]);

            const switchPort = new SwitchPort(
                this,
                name,
                core_port/* Port */.I.TYPE_STRING,
                {
                    "display": "switch",
                    "hidePort": true,
                    "type": "string",
                    "values": values
                },
                n
            );

            switchPort.indexPort = indexPort;

            switchPort.on("change", (val, thePort) =>
            {
                if (!thePort.indexPort.isLinked() && thePort.uiAttribs.values)
                {
                    const idx = thePort.uiAttribs.values.indexOf(val);
                    if (idx > -1) thePort.indexPort.set(idx);
                }
            });

            indexPort.onLinkChanged = function ()
            {
                switchPort.setUiAttribs({ "greyout": indexPort.isLinked() });
            };
            p = this.addInPort(switchPort);

            if (v !== undefined)
            {
                p.set(v);
                const index = values.findIndex((item) => { return item == v; });
                n.setValue(index);
                p.defaultValue = v;
                n.defaultValue = index;
            }
        }
        else
        {
            const switchPort = new core_port/* Port */.I(this, name, core_port/* Port */.I.TYPE_STRING, {
                "display": "switch",
                "hidePort": true,
                "type": "string",
                "values": values
            });
            p = this.addInPort(switchPort);
        }

        return p;
    }

    /**
     * @deprecated
     */
    inValueInt(name, v)
    {
        return this.inInt(name, v);
    }

    /**
     * create a integer input port
     * @param {String} name
     * @param {number} v default value
     * @return {Port} created port
     */
    inInt(name, v)
    {
        // old
        const p = this.addInPort(
            new core_port/* Port */.I(this, name, core_port/* Port */.I.TYPE_VALUE, { "increment": "integer" })
        );
        if (v !== undefined)
        {
            p.set(v);
            p.defaultValue = v;
        }
        return p;
    }

    /**
     * create a file/URL input port
     * @param {String} name
     * @param {String} filter
     * @param {String} v
     * @return {Port} created port
     */
    inFile(name, filter, v)
    {
        const p = this.addInPort(
            new core_port/* Port */.I(this, name, core_port/* Port */.I.TYPE_VALUE, {
                "display": "file",
                "type": "string",
                "filter": filter
            })
        );
        if (v !== undefined)
        {
            p.set(v);
            p.defaultValue = v;
        }
        return p;
    }

    /**
     * create a file/URL input port
     * @param {String} name
     * @param {String} filter
     * @param {String} v
     * @return {Port} created port
     */
    inUrl(name, filter, v)
    {
        const p = this.addInPort(
            new core_port/* Port */.I(this, name, core_port/* Port */.I.TYPE_STRING, {
                "display": "file",
                "type": "string",
                "filter": filter
            })
        );
        if (v !== undefined)
        {
            p.set(v);
            p.defaultValue = v;
        }
        return p;
    }

    /**
     * create a texture input port
     * @param {String} name
     * @return {Port} created port
     */
    inTexture(name, v)
    {
        const p = this.addInPort(
            new core_port/* Port */.I(this, name, core_port/* Port */.I.TYPE_OBJECT, {
                "display": "texture",
                "objType": "texture",
                "preview": true
            })
        );
        p.ignoreValueSerialize = true;
        if (v !== undefined) p.set(v);
        return p;
    }

    /**
     * create a object input port
     * @param {String} name
     * @param {Object} v
     * @param {String} objType
     * @return {Port} created port
     */
    inObject(name, v, objType)
    {
        const p = this.addInPort(new core_port/* Port */.I(this, name, core_port/* Port */.I.TYPE_OBJECT, { "objType": objType }));
        p.ignoreValueSerialize = true;

        if (v !== undefined) p.set(v);
        return p;
    }

    /**
     * @param {string} name
     * @param {string} v
     */
    inGradient(name, v)
    {
        const p = this.addInPort(
            new core_port/* Port */.I(this, name, core_port/* Port */.I.TYPE_VALUE, {
                "display": "gradient"
                // "hidePort": true
            })
        );
        if (v !== undefined) p.set(v);
        return p;
    }

    /**
     * @param {Port} p
     * returns {number}
     */
    getPortVisibleIndex(p)
    {
        let ports = this.portsIn;
        if (p.direction == constants/* CONSTANTS */.a.PORT_DIR_OUT)ports = this.portsOut;

        let index = 0;
        for (let i = 0; i < ports.length; i++)
        {
            if (ports[i].uiAttribs.hidePort) continue;
            index++;
            if (ports[i] == p) return index;
        }
    }

    /**
     * create a array input port
     * @param {String} name
     * @param {Array|Number} v
     * @param {Number} _stride
     * @return {Port} created port
     */
    inArray(name, v = undefined, _stride = undefined)
    {
        let stride = _stride;
        // @ts-ignore
        if (!_stride && CABLES.isNumeric(v))stride = v;

        const p = this.addInPort(new core_port/* Port */.I(this, name, core_port/* Port */.I.TYPE_ARRAY, { "stride": stride }));

        if (v !== undefined && (Array.isArray(v) || v == null)) p.set(v);

        return p;
    }

    /**
     * @deprecated
     */
    inValueSlider(name, v, min, max)
    {
        return this.inFloatSlider(name, v, min, max);
    }

    /**
     * create a value slider input port
     * @param {String} name
     * @param {number} v
     * @param {number} min
     * @param {number} max
     * @return {Port} created port
     */
    inFloatSlider(name, v, min, max)
    {
        const uiattribs = { "display": "range" };

        if (min != undefined && max != undefined)
        {
            uiattribs.min = min;
            uiattribs.max = max;
        }

        const p = this.addInPort(new core_port/* Port */.I(this, name, core_port/* Port */.I.TYPE_VALUE, uiattribs));
        if (v !== undefined)
        {
            p.set(v);
            p.defaultValue = v;
        }
        return p;
    }

    /**
     * @deprecated
     */
    outFunction(name, v)
    {
        return this.outTrigger(name, v);
    }

    /**
     * create output trigger port
     * @param {String} name
     * @param {String} v
     * @return {Port} created port
     */
    outTrigger(name, v)
    {
        // old
        const p = this.addOutPort(new core_port/* Port */.I(this, name, core_port/* Port */.I.TYPE_FUNCTION));
        if (v !== undefined) p.set(v);
        return p;
    }

    /**
     * @deprecated
     */
    outValue(name, v)
    {
        return this.outNumber(name, v);
    }

    /**
     * create output value port
     * @param {String} name
     * @param {number} v default value
     * @return {Port} created port
     */
    outNumber(name, v)
    {
        const p = this.addOutPort(new core_port/* Port */.I(this, name, core_port/* Port */.I.TYPE_VALUE));
        if (v !== undefined) p.set(v);
        return p;
    }

    /**
     * @deprecated
     */
    outValueBool(name, v)
    {
        return this.outBool(name, v);
    }

    /**
     * deprecated create output boolean port
     * @deprecated
     * @param {String} name
     * @param {boolean} v default value
     * @return {Port} created port
     */
    outBool(name, v)
    {
        // old: use outBoolNum
        const p = this.addOutPort(
            new core_port/* Port */.I(this, name, core_port/* Port */.I.TYPE_VALUE, {
                "display": "bool"
            })
        );
        if (v !== undefined) p.set(v);
        else p.set(0);
        return p;
    }

    /**
     * create output boolean port,value will be converted to 0 or 1
     * @param {String} name
     * @return {Port} created port
     */
    outBoolNum(name, v)
    {
        const p = this.addOutPort(
            new core_port/* Port */.I(this, name, core_port/* Port */.I.TYPE_VALUE, {
                "display": "boolnum"
            })
        );

        p.set = function (b)
        {
            this.setValue(b ? 1 : 0);
        }.bind(p);

        if (v !== undefined) p.set(v);
        else p.set(0);
        return p;
    }

    /**
     * @deprecated
     * @param {string} name
     * @param {string} v
     */
    outValueString(name, v)
    {
        const p = this.addOutPort(
            new core_port/* Port */.I(this, name, core_port/* Port */.I.TYPE_VALUE, {
                "type": "string"
            })
        );
        if (v !== undefined) p.set(v);
        return p;
    }

    /**
     * create output string port
     * @param {string} name
     * @param {String} v
     * @return {Port} created port
     */
    outString(name, v)
    {
        const p = this.addOutPort(
            new core_port/* Port */.I(this, name, core_port/* Port */.I.TYPE_STRING, {
                "type": "string"
            })
        );
        if (v !== undefined) p.set(v);
        else p.set("");
        return p;
    }

    /**
     * create output object port
     * @param {String} name
     * @return {Port} created port
     * @param {object} v
     * @param {string} objType
     */
    outObject(name, v, objType)
    {
        const p = this.addOutPort(new core_port/* Port */.I(this, name, core_port/* Port */.I.TYPE_OBJECT, { "objType": objType || null }));
        p.set(v || null);
        p.ignoreValueSerialize = true;
        return p;
    }

    /**
     * create output array port
     * @param {String} name
     * @return {Port} created port
     * @param {array|number} v
     * @param {number} stride
     */
    outArray(name, v, stride)
    {
        if (!stride && CABLES.isNumeric(v))stride = v;
        const p = this.addOutPort(new core_port/* Port */.I(this, name, core_port/* Port */.I.TYPE_ARRAY, { "stride": stride }));
        if (v !== undefined && (Array.isArray(v) || v == null)) p.set(v);

        p.ignoreValueSerialize = true;
        return p;
    }

    /**
     * create output texture port
     * @param {String} name
     * @return {Port} created port
     * @param {any} v
     */
    outTexture(name, v)
    {
        const p = this.addOutPort(
            new core_port/* Port */.I(this, name, core_port/* Port */.I.TYPE_OBJECT, {
                "preview": true,
                "objType": "texture",
                "display": "texture"
            })
        );
        if (v !== undefined) p.setRef(v || cgl/* CGL */.Rq.Texture.getEmptyTexture(this.patch.cgl));

        p.ignoreValueSerialize = true;
        return p;
    }

    /**
     * @deprecated
     * @param {string} name
     * @param {any} filter
     * @param {any} options
     * @param {any} v
     */
    inDynamic(name, filter, options, v)
    {
        const p = new core_port/* Port */.I(this, name, core_port/* Port */.I.TYPE_DYNAMIC, options);

        p.shouldLink = (p1, p2) =>
        {
            if (filter && CABLES.isArray(filter))
            {
                // for (let i = 0; i < filter.length; i++)
                // {
                // if (p1 == this && p2.type === filter[i]) return true;
                // if (p2 == this && p1.type === filter[i]) return true;
                // }
                return false; // types do not match
            }
            return true; // no filter set
        };

        this.addInPort(p);
        if (v !== undefined)
        {
            p.set(v);
            p.defaultValue = v;
        }
        return p;
    }

    removeLinks()
    {
        for (let i = 0; i < this.portsIn.length; i++) this.portsIn[i].removeLinks();
        for (let i = 0; i < this.portsOut.length; i++) this.portsOut[i].removeLinks();
    }

    getSerialized()
    {
        const opObj = {};

        if (this.opId) opObj.opId = this.opId;
        if (this.patch.storeObjNames) opObj.objName = this.objName;

        opObj.id = this.id;
        opObj.uiAttribs = JSON.parse(JSON.stringify(this.uiAttribs)) || {};

        if (this.storage && Object.keys(this.storage).length > 0) opObj.storage = JSON.parse(JSON.stringify(this.storage));
        if (this.uiAttribs.hasOwnProperty("working") && this.uiAttribs.working == true) delete this.uiAttribs.working;
        if (opObj.uiAttribs.hasOwnProperty("uierrors")) delete opObj.uiAttribs.uierrors;

        if (opObj.uiAttribs.title === "") delete opObj.uiAttribs.title;
        if (opObj.uiAttribs.color === null) delete opObj.uiAttribs.color;
        if (opObj.uiAttribs.comment === null) delete opObj.uiAttribs.comment;

        if (opObj.uiAttribs.title == this.#shortOpName ||
            (this.uiAttribs.title || "").toLowerCase() == this.#shortOpName.toLowerCase()) delete opObj.uiAttribs.title;

        opObj.portsIn = [];
        opObj.portsOut = [];

        for (let i = 0; i < this.portsIn.length; i++)
        {
            const s = this.portsIn[i].getSerialized();
            if (s) opObj.portsIn.push(s);
        }

        for (let i = 0; i < this.portsOut.length; i++)
        {
            const s = this.portsOut[i].getSerialized();
            if (s) opObj.portsOut.push(s);
        }

        if (opObj.portsIn.length == 0) delete opObj.portsIn;
        if (opObj.portsOut.length == 0) delete opObj.portsOut;
        (0,utils.cleanJson)(opObj);

        return opObj;
    }

    /**
     * @param {number} type
     */
    getFirstOutPortByType(type)
    {
        for (let i = 0; i < this.portsOut.length; i++)
            if (this.portsOut[i].type == type) return this.portsOut[i];
    }

    /**
     * @param {number} type
     */
    getFirstInPortByType(type)
    {
        for (let i = 0; i < this.portsIn.length; i++)
            if (this.portsIn[i].type == type) return this.portsIn[i];
    }

    /**
     * return port by the name portName
     * @param {String} name
     * @param {boolean} [lowerCase]
     * @return {Port}
     */
    getPort(name, lowerCase = false)
    {
        return this.getPortByName(name, lowerCase);
    }

    /**
     * @param {string} name
     * @param {boolean} [lowerCase]
     * @returns {Port}
     */
    getPortByName(name, lowerCase = false)
    {
        if (lowerCase)
        {
            for (let ipi = 0; ipi < this.portsIn.length; ipi++)
                if (this.portsIn[ipi].getName().toLowerCase() == name || this.portsIn[ipi].id.toLowerCase() == name)
                    return this.portsIn[ipi];

            for (let ipo = 0; ipo < this.portsOut.length; ipo++)
                if (this.portsOut[ipo].getName().toLowerCase() == name || this.portsOut[ipo].id.toLowerCase() == name)
                    return this.portsOut[ipo];
        }
        else
        {
            for (let ipi = 0; ipi < this.portsIn.length; ipi++)
                if (this.portsIn[ipi].getName() == name || this.portsIn[ipi].id == name)
                    return this.portsIn[ipi];

            for (let ipo = 0; ipo < this.portsOut.length; ipo++)
                if (this.portsOut[ipo].getName() == name || this.portsOut[ipo].id == name)
                    return this.portsOut[ipo];
        }
    }

    /**
     * return port by the name id
     * @param {String} id
     * @return {Port}
     */
    getPortById(id)
    {
        for (let ipi = 0; ipi < this.portsIn.length; ipi++) if (this.portsIn[ipi].id == id) return this.portsIn[ipi];
        for (let ipo = 0; ipo < this.portsOut.length; ipo++) if (this.portsOut[ipo].id == id) return this.portsOut[ipo];
    }

    updateAnims()
    {
        if (this.hasAnimPort)
            for (let i = 0; i < this.portsIn.length; i++) this.portsIn[i].updateAnim();
    }

    log()
    {
        this._log.log(...arguments);
    }

    /**
     * @deprecated
     */
    error()
    {
        this._log.error(...arguments);
    }

    logError()
    {
        this._log.error(...arguments);
    }

    /**
     * @deprecated
     */
    warn()
    {
        this._log.warn(...arguments);
    }

    logWarn()
    {
        this._log.warn(...arguments);
    }

    /**
     * @deprecated
     */
    verbose()
    {
        this._log.verbose(...arguments);
    }

    logVerbose()
    {
        this._log.verbose(...arguments);
    }

    profile()
    {
        for (let ipi = 0; ipi < this.portsIn.length; ipi++)
        {
            this.portsIn[ipi]._onTriggered = this.portsIn[ipi]._onTriggeredProfiling;
            this.portsIn[ipi].set = this.portsIn[ipi]._onSetProfiling;
        }
    }

    // todo: check instancing stuff?
    cleanUp()
    {
        if (this._instances)
        {
            for (let i = 0; i < this._instances.length; i++)
                if (this._instances[i].onDelete) this._instances[i].onDelete();

            this._instances.length = 0;
        }

        for (let i = 0; i < this.portsIn.length; i++)
            this.portsIn[i].setAnimated(false);

        if (this.onAnimFrame) this.patch.removeOnAnimFrame(this);
    }

    // todo: check instancing stuff?
    instanced(triggerPort)
    {
        return false;

        /*
         * this._log.log("instanced", this.patch.instancing.numCycles());
         * if (this.patch.instancing.numCycles() === 0) return false;
         */

        /*
         * let i = 0;
         * let ipi = 0;
         * if (!this._instances || this._instances.length != this.patch.instancing.numCycles())
         * {
         *     if (!this._instances) this._instances = [];
         *     this._.log("creating instances of ", this.objName, this.patch.instancing.numCycles(), this._instances.length);
         *     this._instances.length = this.patch.instancing.numCycles();
         */

        /*
         *     for (i = 0; i < this._instances.length; i++)
         *     {
         *         this._instances[i] = this.patch.createOp(this.objName, true);
         *         this._instances[i].instanced ()
         *         {
         *             return false;
         *         };
         *         this._instances[i].uiAttr(this.uiAttribs);
         */

        /*
         *         for (let ipo = 0; ipo < this.portsOut.length; ipo++)
         *         {
         *             if (this.portsOut[ipo].type == Port.TYPE_FUNCTION)
         *             {
         *                 this._instances[i].getPortByName(this.portsOut[ipo].name).trigger = this.portsOut[ipo].trigger.bind(this.portsOut[ipo]);
         *             }
         *         }
         *     }
         */

        /*
         *     for (ipi = 0; ipi < this.portsIn.length; ipi++)
         *     {
         *         this.portsIn[ipi].onChange = null;
         *         this.portsIn[ipi].onValueChanged = null;
         *     }
         * }
         */

        /*
         * const theTriggerPort = null;
         * for (ipi = 0; ipi < this.portsIn.length; ipi++)
         * {
         *     if (
         *         this.portsIn[ipi].type == Port.TYPE_VALUE ||
         *         this.portsIn[ipi].type == Port.TYPE_ARRAY
         *     )
         *     {
         *         this._instances[this.patch.instancing.index()].portsIn[ipi].set(this.portsIn[ipi].get());
         *     }
         *     if (this.portsIn[ipi].type == Port.TYPE_FUNCTION)
         *     {
         *         // if(this._instances[ this.patch.instancing.index() ].portsIn[ipi].name==triggerPort.name)
         *         // theTriggerPort=this._instances[ this.patch.instancing.index() ].portsIn[ipi];
         *     }
         * }
         */

        // if (theTriggerPort) theTriggerPort.onTriggered();

        /*
         * for (ipi = 0; ipi < this.portsOut.length; ipi++)
         * {
         *     if (this.portsOut[ipi].type == Port.TYPE_VALUE)
         *     {
         *         this.portsOut[ipi].set(this._instances[this.patch.instancing.index()].portsOut[ipi].get());
         *     }
         * }
         */

        // return true;
    }

    // todo: check instancing stuff?
    initInstancable()
    {
        //         if(this.isInstanced)
        //         {
        //             this._log.log('cancel instancing');
        //             return;
        //         }
        //         this._instances=[];
        //         for(var ipi=0;ipi<this.portsIn.length;ipi++)
        //         {
        //             if(this.portsIn[ipi].type==Port.TYPE_VALUE)
        //             {
        //
        //             }
        //             if(this.portsIn[ipi].type==Port.TYPE_FUNCTION)
        //             {
        //                 // var piIndex=ipi;
        //                 this.portsIn[ipi].onTriggered=function(piIndex)
        //                 {
        //
        //                     var i=0;
        // // this._log.log('trigger',this._instances.length);
        //
        //                 }.bind(this,ipi );
        //
        //             }
        // };
        // this._instances=null;
    }

    // setValues(obj)
    // {
    //     for (const i in obj)
    //     {
    //         const port = this.getPortByName(i);
    //         if (port) port.set(obj[i]);
    //         else this._log.warn("op.setValues: port not found:", i);
    //     }
    // }

    /**
     * return true if op has this error message id
     * @param {String} id
     * @returns {Boolean} - has id
     */
    hasUiError(id)
    {
        return this.uiErrors.hasOwnProperty(id) && this.uiErrors[id];
    }

    /**
     * show op error message - set message to null to remove error message
     * @param {string} id error id
     * @param {string} txt text message
     * @param {number} level level
     */
    setUiError(id, txt, level = 2, options = {})
    {
        // overwritten in ui: core_extend_op
    }

    /**
     * enable/disable op
     * @function
     * @param {boolean} b
     */
    setEnabled(b)
    {
        this.enabled = b;
        this.emitEvent("onEnabledChange", b);
    }

    /**
     * organize ports into a group
     * @function
     * @param {String} name
     * @param {Array} ports
     */
    setPortGroup(name, ports)
    {
        for (let i = 0; i < ports.length; i++)
        {
            if (ports[i])
                if (ports[i].setUiAttribs) ports[i].setUiAttribs({ "group": name });
                else this._log.error("setPortGroup: invalid port!");
        }
    }

    /**
     * visually indicate ports that they are coordinate inputs
     * @function
     * @param {Port} px
     * @param {Port} py
     * @param {Port} pz
     */
    setUiAxisPorts(px, py, pz)
    {
        if (px) px.setUiAttribs({ "axis": "X" });
        if (py) py.setUiAttribs({ "axis": "Y" });
        if (pz) pz.setUiAttribs({ "axis": "Z" });
    }

    /**
     * remove port from op
     * @param {Port} port to remove
     */
    removePort(port)
    {
        for (let ipi = 0; ipi < this.portsIn.length; ipi++)
        {
            if (this.portsIn[ipi] == port)
            {
                this.portsIn.splice(ipi, 1);
                this.emitEvent(Op.EVENT_UIATTR_CHANGE, {});
                this.emitEvent("onPortRemoved", {});
                return;
            }
        }
        for (let ipi = 0; ipi < this.portsOut.length; ipi++)
        {
            if (this.portsOut[ipi] == port)
            {
                this.portsOut.splice(ipi, 1);
                this.emitEvent(Op.EVENT_UIATTR_CHANGE, {});
                this.emitEvent("onPortRemoved", {});
                return;
            }
        }
    }

    /**
     * show a warning of this op is not a child of parentOpName
     * @function
     * @param {String} parentOpName
     */
    toWorkNeedsParent(parentOpName)
    {
        this.linkTimeRules.needsParentOp = parentOpName;
    }

    /**
     * show a warning of this op is a child of parentOpName
     * @function
     * @instance
     * @memberof Op
     * @param {String} parentOpName
     * @param {number} type
     */
    toWorkShouldNotBeChild(parentOpName, type)
    {
        if (!this.patch.isEditorMode()) return;
        this.linkTimeRules.forbiddenParent = parentOpName;
        if (type != undefined) this.linkTimeRules.forbiddenParentType = type;
    }

    toWorkPortsNeedsString()
    {
        if (!this.patch.isEditorMode()) return;
        for (let i = 0; i < arguments.length; i++)
            if (this.linkTimeRules.needsStringToWork.indexOf(arguments[i]) == -1) this.linkTimeRules.needsStringToWork.push(arguments[i]);
    }

    /**
     * show a small X to indicate op is not working when given ports are not linked
     * @function
     * @instance
     * @memberof Op
     * @param {Array<Port>} port
     */
    toWorkPortsNeedToBeLinked()
    {
        if (!this.patch.isEditorMode()) return;
        for (let i = 0; i < arguments.length; i++)
            if (this.linkTimeRules.needsLinkedToWork.indexOf(arguments[i]) == -1) this.linkTimeRules.needsLinkedToWork.push(arguments[i]);
    }

    toWorkPortsNeedToBeLinkedReset()
    {
        if (!this.patch.isEditorMode()) return;
        this.linkTimeRules.needsLinkedToWork.length = 0;
        if (this.checkLinkTimeWarnings) this.checkLinkTimeWarnings();
    }

    initVarPorts()
    {
        for (let i = 0; i < this.portsIn.length; i++)
            if (this.portsIn[i].getVariableName()) this.portsIn[i].setVariable(this.portsIn[i].getVariableName());
    }

    checkLinkTimeWarnings() {}
    _checkLinksNeededToWork() { }

    /**
     * refresh op parameters, if current op is selected
     * @function
     * @instance
     * @memberof Op
     */
    refreshParams()
    {
        if (this.patch && this.patch.isEditorMode() && this.isCurrentUiOp()) gui.opParams.show(this);
    }

    /**
     * Returns true if op is selected and parameter are shown in the editor, can only return true if in editor/ui
     * @instance
     * @memberof Op
     * @returns {Boolean} - is current ui op
     */
    isCurrentUiOp()
    {
        if (this.patch.isEditorMode()) return gui.patchView.isCurrentOp(this);
    }

    checkGraphicsApi(api = cgl_state/* CglContext */.G.API_WEBGL)
    {
        if (this.patch.isEditorMode())
            if (this.patch.cg && this.patch.cg.gApi != api)
                this.setUiError("wronggapi", "Wrong graphics API", 2);
    }
}

;// CONCATENATED MODULE: ./src/core/loadingstatus.js





/**
 * LoadingStatus class, manages asynchronous loading jobs
 *
 * @namespace external:CABLES#LoadingStatus
 * @hideconstructor
 * @class
 * @param patch
 */

class LoadingStatus extends eventtarget/* default */.A
{

    /**
     * @param {Patch} patch
     */
    constructor(patch)
    {
        super();
        this._log = new logger/* default */.A("LoadingStatus");
        this._loadingAssets = {};
        this._cbFinished = [];
        this._assetTasks = [];
        this._percent = 0;
        this._count = 0;
        this._countFinished = 0;
        this._order = 0;
        this._startTime = 0;
        this._patch = patch;
        this._wasFinishedPrinted = false;
        this._loadingAssetTaskCb = false;
    }

    /**
     * @param {Function} cb
     */
    setOnFinishedLoading(cb)
    {
        this._cbFinished.push(cb);
    }

    getNumAssets()
    {
        return this._countFinished;
    }

    getProgress()
    {
        return this._percent;
    }

    checkStatus()
    {
        this._countFinished = 0;
        this._count = 0;

        for (const i in this._loadingAssets)
        {
            this._count++;
            if (!this._loadingAssets[i].finished)
            {
                this._countFinished++;
            }
        }

        this._percent = (this._count - this._countFinished) / this._count;

        if (this._countFinished === 0)
        {
            for (let j = 0; j < this._cbFinished.length; j++)
            {
                if (this._cbFinished[j])
                {
                    const cb = this._cbFinished[j];
                    setTimeout(() => { cb(this._patch); this.emitEvent("finishedAll"); }, 100);
                }
            }

            if (!this._wasFinishedPrinted)
            {
                this._wasFinishedPrinted = true;
                this.print();
            }
            this.emitEvent("finishedAll");
        }
    }

    getList()
    {
        let arr = [];
        for (const i in this._loadingAssets)
        {
            arr.push(this._loadingAssets[i]);
        }

        return arr;
    }

    getListJobs()
    {
        let arr = [];
        for (const i in this._loadingAssets)
        {
            if (!this._loadingAssets[i].finished)arr.push(this._loadingAssets[i].name);
        }

        return arr;
    }

    print()
    {
        if (this._patch.config.silent) return;

        const rows = [];

        for (const i in this._loadingAssets)
        {
            rows.push([
                this._loadingAssets[i].order,
                this._loadingAssets[i].type,
                this._loadingAssets[i].name,
                (this._loadingAssets[i].timeEnd - this._loadingAssets[i].timeStart) / 1000 + "s",
            ]);
        }

        this._log.groupCollapsed("finished loading " + this._order + " assets in " + (Date.now() - this._startTime) / 1000 + "s");
        this._log.table(rows);
        this._log.groupEnd();
    }

    /**
     * @param {string} id
     */
    finished(id)
    {
        const l = this._loadingAssets[id];
        if (l)
        {
            if (l.finished) this._log.warn("loading job was already finished", l);

            if (l.op) l.op.setUiAttribs({ "loading": false });
            l.finished = true;
            l.timeEnd = Date.now();
        }

        this.checkStatus();
        this.emitEvent("finishedTask");
        return null;
    }

    _startAssetTasks()
    {
        for (let i = 0; i < this._assetTasks.length; i++) this._assetTasks[i]();
        this._assetTasks.length = 0;
    }

    /**
     * delay an asset loading task, mainly to wait for ui to be finished loading and showing, and only then start loading assets
     * @function addAssetLoadingTask
     * @instance
     * @memberof LoadingStatus
     * @param {function} cb callback
     */
    addAssetLoadingTask(cb)
    {
        if (this._patch.isEditorMode() && !CABLES.UI.loaded)
        {
            this._assetTasks.push(cb);

            if (!this._loadingAssetTaskCb)window.gui.addEventListener("uiloaded", this._startAssetTasks.bind(this));
            this._loadingAssetTaskCb = true;
        }
        else
        {
            cb();
        }
        this.emitEvent("addAssetTask");
    }

    /**
     * @param {string} name
     */
    existByName(name)
    {
        for (let i in this._loadingAssets)
        {
            if (this._loadingAssets[i].name == name && !this._loadingAssets[i].finished)
                return true;
        }
    }

    /**
     * @param {string} type
     * @param {string} name
     * @param {Op} [op]
     */
    start(type, name, op)
    {
        if (this._startTime == 0) this._startTime = Date.now();
        const id = (0,utils.generateUUID)();

        name = name || "unknown";
        if (name.length > 100)name = name.substring(0, 100);

        if (op)op.setUiAttrib({ "loading": true });

        this._loadingAssets[id] = {
            "id": id,
            "op": op,
            "type": type,
            "name": name,
            "finished": false,
            "timeStart": Date.now(),
            "order": this._order,
        };
        this._order++;

        this.emitEvent("startTask");

        return id;
    }
}

// EXTERNAL MODULE: ./src/core/timer.js
var timer = __webpack_require__(920);
;// CONCATENATED MODULE: ./src/core/core_profiler.js



class Profiler
{

    /**
     * @param {Patch} patch
     */
    constructor(patch)
    {
        this.startFrame = patch.getFrameNum();
        this.items = {};
        this.currentId = null;
        this.currentStart = 0;
        this._patch = patch;
    }

    getItems()
    {
        return this.items;
    }

    clear()
    {
        if (this.paused) return;
        this.items = {};
    }

    togglePause()
    {
        this.paused = !this.paused;
        if (!this.paused)
        {
            this.items = {};
            this.currentStart = performance.now();
        }
    }

    add(type, object)
    {
        if (this.paused) return;

        if (this.currentId !== null)
        {
            if (!object || object.id != this.currentId)
            {
                if (this.items[this.currentId])
                {
                    this.items[this.currentId].timeUsed += performance.now() - this.currentStart;

                    if (!this.items[this.currentId].peakTime || (0,timer/* now */.tB)() - this.items[this.currentId].peakTime > 5000)
                    {
                        this.items[this.currentId].peak = 0;
                        this.items[this.currentId].peakTime = (0,timer/* now */.tB)();
                    }
                    this.items[this.currentId].peak = Math.max(this.items[this.currentId].peak, performance.now() - this.currentStart);
                }
            }
        }

        if (object !== null)
        {
            if (!this.items[object.id])
            {
                this.items[object.id] = {
                    "numTriggers": 0,
                    "timeUsed": 0,
                };
            }

            if (this.items[object.id].lastFrame != this._patch.getFrameNum()) this.items[object.id].numTriggers = 0;

            this.items[object.id].lastFrame = this._patch.getFrameNum();
            this.items[object.id].numTriggers++;
            this.items[object.id].opid = object.op.id;
            this.items[object.id].title = object.op.name + "." + object.name;
            this.items[object.id].subPatch = object.op.uiAttribs.subPatch;

            this.currentId = object.id;
            this.currentStart = performance.now();
        }
        else
        {
            this.currentId = null;
        }
    }

    print()
    {
        console.log("--------");
        for (const i in this.items)
        {
            console.log(this.items[i].title + ": " + this.items[i].numTriggers + " / " + this.items[i].timeUsed);
        }
    }
}

;// CONCATENATED MODULE: ./src/core/core_variable.js


class PatchVariable extends eventtarget/* default */.A
{

    /**
     * @param {String} name
     * @param {String|Number} val
     * @param {number} type
     */
    constructor(name, val, type)
    {
        super();
        this._name = name;
        this.type = type;
        this.setValue(val);
    }

    /**
     * keeping this for backwards compatibility in older
     * exports before using eventtarget
     *
     * @param cb
     */
    addListener(cb)
    {
        this.on("change", cb, "var");
    }

    /**
     * @function Variable.getValue
     * @memberof PatchVariable
     * @returns {String|Number|Boolean}
     */
    getValue()
    {
        return this._v;
    }

    /**
     * @function getName
     * @memberof PatchVariable
     * @instance
     * @returns {String|Number|Boolean}
     * @function
     */
    getName()
    {
        return this._name;
    }

    /**
     * @function setValue
     * @memberof PatchVariable
     * @instance
     * @param v
     * @returns {any}
     * @function
     */
    setValue(v)
    {
        this._v = v;
        this.emitEvent("change", v, this);
    }
}

;// CONCATENATED MODULE: ./src/core/core_patch.js











/** @global CABLES.OPS  */

/**
 * @typedef {import("./core_op.js").OpUiAttribs} OpUiAttribs
 */

/**
 * @typedef PatchConfig
 * @property {String} [prefixAssetPath=''] prefix for path to assets
 * @property {String} [assetPath=''] path to assets
 * @property {String} [jsPath=''] path to javascript files
 * @property {String} [glCanvasId='glcanvas'] dom element id of canvas element
 * @property {Function} [onError=null] called when an error occurs
 * @property {Function} [onFinishedLoading=null] called when patch finished loading all assets
 * @property {Function} [onFirstFrameRendered=null] called when patch rendered it's first frame
 * @property {Boolean} [glCanvasResizeToWindow=false] resize canvas automatically to window size
 * @property {Boolean} [glCanvasResizeToParent] resize canvas automatically to parent element
 * @property {Boolean} [doRequestAnimation=true] do requestAnimationFrame set to false if you want to trigger exec() from outside (only do if you know what you are doing)
 * @property {Boolean} [clearCanvasColor=true] clear canvas in transparent color every frame
 * @property {Boolean} [clearCanvasDepth=true] clear depth every frame
 * @property {Boolean} [glValidateShader=true] enable/disable validation of shaders *
 * @property {Boolean} [silent=false]
 * @property {Number} [fpsLimit=0] 0 for maximum possible frames per second
 * @property {String} [glslPrecision='mediump'] default precision for glsl shader
 * @property {String} [prefixJsPath]
 * @property {Function} [onPatchLoaded]
 * @property {Object} [canvas]
 * @property {Object} [patch]
 * @property {String} [patchFile]
 * @property {String} [subPatch] internal use
 * @property {Number} [masterVolume] 0 for maximum possible frames per second
 * @property {HTMLCanvasElement} [glCanvas]
*/

/**
 * @typedef CoreOp
 * @type Op
 */

/**
 * @template {CoreOp} Op
 *
 * Patch class, contains all operators,values,links etc. manages loading and running of the whole patch
 *
 * see {@link PatchConfig}
 *
 * @example
 * CABLES.patch=new CABLES.Patch(
 * {
 *     patch:pStr,
 *     glCanvasId:'glcanvas',
 *     glCanvasResizeToWindow:true,
 *     canvas:{powerPreference:"high-performance"},
 *     prefixAssetPath:'/assets/',
 *     prefixJsPath:'/js/',
 *     onError:function(e){console.log(e);}
 *     glslPrecision:'highp'
 * });
 */
class Patch extends eventtarget/* default */.A
{
    static EVENT_OP_DELETED = "onOpDelete";
    static EVENT_OP_ADDED = "onOpAdd";
    static EVENT_PAUSE = "pause";
    static EVENT_RESUME = "resume";
    static EVENT_PATCHLOADEND = "patchLoadEnd";
    static EVENT_VARIABLES_CHANGED = "variablesChanged";
    static EVENT_RENDER_FRAME = "onRenderFrame";
    static EVENT_RENDERED_ONE_FRAME = "renderedOneFrame";
    static EVENT_LINK = "onLink";
    static EVENT_VALUESSET = "loadedValueSet";

    #renderOneFrame = false;
    #initialDeserialize = true;

    /** @param {PatchConfig} cfg */
    constructor(cfg)
    {
        super();

        this._log = new logger/* default */.A("core_patch", { "onError": cfg.onError });

        /** @type {Array<Op>} */
        this.ops = [];
        this.settings = {};

        /** @type {PatchConfig} */
        this.config = cfg ||
        {
            "glCanvasResizeToWindow": false,
            "prefixAssetPath": "",
            "prefixJsPath": "",
            "silent": true,
            "onError": null,
            "onFinishedLoading": null,
            "onFirstFrameRendered": null,
            "onPatchLoaded": null,
            "fpsLimit": 0,

        };

        this.timer = new timer/* Timer */.M4();
        this.freeTimer = new timer/* Timer */.M4();
        this.animFrameOps = [];
        this.animFrameCallbacks = [];
        this.gui = false;
        CABLES.logSilent = this.silent = true;
        this.profiler = null;
        this.aborted = false;
        this._crashedOps = [];

        this._animReq = null;
        this._opIdCache = {};
        this._triggerStack = [];
        this.storeObjNames = false; // remove after may release

        /** @type {LoadingStatus} */
        this.loading = new LoadingStatus(this);

        this._volumeListeners = [];
        this._paused = false;
        this._frameNum = 0;
        this.onOneFrameRendered = null;
        this.namedTriggers = {};

        this._origData = null;
        this._frameNext = 0;
        this._frameInterval = 0;
        this._lastFrameTime = 0;
        this._frameWasdelayed = true;
        this.tempData = this.frameStore = {};
        this.reqAnimTimeStamp = 0;

        this.cgCanvas = null;

        if (!(function () { return !this; }())) console.log("not in strict mode: core patch");

        if (this.config.hasOwnProperty("silent")) this.silent = CABLES.logSilent = this.config.silent;
        if (!this.config.hasOwnProperty("doRequestAnimation")) this.config.doRequestAnimation = true;

        if (!this.config.prefixAssetPath) this.config.prefixAssetPath = "";
        if (!this.config.prefixJsPath) this.config.prefixJsPath = "";
        if (!this.config.masterVolume) this.config.masterVolume = 1.0;

        this._variables = {};

        this.vars = {};
        if (cfg && cfg.vars) this.vars = cfg.vars; // vars is old!

        this.cgl = new cgl/* CGL */.Rq.Context(this);
        this.cgp = null;

        this._subpatchOpCache = {};

        this.cgl.setCanvas(this.config.glCanvasId || this.config.glCanvas || "glcanvas");
        if (this.config.glCanvasResizeToWindow === true) this.cgl.setAutoResize("window");
        if (this.config.glCanvasResizeToParent === true) this.cgl.setAutoResize("parent");
        this.loading.setOnFinishedLoading(this.config.onFinishedLoading);

        if (this.cgl.aborted) this.aborted = true;
        if (this.cgl.silent) this.silent = true;

        if (!CABLES.OPS)
        {
            this.aborted = true;
            throw new Error("no CABLES.OPS found");
        }
        this.freeTimer.play();
        this.exec();

        if (!this.aborted)
        {
            if (this.config.patch)
            {
                this.deSerialize(this.config.patch);
            }
            else if (this.config.patchFile)
            {
                (0,utils.ajax)(
                    this.config.patchFile,
                    (err, _data) =>
                    {
                        try
                        {
                            const data = JSON.parse(_data);
                            if (err)
                            {
                                const txt = "";
                                this._log.error("err", err);
                                this._log.error("data", data);
                                this._log.error("data", data.msg);
                                return;
                            }
                            this.deSerialize(data);
                        }
                        catch (e)
                        {
                            this._log.error("could not load/parse patch ", e);
                        }
                    }
                );
            }
            this.timer.play();
        }

        console.log("made with https://cables.gl"); // eslint-disable-line
        this.cg = undefined;

    }

    isPlaying()
    {
        return !this._paused;
    }

    /** @deprecated */
    renderOneFrame()
    {
        this._paused = true;
        this._renderOneFrame = true;
        this.exec();
        this._renderOneFrame = false;
    }

    /**
     * returns true if patch is opened in editor/gui mode
     * @function isEditorMode
     * @memberof Patch
     * @instance
     * @return {Boolean} editor mode
     */
    isEditorMode()
    {
        return this.config.editorMode === true;
    }

    /**
     * pauses patch execution
     * @function pause
     * @memberof Patch
     * @instance
     */
    pause()
    {
        cancelAnimationFrame(this._animReq);
        this.emitEvent(Patch.EVENT_PAUSE);
        this._animReq = null;
        this._paused = true;
        this.freeTimer.pause();
    }

    /**
     * resumes patch execution
     * @function resume
     * @memberof Patch
     * @instance
     */
    resume()
    {
        if (this._paused)
        {
            cancelAnimationFrame(this._animReq);
            this._paused = false;
            this.freeTimer.play();
            this.emitEvent(Patch.EVENT_RESUME);
            this.exec();
        }
    }

    /**
     * set volume [0-1]
     * @function setVolume
     * @param {Number} v volume
     * @memberof Patch
     * @instance
     */
    setVolume(v)
    {
        this.config.masterVolume = v;
        for (let i = 0; i < this._volumeListeners.length; i++) this._volumeListeners[i].onMasterVolumeChanged(v);
    }

    /**
     * get asset path
     * @function getAssetPath
     * @memberof Patch
     * @param patchId
     * @instance
     */
    getAssetPath(patchId = null)
    {
        if (this.config.hasOwnProperty("assetPath"))
        {
            return this.config.assetPath;
        }
        else if (this.isEditorMode())
        {
            let id = patchId || gui.project()._id;
            return "/assets/" + id + "/";
        }
        else if (document.location.href.indexOf("cables.gl") > 0 || document.location.href.indexOf("cables.local") > 0)
        {
            const parts = document.location.pathname.split("/");
            let id = patchId || parts[parts.length - 1];
            return "/assets/" + id + "/";
        }
        else
        {
            return "assets/";
        }
    }

    /**
     * get js path
     * @function getJsPath
     * @memberof Patch
     * @instance
     */
    getJsPath()
    {
        if (this.config.hasOwnProperty("jsPath"))
        {
            return this.config.jsPath;
        }
        else
        {
            return "js/";
        }
    }

    /**
     * get url/filepath for a filename
     * this uses prefixAssetpath in exported patches
     * @function getFilePath
     * @memberof Patch
     * @instance
     * @param {String} filename
     * @return {String} url
     */
    getFilePath(filename)
    {
        if (!filename) return filename;
        filename = String(filename);
        if (filename.indexOf("https:") === 0 || filename.indexOf("http:") === 0) return filename;
        if (filename.indexOf("data:") === 0) return filename;
        if (filename.indexOf("file:") === 0) return filename;
        filename = filename.replace("//", "/");
        if (filename.startsWith(this.config.prefixAssetPath)) filename = filename.replace(this.config.prefixAssetPath, "");
        return this.config.prefixAssetPath + filename + (this.config.suffixAssetPath || ""); //
    }

    clear()
    {
        this.emitEvent("patchClearStart");
        this.cgl.TextureEffectMesh = null;
        this.animFrameOps.length = 0;
        this.timer = new timer/* Timer */.M4();
        while (this.ops.length > 0) this.deleteOp(this.ops[0].id);

        this._opIdCache = {};
        this.emitEvent("patchClearEnd");
    }

    /**
     * @param {string} identifier
     * @param {string} id
     * @param {string} [opName]
     * @returns {Op}
     */
    createOp(identifier, id, opName = null)
    {

        /**
         * @type {Op}
         */
        let op = null;
        let objName = "";

        try
        {
            if (!identifier)
            {
                console.error("createop identifier false", identifier);
                console.log((new Error()).stack);
                return;
            }
            if (identifier.indexOf("Ops.") === -1)
            {

                /*
                 * this should be a uuid, not a namespace
                 * creating ops by id should be the default way from now on!
                 */
                const opId = identifier;

                if (CABLES.OPS[opId])
                {
                    objName = CABLES.OPS[opId].objName;
                    op = new CABLES.OPS[opId].f(this, objName, id, opId);
                    op.opId = opId;
                }
                else
                {
                    if (opName)
                    {
                        identifier = opName;
                        this._log.warn("could not find op by id: " + opId);
                    }
                    else
                    {
                        throw new Error("could not find op by id: " + opId, { "cause": "opId:" + opId });
                    }
                }
            }

            if (!op)
            {
                // fallback: create by objname!
                objName = identifier;
                const parts = identifier.split(".");
                const opObj = Patch.getOpClass(objName);

                if (!opObj)
                {
                    this.emitEvent("criticalError", { "title": "Unknown op: " + objName, "text": "Unknown op: " + objName });

                    this._log.error("unknown op: " + objName);
                    throw new Error("unknown op: " + objName);
                }
                else
                {
                    if (parts.length == 2) op = new window[parts[0]][parts[1]](this, objName, id);
                    else if (parts.length == 3) op = new window[parts[0]][parts[1]][parts[2]](this, objName, id);
                    else if (parts.length == 4) op = new window[parts[0]][parts[1]][parts[2]][parts[3]](this, objName, id);
                    else if (parts.length == 5) op = new window[parts[0]][parts[1]][parts[2]][parts[3]][parts[4]](this, objName, id);
                    else if (parts.length == 6) op = new window[parts[0]][parts[1]][parts[2]][parts[3]][parts[4]][parts[5]](this, objName, id);
                    else if (parts.length == 7) op = new window[parts[0]][parts[1]][parts[2]][parts[3]][parts[4]][parts[5]][parts[6]](this, objName, id);
                    else if (parts.length == 8) op = new window[parts[0]][parts[1]][parts[2]][parts[3]][parts[4]][parts[5]][parts[6]][parts[7]](this, objName, id);
                    else if (parts.length == 9) op = new window[parts[0]][parts[1]][parts[2]][parts[3]][parts[4]][parts[5]][parts[6]][parts[7]][parts[8]](this, objName, id);
                    else if (parts.length == 10) op = new window[parts[0]][parts[1]][parts[2]][parts[3]][parts[4]][parts[5]][parts[6]][parts[7]][parts[8]][parts[9]](this, objName, id);
                    else console.log("parts.length", parts.length);
                }

                if (op)
                {
                    op.opId = null;
                    for (const i in CABLES.OPS)
                    {
                        if (CABLES.OPS[i].objName == objName) op.opId = i;
                    }
                }
            }
        }
        catch (e)
        {
            this._crashedOps.push(objName);

            this._log.error("[instancing error] " + objName, e);

            if (!this.isEditorMode())
            {
                this._log.error("INSTANCE_ERR", "Instancing Error: " + objName, e);
                // throw new Error("instancing error 1" + objName);
            }
        }

        if (op)
        {
            op._objName = objName;
            op.patch = this;
        }
        else
        {
            this._log.log("no op was created!?", identifier, id);
        }
        return op;
    }

    /**
     * create a new op in patch
     * @function addOp
     * @memberof Patch
     * @instance
     * @param {string} opIdentifier uuid or name, e.g. Ops.Math.Sum
     * @param {OpUiAttribs} uiAttribs Attributes
     * @param {string} [id]
     * @param {boolean} [fromDeserialize]
     * @param {string} [opName] e.g. Ops.Math.Sum
     * @example
     * // add invisible op
     * patch.addOp('Ops.Math.Sum', { showUiAttribs: false });
     */
    addOp(opIdentifier, uiAttribs, id, fromDeserialize = false, opName = null)
    {
        const op = this.createOp(opIdentifier, id, opName);

        if (op)
        {
            uiAttribs = uiAttribs || {};
            if (uiAttribs.hasOwnProperty("errors")) delete uiAttribs.errors;
            if (uiAttribs.hasOwnProperty("error")) delete uiAttribs.error;
            uiAttribs.subPatch = uiAttribs.subPatch || 0;
            op.setUiAttribs(uiAttribs);
            if (op.onCreate) op.onCreate();

            if (op.hasOwnProperty("onAnimFrame")) this.addOnAnimFrame(op);
            if (op.hasOwnProperty("onMasterVolumeChanged")) this._volumeListeners.push(op);

            if (this._opIdCache[op.id])
            {
                this._log.warn("opid with id " + op.id + " already exists in patch!");
                this.deleteOp(op.id); // strange with subpatch ops: why is this needed, somehow ops get added twice ???.....
                // return;
            }

            this.ops.push(op);
            this._opIdCache[op.id] = op;

            if (this._subPatchCacheAdd) this._subPatchCacheAdd(uiAttribs.subPatch, op);
            this.emitEvent(Patch.EVENT_OP_ADDED, op, fromDeserialize);

            if (op.init) op.init();

            op.emitEvent(Op.EVENT_INIT, fromDeserialize);
        }
        else
        {
            this._log.error("addop: op could not be created: ", opIdentifier);
        }

        return op;
    }

    addOnAnimFrame(op)
    {
        for (let i = 0; i < this.animFrameOps.length; i++) if (this.animFrameOps[i] == op) { return; }

        this.animFrameOps.push(op);
    }

    removeOnAnimFrame(op)
    {
        for (let i = 0; i < this.animFrameOps.length; i++)
        {
            if (this.animFrameOps[i] == op)
            {
                this.animFrameOps.splice(i, 1);
                return;
            }
        }
    }

    addOnAnimFrameCallback(cb)
    {
        this.animFrameCallbacks.push(cb);
    }

    removeOnAnimCallback(cb)
    {
        for (let i = 0; i < this.animFrameCallbacks.length; i++)
        {
            if (this.animFrameCallbacks[i] == cb)
            {
                this.animFrameCallbacks.splice(i, 1);
                return;
            }
        }
    }

    deleteOp(opid, tryRelink, reloadingOp)
    {
        let found = false;
        for (let i = 0; i < this.ops.length; i++)
        {
            if (this.ops[i].id == opid)
            {
                const op = this.ops[i];

                /** @type {Port} */
                let reLinkP1 = null;

                /** @type {Port} */
                let reLinkP2 = null;

                if (op)
                {
                    found = true;
                    if (tryRelink)
                    {
                        if (op.portsIn.length > 0 && op.portsIn[0].isLinked() && (op.portsOut.length > 0 && op.portsOut[0].isLinked()))
                        {
                            if (op.portsIn[0].getType() == op.portsOut[0].getType() && op.portsIn[0].links[0])
                            {
                                reLinkP1 = op.portsIn[0].links[0].getOtherPort(op.portsIn[0]);
                                reLinkP2 = op.portsOut[0].links[0].getOtherPort(op.portsOut[0]);
                            }
                        }
                    }

                    const opToDelete = this.ops[i];
                    opToDelete.removeLinks();

                    this.ops.splice(i, 1);
                    opToDelete.emitEvent("delete", opToDelete);
                    this.emitEvent(Patch.EVENT_OP_DELETED, opToDelete, reloadingOp);

                    if (this.clearSubPatchCache) this.clearSubPatchCache(opToDelete.uiAttribs.subPatch);

                    if (opToDelete.onDelete) opToDelete.onDelete(reloadingOp);
                    opToDelete.cleanUp();

                    if (reLinkP1 !== null && reLinkP2 !== null)
                    {
                        this.link(reLinkP1.op, reLinkP1.getName(), reLinkP2.op, reLinkP2.getName());
                    }

                    delete this._opIdCache[opid];
                    break;
                }
            }
        }

        if (!found) this._log.warn("core patch deleteop: not found...", opid);
    }

    getFrameNum()
    {
        return this._frameNum;
    }

    emitOnAnimFrameEvent(time, delta)
    {
        time = time || this.timer.getTime();

        for (let i = 0; i < this.animFrameCallbacks.length; ++i)
            if (this.animFrameCallbacks[i])
                this.animFrameCallbacks[i](time, this._frameNum, delta);

        for (let i = 0; i < this.animFrameOps.length; ++i)
            if (this.animFrameOps[i].onAnimFrame)
                this.animFrameOps[i].onAnimFrame(time, this._frameNum, delta);
    }

    renderFrame(timestamp)
    {
        this.timer.update(this.reqAnimTimeStamp);
        this.freeTimer.update(this.reqAnimTimeStamp);
        const time = this.timer.getTime();
        const startTime = performance.now();
        this.cgl.frameStartTime = this.timer.getTime();

        const delta = timestamp - this.reqAnimTimeStamp || timestamp;

        this.emitOnAnimFrameEvent(null, delta);

        this.cgl.profileData.profileFrameDelta = delta;
        this.reqAnimTimeStamp = timestamp;
        this.cgl.profileData.profileOnAnimFrameOps = performance.now() - startTime;

        this.emitEvent(Patch.EVENT_RENDER_FRAME, time);

        this._frameNum++;
        if (this._frameNum == 1)
        {
            if (this.config.onFirstFrameRendered) this.config.onFirstFrameRendered();
        }
    }

    /**
     * @param {number} [timestamp]
     */
    exec(timestamp)
    {
        if (!this.#renderOneFrame && (this._paused || this.aborted)) return;
        this.emitEvent("reqAnimFrame");
        cancelAnimationFrame(this._animReq);

        this.config.fpsLimit = this.config.fpsLimit || 0;
        if (this.config.fpsLimit)
        {
            this._frameInterval = 1000 / this.config.fpsLimit;
        }

        const now = CABLES.now();
        const frameDelta = now - this._frameNext;

        if (this.isEditorMode())
        {
            if (!this.#renderOneFrame)
            {
                if (now - this._lastFrameTime >= 500 && this._lastFrameTime !== 0 && !this._frameWasdelayed)
                {
                    this._lastFrameTime = 0;
                    setTimeout(this.exec.bind(this), 500);
                    this.emitEvent("renderDelayStart");
                    this._frameWasdelayed = true;
                    return;
                }
            }
        }

        if (this.#renderOneFrame || this.config.fpsLimit === 0 || frameDelta > this._frameInterval || this._frameWasdelayed)
        {
            this.renderFrame(timestamp);

            if (this._frameInterval) this._frameNext = now - (frameDelta % this._frameInterval);
        }

        if (this._frameWasdelayed)
        {
            this.emitEvent("renderDelayEnd");
            this._frameWasdelayed = false;
        }

        if (this.#renderOneFrame)
        {
            if (this.onOneFrameRendered) this.onOneFrameRendered(); // todo remove everywhere and use propper event...
            this.emitEvent(Patch.EVENT_RENDERED_ONE_FRAME);
            this._renderOneFrame = false;
        }

        if (this.config.doRequestAnimation) this._animReq = this.cgl.canvas.ownerDocument.defaultView.requestAnimationFrame(this.exec.bind(this));
    }

    /**
     * link two ops/ports
     * @function link
     * @memberof Patch
     * @instance
     * @param {Op} op1
     * @param {String} port1Name
     * @param {Op} op2
     * @param {String} port2Name
     * @param {boolean} lowerCase
     * @param {boolean} fromDeserialize
     */
    link(op1, port1Name, op2, port2Name, lowerCase = false, fromDeserialize = false)
    {
        if (!op1) return this._log.warn("link: op1 is null ");
        if (!op2) return this._log.warn("link: op2 is null");

        const port1 = op1.getPort(port1Name, lowerCase);
        const port2 = op2.getPort(port2Name, lowerCase);

        if (!port1) return this._log.warn("port1 not found! " + port1Name + " (" + op1.objName + ")");
        if (!port2) return this._log.warn("port2 not found! " + port2Name + " of " + op2.name + "(" + op2.objName + ")", op2);

        if (!port1.shouldLink(port1, port2) || !port2.shouldLink(port1, port2)) return false;

        if (Link.canLink(port1, port2))
        {
            const link = new Link(this);
            link.link(port1, port2);

            this.emitEvent(Patch.EVENT_LINK, port1, port2, link, fromDeserialize);
            return link;
        }
    }

    /**
     * @param {Object} options
     * @returns {Object|String}
     */
    serialize(options)
    {
        const obj = {};

        options = options || {};
        obj.ops = [];
        obj.settings = this.settings;
        for (let i = 0; i < this.ops.length; i++)
        {
            const op = this.ops[i];
            if (op && op.getSerialized)obj.ops.push(op.getSerialized());
        }

        (0,utils.cleanJson)(obj);

        if (options.asObject) return obj;
        return JSON.stringify(obj);
    }

    getOpsByRefId(refId) // needed for instancing ops ?
    {
        const perf = gui.uiProfiler.start("[corepatchetend] getOpsByRefId");
        const refOps = [];
        const ops = gui.corePatch().ops;
        for (let i = 0; i < ops.length; i++)
            if (ops[i].storage && ops[i].storage.ref == refId) refOps.push(ops[i]);
        perf.finish();
        return refOps;
    }

    /**
     * @param {String} opid
     * @returns {Op}
     */
    getOpById(opid)
    {
        return this._opIdCache[opid];
    }

    /**
     * @param {String} name
     */
    getOpsByObjName(name)
    {
        const arr = [];
        // for (const i in this.ops
        for (let i = 0; i < this.ops.length; i++)
            if (this.ops[i].objName == name) arr.push(this.ops[i]);
        return arr;
    }

    /**
     * @param {String} opid
     */
    getOpsByOpId(opid)
    {
        const arr = [];
        // for (const i in this.ops)
        for (let i = 0; i < this.ops.length; i++)
            if (this.ops[i].opId == opid) arr.push(this.ops[i]);
        return arr;
    }

    getSubPatchOpsByName(patchId, objName)
    {
        const arr = [];
        // for (const i in this.ops)
        for (let i = 0; i < this.ops.length; i++)
            if (this.ops[i].uiAttribs && this.ops[i].uiAttribs.subPatch == patchId && this.ops[i].objName == objName)
                arr.push(this.ops[i]);

        return arr;
    }

    getSubPatchOp(patchId, objName)
    {
        return this.getFirstSubPatchOpByName(patchId, objName);
    }

    /**
     * @param {string} patchId
     * @param {string} objName
     * @returns {Op}
     */
    getFirstSubPatchOpByName(patchId, objName)
    {
        for (let i = 0; i < this.ops.length; i++)
            if (this.ops[i].uiAttribs && this.ops[i].uiAttribs.subPatch == patchId && this.ops[i].objName == objName)
                return this.ops[i];

        return null;
    }

    _addLink(opinid, opoutid, inName, outName)
    {
        return this.link(this.getOpById(opinid), inName, this.getOpById(opoutid), outName, false, true);
    }

    /**
     * @param {String} s
     */
    logStartup(s)
    {
        if (window.logStartup)window.logStartup(s);
    }

    /**
     * @typedef DeserializeOptions
     * @property {boolean} [genIds]
     * @property {boolean} [createRef]
     */

    /**
     * Description
     * @param {Object} obj
     * @param {DeserializeOptions} options
     * @returns {any}
     */
    deSerialize(obj, options = { "genIds": false, "createRef": false })
    {
        if (this.aborted) return;
        const newOps = [];
        const loadingId = this.loading.start("core", "deserialize");

        if (typeof obj === "string") obj = JSON.parse(obj);

        if (this.#initialDeserialize)
        {
            this.#initialDeserialize = false;
            this.namespace = obj.namespace || "";
            this.name = obj.name || "";
            this.settings = obj.settings;
        }

        this.emitEvent("patchLoadStart");

        obj.ops = obj.ops || [];

        this.logStartup("add " + obj.ops.length + " ops... ");

        const addedOps = [];

        // add ops...
        for (let iop = 0; iop < obj.ops.length; iop++)
        {
            const start = CABLES.now();
            const opData = obj.ops[iop];
            let op = null;

            try
            {
                if (opData.opId) op = this.addOp(opData.opId, opData.uiAttribs, opData.id, true, opData.objName);
                else op = this.addOp(opData.objName, opData.uiAttribs, opData.id, true);
            }
            catch (e)
            {
                this._log.error("[instancing error] op data:", opData, e);
                // throw new Error("could not create op by id: <b>" + (opData.objName || opData.opId) + "</b> (" + opData.id + ")");
            }

            if (op)
            {
                addedOps.push(op);
                if (options.genIds) op.id = (0,utils.shortId)();
                op.portsInData = opData.portsIn;
                op._origData = JSON.parse(JSON.stringify(opData));
                op.storage = opData.storage;
                // if (opData.hasOwnProperty("disabled"))op.setEnabled(!opData.disabled);

                // for (const ipi in opData.portsIn)
                if (opData.portsIn)
                    for (let ipi = 0; ipi < opData.portsIn.length; ipi++)
                    {
                        const objPort = opData.portsIn[ipi];
                        if (objPort && objPort.hasOwnProperty("name"))
                        {
                            const port = op.getPort(objPort.name);

                            if (port && (port.uiAttribs.display == "bool" || port.uiAttribs.type == "bool") && !isNaN(objPort.value)) objPort.value = objPort.value == true ? 1 : 0;
                            if (port && objPort.value !== undefined && port.type != core_port/* Port */.I.TYPE_TEXTURE) port.set(objPort.value);

                            if (port)
                            {
                                port.deSerializeSettings(objPort);
                            }
                            else
                            {

                                /*
                             * if (port.uiAttribs.hasOwnProperty("title"))
                             * {
                             *     op.preservedPortTitles = op.preservedPortTitles || {};
                             *     op.preservedPortTitles[port.name] = port.uiAttribs.title;
                             * }
                             */
                                op.preservedPortValues = op.preservedPortValues || {};
                                op.preservedPortValues[objPort.name] = objPort.value;
                            }
                        }
                    }

                // for (const ipo in opData.portsOut)
                if (opData.portsOut)
                    for (let ipo = 0; ipo < opData.portsOut.length; ipo++)
                    {
                        const objPort = opData.portsOut[ipo];
                        if (objPort && objPort.hasOwnProperty("name"))
                        {
                            const port2 = op.getPort(objPort.name);

                            if (port2)
                            {
                                port2.deSerializeSettings(objPort);

                                if (port2.uiAttribs.hasOwnProperty("title"))
                                {
                                    op.preservedPortTitles = op.preservedPortTitles || {};
                                    op.preservedPortTitles[port2.name] = port2.uiAttribs.title;
                                }

                                if (port2.type != core_port/* Port */.I.TYPE_TEXTURE && objPort.hasOwnProperty("value"))
                                    port2.set(obj.ops[iop].portsOut[ipo].value);

                                if (objPort.expose) port2.setUiAttribs({ "expose": true });
                            }
                        }
                    }
                newOps.push(op);
            }

            const timeused = Math.round(100 * (CABLES.now() - start)) / 100;
            if (!this.silent && timeused > 5) console.log("long op init ", obj.ops[iop].objName, timeused);
        }
        this.logStartup("add ops done");

        // for (const i in this.ops)
        for (let i = 0; i < this.ops.length; i++)
        {
            // deprecated use event
            if (this.ops[i].onLoadedValueSet)
            {
                this.ops[i].onLoadedValueSet(this.ops[i]._origData);
                this.ops[i].onLoadedValueSet = null;
                this.ops[i]._origData = null;
            }

            // this is only emited when the patch is loaded from serializid data, e.g. loading from api
            // NOT when op is created by hand!
            this.ops[i].emitEvent(Patch.EVENT_VALUESSET);
        }

        this.logStartup("creating links");

        if (options.opsCreated)options.opsCreated(addedOps);
        // create links...
        if (obj.ops)
        {
            for (let iop = 0; iop < obj.ops.length; iop++)
            {
                if (obj.ops[iop].portsIn)
                {
                    for (let ipi2 = 0; ipi2 < obj.ops[iop].portsIn.length; ipi2++)
                    {
                        if (obj.ops[iop].portsIn[ipi2] && obj.ops[iop].portsIn[ipi2].links)
                        {
                            for (let ili = 0; ili < obj.ops[iop].portsIn[ipi2].links.length; ili++)
                            {
                                this._addLink(
                                    obj.ops[iop].portsIn[ipi2].links[ili].objIn,
                                    obj.ops[iop].portsIn[ipi2].links[ili].objOut,
                                    obj.ops[iop].portsIn[ipi2].links[ili].portIn,
                                    obj.ops[iop].portsIn[ipi2].links[ili].portOut);

                                /*
                                 * const took = performance.now - startTime;
                                 * if (took > 100)console.log(obj().ops[iop].portsIn[ipi2].links[ili].objIn, obj.ops[iop].portsIn[ipi2].links[ili].objOut, took);
                                 */
                            }
                        }
                    }
                }
                if (obj.ops[iop].portsOut)
                    for (let ipi2 = 0; ipi2 < obj.ops[iop].portsOut.length; ipi2++)
                        if (obj.ops[iop].portsOut[ipi2] && obj.ops[iop].portsOut[ipi2].links)
                        {
                            for (let ili = 0; ili < obj.ops[iop].portsOut[ipi2].links.length; ili++)
                            {
                                if (obj.ops[iop].portsOut[ipi2].links[ili])
                                {
                                    if (obj.ops[iop].portsOut[ipi2].links[ili].subOpRef)
                                    {
                                        // lost link
                                        const outOp = this.getOpById(obj.ops[iop].portsOut[ipi2].links[ili].objOut);
                                        let dstOp = null;
                                        let theSubPatch = 0;

                                        for (let i = 0; i < this.ops.length; i++)
                                        {
                                            if (
                                                this.ops[i].storage &&
                                                this.ops[i].storage.ref == obj.ops[iop].portsOut[ipi2].links[ili].subOpRef &&
                                                outOp.uiAttribs.subPatch == this.ops[i].uiAttribs.subPatch
                                            )
                                            {
                                                theSubPatch = this.ops[i].patchId.get();
                                                break;
                                            }
                                        }

                                        for (let i = 0; i < this.ops.length; i++)
                                        {
                                            if (
                                                this.ops[i].storage &&
                                                this.ops[i].storage.ref == obj.ops[iop].portsOut[ipi2].links[ili].refOp &&
                                                this.ops[i].uiAttribs.subPatch == theSubPatch)
                                            {
                                                dstOp = this.ops[i];
                                                break;
                                            }
                                        }

                                        if (!dstOp) this._log.warn("could not find op for lost link");
                                        else
                                        {
                                            this._addLink(
                                                dstOp.id,
                                                obj.ops[iop].portsOut[ipi2].links[ili].objOut,

                                                obj.ops[iop].portsOut[ipi2].links[ili].portIn,
                                                obj.ops[iop].portsOut[ipi2].links[ili].portOut);
                                        }
                                    }
                                    else
                                    {
                                        const l = this._addLink(obj.ops[iop].portsOut[ipi2].links[ili].objIn, obj.ops[iop].portsOut[ipi2].links[ili].objOut, obj.ops[iop].portsOut[ipi2].links[ili].portIn, obj.ops[iop].portsOut[ipi2].links[ili].portOut);

                                        if (!l)
                                        {
                                            const op1 = this.getOpById(obj.ops[iop].portsOut[ipi2].links[ili].objIn);
                                            const op2 = this.getOpById(obj.ops[iop].portsOut[ipi2].links[ili].objOut);

                                            if (!op1)console.log("could not find link op1");
                                            if (!op2)console.log("could not find link op2");

                                            const p1Name = obj.ops[iop].portsOut[ipi2].links[ili].portIn;

                                            if (op1 && !op1.getPort(p1Name))
                                            {
                                                // console.log("PRESERVE port 1 not found", p1Name);

                                                op1.preservedPortLinks[p1Name] = op1.preservedPortLinks[p1Name] || [];
                                                op1.preservedPortLinks[p1Name].push(obj.ops[iop].portsOut[ipi2].links[ili]);
                                            }

                                            const p2Name = obj.ops[iop].portsOut[ipi2].links[ili].portOut;
                                            if (op2 && !op2.getPort(p2Name))
                                            {
                                                // console.log("PRESERVE port 2 not found", obj.ops[iop].portsOut[ipi2].links[ili].portOut);
                                                op2.preservedPortLinks[p1Name] = op2.preservedPortLinks[p1Name] || [];
                                                op2.preservedPortLinks[p1Name].push(obj.ops[iop].portsOut[ipi2].links[ili]);
                                            }
                                        }
                                    }
                                }
                            }
                        }
            }
        }

        this.logStartup("calling ops onloaded");

        // for (const i in this.ops)
        for (let i = 0; i < this.ops.length; i++)
        {
            if (this.ops[i].onLoaded)
            {
                // TODO: deprecated - use even
                this.ops[i].onLoaded();
                this.ops[i].onLoaded = null;
            }
        }

        this.logStartup("initializing ops...");
        for (let i = 0; i < this.ops.length; i++)
        // for (const i in this.ops)
        {
            if (this.ops[i].init)
            {
                try
                {
                    this.ops[i].init();
                    this.ops[i].init = null;
                }
                catch (e)
                {
                    console.error("op.init crash", e);
                }
            }
        }

        this.logStartup("initializing vars...");

        if (this.config.variables)
            for (const varName in this.config.variables)
                this.setVarValue(varName, this.config.variables[varName]);

        this.logStartup("initializing var ports");

        // for (const i in this.ops)
        for (let i = 0; i < this.ops.length; i++)
        {
            this.ops[i].initVarPorts();
            delete this.ops[i].uiAttribs.pasted;
        }

        setTimeout(() => { this.loading.finished(loadingId); }, 100);

        if (this.config.onPatchLoaded) this.config.onPatchLoaded(this);

        this.emitEvent(Patch.EVENT_PATCHLOADEND, newOps, obj, options.genIds);
    }

    profile(enable)
    {
        this.profiler = new Profiler(this);
        // for (const i in this.ops)
        for (let i = 0; i < this.ops.length; i++)
            this.ops[i].profile();
    }

    // ----------------------

    /**
     * set variable value
     * @function setVariable
     * @memberof Patch
     * @instance
     * @param {String} name of variable
     * @param {Number|String|Boolean} val value
     */
    setVariable(name, val)
    {
        if (this._variables[name] !== undefined)
        {
            this._variables[name].setValue(val);
        }
        else
        {
            this._log.warn("variable " + name + " not found!");
        }
    }

    _sortVars()
    {
        if (!this.isEditorMode()) return;
        const ordered = {};
        Object.keys(this._variables).sort(
            (a, b) =>
            { return a.localeCompare(b, "en", { "sensitivity": "base" }); }
        ).forEach((key) =>
        {
            ordered[key] = this._variables[key];
        });
        this._variables = ordered;
    }

    /**
     * has variable
     * @function hasVariable
     * @memberof Patch
     * @instance
     * @param {String} name of variable
     */
    hasVar(name)
    {
        return this._variables[name] !== undefined;
    }

    // used internally
    setVarValue(name, val, type)
    {
        if (this.hasVar(name))
        {
            this._variables[name].setValue(val);
        }
        else
        {
            this._variables[name] = new PatchVariable(name, val, type);
            this._sortVars();
            this.emitEvent(Patch.EVENT_VARIABLES_CHANGED);
        }
        return this._variables[name];
    }

    // old?
    getVarValue(name, val)
    {
        if (this._variables.hasOwnProperty(name)) return this._variables[name].getValue();
    }

    /**
     * @function getVar
     * @memberof Patch
     * @instance
     * @param {String} name
     * @return {PatchVariable} variable
     */
    getVar(name)
    {
        if (this._variables.hasOwnProperty(name)) return this._variables[name];
    }

    deleteVar(name)
    {
        for (let i = 0; i < this.ops.length; i++)
            for (let j = 0; j < this.ops[i].portsIn.length; j++)
                if (this.ops[i].portsIn[j].getVariableName() == name)
                    this.ops[i].portsIn[j].setVariable(null);

        delete this._variables[name];
        this.emitEvent("variableDeleted", name);
        this.emitEvent("variablesChanged");
    }

    /**
     * @param {number} t
     * @returns {Object}
     */
    getVars(t)
    {
        if (t === undefined) return this._variables;
        if (t === 1) return {};

        const perf = gui.uiProfiler.start("[corepatchetend] getVars");

        const vars = [];
        let tStr = "";
        if (t == core_port/* Port */.I.TYPE_STRING) tStr = "string";
        else if (t == core_port/* Port */.I.TYPE_VALUE) tStr = "number";
        else if (t == core_port/* Port */.I.TYPE_ARRAY) tStr = "array";
        else if (t == core_port/* Port */.I.TYPE_OBJECT) tStr = "object";
        else if (t == core_port/* Port */.I.TYPE_DYNAMIC) tStr = "dynamic";
        else
        {
            console.log("unknown port type", t);
            console.log(new Error().stack);
        }

        for (const i in this._variables)
        {
            if (!this._variables[i].type || this._variables[i].type == tStr || this._variables[i].type == t) vars.push(this._variables[i]);
        }

        perf.finish();

        return vars;
    }

    // getVars(t)
    // {
    //     if (t === undefined) return this._variables;

    //     const vars = [];
    //     let tStr = "";
    //     if (t == Port.TYPE_STRING) tStr = "string";
    //     if (t == Port.TYPE_VALUE) tStr = "number";
    //     if (t == Port.TYPE_ARRAY) tStr = "array";
    //     if (t == Port.TYPE_OBJECT) tStr = "object";

    //     for (const i in this._variables)
    //     {
    //         if (!this._variables[i].type || this._variables[i].type == tStr || this._variables[i].type == t) vars.push(this._variables[i]);
    //     }
    //     return vars;
    // }

    /**
     * @function preRenderOps
     * @memberof Patch
     * @instance
     * @description invoke pre rendering of ops
     * @function
     */
    preRenderOps()
    {
        this._log.log("prerendering...");

        for (let i = 0; i < this.ops.length; i++)
        {
            if (this.ops[i].preRender)
            {
                this.ops[i].preRender();
                this._log.log("prerender " + this.ops[i].objName);
            }
        }
    }

    /**
     * @function dispose
     * @memberof Patch
     * @instance
     * @description stop, dispose and cleanup patch
     */
    dispose()
    {
        this.pause();
        this.clear();
        this.cgl.dispose();
    }

    pushTriggerStack(p)
    {
        this._triggerStack.push(p);
    }

    popTriggerStack()
    {
        this._triggerStack.pop();
    }

    printTriggerStack()
    {
        if (this._triggerStack.length == 0)
        {
            // console.log("stack length", this._triggerStack.length); // eslint-disable-line
            return;
        }
        console.groupCollapsed( // eslint-disable-line
            "trigger port stack " + this._triggerStack[this._triggerStack.length - 1].op.objName + "." + this._triggerStack[this._triggerStack.length - 1].name,
        );

        const rows = [];
        for (let i = 0; i < this._triggerStack.length; i++)
        {
            rows.push(i + ". " + this._triggerStack[i].op.objName + " " + this._triggerStack[i].name);
        }

        console.table(rows); // eslint-disable-line
        console.groupEnd(); // eslint-disable-line
    }

    /**
     * returns document object of the patch could be != global document object when opening canvas ina popout window
     * @function getDocument
     * @memberof Patch
     * @instance
     * @return {Object} document
     */
    getDocument()
    {
        return this.cgl.canvas.ownerDocument;
    }
}

Patch.getOpClass = function (objName)
{
    const parts = objName.split(".");
    let opObj = null;

    try
    {
        if (parts.length == 2) opObj = window[parts[0]][parts[1]];
        else if (parts.length == 3) opObj = window[parts[0]][parts[1]][parts[2]];
        else if (parts.length == 4) opObj = window[parts[0]][parts[1]][parts[2]][parts[3]];
        else if (parts.length == 5) opObj = window[parts[0]][parts[1]][parts[2]][parts[3]][parts[4]];
        else if (parts.length == 6) opObj = window[parts[0]][parts[1]][parts[2]][parts[3]][parts[4]][parts[5]];
        else if (parts.length == 7) opObj = window[parts[0]][parts[1]][parts[2]][parts[3]][parts[4]][parts[5]][parts[6]];
        else if (parts.length == 8) opObj = window[parts[0]][parts[1]][parts[2]][parts[3]][parts[4]][parts[5]][parts[6]][parts[7]];
        else if (parts.length == 9) opObj = window[parts[0]][parts[1]][parts[2]][parts[3]][parts[4]][parts[5]][parts[6]][parts[7]][parts[8]];
        else if (parts.length == 10) opObj = window[parts[0]][parts[1]][parts[2]][parts[3]][parts[4]][parts[5]][parts[6]][parts[7]][parts[8]][parts[9]];
        return opObj;
    }
    catch (e)
    {
        return null;
    }
};

Patch.replaceOpIds = function (json, options)
{
    const opids = {};
    for (const i in json.ops)
    {
        opids[json.ops[i].id] = json.ops[i];
    }

    for (const j in json.ops)
    {
        for (const k in json.ops[j].portsOut)
        {
            const links = json.ops[j].portsOut[k].links;
            if (links)
            {
                let l = links.length;

                while (l--)
                {
                    if (links[l] && (!opids[links[l].objIn] || !opids[links[l].objOut]))
                    {
                        if (!options.doNotUnlinkLostLinks)
                        {
                            links.splice(l, 1);
                        }
                        else
                        {
                            if (options.fixLostLinks)
                            {
                                const op = gui.corePatch().getOpById(links[l].objIn);
                                if (!op) console.log("op not found!");
                                else
                                {
                                    const outerOp = gui.patchView.getSubPatchOuterOp(op.uiAttribs.subPatch);
                                    if (outerOp)
                                    {
                                        op.storage = op.storage || {};
                                        op.storage.ref = op.storage.ref || (0,utils.shortId)();
                                        links[l].refOp = op.storage.ref;
                                        links[l].subOpRef = outerOp.storage.ref;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    for (const i in json.ops)
    {
        const op = json.ops[i];
        const oldId = op.id;
        let newId = (0,utils.shortId)();

        if (options.prefixHash) newId = (0,utils.prefixedHash)(options.prefixHash + oldId);

        else if (options.prefixId) newId = options.prefixId + oldId;
        else if (options.refAsId) // when saving json
        {
            if (op.storage && op.storage.ref)
            {
                newId = op.storage.ref;
                delete op.storage.ref;
            }
            else
            {
                op.storage = op.storage || {};
                op.storage.ref = newId = (0,utils.shortId)();
            }
        }

        const newID = op.id = newId;

        if (options.oldIdAsRef) // when loading json
        {
            op.storage = op.storage || {};
            op.storage.ref = oldId;
        }

        for (const j in json.ops)
        {
            if (json.ops[j].portsIn)
                for (const k in json.ops[j].portsIn)
                {
                    if (json.ops[j].portsIn[k].links)
                    {
                        let l = json.ops[j].portsIn[k].links.length;

                        while (l--) if (json.ops[j].portsIn[k].links[l] === null) json.ops[j].portsIn[k].links.splice(l, 1);

                        for (l in json.ops[j].portsIn[k].links)
                        {
                            if (json.ops[j].portsIn[k].links[l].objIn === oldId) json.ops[j].portsIn[k].links[l].objIn = newID;
                            if (json.ops[j].portsIn[k].links[l].objOut === oldId) json.ops[j].portsIn[k].links[l].objOut = newID;
                        }
                    }
                }

            if (json.ops[j].portsOut)
                for (const k in json.ops[j].portsOut)
                {
                    if (json.ops[j].portsOut[k].links)
                    {
                        let l = json.ops[j].portsOut[k].links.length;

                        while (l--) if (json.ops[j].portsOut[k].links[l] === null) json.ops[j].portsOut[k].links.splice(l, 1);

                        for (l in json.ops[j].portsOut[k].links)
                        {
                            if (json.ops[j].portsOut[k].links[l].objIn === oldId) json.ops[j].portsOut[k].links[l].objIn = newID;
                            if (json.ops[j].portsOut[k].links[l].objOut === oldId) json.ops[j].portsOut[k].links[l].objOut = newID;
                        }
                    }
                }
        }
    }

    // set correct subpatch
    const subpatchIds = [];
    const fixedSubPatches = [];

    for (let i = 0; i < json.ops.length; i++)
    {
        // if (CABLES.Op.isSubPatchOpName(json.ops[i].objName))
        if (json.ops[i].storage && json.ops[i].storage.subPatchVer)
        {
            // for (const k in json.ops[i].portsInckkkkk
            for (let k = 0; k < json.ops[i].portsIn.length; k++)
            {
                if (json.ops[i].portsIn[k].name === "patchId")
                {
                    let newId = (0,utils.shortId)();

                    if (options.prefixHash) newId = (0,utils.prefixedHash)(options.prefixHash + json.ops[i].portsIn[k].value);

                    const oldSubPatchId = json.ops[i].portsIn[k].value;
                    const newSubPatchId = json.ops[i].portsIn[k].value = newId;

                    subpatchIds.push(newSubPatchId);

                    for (let j = 0; j < json.ops.length; j++)
                    {
                        // op has no uiAttribs in export, we don't care about subpatches in export though
                        if (json.ops[j].uiAttribs)
                        {
                            if (json.ops[j].uiAttribs.subPatch === oldSubPatchId)
                            {
                                json.ops[j].uiAttribs.subPatch = newSubPatchId;
                                fixedSubPatches.push(json.ops[j].id);
                            }
                        }
                    }
                }
            }
        }
    }

    for (const kk in json.ops)
    {
        let found = false;
        for (let j = 0; j < fixedSubPatches.length; j++)
        {
            if (json.ops[kk].id === fixedSubPatches[j])
            {
                found = true;
                break;
            }
        }
        // op has no uiAttribs in export, we don't care about subpatches in export though
        if (!found && json.ops[kk].uiAttribs && options.parentSubPatchId != null)
            json.ops[kk].uiAttribs.subPatch = options.parentSubPatchId;
    }

    return json;
};

/**
 * remove an eventlistener
 * @instance
 * @function addEventListener
 * @param {String} name of event
 * @param {function} callback
 */

/**
 * remove an eventlistener
 * @instance
 * @function removeEventListener
 * @param {String} name of event
 * @param {function} callback
 */

/**
 * op added to patch event
 * @event onOpAdd
 *
 * @memberof Patch
 * @type {Object}
 * @property {Op} op new op
 */

/**
 * op deleted from patch
 * @event onOpDelete
 * @memberof Patch
 * @type {Object}
 * @property {Op} op that will be deleted
 */

/**
 * link event - two ports will be linked
 * @event onLink
 * @memberof Patch
 * @type {Object}
 * @property {Port} port1
 * @property {Port} port2
 */

/**
 * unlink event - a link was deleted
 * @event onUnLink
 * @memberof Patch
 * @type {Object}
 */

/**
 * variables has been changed / a variable has been added to the patch
 * @event variablesChanged
 * @memberof Patch
 * @type {Object}
 * @property {Port} port1
 * @property {Port} port2
 */

;// CONCATENATED MODULE: ./src/core/embedding.js



const EMBED = {};

/**
 * add patch into html element (will create canvas and set size to fill containerElement)
 * @name CABLES.EMBED#addPatch
 * @param {object|string} _element containerElement dom element or id of element
 * @param {Object} options patch options
 * @function
 */
EMBED.addPatch = function (_element, options)
{
    let el = _element;
    let id = (0,utils.generateUUID)();
    if (typeof _element == "string")
    {
        id = _element;
        el = document.getElementById(id);

        if (!el)
        {
            console.error(id + " Polyshape Container Element not found!");
            return;
        }
    }

    const canvEl = document.createElement("canvas");
    canvEl.id = "glcanvas_" + id;
    canvEl.width = el.clientWidth;
    canvEl.height = el.clientHeight;

    window.addEventListener(
        "resize",
        function ()
        {
            this.setAttribute("width", el.clientWidth);
            this.height = el.clientHeight;
        }.bind(canvEl),
    );

    el.appendChild(canvEl);

    options = options || {};
    options.glCanvasId = canvEl.id;

    if (!options.onError)
    {
        options.onError = function (err)
        {
            console.error(err);
        };
    }

    CABLES.patch = new Patch(options);
    return canvEl;
};



;// CONCATENATED MODULE: ./src/core/sessionvar.js
// todo: old... remove this from ops...

/**
 * todo: old... remove this from ops...
 *
 * @class
 */
const Variable = function ()
{
    let value = null;
    const changedCallbacks = [];

    this.onChanged = function (f)
    {
        changedCallbacks.push(f);
    };

    this.getValue = function ()
    {
        return value;
    };

    this.setValue = function (v)
    {
        value = v;
        this.emitChanged();
    };

    this.emitChanged = function ()
    {
        for (let i = 0; i < changedCallbacks.length; i++)
        {
            changedCallbacks[i]();
        }
    };
};



// EXTERNAL MODULE: ./src/core/anim_key.js
var anim_key = __webpack_require__(963);
;// CONCATENATED MODULE: ./src/core/index.js


















CABLES = CABLES || {};
CABLES = {
    ...CABLES,
    ...constants/* CONSTANTS */.a.PORT,
    ...constants/* CONSTANTS */.a.PACO,
    ...constants/* CONSTANTS */.a.ANIM,
    ...constants/* CONSTANTS */.a.OP
};

CABLES.EMBED = EMBED;
CABLES.Link = Link;
CABLES.Port = core_port/* Port */.I;
CABLES.Op = Op;
CABLES.Profiler = Profiler;
CABLES.Patch = Patch;
CABLES.Timer = timer/* Timer */.M4;
CABLES.Variable = Variable;
CABLES.LoadingStatus = LoadingStatus;
CABLES.now = timer/* now */.tB;
CABLES.internalNow = timer/* internalNow */.uw;
CABLES.Anim = anim/* Anim */.k;
CABLES.AnimKey = anim_key/* AnimKey */.rA;

CABLES.shortId = utils.shortId;
CABLES.uuid = utils.uuid;
CABLES.getShortOpName = utils.getShortOpName;
CABLES.simpleId = utils.simpleId;
CABLES.clamp = utils.clamp;
CABLES.map = utils.map;
CABLES.shuffleArray = utils.shuffleArray;
CABLES.generateUUID = utils.generateUUID;
CABLES.prefixedHash = utils.prefixedHash;
CABLES.smoothStep = utils.smoothStep;
CABLES.smootherStep = utils.smootherStep;
CABLES.cacheBust = utils.cacheBust;
CABLES.copyArray = utils.copyArray;
CABLES.basename = utils.basename;
CABLES.logStack = utils.logStack;
CABLES.filename = utils.filename;
CABLES.ajax = utils.ajax;
CABLES.request = utils.request;
CABLES.logErrorConsole = utils.logErrorConsole;
CABLES.isNumeric = utils.isNumeric;
CABLES.uniqueArray = utils.uniqueArray;

/** @type {Array<Op>} */
CABLES.OPS = [];
CABLES.utils = utils;
CABLES.CONSTANTS = constants/* CONSTANTS */.a;

CABLES.GLMatrix = esm_namespaceObject;
CABLES.SHARED = {};
CABLES.SHARED.Events = eventtarget/* default */.A;
CABLES.SHARED.Logger = logger/* default */.A;

/* harmony default export */ const core = (CABLES);


if (!(function () { return !this; }())) console.warn("not in strict mode: index core"); // eslint-disable-line


/***/ }),

/***/ 920:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   M4: () => (/* binding */ Timer),
/* harmony export */   tB: () => (/* binding */ now),
/* harmony export */   uw: () => (/* binding */ internalNow)
/* harmony export */ });
/* harmony import */ var cables_shared_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(125);


/**
 * @namespace CABLES
 */

const internalNow = function ()
{
    return window.performance.now();
};

/*
 * current time in milliseconds
 * @memberof CABLES
 * @function now
 * @static
 *
 */
const now = function ()
{
    return internalNow();
};

/**
 * Measuring time
 * @namespace external:CABLES#Timer
 * @hideconstructor
 * @class
 */
class Timer extends cables_shared_client__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A
{
    static EVENT_PLAY_PAUSE = "playPause";
    static EVENT_TIME_CHANGED = "timeChanged";

    constructor()
    {
        super();

        /**
         * @private
         */
        this._timeStart = internalNow();
        this._timeOffset = 0;
        this._currentTime = 0;
        this._lastTime = 0;
        this._paused = true;
        this._delay = 0;
        this.overwriteTime = -1;
    }

    _internalNow()
    {
        if (this._ts) return this._ts;
        return internalNow();
    }

    _getTime()
    {
        this._lastTime = (this._internalNow() - this._timeStart) / 1000;
        return this._lastTime + this._timeOffset;
    }

    /**
     * @param {number} d
     */
    setDelay(d)
    {
        this._delay = d;
        this.emitEvent(Timer.EVENT_TIME_CHANGED);
    }

    /**
     * @function
     * @memberof Timer
     * @instance
     * @description returns true if timer is playing
     * @return {Boolean} value
     */
    isPlaying()
    {
        return !this._paused;
    }

    /**
     * @function
     * @memberof Timer
     * @instance
     * @param {any} ts
     * @description update timer
     * @return {Number} time
     */
    update(ts)
    {
        if (ts) this._ts = ts;
        if (this._paused) return;
        this._currentTime = this._getTime();

        return this._currentTime;
    }

    /**
     * @function
     * @memberof Timer
     * @instance
     * @return {Number} time in milliseconds
     */
    getMillis()
    {
        return this.get() * 1000;
    }

    /**
     * @function
     * @memberof Timer
     * @instance
     * @return {Number} value time in seconds
     */
    get()
    {
        return this.getTime();
    }

    getTime()
    {
        if (this.overwriteTime >= 0) return this.overwriteTime - this._delay;
        return this._currentTime - this._delay;
    }

    /**
     * toggle between play/pause state
     * @function
     * @memberof Timer
     * @instance
     */
    togglePlay()
    {
        if (this._paused) this.play();
        else this.pause();
    }

    /**
     * set current time
     * @function
     * @memberof Timer
     * @instance
     * @param {Number} t
     */
    setTime(t)
    {
        if (isNaN(t) || t < 0) t = 0;
        this._timeStart = this._internalNow();
        this._timeOffset = t;
        this._currentTime = t;
        this.emitEvent((Timer.EVENT_TIME_CHANGED));
    }

    setOffset(val)
    {
        if (this._currentTime + val < 0)
        {
            this._timeStart = this._internalNow();
            this._timeOffset = 0;
            this._currentTime = 0;
        }
        else
        {
            this._timeOffset += val;
            this._currentTime = this._lastTime + this._timeOffset;
        }
        this.emitEvent(Timer.EVENT_TIME_CHANGED);
    }

    /**
     * (re)starts the timer
     * @function
     * @memberof Timer
     * @instance
     */
    play()
    {
        this._timeStart = this._internalNow();
        this._paused = false;
        this.emitEvent(Timer.EVENT_PLAY_PAUSE);
    }

    /**
     * pauses the timer
     * @function
     * @memberof Timer
     * @instance
     */
    pause()
    {
        this._timeOffset = this._currentTime;
        this._paused = true;
        this.emitEvent(Timer.EVENT_PLAY_PAUSE);
    }

    static now()
    {
        return window.performance.now();
    }
}




/***/ }),

/***/ 562:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  ajax: () => (/* binding */ ajax),
  basename: () => (/* binding */ basename),
  cacheBust: () => (/* binding */ cacheBust),
  clamp: () => (/* binding */ clamp),
  cleanJson: () => (/* binding */ cleanJson),
  copyArray: () => (/* binding */ copyArray),
  escapeHTML: () => (/* binding */ escapeHTML),
  filename: () => (/* binding */ filename),
  float32Concat: () => (/* binding */ float32Concat),
  generateUUID: () => (/* binding */ generateUUID),
  getShortOpName: () => (/* binding */ getShortOpName),
  isNumeric: () => (/* binding */ isNumeric),
  logErrorConsole: () => (/* binding */ logErrorConsole),
  logStack: () => (/* binding */ logStack),
  map: () => (/* binding */ map),
  prefixedHash: () => (/* binding */ prefixedHash),
  request: () => (/* binding */ request),
  shortId: () => (/* binding */ shortId),
  shuffleArray: () => (/* binding */ shuffleArray),
  simpleId: () => (/* binding */ simpleId),
  smoothStep: () => (/* binding */ smoothStep),
  smootherStep: () => (/* binding */ smootherStep),
  uniqueArray: () => (/* binding */ uniqueArray),
  uuid: () => (/* binding */ uuid)
});

// EXTERNAL MODULE: ./src/core/constants.js
var constants = __webpack_require__(440);
;// CONCATENATED MODULE: ./src/core/extendjs.js
/**
 * extend javascript functionality
 */

/**
 * @external Math
 */

/**
 * set random seed for seededRandom()
 * @type Number
 * @static
 */
Math.randomSeed = 1;

/**
 * @function external:Math#setRandomSeed
 * @param {number} seed
 */
Math.setRandomSeed = function (seed)
{
    // https://github.com/cables-gl/cables_docs/issues/622
    Math.randomSeed = seed * 50728129;
    if (seed != 0)
    {
        Math.randomSeed = Math.seededRandom() * 17624813;
        Math.randomSeed = Math.seededRandom() * 9737333;
    }
};

/**
 * generate a seeded random number
 * @function seededRandom
 * @memberof Math
 * @param {Number} max minimum possible random number
 * @param {Number} min maximum possible random number
 * @return {Number} random value
 * @static
 */
Math.seededRandom = function (max, min)
{
    if (Math.randomSeed === 0) Math.randomSeed = Math.random() * 999;
    max = max || 1;
    min = min || 0;

    Math.randomSeed = (Math.randomSeed * 9301 + 49297) % 233280;
    const rnd = Math.randomSeed / 233280.0;

    return min + rnd * (max - min);
};

/**
     * @namespace String
     */

/**
 * append a linebreak to a string
 * @this {String}
 * @returns {string} string with newline appended
*/
String.prototype.endl = function ()
{
    return this + "\n";
};

String.prototype.contains = function (str)
{
    console.warn("string.contains deprecated, use string.includes");
    console.log((new Error()).stack);
    return this.includes(str);

};

function extendJs() {}

;// CONCATENATED MODULE: ./src/core/utils.js
/**
 * @namespace external:CABLES#Utils
 */




extendJs();

/**
 * Merge two Float32Arrays.
 * @function float32Concat
 * @param {Float32Array} first Left-hand side array
 * @param {Float32Array} second Right-hand side array
 * @return {Float32Array}
 * @static
 */
function float32Concat(first, second)
{
    if (!(first instanceof Float32Array)) first = new Float32Array(first);
    if (!(second instanceof Float32Array)) second = new Float32Array(second);

    const result = new Float32Array(first.length + second.length);

    result.set(first);
    result.set(second, first.length);

    return result;
}

/**
 * get op shortname: only last part of fullname and without version
 * @function getShortOpName
 * @memberof CABLES
 * @param {string} fullname full op name
 * @static
 */
const getShortOpName = function (fullname)
{
    let name = fullname.split(".")[fullname.split(".").length - 1];

    if (name.includes(constants/* CONSTANTS */.a.OP.OP_VERSION_PREFIX))
    {
        const n = name.split(constants/* CONSTANTS */.a.OP.OP_VERSION_PREFIX)[1];
        name = name.substring(0, name.length - (constants/* CONSTANTS */.a.OP.OP_VERSION_PREFIX + n).length);
    }
    return name;
};

/**
 * randomize order of an array
 * @function shuffleArray
 * @param {Array|Float32Array} array {Array} original
 * @return {Array|Float32Array} shuffled array
 * @static
 */
const shuffleArray = function (array)
{
    for (let i = array.length - 1; i > 0; i--)
    {
        const j = Math.floor(Math.seededRandom() * (i + 1));
        const temp = array[i];
        array[i] = array[j];
        array[j] = temp;
    }
    return array;
};

/**
 * generate a short "relativly unique" id
 * @function shortId
 * @return {String} generated ID
 * @static
 */

const _shortIds = {};
const shortId = function ()
{
    let str = Math.random().toString(36).substr(2, 9);

    if (_shortIds.hasOwnProperty(str)) str = shortId();
    _shortIds[str] = true;
    return str;
};

/**
 * @typedef {String} UUID
*/

/**
 * generate a UUID
 * @function uuid
 * @return {UUID} generated UUID
 * @static
 */
const uuid = function ()
{
    let d = new Date().getTime();
    const uuidStr = "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) =>
    {
        const r = (d + Math.random() * 16) % 16 | 0;
        d = Math.floor(d / 16);
        return (c == "x" ? r : (r & 0x3) | 0x8).toString(16);
    });
    return uuidStr;
};
const generateUUID = uuid;

function cleanJson(obj)
{
    for (const i in obj)
    {
        if (obj[i] && typeof objValue === "object" && obj[i].constructor === Object) obj[i] = cleanJson(obj[i]);

        if (obj[i] === null || obj[i] === undefined) delete obj[i];
        else if (Array.isArray(obj[i]) && obj[i].length == 0) delete obj[i];
    }

    return obj;
}

/**
 * @see http://stackoverflow.com/q/7616461/940217
 * @param {string} str
 * @param {string} prefix
 * @return {string}
 */
const prefixedHash = function (str, prefix = "id")
{
    let hash = 0;
    if (str.length > 0)
    {
        for (let i = 0; i < str.length; i++)
        {
            let character = str.charCodeAt(i);
            hash = ((hash << 5) - hash) + character;
            hash &= hash; // Convert to 32bit integer
        }
    }
    return prefix + "" + hash;
};

/**
 * generate a simple ID
 * @return {Number} new id
 * @static
 */
let simpleIdCounter = 0;
const simpleId = function ()
{
    simpleIdCounter++;
    return simpleIdCounter;
};

/**
 * smoothStep a value
 * @param {Number} perc value value to be smoothed [0-1]
 * @return {Number} smoothed value
 * @static
 */
const smoothStep = function (perc)
{
    const x = Math.max(0, Math.min(1, (perc - 0) / (1 - 0)));
    perc = x * x * (3 - 2 * x); // smoothstep
    return perc;
};

/**
 * smootherstep a value
 * @param {Number} perc value to be smoothed [0-1]
 * @return {Number} smoothed value
 * @static
 */
const smootherStep = function (perc)
{
    const x = Math.max(0, Math.min(1, (perc - 0) / (1 - 0)));
    perc = x * x * x * (x * (x * 6 - 15) + 10); // smootherstep
    return perc;
};

/**
 * clamp number / make sure its between min/max
 * @param {Number} value value to be mapped
 * @param {Number} min minimum value
 * @param {Number} max maximum value
 * @static
 */
const clamp = function (value, min, max)
{
    return Math.min(Math.max(value, min), max);
};

/**
 * map a value in a range to a value in another range
 * @param {Number} x value to be mapped
 * @param {Number} _oldMin old range minimum value
 * @param {Number} _oldMax old range maximum value
 * @param {Number} _newMin new range minimum value
 * @param {Number} _newMax new range maximum value
 * @param {Number} _easing
 * @return {Number} mapped value
 * @static
 */
const map = function (x, _oldMin, _oldMax, _newMin, _newMax, _easing = 0, clamp = true)
{
    if (clamp)
    {
        if (x >= _oldMax) return _newMax;
        if (x <= _oldMin) return _newMin;
    }

    let reverseInput = false;
    const oldMin = Math.min(_oldMin, _oldMax);
    const oldMax = Math.max(_oldMin, _oldMax);
    if (oldMin != _oldMin) reverseInput = true;

    let reverseOutput = false;
    const newMin = Math.min(_newMin, _newMax);
    const newMax = Math.max(_newMin, _newMax);
    if (newMin != _newMin) reverseOutput = true;

    let portion = 0;
    let r = 0;

    if (reverseInput) portion = ((oldMax - x) * (newMax - newMin)) / (oldMax - oldMin);
    else portion = ((x - oldMin) * (newMax - newMin)) / (oldMax - oldMin);

    if (reverseOutput) r = newMax - portion;
    else r = portion + newMin;

    if (!_easing) return r;
    if (_easing == 1)
    {
        // smoothstep
        x = Math.max(0, Math.min(1, (r - _newMin) / (_newMax - _newMin)));
        return _newMin + x * x * (3 - 2 * x) * (_newMax - _newMin);
    }
    if (_easing == 2)
    {
        // smootherstep
        x = Math.max(0, Math.min(1, (r - _newMin) / (_newMax - _newMin)));
        return _newMin + x * x * x * (x * (x * 6 - 15) + 10) * (_newMax - _newMin);
    }

    return r;
};

// ----------------------------------------------------------------

/**
 * returns true if parameter is a number
 * @param {any} n value The value to check.
 * @return {Boolean}
 * @static
 */
function isNumeric(n)
{
    return !isNaN(parseFloat(n)) && isFinite(n);
}

// ----------------------------------------------------------------

/**
 * append a unique/random parameter to a url, so the browser is forced to reload the file, even if its cached
 * @static
 * @param {String} url The url to append the cachebuster parameter to.
 * @return {String} url with cachebuster parameter
 */
const cacheBust = function (url = "")
{
    if (!url) return "";
    if (url.startsWith("data:")) return;
    if (url.includes("?")) url += "&";
    else url += "?";
    return url + "cache=" + CABLES.uuid();
};

/**
 * copy the content of an array
 * @static
 * @param {Array} src sourceArray
 * @param {Array} dst optional
 * @return {Array} dst
 */
const copyArray = function (src, dst)
{
    if (!src) return null;
    dst = dst || [];
    dst.length = src.length;
    for (let i = 0; i < src.length; i++)
        dst[i] = src[i];

    return dst;
};

/**
 * return the filename part of a url without extension
 * @static
 * @param {String} url
 * @return {String} just the filename
 */
const basename = function (url)
{
    let name = CABLES.filename(url);

    const parts2 = name.split(".");
    name = parts2[0];

    return name;
};

/**
 * output a stacktrace to the console
 * @static
 */
const logStack = function ()
{
    console.log("logstack", (new Error()).stack);
};

/**
 * return the filename part of a url
 * @static
 * @param {String} url
 * @return {String} just the filename
 */
const filename = function (url)
{
    let name = "";
    if (!url) return "";

    if (url.startsWith("data:") && url.includes(":"))
    {
        const parts = url.split(",");
        return parts[0];
    }

    let parts = (url + "").split("/");
    if (parts.length > 0)
    {
        const str = parts[parts.length - 1];
        let parts2 = str.split("?");
        name = parts2[0];
    }

    return name || "";
};

/**
 * make an ajax request
 * @static
 * @function ajax
 * @param url
 * @param cb
 * @param method
 * @param post
 * @param contenttype
 * @param jsonP
 * @param headers
 * @param options
 */
const ajax = function (url, cb, method, post, contenttype, jsonP, headers = {}, options = {})
{
    const requestOptions = {
        "url": url,
        "cb": cb,
        "method": method,
        "data": post,
        "contenttype": contenttype,
        "sync": false,
        "jsonP": jsonP,
        "headers": headers,
    };
    if (options && options.credentials) requestOptions.credentials = options.credentials;
    request(requestOptions);
};

const request = function (options)
{
    if (!options.hasOwnProperty("asynch")) options.asynch = true;

    let xhr;
    try
    {
        xhr = new XMLHttpRequest();
    }
    catch (e) {}

    xhr.onreadystatechange = function ()
    {
        if (xhr.readyState != 4) return;

        if (options.cb)
        {
            if (xhr.status == 200 || xhr.status == 0) options.cb(false, xhr.responseText, xhr);
            else options.cb(true, xhr.responseText, xhr);
        }
    };

    try
    {
        xhr.open(options.method ? options.method.toUpperCase() : "GET", options.url, !options.sync);
    }
    catch (e)
    {
        if (options.cb && e) options.cb(true, e.msg, xhr);
    }

    if (typeof options.headers === "object")
    {
        if (options.headers)
        {
            const keys = Object.keys(options.headers);
            for (let i = 0; i < keys.length; i++)
            {
                const name = keys[i];
                const value = options.headers[name];
                xhr.setRequestHeader(name, value);
            }
        }
    }

    if (options.credentials && options.credentials !== "omit")
    {
        xhr.withCredentials = true;
    }

    try
    {
        if (!options.post && !options.data)
        {
            xhr.send();
        }
        else
        {
            xhr.setRequestHeader(
                "Content-type",
                options.contenttype ? options.contenttype : "application/x-www-form-urlencoded",
            );
            xhr.send(options.data || options.post);
        }
    }
    catch (e)
    {
        if (options.cb) options.cb(true, e.msg, xhr);
    }
};

// ----------------------------------------------------------------

const logErrorConsole = function (initiator)
{
    CABLES.errorConsole = CABLES.errorConsole || { "log": [] };
    CABLES.errorConsole.log.push({ "initiator": initiator, "arguments": arguments });

    if (!CABLES.errorConsole.ele)
    {
        const ele = document.createElement("div");
        ele.id = "cablesErrorConsole";
        ele.style.width = "90%";
        ele.style.height = "300px";
        ele.style.zIndex = "9999999";
        ele.style.display = "inline-block";
        ele.style.position = "absolute";
        ele.style.padding = "10px";
        ele.style.fontFamily = "monospace";
        ele.style.color = "red";
        ele.style.backgroundColor = "#200";

        CABLES.errorConsole.ele = ele;
        document.body.appendChild(ele);
    }

    let logHtml = "ERROR<br/>for more info, open your browsers dev tools console (Ctrl+Shift+I or Command+Alt+I)<br/>";

    for (let l = 0; l < CABLES.errorConsole.log.length; l++)
    {
        logHtml += CABLES.errorConsole.log[l].initiator + " ";
        for (let i = 1; i < CABLES.errorConsole.log[l].arguments.length; i++)
        {
            if (i > 2)logHtml += ", ";
            let arg = CABLES.errorConsole.log[l].arguments[i];
            if (arg.constructor.name.indexOf("Error") > -1 || arg.constructor.name.indexOf("error") > -1)
            {
                let txt = "Uncaught ErrorEvent ";
                if (arg.message)txt += " message: " + arg.message;
                logHtml += txt;
            }
            else if (typeof arg == "string")
                logHtml += arg;
            else if (typeof arg == "number")
                logHtml += String(arg) + " ";
        }
        logHtml += "<br/>";
    }

    CABLES.errorConsole.ele.innerHTML = logHtml;
};

/**
 * @param {Array<any>} arr
 */
function uniqueArray(arr)
{
    const u = {}, a = [];
    for (let i = 0, l = arr.length; i < l; ++i)
    {
        if (!u.hasOwnProperty(arr[i]))
        {
            a.push(arr[i]);
            u[arr[i]] = 1;
        }
    }
    return a;
}

const htmlEscapes = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    "\"": "&quot;",
    "'": "&#39;",
};

/** Used to match HTML entities and HTML characters. */
const reUnescapedHtml = /[&<>"']/g;
const reHasUnescapedHtml = RegExp(reUnescapedHtml.source);

// from https://github.com/lodash/lodash/blob/master/escape.js
/*  eslint-disable */
const escapeHTML = function(string)
{
    return string && reHasUnescapedHtml.test(string) ?
        string.replace(reUnescapedHtml, function(chr) { return htmlEscapes[chr]; })
        : string || "";
}
/* eslint-enable */


/***/ }),

/***/ 982:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   I: () => (/* binding */ BoundingBox)
/* harmony export */ });
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(329);
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(684);
/* harmony import */ var cables__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(562);





/**
 * bounding box
 *
 * @namespace external:CGL
 * @param {Geometry} geometry or bounding box
 */
class BoundingBox
{

    /**
     * @param {Geometry} [geom]
     */
    constructor(geom)
    {
        this._init();
        this._first = true;
        this._wireMesh = null;

        if (geom) this.applyGeom(geom);
    }

    _init()
    {
        this._max = [-0, -0, -0];
        this._min = [0, 0, 0];
        this._center = [0, 0, 0];
        this._size = [0, 0, 0];
        this._maxAxis = 0.0;
        this._first = true;
    }

    /**
     * get biggest number of maxX,maxY,maxZ
     * @type {Number}
     */
    get maxAxis() { return this._maxAxis || 1; }

    /**
     * size of bounding box
     * @type {vec3}
     */
    get size() { return this._size; }

    /**
     * center of bounding box
     * @type {vec3}
     */
    get center() { return this._center; }

    /**
     * center x
     * @type {Number}
     */
    get x() { return this._center[0]; }

    /**
     * center y
     * @type {Number}
     */
    get y() { return this._center[1]; }

    /**
     * center z
     * @type {Number}
     */
    get z() { return this._center[2]; }

    /**
     * minimum x
     * @type {Number}
     */
    get minX() { return this._min[0]; }

    /**
     * minimum y
     * @type {Number}
     */
    get minY() { return this._min[1]; }

    /**
     * minimum z
     * @type {Number}
     */
    get minZ() { return this._min[2]; }

    /**
     * maximum x
     * @type {Number}
     */
    get maxX() { return this._max[0]; }

    /**
     * maximum y
     * @type {Number}
     */
    get maxY() { return this._max[1]; }

    /**
     * maximum z
     * @type {Number}
     */
    get maxZ() { return this._max[2]; }

    /**
     * @deprecated
     * @param {Geometry} geom
     */
    apply(geom)
    {
        return this.applyGeom(geom);
    }

    /**
     * @param {Geometry} geom
     */
    applyGeom(geom)
    {
        if (!geom) return;

        if (geom instanceof BoundingBox)
        {
            const bb = geom;

            this.applyPos(bb.maxX, bb.maxY, bb.maxZ);
            this.applyPos(bb.minX, bb.minY, bb.minZ);
        }
        else
        {
            if (geom.isGeometry)
                for (let i = 0; i < geom.vertices.length; i += 3)
                    this.applyPos(geom.vertices[i], geom.vertices[i + 1], geom.vertices[i + 2]);
        }
        this.calcCenterSize();
    }

    /**
     * returns a copy of the bounding box
     * @function copy
     * @memberof BoundingBox
     * @instance
     */
    copy()
    {
        return new BoundingBox(this);
    }

    get changed()
    {
        return !(this._max[0] == -Number.MAX_VALUE && this._max[1] == -Number.MAX_VALUE && this._max[2] == -Number.MAX_VALUE);
    }

    /**
     * @param {number} x
     * @param {number} y
     * @param {number} z
     */
    applyPos(x, y, z)
    {
        if (x == Number.MAX_VALUE || x == -Number.MAX_VALUE ||
            y == Number.MAX_VALUE || y == -Number.MAX_VALUE ||
            z == Number.MAX_VALUE || z == -Number.MAX_VALUE) return;

        if (!cables__WEBPACK_IMPORTED_MODULE_0__.isNumeric(x) || !cables__WEBPACK_IMPORTED_MODULE_0__.isNumeric(y) || !cables__WEBPACK_IMPORTED_MODULE_0__.isNumeric(z)) return;

        if (this._first)
        {
            this._max[0] = x;
            this._max[1] = y;
            this._max[2] = z;

            this._min[0] = x;
            this._min[1] = y;
            this._min[2] = z;
            this._first = false;
            return;
        }

        this._max[0] = Math.max(this._max[0], x);
        this._max[1] = Math.max(this._max[1], y);
        this._max[2] = Math.max(this._max[2], z);

        this._min[0] = Math.min(this._min[0], x);
        this._min[1] = Math.min(this._min[1], y);
        this._min[2] = Math.min(this._min[2], z);
    }

    calcCenterSize()
    {
        if (this._first) return;

        this._size[0] = this._max[0] - this._min[0];
        this._size[1] = this._max[1] - this._min[1];
        this._size[2] = this._max[2] - this._min[2];

        this._center[0] = (this._min[0] + this._max[0]) / 2;
        this._center[1] = (this._min[1] + this._max[1]) / 2;
        this._center[2] = (this._min[2] + this._max[2]) / 2;

        this._maxAxis = Math.max(this._size[2], Math.max(this._size[0], this._size[1]));
    }

    /**
     * @param {mat4} m
     */
    mulMat4(m)
    {
        if (this._first)
        {
            this._max[0] = 0;
            this._max[1] = 0;
            this._max[2] = 0;

            this._min[0] = 0;
            this._min[1] = 0;
            this._min[2] = 0;
            this._first = false;
        }
        gl_matrix__WEBPACK_IMPORTED_MODULE_1__.transformMat4(this._max, this._max, m);
        gl_matrix__WEBPACK_IMPORTED_MODULE_1__.transformMat4(this._min, this._min, m);
        this.calcCenterSize();
    }

    /**
     * @param {CglContext} cgl
     * @param {Shader} _shader
     * @param {Op} op
     */
    render(cgl, _shader, op)
    {
        if (!this._wireMesh) this._wireMesh = new CGL.WireCube(cgl);

        cgl.pushModelMatrix();
        gl_matrix__WEBPACK_IMPORTED_MODULE_2__.translate(cgl.mMatrix, cgl.mMatrix, this._center);

        if (CABLES.UI && op)
        {
            CABLES.UI.OverlayMeshes.drawCube(op, this._size[0] / 2, this._size[1] / 2, this._size[2] / 2);
        }

        cgl.popModelMatrix();
    }
}


/***/ }),

/***/ 223:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   f: () => (/* binding */ CgCanvas)
/* harmony export */ });
/* harmony import */ var cables_shared_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(849);


class CgCanvas
{
    hasFocus = false;

    forceAspect = 0;

    /**
     * @param {{ canvasEle: any; cg: any; }} options
     */
    constructor(options)
    {
        this._log = new cables_shared_client__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A("CgCanvas");
        if (!options)
        {
            this._log.error("CgCanvas no options");
        }
        else
        {
            this._canvasEle = options.canvasEle;
        }

        if (!options.cg) this._log.error("CgCanvas options has no cg");
        if (!options.canvasEle) this._log.error("CgCanvas options has no canvasEle");

        this._cg = options.cg;
        this.pixelDensity = 1;
        this.canvasWidth = this.canvasEle.clientWidth;
        this.canvasHeight = this.canvasEle.clientHeight;

        this._oldWidthRp = -1;
        this._oldHeightRp = -1;

        this.setSize(this.canvasWidth, this.canvasHeight);
        this.canvasEle.addEventListener("focus", () => { this.hasFocus = true; });
        this.canvasEle.addEventListener("blur", () => { this.hasFocus = false; });
    }

    get canvasEle() { return this._canvasEle; }

    /**
     * @param {Number} w
     * @param {Number} h
     * @param {any} ignorestyle
     * @returns {any}
     */
    setSize(w, h, ignorestyle = false)
    {
        let offY = 0;
        if (this.forceAspect)
        {
            let nh = w / this.forceAspect;
            if (nh < h)offY = (h - nh) / 2;
            h = nh;
        }

        if (this._oldWidthRp != w * this.pixelDensity || this._oldHeightRp != h * this.pixelDensity)
        {
            this._oldWidthRp = this.canvasEle.width = w * this.pixelDensity;
            this._oldHeightRp = this.canvasEle.height = h * this.pixelDensity;

            if (!ignorestyle)
            {
                this.canvasEle.style.width = w + "px";
                this.canvasEle.style.height = h + "px";
                this.canvasEle.style.marginTop = offY + "px";
            }

            this.updateSize();

            this._cg.emitEvent("resize");
        }
    }

    updateSize()
    {
        this.canvasEle.width = this.canvasWidth = this.canvasEle.clientWidth * this.pixelDensity;
        this.canvasEle.height = this.canvasHeight = this.canvasEle.clientHeight * this.pixelDensity;
    }

    dispose()
    {
        if (this._canvasEle) this._canvasEle.remove();
        this._canvasEle = null;
    }
}


/***/ }),

/***/ 628:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ CgContext)
/* harmony export */ });
/* harmony import */ var cables_shared_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(125);
/* harmony import */ var cables_shared_client__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(849);
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(329);
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(684);
/* harmony import */ var _cg_canvas_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(223);
/* harmony import */ var _cg_matrixstack_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(868);
/* harmony import */ var _cgl_cgl_profiledata_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(460);
/* harmony import */ var _cg_fpscounter_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(294);








class CgContext extends cables_shared_client__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A
{

    static API_UNKNOWN = 0;
    static API_WEBGL = 1;
    static API_WEBGPU = 2;

    static EVENT_RESIZE = "resize";

    gApi = 0;

    /**
     * Description
     * @param {Patch} _patch
     */
    constructor(_patch)
    {
        super();

        this._log = new cables_shared_client__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A("cg_context", { "onError": _patch.config.onError });

        /** @type {object} */
        this.tempData = this.frameStore = this.frameStore || {};
        this.fpsCounter = new _cg_fpscounter_js__WEBPACK_IMPORTED_MODULE_2__/* .FpsCounter */ .K();
        this._identView = gl_matrix__WEBPACK_IMPORTED_MODULE_3__.create();
        this._ident = gl_matrix__WEBPACK_IMPORTED_MODULE_3__.create();
        gl_matrix__WEBPACK_IMPORTED_MODULE_3__.set(this._identView, 0, 0, -2);
        gl_matrix__WEBPACK_IMPORTED_MODULE_3__.set(this._ident, 0, 0, 0);
        this._onetimeCallbacks = [];
        this.maxTexSize = 2048;
        this._viewPort = [0, 0, 1, 1];
        this._viewPortStack = [];
        this.patch = _patch;
        this.autoReSize = true;

        this.DEPTH_COMPARE_FUNC_NEVER = 0;
        this.DEPTH_COMPARE_FUNC_LESS = 1;
        this.DEPTH_COMPARE_FUNC_EQUAL = 2;
        this.DEPTH_COMPARE_FUNC_LESSEQUAL = 3;
        this.DEPTH_COMPARE_FUNC_GREATER = 4;
        this.DEPTH_COMPARE_FUNC_NOTEQUAL = 5;
        this.DEPTH_COMPARE_FUNC_GREATEREQUAL = 6;
        this.DEPTH_COMPARE_FUNC_ALWAYS = 7;

        this.profileData = new _cgl_cgl_profiledata_js__WEBPACK_IMPORTED_MODULE_4__/* .ProfileData */ .E(this);

        /**
         * Current projection matrix
         * @memberof Context
         * @instance
         * @type {mat4}
         */
        this.pMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_5__.create();

        /**
         * Current model matrix
         * @memberof Context
         * @instance
         * @type {mat4}
         */
        this.mMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_5__.create();

        /**
         * Current view matrix
         * @memberof Context
         * @instance
         * @type {mat4}
         */
        this.vMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_5__.create();
        this._textureslots = [];

        this._pMatrixStack = new _cg_matrixstack_js__WEBPACK_IMPORTED_MODULE_6__/* .MatrixStack */ .u();
        this._mMatrixStack = new _cg_matrixstack_js__WEBPACK_IMPORTED_MODULE_6__/* .MatrixStack */ .u();
        this._vMatrixStack = new _cg_matrixstack_js__WEBPACK_IMPORTED_MODULE_6__/* .MatrixStack */ .u();

        this.canvasScale = 1;

        gl_matrix__WEBPACK_IMPORTED_MODULE_5__.identity(this.mMatrix);
        gl_matrix__WEBPACK_IMPORTED_MODULE_5__.identity(this.vMatrix);

        window.matchMedia("screen and (min-resolution: 2dppx)").addEventListener("change", () =>
        {
            this.emitEvent("resize");
        });

    }

    get canvasWidth()
    {
        return this.cgCanvas.canvasWidth;
    }

    get canvasHeight()
    {
        return this.cgCanvas.canvasHeight;
    }

    set pixelDensity(p)
    {
        if (this.cgCanvas.pixelDensity != p)
        {
            this.cgCanvas.pixelDensity = p;
            this.cgCanvas.updateSize();
            this.emitEvent("resize");
        }
    }

    get pixelDensity()
    {
        return this.cgCanvas.pixelDensity;
    }

    getGApiName()
    {
        return ["unknown", "WebGL", "WebGPU"][this.gApi];
    }

    get canvas()
    {
        return this.cgCanvas.canvasEle;
    }

    get viewPort()
    {
        // TODO: add stack...
        return [0, 0, this.canvasWidth, this.canvasHeight];
    }

    /**
     * @param {HTMLElement} canvEle
     */
    setCanvas(canvEle)
    {
        if (this.cgCanvas && canvEle == this.cgCanvas.canvasEle) return;
        if (typeof canvEle === "string") canvEle = document.getElementById(canvEle);

        this.cgCanvas = new _cg_canvas_js__WEBPACK_IMPORTED_MODULE_7__/* .CgCanvas */ .f({ "canvasEle": canvEle, "cg": this });

        canvEle.parentElement.classList.add("cablesContainer");
        if (this._setCanvas) this._setCanvas(canvEle);

        this.updateSize();
    }

    /**
     * @param {HTMLElement} _canvEle
     */
    _setCanvas(_canvEle)
    {
    }

    updateSize()
    {
        this.cgCanvas.updateSize();
    }

    /**
     * @param {number} w
     * @param {number} h
     * @param {boolean} ignorestyle
     */
    setSize(w, h, ignorestyle = false)
    {
        this.cgCanvas.setSize(w, h, ignorestyle);
    }

    _resizeToWindowSize()
    {
        if (this.autoReSize)
        {
            this.setSize(window.innerWidth, window.innerHeight);
            this.updateSize();
        }
    }

    _resizeToParentSize()
    {
        if (this.autoReSize)
        {
            const p = this.canvas.parentElement;
            if (!p)
            {
                this._log.error("cables: can not resize to container element");
                return;
            }

            this.setSize(p.clientWidth, p.clientHeight);
            this.updateSize();
        }
    }

    setAutoResize(parent)
    {
        window.removeEventListener("resize", this._resizeToWindowSize.bind(this));
        window.removeEventListener("resize", this._resizeToParentSize.bind(this));

        if (parent == "window")
        {
            window.addEventListener("resize", this._resizeToWindowSize.bind(this));
            window.addEventListener("orientationchange", this._resizeToWindowSize.bind(this));
            this._resizeToWindowSize();
        }
        if (parent == "parent")
        {
            window.addEventListener("resize", this._resizeToParentSize.bind(this));
            this._resizeToParentSize();
        }
    }

    /**
     * push a matrix to the projection matrix stack
     * @function pushPMatrix
     * @memberof Context
     * @instance
     */
    pushPMatrix()
    {
        this.pMatrix = this._pMatrixStack.push(this.pMatrix);
    }

    /**
      * pop projection matrix stack
      * @function popPMatrix
      * @memberof Context
      * @instance
      * @returns {mat4} current projectionmatrix
      */
    popPMatrix()
    {
        this.pMatrix = this._pMatrixStack.pop();
        return this.pMatrix;
    }

    getProjectionMatrixStateCount()
    {
        return this._pMatrixStack.stateCounter;
    }

    /**
      * push a matrix to the model matrix stack
      * @function pushModelMatrix
      * @memberof Context
      * @instance
      * @example
      * // see source code of translate op:
      * cgl.pushModelMatrix();
      * mat4.translate(cgl.mMatrix,cgl.mMatrix, vec);
      * trigger.trigger();
      * cgl.popModelMatrix();
      */
    pushModelMatrix()
    {
        this.mMatrix = this._mMatrixStack.push(this.mMatrix);
    }

    /**
      * pop model matrix stack
      * @function popModelMatrix
      * @memberof Context
      * @instance
      * @returns {mat4} current modelmatrix
      */
    popModelMatrix()
    {
        // todo: DEPRECATE
        // if (this._mMatrixStack.length === 0) throw "Invalid modelview popMatrix!";
        this.mMatrix = this._mMatrixStack.pop();
        return this.mMatrix;
    }

    /**
      * get model matrix
      * @function modelMatrix
      * @memberof Context
      * @instance
      * @returns {mat4} current modelmatrix
      */
    modelMatrix()
    {
        return this.mMatrix;
    }

    /**
     * push a matrix to the view matrix stack
     * @function pushviewMatrix
     * @memberof Context
     * @instance
     */
    pushViewMatrix()
    {
        this.vMatrix = this._vMatrixStack.push(this.vMatrix);
    }

    /**
      * pop view matrix stack
      * @function popViewMatrix
      * @memberof Context
      * @instance
      * @returns {mat4} current viewmatrix
      * @function
      */
    popViewMatrix()
    {
        this.vMatrix = this._vMatrixStack.pop();
    }

    getViewMatrixStateCount()
    {
        return this._vMatrixStack.stateCounter;
    }

    /**
     * @param {vec3} identTranslate
     * @param {vec3} identTranslateView
     */
    _startMatrixStacks(identTranslate, identTranslateView)
    {
        identTranslate = identTranslate || this._ident;
        identTranslateView = identTranslateView || this._identView;

        gl_matrix__WEBPACK_IMPORTED_MODULE_5__.perspective(this.pMatrix, 45, this.canvasWidth / this.canvasHeight, 0.1, 1000.0);

        gl_matrix__WEBPACK_IMPORTED_MODULE_5__.identity(this.mMatrix);
        gl_matrix__WEBPACK_IMPORTED_MODULE_5__.identity(this.vMatrix);
        gl_matrix__WEBPACK_IMPORTED_MODULE_5__.translate(this.mMatrix, this.mMatrix, identTranslate);
        gl_matrix__WEBPACK_IMPORTED_MODULE_5__.translate(this.vMatrix, this.vMatrix, identTranslateView);

        this.pushPMatrix();
        this.pushModelMatrix();
        this.pushViewMatrix();
    }

    _endMatrixStacks()
    {
        this.popViewMatrix();
        this.popModelMatrix();
        this.popPMatrix();
    }

    dispose()
    {
        this.aborted = true;
        if (this.cgCanvas) this.cgCanvas.dispose();
        if (this._dispose) this._dispose();
    }

    _dispose()
    {
    }

    /**
     * @param {any} _op
     */
    shouldDrawHelpers(_op)
    {
        return false;
    }

    /**
     * execute the callback next frame, once
     * @param {function} cb
     */
    addNextFrameOnceCallback(cb)
    {
        if (cb && this._onetimeCallbacks.indexOf(cb) == -1) this._onetimeCallbacks.push(cb);
    }

    _execOneTimeCallbacks()
    {
        if (this._onetimeCallbacks.length > 0)
        {
            for (let i = 0; i < this._onetimeCallbacks.length; i++) this._onetimeCallbacks[i]();
            this._onetimeCallbacks.length = 0;
        }
    }

    /**
     * @param {number} x
     */
    checkTextureSize(x)
    {
        x = x || 1;
        x = Math.floor(x);
        x = Math.min(x, this.maxTexSize);
        x = Math.max(x, 1);
        return x;
    }

    // should be overwritten...
    screenShot(cb, doScreenshotClearAlpha, mimeType, quality)
    {
        console.log("no screenshot function implemented");
    }

    /**
     * @param {string} [filename]
     * @param {function} [cb]
     * @param {number} [pw]
     * @param {number} [ph]
     * @param {boolean} [_noclearalpha]
     */
    saveScreenshot(filename, cb, pw, ph, _noclearalpha)
    {
        this.patch.renderOneFrame();

        let w = this.canvas.clientWidth * this.pixelDensity;
        let h = this.canvas.clientHeight * this.pixelDensity;

        if (pw)
        {
            this.canvas.width = pw;
            w = pw;
        }
        if (ph)
        {
            this.canvas.height = ph;
            h = ph;
        }

        function padLeft(nr, n, str)
        {
            return Array(n - String(nr).length + 1).join(str || "0") + nr;
        }

        const d = new Date();
        const dateStr = "".concat(String(d.getFullYear()) + String(d.getMonth() + 1) + String(d.getDate()), "_").concat(padLeft(d.getHours(), 2)).concat(padLeft(d.getMinutes(), 2)).concat(padLeft(d.getSeconds(), 2));

        if (!filename) filename = "cables_" + dateStr + ".png";
        else filename += ".png";

        this.screenShot((blob) =>
        {
            this.canvas.width = w;
            this.canvas.height = h;

            if (blob)
            {
                const anchor = document.createElement("a");

                anchor.download = filename;
                anchor.href = URL.createObjectURL(blob);

                console.log("scrrenshot");
                setTimeout(function ()
                {
                    anchor.click();
                    if (cb) cb(blob);
                }, 100);
            }
            else
            {
                this._log.log("screenshot: no blob");
            }
        });
    }

    hasFocus()
    {
        return this.cgCanvas.hasFocus;

    }

}


/***/ }),

/***/ 294:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   K: () => (/* binding */ FpsCounter)
/* harmony export */ });
/* harmony import */ var cables_shared_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(125);
/* harmony import */ var cables__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(920);



class FpsCounter extends cables_shared_client__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A
{
    constructor()
    {
        super();
        this._timeStartFrame = 0;
        this._timeStartSecond = 0;
        this._fpsCounter = 0;
        this._msCounter = 0;
        this._frameCount = 0;
        this.logFps = false;

        this.stats = { "ms": 0, "fps": 0 };
    }

    get frameCount()
    {
        return this._frameCount;
    }

    startFrame()
    {
        this._timeStartFrame = (0,cables__WEBPACK_IMPORTED_MODULE_1__/* .now */ .tB)();
    }

    endFrame()
    {
        this._frameCount++;
        this._fpsCounter++;

        const timeFrame = (0,cables__WEBPACK_IMPORTED_MODULE_1__/* .now */ .tB)() - this._timeStartFrame;
        this._msCounter += timeFrame;

        if ((0,cables__WEBPACK_IMPORTED_MODULE_1__/* .now */ .tB)() - this._timeStartSecond > 1000) this.endSecond();
    }

    endSecond()
    {
        this.stats.fps = this._fpsCounter;
        this.stats.ms = Math.round(this._msCounter / this._fpsCounter * 100) / 100;

        this.emitEvent("performance", this.stats);
        if (this.logFps)console.log(this.stats);

        // reset
        this._fpsCounter = 0;
        this._msCounter = 0;
        this._timeStartSecond = (0,cables__WEBPACK_IMPORTED_MODULE_1__/* .now */ .tB)();
    }
}


/***/ }),

/***/ 331:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   V: () => (/* binding */ Geometry)
/* harmony export */ });
/* harmony import */ var cables_shared_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(849);
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(329);
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(842);
/* harmony import */ var cables__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(562);
/* harmony import */ var _cg_boundingbox_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(982);





/**
 * a geometry contains all information about a mesh, vertices, texturecoordinates etc. etc.
 * @param {String} name
 * @example
 * // create a triangle with all attributes
 * const geom=new Geometry("triangle"),
 *
 * geom.vertices = [
 *      0.0,           sizeH.get(),  0.0,
 *     -sizeW.get(),  -sizeH.get(),  0.0,
 *      sizeW.get(),  -sizeH.get(),  0.0 ];
 *
 * geom.vertexNormals = [
 *      0.0,  0.0,  1.0,
 *      0.0,  0.0,  1.0,
 *      0.0,  0.0,  1.0 ];
 *
 * geom.tangents = [
 *     1,0,0,
 *     1,0,0,
 *     1,0,0 ];
 *
 * geom.biTangents = [
 *     0,1,0,
 *     0,1,0,
 *     0,1,0 ];
 *
 * geom.texCoords = [
 *      0.5,  0.0,
 *      1.0,  1.0,
 *      0.0,  1.0, ];
 *
 * geom.verticesIndices = [
 *     0, 1, 2 ];
 *
 */

class Geometry
{
    isGeometry = true;

    /**
     * @param {String} name
    */
    constructor(name)
    {
        this.name = name || "unknown";
        this._log = new cables_shared_client__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A("cgl_geometry");

        this.faceVertCount = 3;
        this.glPrimitive = null;
        this._attributes = {};

        /** @type {Array|Float32Array} */
        this._vertices = [];

        /** @type {Array} */
        this.verticesIndices = [];

        this.morphTargets = [];
    }

    get vertices()
    {
        return this._vertices;
    }

    set vertices(v)
    {
        this.setVertices(v);
    }

    get texCoords()
    {
        const att = this.getAttribute("texCoords");
        if (!att) return [];
        return att.data;
    }

    set texCoords(v)
    {
        this.setAttribute("texCoords", v, 2);
    }

    get vertexNormals()
    {
        const att = this.getAttribute("vertexNormals");
        if (!att) return [];
        return att.data;
    }

    set vertexNormals(v)
    {
        this.setAttribute("vertexNormals", v, 3);
    }

    get tangents()
    {
        const att = this.getAttribute("tangents");
        if (!att) return [];
        return att.data;
    }

    set tangents(v)
    {
        this.setAttribute("tangents", v, 3);
    }

    get biTangents()
    {
        const att = this.getAttribute("biTangents");
        if (!att) return [];
        return att.data;
    }

    set biTangents(v)
    {
        this.setAttribute("biTangents", v, 3);
    }

    get vertexColors()
    {
        const att = this.getAttribute("vertexColors");
        if (!att) return [];
        return att.data;
    }

    set vertexColors(v)
    {
        this.setAttribute("vertexColors", v, 4);
    }

    /**
     * @description clear all buffers/set them to length 0
     */
    clear()
    {
        this._vertices = new Float32Array([]);
        this.verticesIndices = [];
        this.texCoords = new Float32Array([]);
        this.vertexNormals = new Float32Array([]);
        this.tangents = [];
        this.biTangents = [];
        this._attributes = {};
    }

    /**
    * @return {Object} returns array of attribute objects
    */
    getAttributes()
    {
        return this._attributes;
    }

    /**
     * @function getAttribute
     * @memberof Geometry
     * @instance
     * @param {String} name
     * @return {Object}
     */
    getAttribute(name)
    {
        for (const i in this._attributes)
        {
            if (this._attributes[i].name == name) return this._attributes[i];
        }
        return null;
    }

    /**
     * @function setAttribute
     * @description create an attribute
     * @memberof Geometry
     * @instance
     * @param {String} name
     * @param {Array} arr
     * @param {Number} itemSize
     */
    setAttribute(name, arr, itemSize)
    {
        let attrType = "";
        if (!itemSize || itemSize > 4)
        {
            this._log.warn("itemsize wrong?", itemSize, name);
            this._log.stack("itemsize");

            itemSize = 3;
        }

        if (itemSize == 1) attrType = "float";
        else if (itemSize == 2) attrType = "vec2";
        else if (itemSize == 3) attrType = "vec3";
        else if (itemSize == 4) attrType = "vec4";

        const attr = {
            "name": name,
            "data": arr,
            "itemSize": itemSize,
            "type": attrType,
        };

        this._attributes[name] = attr;
    }

    /**
     * @param {string} name
     * @param {Geometry} newgeom
     */
    copyAttribute(name, newgeom)
    {
        const attr = this.getAttribute(name);
        newgeom.setAttribute(name, new Float32Array(attr.data), attr.itemSize);
    }

    /**
     * @function setVertices
     * @memberof Geometry
     * @instance
     * @description set vertices
     * @param {Array|Float32Array} arr [x,y,z,x,y,z,...]
     */
    setVertices(arr)
    {
        if (arr instanceof Float32Array) this._vertices = arr;
        else this._vertices = new Float32Array(arr);
    }

    /**
     * set texcoords
     * @param {Array|Float32Array} arr [u,v,u,v,...]
     */
    setTexCoords(arr)
    {
        if (arr instanceof Float32Array) this.texCoords = arr;
        else this.texCoords = new Float32Array(arr);
    }

    // deprecated
    calcNormals(smooth)
    {
        const options = { "smooth": smooth };
        this.calculateNormals(options);
    }

    /**
     * @param {number} x
     * @param {number} y
     * @param {number} z
     */
    flipNormals(x, y, z)
    {
        let vec = gl_matrix__WEBPACK_IMPORTED_MODULE_1__.create();

        if (x == undefined)x = 1;
        if (y == undefined)y = 1;
        if (z == undefined)z = 1;

        for (let i = 0; i < this.vertexNormals.length; i += 3)
        {
            gl_matrix__WEBPACK_IMPORTED_MODULE_1__.set(vec,
                this.vertexNormals[i + 0],
                this.vertexNormals[i + 1],
                this.vertexNormals[i + 2]);

            vec[0] *= -x;
            vec[1] *= -y;
            vec[2] *= -z;

            gl_matrix__WEBPACK_IMPORTED_MODULE_1__.normalize(vec, vec);

            this.vertexNormals[i + 0] = vec[0];
            this.vertexNormals[i + 1] = vec[1];
            this.vertexNormals[i + 2] = vec[2];
        }
    }

    getNumTriangles()
    {
        if (this.verticesIndices && this.verticesIndices.length) return this.verticesIndices.length / 3;
        return this.vertices.length / 3;
    }

    /**
     * flip order of vertices in geom faces
     */
    flipVertDir()
    {
        const newInd = [];
        newInd.length = this.verticesIndices.length;
        for (let i = 0; i < this.verticesIndices.length; i += 3)
        {
            newInd[i] = this.verticesIndices[i + 2];
            newInd[i + 1] = this.verticesIndices[i + 1];
            newInd[i + 2] = this.verticesIndices[i];
        }
        this.verticesIndices = newInd;
    }

    /**
     * @param {Array} verts
     */
    setPointVertices(verts)
    {
        if (verts.length % 3 !== 0)
        {
            this._log.error("SetPointVertices: Array must be multiple of three.");
            return;
        }

        if (!(verts instanceof Float32Array)) this.vertices = new Float32Array(verts);
        else this.vertices = verts;

        if (!(this.texCoords instanceof Float32Array)) this.texCoords = new Float32Array((verts.length / 3) * 2);

        // this.texCoords.length=verts.length/3*2;
        this.verticesIndices.length = verts.length / 3;
        // this.verticesIndices=[];

        for (let i = 0; i < verts.length / 3; i++)
        {
            this.verticesIndices[i] = i;
            this.texCoords[i * 2] = 0;
            this.texCoords[i * 2 + 1] = 0;
        }
    }

    /**
     * merge a different geometry into the this geometry
     * @param {Geometry} geom
     */
    merge(geom)
    {
        if (!geom) return;

        if (this.isIndexed() != geom.isIndexed())
        {
            if (this.isIndexed())
            {
                this.unIndex(false, true);
            }
            if (geom.isIndexed())
            {
                const g = geom.copy();
                g.unIndex(false, true);
                geom = g;
            }
        }

        const oldIndizesLength = this.verticesIndices.length;
        const vertLength = this._vertices.length / 3;

        this.verticesIndices.length += geom.verticesIndices.length;
        for (let i = 0; i < geom.verticesIndices.length; i++)
            this.verticesIndices[oldIndizesLength + i] = geom.verticesIndices[i] + vertLength;

        this.vertices = cables__WEBPACK_IMPORTED_MODULE_2__.float32Concat(this._vertices, geom.vertices);
        this.texCoords = cables__WEBPACK_IMPORTED_MODULE_2__.float32Concat(this.texCoords, geom.texCoords);
        this.vertexNormals = cables__WEBPACK_IMPORTED_MODULE_2__.float32Concat(this.vertexNormals, geom.vertexNormals);
        this.tangents = cables__WEBPACK_IMPORTED_MODULE_2__.float32Concat(this.tangents, geom.tangents);
        this.biTangents = cables__WEBPACK_IMPORTED_MODULE_2__.float32Concat(this.biTangents, geom.biTangents);
    }

    /**
     *   a copy of the geometry
     * @function copy
     * @memberof Geometry
     * @instance
     */
    copy()
    {
        const geom = new Geometry(this.name + " copy");
        geom.faceVertCount = this.faceVertCount;
        geom.glPrimitive = this.glPrimitive;

        geom.setVertices(this._vertices.slice(0));

        if (this.verticesIndices)
        {
            geom.verticesIndices.length = this.verticesIndices.length;
            for (let i = 0; i < this.verticesIndices.length; i++) geom.verticesIndices[i] = this.verticesIndices[i];
        }

        for (let i in this._attributes) this.copyAttribute(i, geom);

        geom.morphTargets.length = this.morphTargets.length;
        for (let i = 0; i < this.morphTargets.length; i++) geom.morphTargets[i] = this.morphTargets[i];

        return geom;
    }

    /**
     * Calculaten normals
     * @function calculateNormals
     * @param {{ smooth?: any; forceZUp?: any; }} options
     */
    calculateNormals(options = null)
    {
        // todo: should check angle of normals to get edges    https://community.khronos.org/t/calculating-accurate-vertex-normals/28152
        options = options || {};
        if (options.smooth === false) this.unIndex();

        const u = gl_matrix__WEBPACK_IMPORTED_MODULE_1__.create();
        const v = gl_matrix__WEBPACK_IMPORTED_MODULE_1__.create();
        const n = gl_matrix__WEBPACK_IMPORTED_MODULE_1__.create();

        function calcNormal(triangle)
        {
            gl_matrix__WEBPACK_IMPORTED_MODULE_1__.subtract(u, triangle[0], triangle[1]);
            gl_matrix__WEBPACK_IMPORTED_MODULE_1__.subtract(v, triangle[0], triangle[2]);
            gl_matrix__WEBPACK_IMPORTED_MODULE_1__.cross(n, u, v);
            gl_matrix__WEBPACK_IMPORTED_MODULE_1__.normalize(n, n);

            if (options && options.forceZUp)
            {
                if (n[2] < 0)
                {
                    n[0] *= -1;
                    n[1] *= -1;
                    n[2] *= -1;
                }
            }
            return n;
        }

        this.getVertexVec = function (which)
        {
            const vec = [0, 0, 0];
            vec[0] = this.vertices[which * 3 + 0];
            vec[1] = this.vertices[which * 3 + 1];
            vec[2] = this.vertices[which * 3 + 2];
            return vec;
        };

        if (!(this.vertexNormals instanceof Float32Array) || this.vertexNormals.length != this.vertices.length) this.vertexNormals = new Float32Array(this.vertices.length);

        for (let i = 0; i < this.vertices.length; i++)
        {
            this.vertexNormals[i] = 0;
        }

        if (!this.isIndexed())
        {
            const norms = [];
            for (let i = 0; i < this.vertices.length; i += 9)
            {
                const triangle = [[this.vertices[i + 0], this.vertices[i + 1], this.vertices[i + 2]], [this.vertices[i + 3], this.vertices[i + 4], this.vertices[i + 5]], [this.vertices[i + 6], this.vertices[i + 7], this.vertices[i + 8]]];
                const nn = calcNormal(triangle);
                norms.push(nn[0], nn[1], nn[2], nn[0], nn[1], nn[2], nn[0], nn[1], nn[2]);
            }
            this.vertexNormals = norms;
        }
        else
        {
            const faceNormals = [];

            faceNormals.length = Math.floor(this.verticesIndices.length / 3);

            for (let i = 0; i < this.verticesIndices.length; i += 3)
            {
                const triangle = [this.getVertexVec(this.verticesIndices[i + 0]), this.getVertexVec(this.verticesIndices[i + 1]), this.getVertexVec(this.verticesIndices[i + 2])];

                faceNormals[i / 3] = calcNormal(triangle);

                this.vertexNormals[this.verticesIndices[i + 0] * 3 + 0] += faceNormals[i / 3][0];
                this.vertexNormals[this.verticesIndices[i + 0] * 3 + 1] += faceNormals[i / 3][1];
                this.vertexNormals[this.verticesIndices[i + 0] * 3 + 2] += faceNormals[i / 3][2];

                this.vertexNormals[this.verticesIndices[i + 1] * 3 + 0] += faceNormals[i / 3][0];
                this.vertexNormals[this.verticesIndices[i + 1] * 3 + 1] += faceNormals[i / 3][1];
                this.vertexNormals[this.verticesIndices[i + 1] * 3 + 2] += faceNormals[i / 3][2];

                this.vertexNormals[this.verticesIndices[i + 2] * 3 + 0] += faceNormals[i / 3][0];
                this.vertexNormals[this.verticesIndices[i + 2] * 3 + 1] += faceNormals[i / 3][1];
                this.vertexNormals[this.verticesIndices[i + 2] * 3 + 2] += faceNormals[i / 3][2];
            }

            for (let i = 0; i < this.verticesIndices.length; i += 3) // faces
            {
                for (let k = 0; k < 3; k++) // triangles
                {
                    const vv = [this.vertexNormals[this.verticesIndices[i + k] * 3 + 0], this.vertexNormals[this.verticesIndices[i + k] * 3 + 1], this.vertexNormals[this.verticesIndices[i + k] * 3 + 2]];
                    gl_matrix__WEBPACK_IMPORTED_MODULE_1__.normalize(vv, vv);
                    this.vertexNormals[this.verticesIndices[i + k] * 3 + 0] = vv[0];
                    this.vertexNormals[this.verticesIndices[i + k] * 3 + 1] = vv[1];
                    this.vertexNormals[this.verticesIndices[i + k] * 3 + 2] = vv[2];
                }
            }
        }
    }

    /**
     * Calculates tangents & bitangents with the help of uv-coordinates. Adapted from
     * Lengyel, Eric. “Computing Tangent Space Basis Vectors for an Arbitrary Mesh”.
     * Terathon Software 3D Graphics Library.
     * https://fenix.tecnico.ulisboa.pt/downloadFile/845043405449073/Tangent%20Space%20Calculation.pdf
     *
     * @function calcTangentsBitangents
     */
    calcTangentsBitangents()
    {
        if (!this.vertices.length)
        {
            // this._log.error("Cannot calculate tangents/bitangents without vertices.");
            return;
        }
        if (!this.vertexNormals.length)
        {
            // this._log.error("Cannot calculate tangents/bitangents without normals.");
            return;
        }
        if (!this.texCoords.length)
        {
            const texCoordLength = (this.vertices.length / 3) * 2;
            this.texCoords = new Float32Array(texCoordLength);
            for (let i = 0; i < texCoordLength; i += 1) this.texCoords[i] = 0;
        }
        if (!this.verticesIndices || !this.verticesIndices.length)
        {
            // this._log.error("Cannot calculate tangents/bitangents without vertex indices.");
            return;
        }
        // this code assumes that we have three indices per triangle
        if (this.verticesIndices.length % 3 !== 0)
        {
            this._log.error("Vertex indices mismatch!");
            return;
        }

        const triangleCount = this.verticesIndices.length / 3;
        const vertexCount = this.vertices.length / 3;

        this.tangents = new Float32Array(this.vertexNormals.length);
        this.biTangents = new Float32Array(this.vertexNormals.length);

        // temporary buffers
        const tempVertices = [];
        tempVertices.length = vertexCount * 2;
        const v1 = gl_matrix__WEBPACK_IMPORTED_MODULE_1__.create();
        const v2 = gl_matrix__WEBPACK_IMPORTED_MODULE_1__.create();
        const v3 = gl_matrix__WEBPACK_IMPORTED_MODULE_1__.create();

        const w1 = gl_matrix__WEBPACK_IMPORTED_MODULE_3__.create();
        const w2 = gl_matrix__WEBPACK_IMPORTED_MODULE_3__.create();
        const w3 = gl_matrix__WEBPACK_IMPORTED_MODULE_3__.create();

        const sdir = gl_matrix__WEBPACK_IMPORTED_MODULE_1__.create();
        const tdir = gl_matrix__WEBPACK_IMPORTED_MODULE_1__.create();

        // for details on calculation, see article referenced above
        for (let tri = 0; tri < triangleCount; tri += 1)
        {
            // indices of the three vertices for a triangle
            const i1 = this.verticesIndices[tri * 3];
            const i2 = this.verticesIndices[tri * 3 + 1];
            const i3 = this.verticesIndices[tri * 3 + 2];

            // vertex position as vec3
            gl_matrix__WEBPACK_IMPORTED_MODULE_1__.set(v1, this.vertices[i1 * 3], this.vertices[i1 * 3 + 1], this.vertices[i1 * 3 + 2]);
            gl_matrix__WEBPACK_IMPORTED_MODULE_1__.set(v2, this.vertices[i2 * 3], this.vertices[i2 * 3 + 1], this.vertices[i2 * 3 + 2]);
            gl_matrix__WEBPACK_IMPORTED_MODULE_1__.set(v3, this.vertices[i3 * 3], this.vertices[i3 * 3 + 1], this.vertices[i3 * 3 + 2]);

            // texture coordinate as vec2
            gl_matrix__WEBPACK_IMPORTED_MODULE_3__.set(w1, this.texCoords[i1 * 2], this.texCoords[i1 * 2 + 1]);
            gl_matrix__WEBPACK_IMPORTED_MODULE_3__.set(w2, this.texCoords[i2 * 2], this.texCoords[i2 * 2 + 1]);
            gl_matrix__WEBPACK_IMPORTED_MODULE_3__.set(w3, this.texCoords[i3 * 2], this.texCoords[i3 * 2 + 1]);

            const x1 = v2[0] - v1[0];
            const x2 = v3[0] - v1[0];
            const y1 = v2[1] - v1[1];
            const y2 = v3[1] - v1[1];
            const z1 = v2[2] - v1[2];
            const z2 = v3[2] - v1[2];

            const s1 = w2[0] - w1[0];
            const s2 = w3[0] - w1[0];
            const t1 = w2[1] - w1[1];
            const t2 = w3[1] - w1[1];

            const r = 1.0 / (s1 * t2 - s2 * t1);

            gl_matrix__WEBPACK_IMPORTED_MODULE_1__.set(sdir, (t2 * x1 - t1 * x2) * r, (t2 * y1 - t1 * y2) * r, (t2 * z1 - t1 * z2) * r);
            gl_matrix__WEBPACK_IMPORTED_MODULE_1__.set(tdir, (s1 * x2 - s2 * x1) * r, (s1 * y2 - s2 * y1) * r, (s1 * z2 - s2 * z1) * r);

            tempVertices[i1] = sdir;
            tempVertices[i2] = sdir;
            tempVertices[i3] = sdir;

            tempVertices[i1 + vertexCount] = tdir;
            tempVertices[i2 + vertexCount] = tdir;
            tempVertices[i3 + vertexCount] = tdir;
        }

        const normal = gl_matrix__WEBPACK_IMPORTED_MODULE_1__.create();
        const tempVert = gl_matrix__WEBPACK_IMPORTED_MODULE_1__.create();
        const tan = gl_matrix__WEBPACK_IMPORTED_MODULE_1__.create();
        const bitan = gl_matrix__WEBPACK_IMPORTED_MODULE_1__.create();
        const temp1 = gl_matrix__WEBPACK_IMPORTED_MODULE_1__.create();
        const temp2 = gl_matrix__WEBPACK_IMPORTED_MODULE_1__.create();
        const crossPd = gl_matrix__WEBPACK_IMPORTED_MODULE_1__.create();
        const normalized = gl_matrix__WEBPACK_IMPORTED_MODULE_1__.create();

        for (let vert = 0; vert < vertexCount; vert += 1)
        {
            // NOTE: some meshes don't have index 0 - n in their indexbuffer, if this is the case, skip calculation of this vertex
            if (!tempVertices[vert]) continue;

            gl_matrix__WEBPACK_IMPORTED_MODULE_1__.set(normal, this.vertexNormals[vert * 3], this.vertexNormals[vert * 3 + 1], this.vertexNormals[vert * 3 + 2]);
            gl_matrix__WEBPACK_IMPORTED_MODULE_1__.set(tempVert, tempVertices[vert][0], tempVertices[vert][1], tempVertices[vert][2]);

            // Gram-Schmidt orthagonalize
            const _dp = gl_matrix__WEBPACK_IMPORTED_MODULE_1__.dot(normal, tempVert);
            gl_matrix__WEBPACK_IMPORTED_MODULE_1__.scale(temp1, normal, _dp);
            gl_matrix__WEBPACK_IMPORTED_MODULE_1__.subtract(temp2, tempVert, temp1);

            gl_matrix__WEBPACK_IMPORTED_MODULE_1__.normalize(normalized, temp2);
            gl_matrix__WEBPACK_IMPORTED_MODULE_1__.cross(crossPd, normal, tempVert);

            // const intermDot = vec3.dot(crossPd, tempVertices[vert + vertexCount]);
            const w = 1.0;// intermDot < 0.0 ? -1.0 : 1.0;

            gl_matrix__WEBPACK_IMPORTED_MODULE_1__.scale(tan, normalized, 1 / w);
            gl_matrix__WEBPACK_IMPORTED_MODULE_1__.cross(bitan, normal, tan);

            this.tangents[vert * 3 + 0] = tan[0];
            this.tangents[vert * 3 + 1] = tan[1];
            this.tangents[vert * 3 + 2] = tan[2];
            this.biTangents[vert * 3 + 0] = bitan[0];
            this.biTangents[vert * 3 + 1] = bitan[1];
            this.biTangents[vert * 3 + 2] = bitan[2];
        }
    }

    isIndexed()
    {
        if (this._vertices.length == 0) return true;
        return this.verticesIndices.length != 0;
    }

    /**
     * @function unIndex
     * @memberof Geometry
     * @instance
     * @description remove all vertex indizes, vertices array will contain 3*XYZ for every triangle
     * @param {boolean} reIndex
     * @param {boolean} dontCalcNormals
     */
    unIndex(reIndex = false, dontCalcNormals = false)
    {
        const newVerts = [];
        const newIndizes = [];
        let count = 0;

        for (let j in this._attributes)
        {
            const attr = this._attributes[j];
            let na = [];

            for (let i = 0; i < this.verticesIndices.length; i += 3)
            {
                for (let s = 0; s < 3; s++)
                {
                    if (attr.itemSize == 3)
                        na.push(
                            attr.data[this.verticesIndices[i + s] * 3 + 0],
                            attr.data[this.verticesIndices[i + s] * 3 + 1],
                            attr.data[this.verticesIndices[i + s] * 3 + 2]);
                    else if (attr.itemSize == 4)
                        na.push(
                            attr.data[this.verticesIndices[i + s] * 4 + 0],
                            attr.data[this.verticesIndices[i + s] * 4 + 1],
                            attr.data[this.verticesIndices[i + s] * 4 + 2],
                            attr.data[this.verticesIndices[i + s] * 4 + 3]);
                    else if (attr.itemSize == 2)
                        na.push(
                            attr.data[this.verticesIndices[i + s] * 2 + 0],
                            attr.data[this.verticesIndices[i + s] * 2 + 1]);
                    else if (attr.itemSize == 1)
                        na.push(
                            attr.data[this.verticesIndices[i + s]]);
                    else this._log.warn("unknown attr", attr);
                }
            }
            this.setAttribute(attr.name, na, attr.itemSize);
        }

        for (let i = 0; i < this.verticesIndices.length; i += 3)
        {
            newVerts.push(
                this.vertices[this.verticesIndices[i + 0] * 3 + 0],
                this.vertices[this.verticesIndices[i + 0] * 3 + 1],
                this.vertices[this.verticesIndices[i + 0] * 3 + 2]);

            newIndizes.push(count);
            count++;

            newVerts.push(
                this.vertices[this.verticesIndices[i + 1] * 3 + 0],
                this.vertices[this.verticesIndices[i + 1] * 3 + 1],
                this.vertices[this.verticesIndices[i + 1] * 3 + 2]);

            newIndizes.push(count);
            count++;

            newVerts.push(
                this.vertices[this.verticesIndices[i + 2] * 3 + 0],
                this.vertices[this.verticesIndices[i + 2] * 3 + 1],
                this.vertices[this.verticesIndices[i + 2] * 3 + 2]);

            newIndizes.push(count);
            count++;
        }

        this.vertices = newVerts;

        this.verticesIndices = [];
        if (reIndex) this.verticesIndices = newIndizes;

        if (!dontCalcNormals) this.calculateNormals();
    }

    calcBarycentric()
    {
        let barycentrics = [];
        barycentrics.length = this.vertices.length;
        for (let i = 0; i < this.vertices.length; i++) barycentrics[i] = 0;

        let count = 0;
        for (let i = 0; i < this.vertices.length; i += 3)
        {
            barycentrics[i + count] = 1;
            count++;
            if (count == 3) count = 0;
        }

        this.setAttribute("attrBarycentric", barycentrics, 3);
    }

    getBounds()
    {
        return new _cg_boundingbox_js__WEBPACK_IMPORTED_MODULE_4__/* .BoundingBox */ .I(this);
    }

    /**
     * @param {boolean} x
     * @param {boolean} y
     * @param {boolean} z
     * @returns {Array} offset
     */
    center(x, y, z)
    {
        if (x === undefined)
        {
            x = true;
            y = true;
            z = true;
        }

        let i = 0;
        const bounds = this.getBounds();
        const offset = [bounds.minX + (bounds.maxX - bounds.minX) / 2, bounds.minY + (bounds.maxY - bounds.minY) / 2, bounds.minZ + (bounds.maxZ - bounds.minZ) / 2];

        for (i = 0; i < this.vertices.length; i += 3)
        {
            if (this.vertices[i + 0] == this.vertices[i + 0])
            {
                if (x) this.vertices[i + 0] -= offset[0];
                if (y) this.vertices[i + 1] -= offset[1];
                if (z) this.vertices[i + 2] -= offset[2];
            }
        }

        return offset;
    }

    mapTexCoords2d()
    {
        const bounds = this.getBounds();
        const num = this.vertices.length / 3;

        this.texCoords = new Float32Array(num * 2);

        for (let i = 0; i < num; i++)
        {
            const vertX = this.vertices[i * 3 + 0];
            const vertY = this.vertices[i * 3 + 1];
            this.texCoords[i * 2 + 0] = vertX / (bounds.maxX - bounds.minX) + 0.5;
            this.texCoords[i * 2 + 1] = 1.0 - vertY / (bounds.maxY - bounds.minY) + 0.5;
        }
    }

    getInfoOneLine()
    {
        let txt = "";
        if (this.faceVertCount == 3 && this.verticesIndices)txt += this.verticesIndices.length / 3;
        else txt += 0;

        txt += " tris ";

        if (this.vertices)txt += this.vertices.length / 3;
        else txt += 0;

        txt += " verts";

        return txt;
    }

    getInfo()
    {
        const info = {};

        info.name = this.name;
        info.class = this.constructor.name;

        if (this.faceVertCount == 3 && this.verticesIndices)info.numFaces = this.verticesIndices.length / 3;
        else info.numFaces = 0;

        if (this.verticesIndices && this.verticesIndices.length)info.indices = this.verticesIndices.length;

        if (this.vertices)info.numVerts = this.vertices.length / 3;
        else info.numVerts = 0;

        if (this.vertexNormals) info.numNormals = this.vertexNormals.length / 3;
        else info.numNormals = 0;

        if (this.texCoords) info.numTexCoords = this.texCoords.length / 2;
        else info.numTexCoords = 0;

        if (this.tangents) info.numTangents = this.tangents.length / 3;
        else info.numTangents = 0;

        if (this.biTangents) info.numBiTangents = this.biTangents.length / 3;
        else info.numBiTangents = 0;

        if (this.biTangents) info.numBiTangents = this.biTangents.length / 3;
        else info.numBiTangents = 0;

        if (this.vertexColors) info.numVertexColors = this.vertexColors.length / 4;
        else info.numVertexColors = 0;

        if (this.getAttributes()) info.numAttribs = Object.keys(this.getAttributes()).length;
        else info.numAttribs = 0;

        info.isIndexed = this.isIndexed();

        return info;
    }

    // -----------------
}

// TODO : rewritwe circle op 1
/** @deprecated */
Geometry.buildFromFaces = function (arr, name, optimize)
{
    const vertices = [];
    const verticesIndices = [];

    for (let i = 0; i < arr.length; i += 3)
    {
        const a = arr[i + 0];
        const b = arr[i + 1];
        const c = arr[i + 2];
        const face = [-1, -1, -1];

        if (optimize)
            for (let iv = 0; iv < vertices.length; iv += 3)
            {
                if (vertices[iv + 0] == a[0] && vertices[iv + 1] == a[1] && vertices[iv + 2] == a[2]) face[0] = iv / 3;
                if (vertices[iv + 0] == b[0] && vertices[iv + 1] == b[1] && vertices[iv + 2] == b[2]) face[1] = iv / 3;
                if (vertices[iv + 0] == c[0] && vertices[iv + 1] == c[1] && vertices[iv + 2] == c[2]) face[2] = iv / 3;
            }

        if (face[0] == -1)
        {
            vertices.push(a[0], a[1], a[2]);
            face[0] = (vertices.length - 1) / 3;
        }

        if (face[1] == -1)
        {
            vertices.push(b[0], b[1], b[2]);
            face[1] = (vertices.length - 1) / 3;
        }

        if (face[2] == -1)
        {
            vertices.push(c[0], c[1], c[2]);
            face[2] = (vertices.length - 1) / 3;
        }

        verticesIndices.push(face[0]);
        verticesIndices.push(face[1]);
        verticesIndices.push(face[2]);
    }

    const geom = new Geometry(name);
    geom.name = name;
    geom.vertices = vertices;
    geom.verticesIndices = verticesIndices;

    return geom;
};


/***/ }),

/***/ 868:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   u: () => (/* binding */ MatrixStack)
/* harmony export */ });
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(684);


class MatrixStack
{
    constructor()
    {
        this._arr = [gl_matrix__WEBPACK_IMPORTED_MODULE_0__.create()];
        this._index = 0;
        this.stateCounter = 0;
    }

    /**
     * @param {mat4} m
     */
    push(m)
    {
        this._index++;
        this.stateCounter++;

        if (this._index == this._arr.length)
        {
            const copy = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.create();
            this._arr.push(copy);
        }

        gl_matrix__WEBPACK_IMPORTED_MODULE_0__.copy(this._arr[this._index], m || this._arr[this._index - 1]);

        return this._arr[this._index];
    }

    pop()
    {
        this.stateCounter++;

        this._index--;
        if (this._index < 0) this._index = 0;

        return this._arr[this._index];
    }

    length()
    {
        return this._index;
    }
}


/***/ }),

/***/ 434:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   w: () => (/* binding */ CgMesh)
/* harmony export */ });
class CgMesh
{
    _name = "unknown";

    constructor()
    {
    }

}


/***/ }),

/***/ 694:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   U: () => (/* binding */ CgShader)
/* harmony export */ });
/* harmony import */ var cables_shared_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(125);
/* harmony import */ var cables__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(562);



/**
 * @typedef ShaderModule
 * @property {String} title
 * @property {String} name
 * @property {Number} id
 * @property {Number} numId
 * @property {String} group
 * @property {String} prefix
 * @property {Number} priority
 * @property {Number} num
 * @property {String} attributes
 * @property {String} srcBodyFrag
 * @property {String} srcBodyVert
 * @property {String} srcHeadFrag
 * @property {String} srcHeadVert
  */

class CgShader extends cables_shared_client__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A
{
    id = cables__WEBPACK_IMPORTED_MODULE_1__.simpleId();
    _isValid = true;

    /** @type {Array<Array<String>>} */
    _defines = [];

    /** @type {Array<String>} */
    _moduleNames = [];

    _moduleNumId = 0;
    _needsRecompile = true;
    _compileReason = "initial";

    /** @type {Array<ShaderModule>} */
    _modules = [];

    _compileCount = 0;

    logError = true;
    num = -1;
    lastCompile = 0;

    constructor()
    {
        super();
    }

    /**
     * @param {string} reason
     */
    setWhyCompile(reason)
    {
        this._compileReason = reason;
        this._needsRecompile = true;
    }

    getWhyCompile()
    {
        return this._compileReason;
    }

    needsRecompile()
    {
        return this._needsRecompile;
    }

    /**
     * @param {string} name
     */
    removeUniform(name)
    {
        for (let i = 0; i < this._uniforms.length; i++)
        {
            if (this._uniforms[i].getName() == name)
            {
                this._uniforms.splice(i, 1);
            }
        }
        this.setWhyCompile("remove uniform " + name);
    }

    /**
     * @param {String} name
     * @param {number} stage
     */
    hasUniformInStage(name, stage)
    {

        let binding = this.defaultUniBindingFrag;
        if (stage == GPUShaderStage.VERTEX) binding = this.defaultUniBindingVert;
        if (stage == GPUShaderStage.COMPUTE) binding = this.defaultUniBindingCompute;

        for (let i = 0; i < this._uniforms.length; i++)
        {

            console.log("hasuniiiiiiiiiiiiiii", this._uniforms[i].getName(), name);
            if (this._uniforms[i].getName() == name) return true;
        }
        return false;
    }

    /**
     * @param {String} name
     */
    hasUniform(name)
    {
    }

    /**
     * easily enable/disable a define without a value
     * @param {String} name
     * @param {Port|boolean} enabled value or port
     */
    toggleDefine(name, enabled)
    {
        if (enabled && typeof (enabled) == "object" && enabled.addEventListener) // port
        {
            if (enabled.changeListener)enabled.off(enabled.changeListener);

            enabled.onToggleDefine = (v) =>
            {
                this.toggleDefine(name, v);
            };

            enabled.changeListener = enabled.on("change", enabled.onToggleDefine);
            enabled = enabled.get();
        }

        if (enabled) this.define(name);
        else this.removeDefine(name);
    }

    /**
     * add a define to a shader, e.g.  #define DO_THIS_THAT 1
     * @param {String} name
     * @param {any} value (can be empty)
     */
    define(name, value = "")
    {
        if (value === null || value === undefined) value = "";

        if (typeof (value) == "object") // port
        {
            value.removeEventListener("change", value.onDefineChange);
            value.onDefineChange = (v) =>
            {
                this.define(name, v);
            };
            value.on("change", value.onDefineChange);

            value = value.get();
        }

        for (let i = 0; i < this._defines.length; i++)
        {
            if (this._defines[i][0] == name && this._defines[i][1] == value) return;
            if (this._defines[i][0] == name)
            {
                this._defines[i][1] = value;
                this.setWhyCompile("define " + name + " " + value);
                return;
            }
        }
        this.setWhyCompile("define " + name + " " + value);

        this._defines.push([name, value]);
    }

    getDefines()
    {
        return this._defines;
    }

    /**
     * @param {string} name
     */
    getDefine(name)
    {
        for (let i = 0; i < this._defines.length; i++)
            if (this._defines[i][0] == name) return this._defines[i][1];
        return null;
    }

    /**
     * return true if shader has define
     * @function hasDefine
     * @memberof Shader
     * @instance
     * @param {String} name
     * @return {Boolean}
     */
    hasDefine(name)
    {
        for (let i = 0; i < this._defines.length; i++)
            if (this._defines[i][0] == name) return true;
    }

    /**
     * remove a define from a shader
     * @param {string} name
     */
    removeDefine(name)
    {
        for (let i = 0; i < this._defines.length; i++)
        {
            if (this._defines[i][0] == name)
            {
                this._defines.splice(i, 1);
                this.setWhyCompile("define removed:" + name);
                return;
            }
        }
    }

    /**
     * @param {any} modId
     */
    hasModule(modId)
    {
        for (let i = 0; i < this._modules.length; i++)
            if (this._modules[i].id == modId) return true;

        return false;
    }

    /**
     *
     * @param {Array<String>} names
     */
    setModules(names)
    {
        this._moduleNames = names;
    }

    /**
     * remove a module from shader
     * @param {ShaderModule} mod the module to be removed
     */
    removeModule(mod)
    {
        for (let i = 0; i < this._modules.length; i++)
        {
            if (mod && mod.id)
            {
                if (this._modules[i].id == mod.id || !this._modules[i])
                {
                    let found = true;
                    while (found)
                    {
                        found = false;
                        for (let j = 0; j < this._uniforms.length; j++)
                        {
                            if (this._uniforms[j].getName().startsWith(mod.prefix))
                            {
                                this._uniforms.splice(j, 1);
                                found = true;
                                continue;
                            }
                        }
                    }

                    this.setWhyCompile("remove module " + mod.title);
                    this._modules.splice(i, 1);
                    break;
                }
            }
        }
    }

    getNumModules()
    {
        return this._modules.length;
    }

    getCurrentModules() { return this._modules; }

    /**
     * add a module
     * @param {ShaderModule} mod the module to be added
     * @param {ShaderModule} [sibling] sibling module, new module will share the same group
     */
    addModule(mod, sibling)
    {
        if (this.hasModule(mod.id)) return;
        if (!mod.id) mod.id = cables__WEBPACK_IMPORTED_MODULE_1__.simpleId();
        if (!mod.numId) mod.numId = this._moduleNumId;
        if (!mod.num)mod.num = this._modules.length;
        if (sibling && !sibling.group) sibling.group = cables__WEBPACK_IMPORTED_MODULE_1__.simpleId();

        if (!mod.group)
            if (sibling) mod.group = sibling.group;
            else mod.group = cables__WEBPACK_IMPORTED_MODULE_1__.simpleId();

        mod.prefix = "mod" + mod.group + "_";
        this._modules.push(mod);

        this.setWhyCompile("add module " + mod.title);
        this._moduleNumId++;

        return mod;
    }

    isValid()
    {
        return this._isValid;
    }

}


/***/ }),

/***/ 356:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   U: () => (/* binding */ CgTexture)
/* harmony export */ });
/* harmony import */ var cables__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(562);


const DEFAULT_TEXTURE_SIZE = 8;

/**
 * @typedef {Object} CglTextureOptions
 * @property {number} [width]
 * @property {number} [height]
 * @property {string} [pixelformat]
 */
class CgTexture
{

    /**
     * @param {CglTextureOptions} options={}
     */
    constructor(options = {})
    {
        this.id = cables__WEBPACK_IMPORTED_MODULE_0__.uuid();
        this.width = 0;
        this.height = 0;
        this.name = "unknown";

        options = options || {};
        this.pixelFormat = options.pixelFormat || CgTexture.PFORMATSTR_RGBA8UB;

        this.name = options.name || "unknown";

        if (!options.width) options.width = DEFAULT_TEXTURE_SIZE;
        if (!options.height) options.height = DEFAULT_TEXTURE_SIZE;
    }
}

CgTexture.getDefaultTextureData = (name, size, options = {}) =>
{
    if (name == "empty")
    {
        return new Uint8Array(size * size * 4).fill(0);
    }
    else
    if (name == "color")
    {
        const data = new Uint8Array(size * size * 4);
        let r = options.r || 1;
        let g = options.g || 1;
        let b = options.b || 1;

        for (let x = 0; x < size * size; x++)
        {
            data[x * 4 + 0] = r;
            data[x * 4 + 1] = g;
            data[x * 4 + 2] = b;
            data[x * 4 + 3] = 255;
        }
        return data;
    }
    else
    if (name == "randomUInt")
    {
        const data = new Uint8Array(size * size * 4);

        for (let x = 0; x < size * size; x++)
        {
            data[x * 4 + 0] = Math.random() * 255;
            data[x * 4 + 1] = Math.random() * 255;
            data[x * 4 + 2] = Math.random() * 255;
            data[x * 4 + 3] = 255;
        }
        return data;
    }
    else
    if (name == "random" || name == "randomFloat")
    {
        const data = new Float32Array(size * size * 4);

        for (let x = 0; x < size * size; x++)
        {
            data[x * 4 + 0] = (Math.random() - 0.5) * 2.0;
            data[x * 4 + 1] = (Math.random() - 0.5) * 2.0;
            data[x * 4 + 2] = (Math.random() - 0.5) * 2.0;
            data[x * 4 + 3] = 1;
        }
        return data;
    }
    else
    if (name == "stripes")
    {
        const arr = [];

        let r = options.r;
        let g = options.g;
        let b = options.b;

        if (r === undefined)r = 1;
        if (g === undefined)g = 1;
        if (b === undefined)b = 1;

        for (let y = 0; y < size; y++)
        {
            for (let x = 0; x < size; x++)
            {
                if ((x + y) % 64 < 32)
                {
                    arr.push((200 + (y / size) * 25 + (x / size) * 25) * r);
                    arr.push((200 + (y / size) * 25 + (x / size) * 25) * g);
                    arr.push((200 + (y / size) * 25 + (x / size) * 25) * b);
                }
                else
                {
                    arr.push((40 + (y / size) * 25 + (x / size) * 25) * r);
                    arr.push((40 + (y / size) * 25 + (x / size) * 25) * g);
                    arr.push((40 + (y / size) * 25 + (x / size) * 25) * b);
                }
                arr.push(255);
            }
        }

        return new Uint8Array(arr);
    }
    else
    {
        console.warn("unknown default texture", name);
        return CgTexture.getDefaultTextureData("stripes", size, { "r": 1, "g": 0, "b": 0 });
    }
};

CgTexture.FILTER_NEAREST = 0;
CgTexture.FILTER_LINEAR = 1;
CgTexture.FILTER_MIPMAP = 2;

CgTexture.WRAP_REPEAT = 0;
CgTexture.WRAP_MIRRORED_REPEAT = 1;
CgTexture.WRAP_CLAMP_TO_EDGE = 2;

CgTexture.TYPE_DEFAULT = 0;
CgTexture.TYPE_DEPTH = 1;
CgTexture.TYPE_FLOAT = 2;

CgTexture.PFORMATSTR_RGB565 = "RGB 5/6/5bit ubyte";

CgTexture.PFORMATSTR_R8UB = "R 8bit ubyte";
CgTexture.PFORMATSTR_RG8UB = "RG 8bit ubyte";
CgTexture.PFORMATSTR_RGB8UB = "RGB 8bit ubyte";
CgTexture.PFORMATSTR_RGBA8UB = "RGBA 8bit ubyte";

CgTexture.PFORMATSTR_SRGBA8 = "SRGBA 8bit ubyte";

CgTexture.PFORMATSTR_R11FG11FB10F = "RGB 11/11/10bit float";

CgTexture.PFORMATSTR_R16F = "R 16bit float";
CgTexture.PFORMATSTR_RG16F = "RG 16bit float";
CgTexture.PFORMATSTR_RGB16F = "RGB 16bit float";
CgTexture.PFORMATSTR_RGBA16F = "RGBA 16bit float";

CgTexture.PFORMATSTR_R32F = "R 32bit float";
CgTexture.PFORMATSTR_RG32F = "RG 32bit float";
CgTexture.PFORMATSTR_RGB32F = "RGB 32bit float";
CgTexture.PFORMATSTR_RGBA32F = "RGBA 32bit float";

CgTexture.PFORMATSTR_DEPTH = "DEPTH";

CgTexture.PIXELFORMATS = [

    CgTexture.PFORMATSTR_RGB565,

    CgTexture.PFORMATSTR_R8UB,
    CgTexture.PFORMATSTR_RG8UB,
    CgTexture.PFORMATSTR_RGB8UB,
    CgTexture.PFORMATSTR_RGBA8UB,

    CgTexture.PFORMATSTR_SRGBA8,

    CgTexture.PFORMATSTR_R11FG11FB10F,
    CgTexture.PFORMATSTR_R16F,
    CgTexture.PFORMATSTR_RG16F,
    CgTexture.PFORMATSTR_RGBA16F,

    CgTexture.PFORMATSTR_R32F,
    CgTexture.PFORMATSTR_RGBA32F

];


/***/ }),

/***/ 475:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   v: () => (/* binding */ CgUniform)
/* harmony export */ });
/* harmony import */ var cables_shared_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(849);
/* harmony import */ var cables__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(50);




class CgUniform
{

    /**
     * Description
     * @param {CgShader|CgpShader|Shader} __shader
     * @param {string} __type
     * @param {string} __name
     * @param {Number|Port} _value
     * @param {Port} _port2
     * @param {Port} _port3
     * @param {Port} _port4
     */
    constructor(__shader, __type, __name, _value, _port2, _port3, _port4, _structUniformName, _structName, _propertyName)
    {
        this._log = new cables_shared_client__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A("cg_uniform");
        this._type = __type;
        this._name = __name;

        /** @type {CgShader} */
        this._shader = __shader;
        this._value = 0.00001;
        this._oldValue = null;
        this._port = null;

        this._structName = _structName;
        this._structUniformName = _structUniformName;
        this._propertyName = _propertyName;

        if (this._shader._addUniform) this._shader._addUniform(this);
        this.needsUpdate = true;
        this.shaderType = null;
        this.comment = null;

        if (__type == "f")
        {
            this.set = this.setValue = this.setValueF.bind(this);
            this.updateValue = this.updateValueF.bind(this);
        }
        else if (__type == "f[]")
        {
            this.set = this.setValue = this.setValueArrayF.bind(this);
            this.updateValue = this.updateValueArrayF.bind(this);
        }
        else if (__type == "2f[]")
        {
            this.set = this.setValue = this.setValueArray2F.bind(this);
            this.updateValue = this.updateValueArray2F.bind(this);
        }
        else if (__type == "3f[]")
        {
            this.set = this.setValue = this.setValueArray3F.bind(this);
            this.updateValue = this.updateValueArray3F.bind(this);
        }
        else if (__type == "4f[]")
        {
            this.set = this.setValue = this.setValueArray4F.bind(this);
            this.updateValue = this.updateValueArray4F.bind(this);
        }
        else if (__type == "i")
        {
            this.set = this.setValue = this.setValueI.bind(this);
            this.updateValue = this.updateValueI.bind(this);
        }
        else if (__type == "2i")
        {
            this.set = this.setValue = this.setValue2I.bind(this);
            this.updateValue = this.updateValue2I.bind(this);
        }
        else if (__type == "3i")
        {
            this.set = this.setValue = this.setValue3I.bind(this);
            this.updateValue = this.updateValue3I.bind(this);
        }
        else if (__type == "4i")
        {
            this.set = this.setValue = this.setValue4I.bind(this);
            this.updateValue = this.updateValue4I.bind(this);
        }
        else if (__type == "b")
        {
            this.set = this.setValue = this.setValueBool.bind(this);
            this.updateValue = this.updateValueBool.bind(this);
        }
        else if (__type == "4f")
        {
            this.set = this.setValue = this.setValue4F.bind(this);
            this.updateValue = this.updateValue4F.bind(this);
        }
        else if (__type == "3f")
        {
            this.set = this.setValue = this.setValue3F.bind(this);
            this.updateValue = this.updateValue3F.bind(this);
        }
        else if (__type == "2f")
        {
            this.set = this.setValue = this.setValue2F.bind(this);
            this.updateValue = this.updateValue2F.bind(this);
        }
        else if (__type == "t")
        {
            this.set = this.setValue = this.setValueT.bind(this);
            this.updateValue = this.updateValueT.bind(this);
        }
        else if (__type == "sampler")
        {
            if (this.setValueAny)
            {
                this.set = this.setValue = this.setValueAny.bind(this);
                this.updateValue = this.updateValueAny.bind(this);
            }
        }
        else if (__type == "tc")
        {
            this.set = this.setValue = this.setValueT.bind(this);
            this.updateValue = this.updateValueT.bind(this);
        }
        else if (__type == "t[]")
        {
            this.set = this.setValue = this.setValueArrayT.bind(this);
            this.updateValue = this.updateValueArrayT.bind(this);
        }
        else if (__type == "m4" || __type == "m4[]")
        {
            this.set = this.setValue = this.setValueM4.bind(this);
            this.updateValue = this.updateValueM4.bind(this);
        }
        else
        {
            // console.error("unknown");
            this._log.error("Unknown uniform type " + __type, __name, typeof this._shader);
        }

        if (typeof _value == "object" && _value instanceof cables__WEBPACK_IMPORTED_MODULE_1__/* .Port */ .I)
        {
            this._port = _value;
            this._value = this._port.get();

            if (_port2 && _port3 && _port4)
            {
                if (!(_port2 instanceof cables__WEBPACK_IMPORTED_MODULE_1__/* .Port */ .I) || !(_port3 instanceof cables__WEBPACK_IMPORTED_MODULE_1__/* .Port */ .I) || !(_port4 instanceof cables__WEBPACK_IMPORTED_MODULE_1__/* .Port */ .I))
                {
                    this._log.error("[cgl_uniform] mixed port/value parameter for vec4 ", this._name);
                }

                this._value = [0, 0, 0, 0];
                this._port2 = _port2;
                this._port3 = _port3;
                this._port4 = _port4;

                this._port.on("change", this.updateFromPort4f.bind(this));
                this._port2.on("change", this.updateFromPort4f.bind(this));
                this._port3.on("change", this.updateFromPort4f.bind(this));
                this._port4.on("change", this.updateFromPort4f.bind(this));

                // this._port.onChange = this._port2.onChange = this._port3.onChange = this._port4.onChange = this.updateFromPort4f.bind(this);
                this.updateFromPort4f();
            }
            else if (_port2 && _port3)
            {
                if (!(_port2 instanceof cables__WEBPACK_IMPORTED_MODULE_1__/* .Port */ .I) || !(_port3 instanceof cables__WEBPACK_IMPORTED_MODULE_1__/* .Port */ .I))
                {
                    this._log.error("[cgl_uniform] mixed port/value parameter for vec4 ", this._name);
                }

                this._value = [0, 0, 0];
                this._port2 = _port2;
                this._port3 = _port3;
                // this._port.onChange = this._port2.onChange = this._port3.onChange = this.updateFromPort3f.bind(this);
                this._port.on("change", this.updateFromPort3f.bind(this));
                this._port2.on("change", this.updateFromPort3f.bind(this));
                this._port3.on("change", this.updateFromPort3f.bind(this));

                this.updateFromPort3f();
            }
            else if (_port2)
            {
                if (!(_port2 instanceof cables__WEBPACK_IMPORTED_MODULE_1__/* .Port */ .I))
                {
                    this._log.error("[cgl_uniform] mixed port/value parameter for vec4 ", this._name);
                }

                this._value = [0, 0];
                this._port2 = _port2;
                // this._port.onChange = this._port2.onChange = this.updateFromPort2f.bind(this);
                this._port.on("change", this.updateFromPort2f.bind(this));
                this._port2.on("change", this.updateFromPort2f.bind(this));

                this.updateFromPort2f();
            }
            else
            {
                // this._port.on = this.updateFromPort.bind(this);
                this._port.on("change", this.updateFromPort.bind(this));
            }
        }
        else this._value = _value;

        if (this._value == undefined)
        {
            this._value = 0;
        }

        this.setValue(this._value);

        this.needsUpdate = true;
    }

    getType()
    {
        return this._type;
    }

    get type()
    {
        return this._type;
    }

    get name()
    {
        return this._name;
    }

    getName()
    {
        return this._name;
    }

    getValue()
    {
        return this._value;
    }

    getShaderType()
    {
        return this.shaderType;
    }

    isStructMember()
    {
        return !!this._structName;
    }

    updateFromPort4f()
    {
        this._value[0] = this._port.get();
        this._value[1] = this._port2.get();
        this._value[2] = this._port3.get();
        this._value[3] = this._port4.get();
        this.setValue(this._value);
    }

    updateFromPort3f()
    {
        this._value[0] = this._port.get();
        this._value[1] = this._port2.get();
        this._value[2] = this._port3.get();
        this.setValue(this._value);
    }

    updateFromPort2f()
    {
        this._value[0] = this._port.get();
        this._value[1] = this._port2.get();
        this.setValue(this._value);
    }

    updateFromPort()
    {
        this.setValue(this._port.get());
    }

    get port()
    {
        return this._port;
    }
}


/***/ }),

/***/ 748:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* unused harmony export CG */
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(823);
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(522);
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(964);
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(409);
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(684);
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(221);
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(991);
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(842);
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(329);
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(796);
/* harmony import */ var _cg_boundingbox_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(982);
/* harmony import */ var _cg_canvas_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(223);
/* harmony import */ var _cg_geom_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(331);
/* harmony import */ var _cg_fpscounter_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(294);












const CG = {

    "DEPTH_COMPARE_NEVER": 0,
    "DEPTH_COMPARE_LESS": 1,
    "DEPTH_COMPARE_EQUAL": 2,
    "DEPTH_COMPARE_LESSEQUAL": 3,
    "DEPTH_COMPARE_GREATER": 4,
    "DEPTH_COMPARE_NOTEQUAL": 5,
    "DEPTH_COMPARE_GREATEREQUAL": 6,
    "DEPTH_COMPARE_ALWAYS": 7,

    "CULL_NONE": 0,
    "CULL_BACK": 1,
    "CULL_FRONT": 2,
    "CULL_BOTH": 3,

    "Geometry": _cg_geom_js__WEBPACK_IMPORTED_MODULE_0__/* .Geometry */ .V,
    "BoundingBox": _cg_boundingbox_js__WEBPACK_IMPORTED_MODULE_1__/* .BoundingBox */ .I,
    "FpsCounter": _cg_fpscounter_js__WEBPACK_IMPORTED_MODULE_2__/* .FpsCounter */ .K,

    "CgCanvas": _cg_canvas_js__WEBPACK_IMPORTED_MODULE_3__/* .CgCanvas */ .f
};

window.CABLES = window.CABLES || {};
window.CABLES.CG = window.CABLES.CG || CG;
window.CG = window.CG || CG;

window.glMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_4__;
window.mat2 = gl_matrix__WEBPACK_IMPORTED_MODULE_5__;
window.mat2d = gl_matrix__WEBPACK_IMPORTED_MODULE_6__;
window.mat3 = gl_matrix__WEBPACK_IMPORTED_MODULE_7__;
window.mat4 = gl_matrix__WEBPACK_IMPORTED_MODULE_8__;
window.quat = gl_matrix__WEBPACK_IMPORTED_MODULE_9__;
window.quat2 = gl_matrix__WEBPACK_IMPORTED_MODULE_10__;
window.vec2 = gl_matrix__WEBPACK_IMPORTED_MODULE_11__;

window.vec3 = gl_matrix__WEBPACK_IMPORTED_MODULE_12__;
window.vec4 = gl_matrix__WEBPACK_IMPORTED_MODULE_13__;




/***/ }),

/***/ 264:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   C: () => (/* binding */ MESH),
/* harmony export */   e: () => (/* binding */ Mesh)
/* harmony export */ });
/* harmony import */ var cables_shared_client__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(849);
/* harmony import */ var cables__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(562);
/* harmony import */ var _cgl_shader_uniform_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(923);
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(997);
/* harmony import */ var _cg_cg_mesh_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(434);










const MESH = {};
MESH.lastMesh = null;

/**
 * @typedef {Object} CglMeshAttributeOptions
 * @property {boolean} [instanced]
 * @property {Function} [cb]
 * @property {Function} [type]
 */

/**
 * @type Object
 * @typedef CglMeshOptions
 * @property {Number} [glPrimitive]
 * @property {String} [opId]
 */

/**
 * webgl renderable 3d object
 * @class
 * @namespace external:CGL
 * @hideconstructor
 * @example
 * const cgl=this._cgl
 * const mesh=new CGL.Mesh(cgl, geometry);
 *
 * function render()
 * {
 *   mesh.render(cgl.getShader());
 * }
 *
 */
class Mesh extends _cg_cg_mesh_js__WEBPACK_IMPORTED_MODULE_0__/* .CgMesh */ .w
{

    /** @type {CglContext} */
    #cgl = null;

    /** @type {Geometry} */
    #geom = null;

    /** @type {WebGLBuffer} */
    #bufVerticesIndizes = null;

    /**
     * @param {CglContext} _cgl cgl
     * @param {Geometry} __geom geometry
     * @param {CglMeshOptions} _options
     */
    constructor(_cgl, __geom, _options = {})
    {
        super();
        this.#cgl = _cgl;

        let options = _options || {};
        if (cables__WEBPACK_IMPORTED_MODULE_1__.isNumeric(options))options = { "glPrimitive": _options }; // old constructor fallback...
        this._log = new cables_shared_client__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A("cgl_mesh");
        this._bufVertexAttrib = null;
        this.#bufVerticesIndizes = this.#cgl.gl.createBuffer();
        this._indexType = this.#cgl.gl.UNSIGNED_SHORT;
        this._attributes = [];
        this._attribLocs = {};

        this._lastShader = null;
        this._numInstances = 0;
        this._glPrimitive = options.glPrimitive;

        this.opId = options.opId || "";
        this._preWireframeGeom = null;
        this.addVertexNumbers = false;

        this.feedBackAttributes = [];
        this.setGeom(__geom);

        this._feedBacks = [];
        this._feedBacksChanged = false;
        this._transformFeedBackLoc = -1;
        this._lastAttrUpdate = 0;

        this.memFreed = false;

        this.#cgl.profileData.addHeavyEvent("mesh constructed", this._name);

        this._queryExt = null;
    }

    get geom()
    {
        return this.#geom;
    }

    get numInstances()
    {
        return this._numInstances;
    }

    set numInstances(v)
    {
        this.setNumInstances(v);
    }

    freeMem()
    {
        this.memFreed = true;

        for (let i = 0; i < this._attributes.length; i++)
            this._attributes[i].floatArray = null;
    }

    /**
     * @function updateVertices
     * @memberof Mesh
     * @instance
     * @description update vertices only from a geometry
     * @param {Geometry} geom
     */
    updateVertices(geom)
    {
        this.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_3__/* .CONSTANTS */ .a.SHADER.SHADERVAR_VERTEX_POSITION, geom.vertices, 3);
        this._numVerts = geom.vertices.length / 3;
    }

    /**
     * @param {String} attrName
     * @param {String} name
     * @param {Number} stride
     * @param {Number} offset
      */
    setAttributePointer(attrName, name, stride, offset)
    {
        for (let i = 0; i < this._attributes.length; i++)
        {
            if (this._attributes[i].name == attrName)
            {
                if (!this._attributes[i].pointer) this._attributes[i].pointer = [];

                this._attributes[i].pointer.push(
                    {
                        "loc": -1,
                        "name": name,
                        "stride": stride,
                        "offset": offset,
                        "instanced": attrName == _constants_js__WEBPACK_IMPORTED_MODULE_3__/* .CONSTANTS */ .a.SHADER.SHADERVAR_INSTANCE_MMATRIX,
                    }
                );
            }
        }
    }

    /**
     * @param {String} name
     * @returns {AttributeObject}
     */
    getAttribute(name)
    {
        for (let i = 0; i < this._attributes.length; i++) if (this._attributes[i].name == name) return this._attributes[i];
    }

    setAttributeRange(attr, array, start, end)
    {
        if (!attr) return;
        if (!start && !end) return;

        if (!attr.name)
            this._log.stack("no attrname?!");

        const gl = this.#cgl.gl;

        gl.bindBuffer(gl.ARRAY_BUFFER, attr.buffer);
        this.#cgl.profileData.profileMeshAttributes += (end - start) || 0;

        this.#cgl.profileData.profileSingleMeshAttribute[this._name] = this.#cgl.profileData.profileSingleMeshAttribute[this._name] || 0;
        this.#cgl.profileData.profileSingleMeshAttribute[this._name] += (end - start) || 0;

        if (attr.numItems < array.length / attr.itemSize)
        {
            this._resizeAttr(array, attr);
        }

        if (end > array.length && !this.warned)
        {
            this.warned = true;
            this._log.warn(this.#cgl.canvas.id + " " + attr.name + " buffersubdata out of bounds ?", array.length, end, start, attr);
            return;
        }

        // if (glVersion == 1) gl.bufferSubData(gl.ARRAY_BUFFER, 0, array); // probably slow/ maybe create and array with only changed size ??
        // else
        gl.bufferSubData(gl.ARRAY_BUFFER, start * 4, array, start, (end - start));
    }

    _resizeAttr(array, attr)
    {
        const gl = this.#cgl.gl;

        if (attr.buffer)
            gl.deleteBuffer(attr.buffer);

        attr.buffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, attr.buffer);
        this._bufferArray(array, attr);
        attr.numItems = array.length / attr.itemSize;// numItems;
    }

    _bufferArray(array, attr)
    {
        let floatArray = attr.floatArray || null;
        if (!array) return;

        if (this.#cgl.debugOneFrame)
        {
        console.log("_bufferArray", array.length, attr.name); // eslint-disable-line
        }

        if (!(array instanceof Float32Array))
        {
            if (attr && floatArray && floatArray.length == array.length)
            {
                floatArray.set(array);
            }
            else
            {
                floatArray = new Float32Array(array);

                if (this.#cgl.debugOneFrame)
                {
                console.log("_bufferArray create new float32array", array.length, attr.name); // eslint-disable-line
                }

                if (array.length > 10000)
                {
                    this.#cgl.profileData.profileNonTypedAttrib++;
                    this.#cgl.profileData.profileNonTypedAttribNames = "(" + this._name + ":" + attr.name + ")";
                }
            }
        }
        else floatArray = array;

        attr.arrayLength = floatArray.length;
        attr.floatArray = null;// floatArray;

        this.#cgl.gl.bufferData(this.#cgl.gl.ARRAY_BUFFER, floatArray, this.#cgl.gl.DYNAMIC_DRAW);
    }

    /**
     * @function setAttribute
     * @description update attribute
     * @memberof Mesh
     * @instance
     * @param {String} name
     * @param {Array} array
     * @param {Number} itemSize
     * @param {Object} options
     */
    addAttribute(name, array, itemSize, options)
    {
        this.setAttribute(name, array, itemSize, options);
    }

    /**
     * @param {String} name
     * @param {Array|Float32Array} array
     * @param {Number} itemSize Integer
     * @param {CglMeshAttributeOptions} options
     */
    setAttribute(name, array, itemSize, options = {})
    {
        if (!array)
        {
            this._log.error("mesh addAttribute - no array given! " + name);
            throw new Error();
        }
        let cb = null;
        let instanced = false;
        let i = 0;
        const numItems = array.length / itemSize;

        this.#cgl.profileData.profileMeshAttributes += numItems || 0;

        if (typeof options == "function")
        {
            cb = options;
        }

        if (typeof options == "object")
        {
            if (options.cb) cb = options.cb;
            if (options.instanced) instanced = options.instanced;
        }

        if (name == _constants_js__WEBPACK_IMPORTED_MODULE_3__/* .CONSTANTS */ .a.SHADER.SHADERVAR_INSTANCE_MMATRIX) instanced = true;

        for (i = 0; i < this._attributes.length; i++)
        {
            const attr = this._attributes[i];
            if (attr.name == name)
            {
                if (attr.numItems === numItems)
                {
                }
                else
                {
                    this._resizeAttr(array, attr);
                }

                this.#cgl.gl.bindBuffer(this.#cgl.gl.ARRAY_BUFFER, attr.buffer);
                this._bufferArray(array, attr);

                return attr;
            }
        }

        // create new buffer...

        const buffer = this.#cgl.gl.createBuffer();

        this.#cgl.gl.bindBuffer(this.#cgl.gl.ARRAY_BUFFER, buffer);
        // this._cgl.gl.bufferData(this._cgl.gl.ARRAY_BUFFER, floatArray, this._cgl.gl.DYNAMIC_DRAW);

        let type = this.#cgl.gl.FLOAT;
        if (options && options.type) type = options.type;
        const attr = {
            "buffer": buffer,
            "name": name,
            "cb": cb,
            "itemSize": itemSize,
            "numItems": numItems,
            "startItem": 0,
            "instanced": instanced,
            "type": type
        };

        this._bufferArray(array, attr);

        if (name == _constants_js__WEBPACK_IMPORTED_MODULE_3__/* .CONSTANTS */ .a.SHADER.SHADERVAR_VERTEX_POSITION) this._bufVertexAttrib = attr;
        this._attributes.push(attr);
        this._attribLocs = {};

        return attr;
    }

    getAttributes()
    {
        return this._attributes;
    }

    /**
     * @function updateTexCoords
     * @description update texture coordinates only from a geometry
     * @memberof Mesh
     * @instance
     * @param {Geometry} geom
     */
    updateTexCoords(geom)
    {
        if (geom.texCoords && geom.texCoords.length > 0)
        {
            this.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_3__/* .CONSTANTS */ .a.SHADER.SHADERVAR_VERTEX_TEXCOORD, geom.texCoords, 2);
        }
        else
        {
            const tcBuff = new Float32Array(Math.round((geom.vertices.length / 3) * 2));
            this.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_3__/* .CONSTANTS */ .a.SHADER.SHADERVAR_VERTEX_TEXCOORD, tcBuff, 2);
        }
    }

    /**
     * @function updateNormals
     * @description update normals only from a geometry
     * @memberof Mesh
     * @instance
     * @param {Geometry} geom
     */
    updateNormals(geom)
    {
        if (geom.vertexNormals && geom.vertexNormals.length > 0)
        {
            this.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_3__/* .CONSTANTS */ .a.SHADER.SHADERVAR_VERTEX_NORMAL, geom.vertexNormals, 3);
        }
        else
        {
            const tcBuff = new Float32Array(Math.round((geom.vertices.length)));
            this.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_3__/* .CONSTANTS */ .a.SHADER.SHADERVAR_VERTEX_NORMAL, tcBuff, 3);
        }
    }

    /**
     * @param {Array} [arr]
     */
    _setVertexNumbers(arr = null)
    {
        if (!this._verticesNumbers || this._verticesNumbers.length != this._numVerts || arr)
        {
            if (arr) this._verticesNumbers = arr;
            else
            {
                this._verticesNumbers = new Float32Array(this._numVerts);
                for (let i = 0; i < this._numVerts; i++) this._verticesNumbers[i] = i;
            }

            this.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_3__/* .CONSTANTS */ .a.SHADER.SHADERVAR_VERTEX_NUMBER, this._verticesNumbers, 1, (_attr, _geom, shader) =>
            {
                if (!shader.uniformNumVertices) shader.uniformNumVertices = new _cgl_shader_uniform_js__WEBPACK_IMPORTED_MODULE_4__/* .Uniform */ .n(shader, "f", "numVertices", this._numVerts);
                shader.uniformNumVertices.setValue(this._numVerts);
            });
        }
    }

    /**
     * @function setVertexIndices
     * @description update vertex indices / faces
     * @memberof Mesh
     * @instance
     * @param {array} vertIndices
     */
    setVertexIndices(vertIndices)
    {
        if (!this.#bufVerticesIndizes)
        {
            this._log.warn("no bufVerticesIndizes: " + this._name);
            return;
        }
        if (vertIndices.length > 0)
        {
            if (vertIndices instanceof Float32Array) this._log.warn("vertIndices float32Array: " + this._name);

            for (let i = 0; i < vertIndices.length; i++)
            {
                if (vertIndices[i] >= this._numVerts)
                {
                    this._log.warn("invalid index in " + this._name, i, vertIndices[i]);
                    return;
                }
            }

            this.#cgl.gl.bindBuffer(this.#cgl.gl.ELEMENT_ARRAY_BUFFER, this.#bufVerticesIndizes);

            /*
             * todo cache this ?
             * if(!this.vertIndicesTyped || this.vertIndicesTyped.length!=this._geom.verticesIndices.length)
             */

            if (vertIndices.length > 65535)
            {
                this.vertIndicesTyped = new Uint32Array(vertIndices);
                this._indexType = this.#cgl.gl.UNSIGNED_INT;
            }
            else
            if (vertIndices instanceof Uint32Array)
            {
                this.vertIndicesTyped = vertIndices;
                this._indexType = this.#cgl.gl.UNSIGNED_INT;
            }
            else
            if (!(vertIndices instanceof Uint16Array))
            {
                this.vertIndicesTyped = new Uint16Array(vertIndices);
                this._indexType = this.#cgl.gl.UNSIGNED_SHORT;
            }
            else this.vertIndicesTyped = vertIndices;

            this.#cgl.gl.bufferData(this.#cgl.gl.ELEMENT_ARRAY_BUFFER, this.vertIndicesTyped, this.#cgl.gl.DYNAMIC_DRAW);
            this.#bufVerticesIndizes.itemSize = 1;
            this.#bufVerticesIndizes.numItems = vertIndices.length;
        }
        else this.#bufVerticesIndizes.numItems = 0;
    }

    /**
     * @function setGeom
     * @memberof Mesh
     * @instance
     * @description set geometry for mesh
     * @param {Geometry} geom
     * @param {boolean} removeRef
     */
    setGeom(geom, removeRef = false)
    {
        this.#geom = geom;
        if (geom.glPrimitive != null) this._glPrimitive = geom.glPrimitive;
        if (this.#geom && this.#geom.name) this._name = "mesh " + this.#geom.name;

        MESH.lastMesh = null;
        this.#cgl.profileData.profileMeshSetGeom++;

        this._disposeAttributes();

        this.updateVertices(this.#geom);
        this.setVertexIndices(this.#geom.verticesIndices);

        if (this.addVertexNumbers) this._setVertexNumbers();

        const geomAttribs = this.#geom.getAttributes();

        const attribAssoc = {
            "texCoords": _constants_js__WEBPACK_IMPORTED_MODULE_3__/* .CONSTANTS */ .a.SHADER.SHADERVAR_VERTEX_TEXCOORD,
            "vertexNormals": _constants_js__WEBPACK_IMPORTED_MODULE_3__/* .CONSTANTS */ .a.SHADER.SHADERVAR_VERTEX_NORMAL,
            "vertexColors": _constants_js__WEBPACK_IMPORTED_MODULE_3__/* .CONSTANTS */ .a.SHADER.SHADERVAR_VERTEX_COLOR,
            "tangents": "attrTangent",
            "biTangents": "attrBiTangent",
        };

        for (const index in geomAttribs)
            if (geomAttribs[index].data && geomAttribs[index].data.length)
                this.setAttribute(attribAssoc[index] || index, geomAttribs[index].data, geomAttribs[index].itemSize);

        if (removeRef)
        {
            this.#geom = null;
        }
    }

    _preBind(shader)
    {
        for (let i = 0; i < this._attributes.length; i++)
            if (this._attributes[i].cb)
                this._attributes[i].cb(this._attributes[i], this.#geom, shader);
    }

    _checkAttrLengths()
    {
        if (this.memFreed) return;
        // check length
        for (let i = 0; i < this._attributes.length; i++)
        {
            if (this._attributes[i].arrayLength / this._attributes[i].itemSize < this._attributes[0].arrayLength / this._attributes[0].itemSize)
            {
                let name = "unknown";
                if (this.#geom)name = this.#geom.name;

            /*
             * this._log.warn(
             *     name + ": " + this._attributes[i].name +
             *     " wrong attr length. is:", this._attributes[i].arrayLength / this._attributes[i].itemSize,
             *     " should be:", this._attributes[0].arrayLength / this._attributes[0].itemSize,
             * );
             */
            }
        }
    }

    _bind(shader)
    {
        if (!shader) return;
        if (!shader.isValid()) return;

        let attrLocs = [];
        if (this._attribLocs[shader.id]) attrLocs = this._attribLocs[shader.id];
        else this._attribLocs[shader.id] = attrLocs;

        this._lastShader = shader;
        if (shader.lastCompile > this._lastAttrUpdate || attrLocs.length != this._attributes.length)
        {
            this._lastAttrUpdate = shader.lastCompile;
            for (let i = 0; i < this._attributes.length; i++) attrLocs[i] = -1;
        }

        for (let i = 0; i < this._attributes.length; i++)
        {
            const attribute = this._attributes[i];
            if (attrLocs[i] == -1)
            {
                if (attribute._attrLocationLastShaderTime != shader.lastCompile)
                {
                    attribute._attrLocationLastShaderTime = shader.lastCompile;
                    attrLocs[i] = this.#cgl.glGetAttribLocation(shader.getProgram(), attribute.name);
                    // this._log.log('attribloc',attribute.name,attrLocs[i]);
                    this.#cgl.profileData.profileAttrLoc++;
                }
            }

            if (attrLocs[i] != -1)
            {
                this.#cgl.gl.enableVertexAttribArray(attrLocs[i]);
                this.#cgl.gl.bindBuffer(this.#cgl.gl.ARRAY_BUFFER, attribute.buffer);

                if (attribute.instanced)
                {
                // todo: easier way to fill mat4 attribs...
                    if (attribute.itemSize <= 4)
                    {
                        if (!attribute.itemSize || attribute.itemSize == 0) this._log.warn("instanced attrib itemsize error", this.#geom.name, attribute);

                        this.#cgl.gl.vertexAttribPointer(attrLocs[i], attribute.itemSize, attribute.type, false, attribute.itemSize * 4, 0);
                        this.#cgl.gl.vertexAttribDivisor(attrLocs[i], 1);
                    }
                    else if (attribute.itemSize == 16)
                    {
                        const stride = 16 * 4;

                        this.#cgl.gl.vertexAttribPointer(attrLocs[i], 4, attribute.type, false, stride, 0);
                        this.#cgl.gl.enableVertexAttribArray(attrLocs[i] + 1);
                        this.#cgl.gl.vertexAttribPointer(attrLocs[i] + 1, 4, attribute.type, false, stride, 4 * 4 * 1);
                        this.#cgl.gl.enableVertexAttribArray(attrLocs[i] + 2);
                        this.#cgl.gl.vertexAttribPointer(attrLocs[i] + 2, 4, attribute.type, false, stride, 4 * 4 * 2);
                        this.#cgl.gl.enableVertexAttribArray(attrLocs[i] + 3);
                        this.#cgl.gl.vertexAttribPointer(attrLocs[i] + 3, 4, attribute.type, false, stride, 4 * 4 * 3);

                        this.#cgl.gl.vertexAttribDivisor(attrLocs[i], 1);
                        this.#cgl.gl.vertexAttribDivisor(attrLocs[i] + 1, 1);
                        this.#cgl.gl.vertexAttribDivisor(attrLocs[i] + 2, 1);
                        this.#cgl.gl.vertexAttribDivisor(attrLocs[i] + 3, 1);
                    }
                    else
                    {
                        this._log.warn("unknown instance attrib size", attribute.name);
                    }
                }
                else
                {
                    if (!attribute.itemSize || attribute.itemSize == 0) this._log.warn("attrib itemsize error", this._name, attribute);
                    this.#cgl.gl.vertexAttribPointer(attrLocs[i], attribute.itemSize, attribute.type, false, attribute.itemSize * 4, 0);

                    if (attribute.pointer)
                    {
                        for (let ip = 0; ip < attribute.pointer.length; ip++)
                        {
                            const pointer = attribute.pointer[ip];

                            if (pointer.loc == -1)
                                pointer.loc = this.#cgl.glGetAttribLocation(shader.getProgram(), pointer.name);

                            this.#cgl.profileData.profileAttrLoc++;

                            this.#cgl.gl.enableVertexAttribArray(pointer.loc);
                            this.#cgl.gl.vertexAttribPointer(pointer.loc, attribute.itemSize, attribute.type, false, pointer.stride, pointer.offset);
                        }
                    }
                    if (this.bindFeedback) this.bindFeedback(attribute);
                }
            }
        }

        if (this.#bufVerticesIndizes && this.#bufVerticesIndizes.numItems !== 0) this.#cgl.gl.bindBuffer(this.#cgl.gl.ELEMENT_ARRAY_BUFFER, this.#bufVerticesIndizes);
    }

    unBind()
    {
        const shader = this._lastShader;
        this._lastShader = null;
        if (!shader) return;

        let attrLocs = [];
        if (this._attribLocs[shader.id]) attrLocs = this._attribLocs[shader.id];
        else this._attribLocs[shader.id] = attrLocs;

        MESH.lastMesh = null;

        for (let i = 0; i < this._attributes.length; i++)
        {
            if (this._attributes[i].instanced)
            {
            // todo: easier way to fill mat4 attribs...
                if (this._attributes[i].itemSize <= 4)
                {
                    if (attrLocs[i] != -1) this.#cgl.gl.vertexAttribDivisor(attrLocs[i], 0);
                    if (attrLocs[i] >= 0) this.#cgl.gl.disableVertexAttribArray(attrLocs[i]);
                }
                else
                {
                    this.#cgl.gl.vertexAttribDivisor(attrLocs[i], 0);
                    this.#cgl.gl.vertexAttribDivisor(attrLocs[i] + 1, 0);
                    this.#cgl.gl.vertexAttribDivisor(attrLocs[i] + 2, 0);
                    this.#cgl.gl.vertexAttribDivisor(attrLocs[i] + 3, 0);
                    this.#cgl.gl.disableVertexAttribArray(attrLocs[i] + 1);
                    this.#cgl.gl.disableVertexAttribArray(attrLocs[i] + 2);
                    this.#cgl.gl.disableVertexAttribArray(attrLocs[i] + 3);
                }
            }

            if (attrLocs[i] != -1) this.#cgl.gl.disableVertexAttribArray(attrLocs[i]);

        }
    }

    meshChanged()
    {
        return this.#cgl.lastMesh && this.#cgl.lastMesh != this;
    }

    printDebug()
    {
        console.log("--attributes");
        for (let i = 0; i < this._attributes.length; i++)
        {
            console.log("attribute " + i + " " + this._attributes[i].name);
        }
    }

    /**
     * @param {Number} num
     */
    setNumVertices(num)
    {
        // this._bufVerticesIndizes.numItems = num;
        this._bufVertexAttrib.numItems = num;
    }

    /**
     * @returns {Number}
     */
    getNumVertices()
    {
        // return this._bufVerticesIndizes.numItems;
        return this._bufVertexAttrib.numItems;
    }

    /**
     * @param {Number} num
     */
    setNumIndices(num)
    {
        this.#bufVerticesIndizes.numItems = num;
    }

    /**
     * @returns {Number}
     */
    getNumIndices()
    {
        return this.#bufVerticesIndizes.numItems;
    }

    /**
     * @function render
     * @memberof Mesh
     * @instance
     * @description draw mesh to screen
     * @param {CgShader} shader
     */
    render(shader)
    {
        // TODO: enable/disablevertex only if the mesh has changed... think drawing 10000x the same mesh

        if (this.#cgl.aborted) return;
        shader = shader || this.#cgl.getShader();

        if (!shader)
        {
            return console.log("shadern not valid");
        }

        if (!shader.isValid())
        {
            shader = this.#cgl.getErrorShader();
        }

        this._checkAttrLengths();

        if (this.#geom)
        {
            if (this._preWireframeGeom && !shader.wireframe && !this.#geom.isIndexed())
            {
                this.setGeom(this._preWireframeGeom);
                this._preWireframeGeom = null;
            }

            if (shader.wireframe)
            {
                let changed = false;

                if (this.#geom.isIndexed())
                {
                    if (!this._preWireframeGeom)
                    {
                        this._preWireframeGeom = this.#geom;
                        this.#geom = this.#geom.copy();
                    }

                    this.#geom.unIndex();
                    changed = true;
                }

                if (!this.#geom.getAttribute("attrBarycentric"))
                {
                    if (!this._preWireframeGeom)
                    {
                        this._preWireframeGeom = this.#geom;
                        this.#geom = this.#geom.copy();
                    }
                    changed = true;

                    this.#geom.calcBarycentric();
                }
                if (changed) this.setGeom(this.#geom);
            }
        }

        let needsBind = false;
        if (MESH.lastMesh != this)
        {
            if (MESH.lastMesh) MESH.lastMesh.unBind();
            needsBind = true;
        }

        if (needsBind) this._preBind(shader);

        if (!shader.bind()) return;

        this._bind(shader);
        if (this.addVertexNumbers) this._setVertexNumbers();

        MESH.lastMesh = this;

        let prim = this.#cgl.gl.TRIANGLES;
        if (this._glPrimitive !== undefined) prim = this._glPrimitive;
        if (shader.glPrimitive !== null) prim = shader.glPrimitive;

        let elementDiv = 1;
        let doQuery = this.#cgl.profileData.doProfileGlQuery;
        let queryStarted = false;
        if (doQuery)
        {
            let id = this._name + " - " + shader.getName() + " #" + shader.id;
            if (this._numInstances) id += " instanced " + this._numInstances + "x";

            let queryProfilerData = this.#cgl.profileData.glQueryData[id];

            if (!queryProfilerData) queryProfilerData = { "id": id, "num": 0 };

            if (shader.opId)queryProfilerData.shaderOp = shader.opId;
            if (this.opId)queryProfilerData.meshOp = this.opId;

            this.#cgl.profileData.glQueryData[id] = queryProfilerData;

            if (!this._queryExt && this._queryExt !== false) this._queryExt = this.#cgl.enableExtension("EXT_disjoint_timer_query_webgl2") || false;
            if (this._queryExt)
            {
                if (queryProfilerData._drawQuery)
                {
                    const available = this.#cgl.gl.getQueryParameter(queryProfilerData._drawQuery, this.#cgl.gl.QUERY_RESULT_AVAILABLE);
                    if (available)
                    {
                        const elapsedNanos = this.#cgl.gl.getQueryParameter(queryProfilerData._drawQuery, this.#cgl.gl.QUERY_RESULT);
                        const currentTimeGPU = elapsedNanos / 1000000;

                        queryProfilerData._times = queryProfilerData._times || 0;
                        queryProfilerData._times += currentTimeGPU;
                        queryProfilerData._numcount++;
                        queryProfilerData.when = performance.now();
                        queryProfilerData._drawQuery = null;
                        queryProfilerData.queryStarted = false;
                    }
                }

                if (!queryProfilerData.queryStarted)
                {
                    queryProfilerData._drawQuery = this.#cgl.gl.createQuery();
                    this.#cgl.gl.beginQuery(this._queryExt.TIME_ELAPSED_EXT, queryProfilerData._drawQuery);
                    queryStarted = queryProfilerData.queryStarted = true;
                }
            }
        }

        if (this.hasFeedbacks && this.hasFeedbacks()) this.drawFeedbacks(shader, prim);
        else if (!this.#bufVerticesIndizes || this.#bufVerticesIndizes.numItems === 0)
        {

            /*
             * for (let i = 0; i < this._attributes.length; i++)
             * {
             *     if (this._attributes[i].arrayLength / this._attributes[i].itemSize != this._bufVertexAttrib.floatArray.length / 3)
             *     {
             *         this._log.warn("attrib buffer length wrong! ", this._attributes[i].name, this._attributes[i].arrayLength / this._attributes[i].itemSize, this._bufVertexAttrib.floatArray.length / 3, this._attributes[i].itemSize);
             *         // this._log.log(this);
             *         // debugger;
             *         return;
             *     }
             * }
             */

            if (prim == this.#cgl.gl.TRIANGLES)elementDiv = 3;

            if (this._numInstances === 0) this.#cgl.gl.drawArrays(prim, this._bufVertexAttrib.startItem, this._bufVertexAttrib.numItems - this._bufVertexAttrib.startItem);
            else this.#cgl.gl.drawArraysInstanced(prim, this._bufVertexAttrib.startItem, this._bufVertexAttrib.numItems, this._numInstances);
        }
        else
        {
            if (prim == this.#cgl.gl.TRIANGLES)elementDiv = 3;
            if (this._numInstances === 0)
            {
                this.#cgl.gl.drawElements(prim, this.#bufVerticesIndizes.numItems, this._indexType, 0);
            }
            else
            {
                this.#cgl.gl.drawElementsInstanced(prim, this.#bufVerticesIndizes.numItems, this._indexType, 0, this._numInstances);
            }
        }

        if (this.#cgl.debugOneFrame && this.#cgl.gl.getError() != this.#cgl.gl.NO_ERROR)
        {
            this._log.error("mesh draw gl error");
            this._log.error("mesh", this);
            this._log.error("shader", shader);

            const attribNames = [];
            for (let i = 0; i < this.#cgl.gl.getProgramParameter(shader.getProgram(), this.#cgl.gl.ACTIVE_ATTRIBUTES); i++)
            {
                const name = this.#cgl.gl.getActiveAttrib(shader.getProgram(), i).name;
                this._log.error("attrib ", name);
            }
        }

        this.#cgl.profileData.profileMeshNumElements += (this._bufVertexAttrib.numItems / elementDiv) * (this._numInstances || 1);
        this.#cgl.profileData.profileMeshDraw++;

        if (doQuery && queryStarted)
        {
            this.#cgl.gl.endQuery(this._queryExt.TIME_ELAPSED_EXT);
        }

        this.#cgl.printError("mesh render " + this._name);

        this.unBind();
    }

    setNumInstances(n)
    {
        n = Math.max(0, n);
        if (this._numInstances != n)
        {
            this._numInstances = n;
            const indexArr = new Float32Array(n);
            for (let i = 0; i < n; i++) indexArr[i] = i;
            this.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_3__/* .CONSTANTS */ .a.SHADER.SHADERVAR_INSTANCE_INDEX, indexArr, 1, { "instanced": true });
        }
    }

    _disposeAttributes()
    {
        if (!this._attributes) return;

        for (let i = 0; i < this._attributes.length; i++)
        {
            if (this._attributes[i].buffer)
            {
                this.#cgl.gl.deleteBuffer(this._attributes[i].buffer);
                this._attributes[i].buffer = null;
            }
        }
        this._attributes.length = 0;
    }

    dispose()
    {
        if (this.#cgl.aborted) return;
        if (this._bufVertexAttrib && this._bufVertexAttrib.buffer) this.#cgl.gl.deleteBuffer(this._bufVertexAttrib.buffer);
        if (this.#bufVerticesIndizes) this.#cgl.gl.deleteBuffer(this.#bufVerticesIndizes);
        this.#bufVerticesIndizes = null;

        this._disposeAttributes();
    }
}




/***/ }),

/***/ 460:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   E: () => (/* binding */ ProfileData)
/* harmony export */ });
class ProfileData
{
    constructor(cgl)
    {
        this._cgl = cgl;
        this._lastTime = 0;
        this.pause = false;
        this.profileUniformCount = 0;
        this.profileShaderBinds = 0;
        this.profileUniformCount = 0;
        this.profileShaderCompiles = 0;
        this.profileVideosPlaying = 0;
        this.profileMVPMatrixCount = 0;
        this.profileEffectBuffercreate = 0;
        this.profileShaderGetUniform = 0;
        this.profileFrameBuffercreate = 0;
        this.profileMeshSetGeom = 0;
        this.profileTextureNew = 0;
        this.profileGenMipMap = 0;
        this.profileOnAnimFrameOps = 0;

        this.profileFencedPixelRead = 0;
        this.profileMainloopMs = 0;
        this.profileMeshDraw = 0;
        this.profileTextureEffect = 0;
        this.profileTexPreviews = 0;
        this.shaderCompileTime = 0;
        this.profileMeshNumElements = 0;
        this.profileMeshAttributes = 0;
        this.profileSingleMeshAttribute = [];
        this.heavyEvents = [];

        this.doProfileGlQuery = false;
        this.glQueryData = {};
        this.counts = {};
    }

    clear()
    {
        this.counts = {};
        this.profileSingleMeshAttribute = {};
        this.profileMeshAttributes = 0;
        this.profileUniformCount = 0;
        this.profileShaderGetUniform = 0;
        this.profileShaderCompiles = 0;
        this.profileShaderBinds = 0;
        this.profileTextureResize = 0;
        this.profileFrameBuffercreate = 0;
        this.profileEffectBuffercreate = 0;
        this.profileTextureDelete = 0;
        this.profileMeshSetGeom = 0;
        this.profileVideosPlaying = 0;
        this.profileMVPMatrixCount = 0;
        this.profileNonTypedAttrib = 0;
        this.profileNonTypedAttribNames = "";
        this.profileTextureNew = 0;
        this.profileGenMipMap = 0;
        this.profileFramebuffer = 0;
        this.profileMeshDraw = 0;
        this.profileTextureEffect = 0;
        this.profileTexPreviews = 0;
        this.profileMeshNumElements = 0;
        this.profileFencedPixelRead = 0;
    }

    clearGlQuery()
    {
        for (let i in this.glQueryData)
        {
            if (!this.glQueryData[i].lastClear || performance.now() - this.glQueryData[i].lastClear > 1000)
            {
                this.glQueryData[i].time = this.glQueryData[i]._times / this.glQueryData[i]._numcount;
                this.glQueryData[i].num = this.glQueryData[i]._numcount;

                this.glQueryData[i]._times = 0;
                this.glQueryData[i]._numcount = 0;
                this.glQueryData[i].lastClear = performance.now();
            }
        }
    }

    /**
     * @param {string} event
     * @param {string} name
     */
    count(event, name)
    {
        this.counts[event] = this.counts[event] || [];
        this.counts[event].push(name);
    }

    /**
     * @param {string} event
     * @param {string} name
     * @param {string} [info]
     */
    addHeavyEvent(event, name, info)
    {
        const e = { "event": event, "name": name, "info": info, "date": performance.now() };
        this.heavyEvents.push(e);
        this._cgl.emitEvent("heavyEvent", e);
    }
}


/***/ }),

/***/ 24:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   M: () => (/* binding */ CglShader)
/* harmony export */ });
/* harmony import */ var cables_shared_client__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(849);
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(684);
/* harmony import */ var cables__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(920);
/* harmony import */ var _cgl_shader_lib_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(960);
/* harmony import */ var _cgl_mesh_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(264);
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(997);
/* harmony import */ var _cg_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(694);
/* harmony import */ var _cgl_texture_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(70);
/* harmony import */ var _cgl_shader_uniform_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(923);











// ---------------------------------------------------------------------------

/*

proposal default shader variable names:

attrVertex - currently: vPosition
attrVertexIndex - currently: attrVertIndex
attrTexCoord
attrInstMat - currently: instMat
attrVertColor
attrTangent
attrBiTangent

uProjMatrix - currently: projMatrix
uModelMatrix - currently: modelMatrix
uNormalMatrix - currently: normalMatrix
uCamPosition - currently: camPos

*/

// ---------------------------------------------------------------------------

// eslint-disable-next-line no-restricted-syntax
const defaultShaderSrcVert = `
{{MODULES_HEAD}}
IN vec3 vPosition; //!@
IN vec2 attrTexCoord;
IN vec3 attrVertNormal;
IN vec3 attrTangent,attrBiTangent;

IN float attrVertIndex;

OUT vec2 texCoord;
OUT vec3 norm;
UNI mat4 projMatrix;
UNI mat4 viewMatrix;
UNI mat4 modelMatrix;

void main()
{
    texCoord=attrTexCoord;
    norm=attrVertNormal;
    vec4 pos=vec4(vPosition,  1.0);
    vec3 tangent=attrTangent;
    vec3 bitangent=attrBiTangent;
    mat4 mMatrix=modelMatrix;
    gl_PointSize=10.0;

    {{MODULE_VERTEX_POSITION}}

    mat4 modelViewMatrix=viewMatrix*mMatrix;
    {{MODULE_VERTEX_MODELVIEW}}

    gl_Position = projMatrix * modelViewMatrix * pos;
}
`;
let materialIdCounter = 0;

function getDefaultVertexShader()
{
    return defaultShaderSrcVert;
}

/**
 * @param {number} [r]
 * @param {number} [g]
 * @param {number} [b]
 */
function getDefaultFragmentShader(r, g, b)
{
    if (r == undefined)
    {
        r = 0.5;
        g = 0.5;
        b = 0.5;
    }
    return ""
        + _constants_js__WEBPACK_IMPORTED_MODULE_0__.nl + "IN vec2 texCoord;"
        + _constants_js__WEBPACK_IMPORTED_MODULE_0__.nl + "{{MODULES_HEAD}}"
        + _constants_js__WEBPACK_IMPORTED_MODULE_0__.nl + "void main()"
        + _constants_js__WEBPACK_IMPORTED_MODULE_0__.nl + "{"

        + _constants_js__WEBPACK_IMPORTED_MODULE_0__.nl + "    vec4 col=vec4(" + r + "," + g + "," + b + ",1.0);"
        + _constants_js__WEBPACK_IMPORTED_MODULE_0__.nl + "    {{MODULE_COLOR}}"
        + _constants_js__WEBPACK_IMPORTED_MODULE_0__.nl + "    outColor = col;"
        + _constants_js__WEBPACK_IMPORTED_MODULE_0__.nl + "}";
}

/**
 * @class
 * @namespace external:CGL
 * @hideconstructor
 * @param _cgl
 * @param _name
 * @param _op
 * @example
 * var shader=new CGL.Shader(cgl,'MinimalMaterial');
 * shader.setSource(attachments.shader_vert,attachments.shader_frag);
 */
class CglShader extends _cg_index_js__WEBPACK_IMPORTED_MODULE_1__/* .CgShader */ .U
{

    /** @type {Uniform[]} */
    _uniforms = [];

    /**
     * @param {CglContext} _cgl
     * @param {string} _name
     * @param {Op} [_op]
     */
    constructor(_cgl, _name, _op)
    {
        super();
        if (!_cgl) throw new Error("shader constructed without cgl " + _name);

        this._log = new cables_shared_client__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A("cgl_shader");
        this._cgl = _cgl;

        if (!_name) this._log.stack("no shader name given");
        this._name = _name || "unknown";

        if (_op) this.opId = _op.id;
        this.glslVersion = 0;
        if (_cgl.glVersion > 1) this.glslVersion = 300;

        this._materialId = ++materialIdCounter;

        this._program = null;
        this._drawBuffers = [true];
        this.error = null;

        this.ignoreMissingUniforms = false;
        this._projMatrixUniform = null;
        this._mvMatrixUniform = null;
        this._mMatrixUniform = null;
        this._vMatrixUniform = null;
        this._camPosUniform = null;
        this._normalMatrixUniform = null;
        this._inverseViewMatrixUniform = null;
        this._fromUserInteraction = false;

        this._attrVertexPos = -1;
        this.precision = _cgl.patch.config.glslPrecision || "highp";

        this._pMatrixState = -1;
        this._vMatrixState = -1;

        this._countMissingUniforms = 0;
        this._modGroupCount = 0; // not needed anymore...
        this._feedBackNames = [];
        this._attributes = [];

        this.glPrimitive = null;
        this.offScreenPass = false;
        this._extensions = [];
        this.srcVert = getDefaultVertexShader();
        this.srcFrag = getDefaultFragmentShader();
        this.lastCompile = 0;

        this._libs = [];
        this._structNames = [];
        this._structUniformNames = [];
        this._textureStackUni = [];
        this._textureStackTex = [];
        this._textureStackType = [];
        this._textureStackTexCgl = [];

        this._tempNormalMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_3__.create();
        this._tempCamPosMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_3__.create();
        this._tempInverseViewMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_3__.create();
        this._tempInverseProjMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_3__.create();

        this.setModules(["MODULE_VERTEX_POSITION", "MODULE_COLOR", "MODULE_NORMAL", "MODULE_BEGIN_FRAG", "MODULE_VERTEX_MODELVIEW"]);
    }

    isValid()
    {
        return this._isValid;
    }

    getCgl()
    {
        return this._cgl;
    }

    getName()
    {
        return this._name;
    }

    /**
     * @param {string} name
     */
    enableExtension(name)
    {
        this.setWhyCompile("enable extension " + name);

        this._extensions.push(name);
    }

    getAttrVertexPos()
    {
        return this._attrVertexPos;
    }

    hasTextureUniforms()
    {
        for (let i = 0; i < this._uniforms.length; i++)
            if (this._uniforms[i].getType() == "t") return true;
        return false;
    }

    /**
     * copy all uniform values from another shader
     * @param {CglShader} origShader uniform values will be copied from this shader
     */
    copyUniformValues(origShader)
    {
        for (let i = 0; i < origShader._uniforms.length; i++)
        {
            if (!this._uniforms[i])
            {
                this._log.log("unknown uniform?!");
                continue;
            }

            this.getUniform(origShader._uniforms[i].getName()).set(origShader._uniforms[i].getValue());
        }

        this.popTextures();
        for (let i = 0; i < origShader._textureStackUni.length; i++)
        {
            this._textureStackUni[i] = origShader._textureStackUni[i];
            this._textureStackTex[i] = origShader._textureStackTex[i];
            this._textureStackType[i] = origShader._textureStackType[i];
            this._textureStackTexCgl[i] = origShader._textureStackTexCgl[i];
        }

    }

    /**
     * copy current shader
     * @returns {CglShader} newShader
     */
    copy()
    {
        const shader = new CglShader(this._cgl, this._name + " copy");
        shader.setSource(this.srcVert, this.srcFrag);

        shader._modules = JSON.parse(JSON.stringify(this._modules));
        shader._defines = JSON.parse(JSON.stringify(this._defines));

        shader._modGroupCount = this._modGroupCount;
        shader._moduleNames = this._moduleNames;
        shader.glPrimitive = this.glPrimitive;
        shader.offScreenPass = this.offScreenPass;
        shader._extensions = this._extensions;
        shader.wireframe = this.wireframe;
        shader._attributes = this._attributes;

        for (let i = 0; i < this._uniforms.length; i++)
        {
            const u = this._uniforms[i].copy(shader);
            u.resetLoc();
        }

        shader.setWhyCompile("copy");
        return shader;
    }

    /**
     * set shader source code
     * @param {String} srcVert
     * @param {String} srcFrag
     * @param {Boolean} fromUserInteraction
     */
    setSource(srcVert, srcFrag, fromUserInteraction = false)
    {
        this._fromUserInteraction = fromUserInteraction;
        this.srcVert = srcVert;
        this.srcFrag = srcFrag;
        this.setWhyCompile("Source changed");
        this._isValid = true;
    }

    _addLibs(src)
    {
        for (const id in _cgl_shader_lib_js__WEBPACK_IMPORTED_MODULE_4__/* .ShaderLibMods */ .y)
        {
            if (src.includes(id))
            {
                const lib = new _cgl_shader_lib_js__WEBPACK_IMPORTED_MODULE_4__/* .ShaderLibMods */ .y[id]();
                src = src.replace("{{" + id + "}}", lib.srcHeadFrag);
                this._libs.push(lib);
                if (lib.initUniforms)lib.initUniforms(this);
            }
        }

        return src;
    }

    createStructUniforms()
    {
        // * create structs
        let structStrFrag = "";
        let structStrVert = ""; // TODO: not used yet

        this._structNames = [];
        // * reset the arrays holding the value each recompile so we don't skip structs
        // * key value mapping so the same struct can be added twice (two times the same modifier)
        this._injectedStringsFrag = {};
        this._injectedStringsVert = {};

        this._structUniformNamesIndicesFrag = [];
        this._structUniformNamesIndicesVert = [];

        for (let i = 0; i < this._uniforms.length; i++)
        {
            // * only add uniforms to struct that are a member of a struct
            if (this._uniforms[i].isStructMember())
            {
                const injectionString = "{{INJECTION_POINT_STRUCT_" + this._uniforms[i]._structName + "}}";

                // * check if struct is not already part of shader
                if (!this._structNames.includes(this._uniforms[i]._structName))
                {
                    // * create struct definition with placeholder string to inject
                    const structDefinition = "struct "
                        + this._uniforms[i]._structName + " {" + _constants_js__WEBPACK_IMPORTED_MODULE_0__.nl
                        + injectionString
                        + "};" + _constants_js__WEBPACK_IMPORTED_MODULE_0__.nl + _constants_js__WEBPACK_IMPORTED_MODULE_0__.nl;

                    if (this._uniforms[i].getShaderType() === "both" || this._uniforms[i].getShaderType() === "frag")
                        structStrFrag = structStrFrag.concat(structDefinition);

                    if (this._uniforms[i].getShaderType() === "both" || this._uniforms[i].getShaderType() === "vert")
                        structStrVert = structStrVert.concat(structDefinition);

                    this._structNames.push(this._uniforms[i]._structName);
                    this._injectedStringsFrag[this._uniforms[i]._structName] = [];
                    this._injectedStringsVert[this._uniforms[i]._structName] = [];
                }

                // * create member & comment
                let comment = "";
                if (this._uniforms[i].comment) comment = " // " + this._uniforms[i].comment;

                let stringToInsert = "";
                if (this._uniforms[i].getGlslTypeString() == undefined)stringToInsert += "//";
                stringToInsert += "  " + this._uniforms[i].getGlslTypeString()
                        + " " + this._uniforms[i]._propertyName + ";"
                        + comment;

                if (this._uniforms[i].getShaderType() === "both")
                {
                    // * inject member before {injectionString}
                    if (
                        !this._injectedStringsFrag[this._uniforms[i]._structName].includes(stringToInsert)
                    && !this._injectedStringsVert[this._uniforms[i]._structName].includes(stringToInsert))
                    {
                        const insertionIndexFrag = structStrFrag.lastIndexOf(injectionString);
                        const insertionIndexVert = structStrVert.lastIndexOf(injectionString);

                        structStrFrag =
                            structStrFrag.slice(0, insertionIndexFrag)
                            + stringToInsert + structStrFrag.slice(insertionIndexFrag - 1);

                        structStrVert =
                            structStrVert.slice(0, insertionIndexVert)
                            + stringToInsert + structStrVert.slice(insertionIndexVert - 1);

                        this._injectedStringsFrag[this._uniforms[i]._structName].push(stringToInsert);
                        this._injectedStringsVert[this._uniforms[i]._structName].push(stringToInsert);
                    }

                    if (!this._structUniformNamesIndicesFrag.includes(i)) this._structUniformNamesIndicesFrag.push(i);
                    if (!this._structUniformNamesIndicesVert.includes(i)) this._structUniformNamesIndicesVert.push(i);
                }
                else if (this._uniforms[i].getShaderType() === "frag")
                {
                    // * inject member before {injectionString}
                    if (!this._injectedStringsFrag[this._uniforms[i]._structName].includes(stringToInsert)) //
                    {
                        const insertionIndexFrag = structStrFrag.lastIndexOf(injectionString);

                        structStrFrag =
                            structStrFrag.slice(0, insertionIndexFrag)
                            + stringToInsert + structStrFrag.slice(insertionIndexFrag - 1);

                        this._injectedStringsFrag[this._uniforms[i]._structName].push(stringToInsert);
                    }

                    if (!this._structUniformNamesIndicesFrag.includes(i)) this._structUniformNamesIndicesFrag.push(i);
                }
                else if (this._uniforms[i].getShaderType() === "vert")
                {
                    // * inject member before {injectionString}
                    if (!this._injectedStringsVert[this._uniforms[i]._structName].includes(stringToInsert))
                    {
                        const insertionIndexVert = structStrVert.lastIndexOf(injectionString);

                        structStrVert =
                            structStrVert.slice(0, insertionIndexVert)
                            + stringToInsert + structStrVert.slice(insertionIndexVert - 1);

                        this._injectedStringsVert[this._uniforms[i]._structName].push(stringToInsert);
                    }

                    if (!this._structUniformNamesIndicesVert.includes(i)) this._structUniformNamesIndicesVert.push(i);
                }
            }
        }

        // * dedupe injected uni declarations
        this._uniDeclarationsFrag = [];
        this._uniDeclarationsVert = [];

        // * remove struct injection points and add uniform in fragment
        for (let i = 0; i < this._structUniformNamesIndicesFrag.length; i += 1)
        {
            const index = this._structUniformNamesIndicesFrag[i];
            const uniDeclarationString = "UNI " + this._uniforms[index]._structName + " " + this._uniforms[index]._structUniformName + ";" + _constants_js__WEBPACK_IMPORTED_MODULE_0__.nl;

            if (!this._uniDeclarationsFrag.includes(uniDeclarationString))
            {
                const injectionString = "{{INJECTION_POINT_STRUCT_" + this._uniforms[index]._structName + "}}";

                structStrFrag = structStrFrag.replace(injectionString, "");
                structStrFrag += uniDeclarationString;

                this._uniDeclarationsFrag.push(uniDeclarationString);
            }
        }

        // * remove struct injection points and add uniform in vertex
        for (let i = 0; i < this._structUniformNamesIndicesVert.length; i += 1)
        {
            const index = this._structUniformNamesIndicesVert[i];
            const uniDeclarationString = "UNI " + this._uniforms[index]._structName + " " + this._uniforms[index]._structUniformName + ";" + _constants_js__WEBPACK_IMPORTED_MODULE_0__.nl;

            if (!this._uniDeclarationsVert.includes(uniDeclarationString))
            {
                const injectionString = "{{INJECTION_POINT_STRUCT_" + this._uniforms[index]._structName + "}}";

                structStrVert = structStrVert.replace(injectionString, "");
                structStrVert += uniDeclarationString;
                this._uniDeclarationsVert.push(uniDeclarationString);
            }
        }

        return [structStrVert, structStrFrag];
    }

    _getAttrSrc(attr, firstLevel)
    {
        const r = {};
        if (attr.name && attr.type)
        {
            r.srcHeadVert = "";
            if (!firstLevel) r.srcHeadVert += "#ifndef ATTRIB_" + attr.name + _constants_js__WEBPACK_IMPORTED_MODULE_0__.nl;
            r.srcHeadVert += "#define ATTRIB_" + attr.name + _constants_js__WEBPACK_IMPORTED_MODULE_0__.nl;
            r.srcHeadVert += "IN " + attr.type + " " + attr.name + ";" + _constants_js__WEBPACK_IMPORTED_MODULE_0__.nl;
            if (!firstLevel) r.srcHeadVert += "#endif" + _constants_js__WEBPACK_IMPORTED_MODULE_0__.nl;

            if (attr.nameFrag)
            {
                r.srcHeadVert += "";
                if (!firstLevel) r.srcHeadVert += "#ifndef ATTRIB_" + attr.nameFrag + _constants_js__WEBPACK_IMPORTED_MODULE_0__.nl;
                r.srcHeadVert += "#define ATTRIB_" + attr.nameFrag + _constants_js__WEBPACK_IMPORTED_MODULE_0__.nl;
                r.srcHeadVert += "OUT " + attr.type + " " + attr.nameFrag + ";" + _constants_js__WEBPACK_IMPORTED_MODULE_0__.nl;
                if (!firstLevel) r.srcHeadVert += "#endif" + _constants_js__WEBPACK_IMPORTED_MODULE_0__.nl;

                r.srcVert = "" + _constants_js__WEBPACK_IMPORTED_MODULE_0__.nl + attr.nameFrag + "=" + attr.name + ";";

                r.srcHeadFrag = "";
                if (!firstLevel) r.srcHeadFrag += "#ifndef ATTRIB_" + attr.nameFrag + _constants_js__WEBPACK_IMPORTED_MODULE_0__.nl;
                r.srcHeadFrag += "#define ATTRIB_" + attr.nameFrag + _constants_js__WEBPACK_IMPORTED_MODULE_0__.nl;
                r.srcHeadFrag += "IN " + attr.type + " " + attr.nameFrag + ";" + _constants_js__WEBPACK_IMPORTED_MODULE_0__.nl;
                if (!firstLevel) r.srcHeadFrag += "#endif" + _constants_js__WEBPACK_IMPORTED_MODULE_0__.nl;
            }
        }
        return r;
    }

    compile()
    {
        if (this._cgl.aborted) return;
        const startTime = performance.now();

        this._cgl.profileData.profileShaderCompiles++;
        this._cgl.profileData.profileShaderCompileName = this._name + " [" + this._compileReason + "]";

        let extensionString = "";
        if (this._extensions)
            for (let i = 0; i < this._extensions.length; i++)
                extensionString += "#extension " + this._extensions[i] + " : enable" + _constants_js__WEBPACK_IMPORTED_MODULE_0__.nl;

        let definesStr = "";
        if (this._defines.length) definesStr = "\n// cgl generated" + _constants_js__WEBPACK_IMPORTED_MODULE_0__.nl;
        for (let i = 0; i < this._defines.length; i++)
            definesStr += "#define " + this._defines[i][0] + " " + this._defines[i][1] + "" + _constants_js__WEBPACK_IMPORTED_MODULE_0__.nl;

        const structStrings = this.createStructUniforms();
        this._cgl.profileData.addHeavyEvent("shader compile", this._name + " [" + this._compileReason + "]");
        this._compileReason = "";

        if (this._uniforms)
        {
            // * we create an array of the uniform names to check our indices & an array to save them
            const uniNames = this._uniforms.map((uni) => { return uni._name; });
            const indicesToRemove = [];

            // * we go through our uniforms and check if the same name is contained somewhere further in the array
            // * if so, we add the current index to be removed later
            for (let i = 0; i < this._uniforms.length; i++)
            {
                const uni = this._uniforms[i];
                const nextIndex = uniNames.indexOf(uni._name, i + 1);
                if (nextIndex > -1) indicesToRemove.push(i);
            }

            // * after that, we go through the uniforms backwards (so we keep the order) and remove the indices
            // * also, we reset the locations of all the other valid uniforms
            for (let j = this._uniforms.length - 1; j >= 0; j -= 1)
            {
                if (indicesToRemove.includes(j)) this._uniforms.splice(j, 1);
                else this._uniforms[j].resetLoc();
            }
        }

        this._cgl.printError("uniform resets");

        this._compileCount++;
        if (this.hasTextureUniforms()) definesStr += "#define HAS_TEXTURES" + _constants_js__WEBPACK_IMPORTED_MODULE_0__.nl;

        let vs = "";
        let fs = "";

        if (!this.srcFrag)
        {
            this._log.warn("[cgl shader] has no fragment source!", this._name, this);
            this.srcVert = getDefaultVertexShader();
            this.srcFrag = getDefaultFragmentShader();
        }

        vs = "#version 300 es"
            + _constants_js__WEBPACK_IMPORTED_MODULE_0__.nl + "// "
            + _constants_js__WEBPACK_IMPORTED_MODULE_0__.nl + "// vertex shader " + this._name
            + _constants_js__WEBPACK_IMPORTED_MODULE_0__.nl + "// "
            + _constants_js__WEBPACK_IMPORTED_MODULE_0__.nl + "precision " + this.precision + " float;"
            + _constants_js__WEBPACK_IMPORTED_MODULE_0__.nl + "precision " + this.precision + " sampler2D;"
            + _constants_js__WEBPACK_IMPORTED_MODULE_0__.nl + ""
            + _constants_js__WEBPACK_IMPORTED_MODULE_0__.nl + "#define WEBGL2"
            + _constants_js__WEBPACK_IMPORTED_MODULE_0__.nl + "#define texture2D texture"
            + _constants_js__WEBPACK_IMPORTED_MODULE_0__.nl + "#define UNI uniform"
            + _constants_js__WEBPACK_IMPORTED_MODULE_0__.nl + "#define IN in"
            + _constants_js__WEBPACK_IMPORTED_MODULE_0__.nl + "#define OUT out"
            + _constants_js__WEBPACK_IMPORTED_MODULE_0__.nl;

        fs = "#version 300 es"
            + _constants_js__WEBPACK_IMPORTED_MODULE_0__.nl + "// "
            + _constants_js__WEBPACK_IMPORTED_MODULE_0__.nl + "// fragment shader " + this._name
            + _constants_js__WEBPACK_IMPORTED_MODULE_0__.nl + "// "
            + _constants_js__WEBPACK_IMPORTED_MODULE_0__.nl + "precision " + this.precision + " float;"
            + _constants_js__WEBPACK_IMPORTED_MODULE_0__.nl + "precision " + this.precision + " sampler2D;"
            + _constants_js__WEBPACK_IMPORTED_MODULE_0__.nl + ""
            + _constants_js__WEBPACK_IMPORTED_MODULE_0__.nl + "#define WEBGL2"
            + _constants_js__WEBPACK_IMPORTED_MODULE_0__.nl + "#define texture2D texture"
            + _constants_js__WEBPACK_IMPORTED_MODULE_0__.nl + "#define IN in"
            + _constants_js__WEBPACK_IMPORTED_MODULE_0__.nl + "#define OUT out"
            + _constants_js__WEBPACK_IMPORTED_MODULE_0__.nl + "#define UNI uniform"
            + _constants_js__WEBPACK_IMPORTED_MODULE_0__.nl + "{{DRAWBUFFER}}"

            + _constants_js__WEBPACK_IMPORTED_MODULE_0__.nl;

        let uniformsStrVert = "\n// cgl generated" + _constants_js__WEBPACK_IMPORTED_MODULE_0__.nl;
        let uniformsStrFrag = "\n// cgl generated" + _constants_js__WEBPACK_IMPORTED_MODULE_0__.nl;

        fs += "\n// active mods: --------------- ";
        vs += "\n// active mods: --------------- ";

        let foundModsFrag = false;
        let foundModsVert = false;
        for (let i = 0; i < this._moduleNames.length; i++)
        {
            for (let j = 0; j < this._modules.length; j++)
            {
                if (this._modules[j].name == this._moduleNames[i])
                {
                    if (this._modules[j].srcBodyFrag || this._modules[j].srcHeadFrag)
                    {
                        foundModsFrag = true;
                        fs += "\n// " + i + "." + j + ". " + this._modules[j].title + " (" + this._modules[j].name + ")";
                    }
                    if (this._modules[j].srcBodyVert || this._modules[j].srcHeadVert)
                    {
                        vs += "\n// " + i + "." + j + ". " + this._modules[j].title + " (" + this._modules[j].name + ")";
                        foundModsVert = true;
                    }
                }
            }
        }
        if (!foundModsVert)fs += "\n// no mods used...";
        if (!foundModsFrag)fs += "\n// no mods used...";
        fs += "\n";
        vs += "\n";

        for (let i = 0; i < this._uniforms.length; i++)
        {
            if (this._uniforms[i].shaderType && !this._uniforms[i].isStructMember())
            {
                let uniStr = "";
                if (!this._uniforms[i].getGlslTypeString())uniStr += "// ";
                uniStr += "UNI " + this._uniforms[i].getGlslTypeString() + " " + this._uniforms[i].getName();
                let comment = "";
                if (this._uniforms[i].comment) comment = " // " + this._uniforms[i].comment;

                if (this._uniforms[i].shaderType == "vert" || this._uniforms[i].shaderType == "both")
                    if (!this.srcVert.includes(uniStr) && !this.srcVert.includes("uniform " + this._uniforms[i].getGlslTypeString() + " " + this._uniforms[i].getName()))
                        uniformsStrVert += uniStr + ";" + comment + _constants_js__WEBPACK_IMPORTED_MODULE_0__.nl;

                if (this._uniforms[i].shaderType == "frag" || this._uniforms[i].shaderType == "both")
                    if (!this.srcFrag.includes(uniStr) && !this.srcFrag.includes("uniform " + this._uniforms[i].getGlslTypeString() + " " + this._uniforms[i].getName()))
                        uniformsStrFrag += uniStr + ";" + comment + _constants_js__WEBPACK_IMPORTED_MODULE_0__.nl;
            }
        }

        let countUniFrag = 0;
        let countUniVert = 0;
        for (let i = 0; i < this._uniforms.length; i++)
        {
            if (this._uniforms[i].shaderType && !this._uniforms[i].isStructMember())
            {
                if (this._uniforms[i].shaderType == "vert" || this._uniforms[i].shaderType == "both") countUniVert++;
                if (this._uniforms[i].shaderType == "frag" || this._uniforms[i].shaderType == "both") countUniFrag++;
            }
        }
        if (countUniFrag >= this._cgl.maxUniformsFrag) this._log.warn("[cgl_shader] num uniforms frag: " + countUniFrag + " / " + this._cgl.maxUniformsFrag);
        if (countUniVert >= this._cgl.maxUniformsVert) this._log.warn("[cgl_shader] num uniforms vert: " + countUniVert + " / " + this._cgl.maxUniformsVert);

        if (!fs.includes("precision")) fs = "precision " + this.precision + " float;" + _constants_js__WEBPACK_IMPORTED_MODULE_0__.nl + fs;
        if (!vs.includes("precision")) vs = "precision " + this.precision + " float;" + _constants_js__WEBPACK_IMPORTED_MODULE_0__.nl + vs;
        if (/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent))
        {
            fs += "#define MOBILE" + _constants_js__WEBPACK_IMPORTED_MODULE_0__.nl;
            vs += "#define MOBILE" + _constants_js__WEBPACK_IMPORTED_MODULE_0__.nl;
        }
        vs = extensionString + vs + definesStr + structStrings[0] + uniformsStrVert + "\n// -- \n" + this.srcVert;
        fs = extensionString + fs + definesStr + structStrings[1] + uniformsStrFrag + "\n// -- \n" + this.srcFrag;

        let srcHeadVert = "";
        let srcHeadFrag = "";

        this._modules.sort(function (a, b)
        {
            return a.priority || 0 - b.priority || 0;
        });

        let addedAttribs = false;

        for (let i = 0; i < this._moduleNames.length; i++)
        {
            let srcVert = "";
            let srcFrag = "";

            if (!addedAttribs)
            {
                addedAttribs = true;

                for (let k = 0; k < this._attributes.length; k++)
                {
                    const r = this._getAttrSrc(this._attributes[k], true);
                    if (r.srcHeadVert)srcHeadVert += r.srcHeadVert;
                    if (r.srcVert)srcVert += r.srcVert;
                    if (r.srcHeadFrag)srcHeadFrag += r.srcHeadFrag;
                }
            }

            for (let j = 0; j < this._modules.length; j++)
            {
                const mod = this._modules[j];
                if (mod.name == this._moduleNames[i])
                {
                    srcHeadVert += "\n//---- MOD: group:" + mod.group + ": idx:" + j + " - prfx:" + mod.prefix + " - " + mod.title + " ------\n";
                    srcHeadFrag += "\n//---- MOD: group:" + mod.group + ": idx:" + j + " - prfx:" + mod.prefix + " - " + mod.title + " ------\n";

                    srcVert += "\n\n//---- MOD: " + mod.title + " / " + mod.priority + " ------\n";
                    srcFrag += "\n\n//---- MOD: " + mod.title + " / " + mod.priority + " ------\n";

                    if (mod.attributes)
                        for (let k = 0; k < mod.attributes.length; k++)
                        {
                            const r = this._getAttrSrc(mod.attributes[k], false);
                            if (r.srcHeadVert)srcHeadVert += r.srcHeadVert;
                            if (r.srcVert)srcVert += r.srcVert;
                            if (r.srcHeadFrag)srcHeadFrag += r.srcHeadFrag;
                        }

                    srcHeadVert += mod.srcHeadVert || "";
                    srcHeadFrag += mod.srcHeadFrag || "";
                    srcVert += mod.srcBodyVert || "";
                    srcFrag += mod.srcBodyFrag || "";

                    srcHeadVert += "\n//---- end mod ------\n";
                    srcHeadFrag += "\n//---- end mod ------\n";

                    srcVert += "\n//---- end mod ------\n";
                    srcFrag += "\n//---- end mod ------\n";

                    srcVert = srcVert.replace(/{{mod}}/g, mod.prefix);
                    srcFrag = srcFrag.replace(/{{mod}}/g, mod.prefix);
                    srcHeadVert = srcHeadVert.replace(/{{mod}}/g, mod.prefix);
                    srcHeadFrag = srcHeadFrag.replace(/{{mod}}/g, mod.prefix);

                    srcVert = srcVert.replace(/MOD_/g, mod.prefix);
                    srcFrag = srcFrag.replace(/MOD_/g, mod.prefix);
                    srcHeadVert = srcHeadVert.replace(/MOD_/g, mod.prefix);
                    srcHeadFrag = srcHeadFrag.replace(/MOD_/g, mod.prefix);
                }
            }

            vs = vs.replace("{{" + this._moduleNames[i] + "}}", srcVert);
            fs = fs.replace("{{" + this._moduleNames[i] + "}}", srcFrag);
        }

        vs = vs.replace("{{MODULES_HEAD}}", srcHeadVert);
        fs = fs.replace("{{MODULES_HEAD}}", srcHeadFrag);

        vs = this._addLibs(vs);
        fs = this._addLibs(fs);

        // SETUP draw buffers / multi texture render targets

        let drawBufferStr = "";
        for (let i = 0; i < 16; i++)
            if (fs.includes("outColor" + i)) this._drawBuffers[i] = true;

        if (this._drawBuffers.length == 1)
        {
            drawBufferStr = "out vec4 outColor;" + _constants_js__WEBPACK_IMPORTED_MODULE_0__.nl;
            drawBufferStr += "#define gl_FragColor outColor" + _constants_js__WEBPACK_IMPORTED_MODULE_0__.nl;
        }
        else
        {
            drawBufferStr += "#define MULTI_COLORTARGETS" + _constants_js__WEBPACK_IMPORTED_MODULE_0__.nl;
            drawBufferStr += "vec4 outColor;" + _constants_js__WEBPACK_IMPORTED_MODULE_0__.nl;

            let count = 0;
            for (let i = 0; i < this._drawBuffers.length; i++)
            {
                if (count == 0) drawBufferStr += "#define gl_FragColor outColor" + i + "" + _constants_js__WEBPACK_IMPORTED_MODULE_0__.nl;
                drawBufferStr += "layout(location = " + i + ") out vec4 outColor" + i + ";" + _constants_js__WEBPACK_IMPORTED_MODULE_0__.nl;
                count++;
            }
        }

        fs = fs.replace("{{DRAWBUFFER}}", drawBufferStr);
        // //////

        if (!this._program)
        {
            this._program = this._createProgram(vs, fs);
        }
        else
        {
            // this.vshader=createShader(vs, gl.VERTEX_SHADER, this.vshader );
            // this.fshader=createShader(fs, gl.FRAGMENT_SHADER, this.fshader );
            // linkProgram(program);
            this._program = this._createProgram(vs, fs);

            this._projMatrixUniform = null;

            for (let i = 0; i < this._uniforms.length; i++) this._uniforms[i].resetLoc();
        }

        this.finalShaderFrag = fs;
        this.finalShaderVert = vs;

        _cgl_mesh_js__WEBPACK_IMPORTED_MODULE_5__/* .MESH */ .C.lastMesh = null;
        _cgl_mesh_js__WEBPACK_IMPORTED_MODULE_5__/* .MESH */ .C.lastShader = null;

        this._countMissingUniforms = 0;
        this._needsRecompile = false;
        this.lastCompile = (0,cables__WEBPACK_IMPORTED_MODULE_6__/* .now */ .tB)();

        this._cgl.profileData.shaderCompileTime += performance.now() - startTime;
    }

    bind()
    {
        if (!this._isValid || this._cgl.aborted) return;

        _cgl_mesh_js__WEBPACK_IMPORTED_MODULE_5__/* .MESH */ .C.lastShader = this;

        if (!this._program || this.needsRecompile()) this.compile();
        if (!this._isValid) return;

        if (!this._projMatrixUniform && !this.ignoreMissingUniforms)
        {
            this._countMissingUniforms++;
            // if (this._countMissingUniforms == 10)this._log.log("stopping getlocation of missing uniforms...", this._name);
            if (this._countMissingUniforms < 10)
            {
                this._projMatrixUniform = this._cgl.gl.getUniformLocation(this._program, _constants_js__WEBPACK_IMPORTED_MODULE_0__/* .CONSTANTS */ .a.SHADER.SHADERVAR_UNI_PROJMAT);
                this._attrVertexPos = this._cgl.glGetAttribLocation(this._program, _constants_js__WEBPACK_IMPORTED_MODULE_0__/* .CONSTANTS */ .a.SHADER.SHADERVAR_VERTEX_POSITION);
                this._mvMatrixUniform = this._cgl.gl.getUniformLocation(this._program, "mvMatrix");
                this._vMatrixUniform = this._cgl.gl.getUniformLocation(this._program, _constants_js__WEBPACK_IMPORTED_MODULE_0__/* .CONSTANTS */ .a.SHADER.SHADERVAR_UNI_VIEWMAT);
                this._mMatrixUniform = this._cgl.gl.getUniformLocation(this._program, _constants_js__WEBPACK_IMPORTED_MODULE_0__/* .CONSTANTS */ .a.SHADER.SHADERVAR_UNI_MODELMAT);
                this._camPosUniform = this._cgl.gl.getUniformLocation(this._program, _constants_js__WEBPACK_IMPORTED_MODULE_0__/* .CONSTANTS */ .a.SHADER.SHADERVAR_UNI_VIEWPOS);
                this._normalMatrixUniform = this._cgl.gl.getUniformLocation(this._program, _constants_js__WEBPACK_IMPORTED_MODULE_0__/* .CONSTANTS */ .a.SHADER.SHADERVAR_UNI_NORMALMAT);
                this._inverseViewMatrixUniform = this._cgl.gl.getUniformLocation(this._program, _constants_js__WEBPACK_IMPORTED_MODULE_0__/* .CONSTANTS */ .a.SHADER.SHADERVAR_UNI_INVVIEWMAT);
                this._inverseProjMatrixUniform = this._cgl.gl.getUniformLocation(this._program, _constants_js__WEBPACK_IMPORTED_MODULE_0__/* .CONSTANTS */ .a.SHADER.SHADERVAR_UNI_INVPROJMAT);
                this._materialIdUniform = this._cgl.gl.getUniformLocation(this._program, _constants_js__WEBPACK_IMPORTED_MODULE_0__/* .CONSTANTS */ .a.SHADER.SHADERVAR_UNI_MATERIALID);
                this._objectIdUniform = this._cgl.gl.getUniformLocation(this._program, _constants_js__WEBPACK_IMPORTED_MODULE_0__/* .CONSTANTS */ .a.SHADER.SHADERVAR_UNI_OBJECTID);

                for (let i = 0; i < this._uniforms.length; i++) this._uniforms[i].needsUpdate = true;
            }
        }

        if (this._cgl.currentProgram != this._program)
        {
            this._cgl.profileData.profileShaderBinds++;
            this._cgl.gl.useProgram(this._program);
            this._cgl.currentProgram = this._program;
        }

        for (let i = 0; i < this._uniforms.length; i++)
            if (this._uniforms[i].needsUpdate) this._uniforms[i].updateValue();

        if (this._pMatrixState != this._cgl.getProjectionMatrixStateCount())
        {
            this._pMatrixState = this._cgl.getProjectionMatrixStateCount();
            this._cgl.gl.uniformMatrix4fv(this._projMatrixUniform, false, this._cgl.pMatrix);
            this._cgl.profileData.profileMVPMatrixCount++;
        }

        if (this._objectIdUniform)
            this._cgl.gl.uniform1f(this._objectIdUniform, ++this._cgl.tempData.objectIdCounter);

        if (this._materialIdUniform)
            this._cgl.gl.uniform1f(this._materialIdUniform, this._materialId);

        if (this._vMatrixUniform)
        {
            if (this._vMatrixState != this._cgl.getViewMatrixStateCount())
            {
                this._cgl.gl.uniformMatrix4fv(this._vMatrixUniform, false, this._cgl.vMatrix);
                this._cgl.profileData.profileMVPMatrixCount++;
                this._vMatrixState = this._cgl.getViewMatrixStateCount();

                if (this._inverseViewMatrixUniform)
                {
                    gl_matrix__WEBPACK_IMPORTED_MODULE_3__.invert(this._tempInverseViewMatrix, this._cgl.vMatrix);
                    this._cgl.gl.uniformMatrix4fv(this._inverseViewMatrixUniform, false, this._tempInverseViewMatrix);
                    this._cgl.profileData.profileMVPMatrixCount++;
                }
                if (this._inverseProjMatrixUniform)
                {
                    gl_matrix__WEBPACK_IMPORTED_MODULE_3__.invert(this._tempInverseProjMatrix, this._cgl.pMatrix);
                    this._cgl.gl.uniformMatrix4fv(this._inverseProjMatrixUniform, false, this._tempInverseProjMatrix);
                    this._cgl.profileData.profileMVPMatrixCount++;
                }
            }
            this._cgl.gl.uniformMatrix4fv(this._mMatrixUniform, false, this._cgl.mMatrix);
            this._cgl.profileData.profileMVPMatrixCount++;

            if (this._camPosUniform)
            {
                gl_matrix__WEBPACK_IMPORTED_MODULE_3__.invert(this._tempCamPosMatrix, this._cgl.vMatrix);
                this._cgl.gl.uniform3f(this._camPosUniform, this._tempCamPosMatrix[12], this._tempCamPosMatrix[13], this._tempCamPosMatrix[14]);
                this._cgl.profileData.profileMVPMatrixCount++;
            }
        }
        else
        {
            // mvmatrix deprecated....
            const tempmv = gl_matrix__WEBPACK_IMPORTED_MODULE_3__.create();

            gl_matrix__WEBPACK_IMPORTED_MODULE_3__.mul(tempmv, this._cgl.vMatrix, this._cgl.mMatrix);
            this._cgl.gl.uniformMatrix4fv(this._mvMatrixUniform, false, tempmv);
            this._cgl.profileData.profileMVPMatrixCount++;
        }

        if (this._normalMatrixUniform)
        {
            // mat4.mul(this._tempNormalMatrix, this._cgl.vMatrix, this._cgl.mMatrix);
            gl_matrix__WEBPACK_IMPORTED_MODULE_3__.invert(this._tempNormalMatrix, this._cgl.mMatrix);
            gl_matrix__WEBPACK_IMPORTED_MODULE_3__.transpose(this._tempNormalMatrix, this._tempNormalMatrix);

            this._cgl.gl.uniformMatrix4fv(this._normalMatrixUniform, false, this._tempNormalMatrix);
            this._cgl.profileData.profileMVPMatrixCount++;
        }

        for (let i = 0; i < this._libs.length; i++)
        {
            if (this._libs[i].onBind) this._libs[i].onBind.bind(this._libs[i])(this._cgl, this);
        }

        this._bindTextures();

        return this._isValid;
    }

    unBind()
    {
    }

    dispose()
    {

        if (this._program && this._cgl && this._cgl.gl) this._cgl.gl.deleteProgram(this._program);
        this._program = null;
    }

    setDrawBuffers(arr)
    {
        this._log.warn("useless drawbuffers...?!");
    }

    getUniforms()
    {
        return this._uniforms;
    }

    getUniform(name)
    {
        for (let i = 0; i < this._uniforms.length; i++)
            if (this._uniforms[i].getName() == name)
                return this._uniforms[i];
        return null;
    }

    removeAllUniforms()
    {
        this._uniforms = [];
        // for (let i = 0; i < this._uniforms.length; i++)
        //     this.removeUniform(this._uniforms[i].name);
    }

    _addUniform(uni)
    {
        this._uniforms.push(uni);
        this.setWhyCompile("add uniform " + name);
    }

    /**
     * add a uniform to the fragment shader
     * @param {String} type ['f','t', etc]
     * @param {String} name
     * @param {any} valueOrPort value or port
     * @param p2
     * @param p3
     * @param p4
     * @returns {Uniform}
     */
    addUniformFrag(type, name, valueOrPort, p2, p3, p4)
    {
        const uni = new _cgl_shader_uniform_js__WEBPACK_IMPORTED_MODULE_7__/* .Uniform */ .n(this, type, name, valueOrPort, p2, p3, p4);
        uni.shaderType = "frag";
        return uni;
    }

    /**
     * add a uniform to the vertex shader
     * @param {String} type ['f','t', etc]
     * @param {String} name
     * @param {any} valueOrPort value or port
     * @param p2
     * @param p3
     * @param p4
     * @returns {Uniform}
     */
    addUniformVert(type, name, valueOrPort, p2, p3, p4)
    {
        const uni = new _cgl_shader_uniform_js__WEBPACK_IMPORTED_MODULE_7__/* .Uniform */ .n(this, type, name, valueOrPort, p2, p3, p4);
        uni.shaderType = "vert";
        return uni;
    }

    /**
     * add a uniform to both shaders
     * @param {String} type ['f','t', etc]
     * @param {String} name
     * @param {any} valueOrPort value or port
     * @param p2
     * @param p3
     * @param p4
     * @returns {Uniform}
     */
    addUniformBoth(type, name, valueOrPort, p2, p3, p4)
    {
        const uni = new _cgl_shader_uniform_js__WEBPACK_IMPORTED_MODULE_7__/* .Uniform */ .n(this, type, name, valueOrPort, p2, p3, p4);
        uni.shaderType = "both";
        return uni;
    }

    /**
     * add a struct & its uniforms to the fragment shader
     * @param {String} structName name of the struct, i.e.: LightStruct
     * @param {String} uniformName name of the struct uniform in the shader, i.e.: lightUni
     * @param {Array} members array of objects containing the struct members. see example for structure

     * @returns {Object}
     * @example
     * const shader = new CGL.Shader(cgl, 'MinimalMaterial');
     * shader.setSource(attachments.shader_vert, attachments.shader_frag);
     * shader.addUniformStructFrag("Light", "uniformLight", [
     * { "type": "3f", "name": "position", "v1": null },
     * { "type": "4f", "name": "color", "v1": inR, v2: inG, v3: inB, v4: inAlpha }
     * ]);
     */
    addUniformStructFrag(structName, uniformName, members)
    {
        const uniforms = {};

        if (!members) return uniforms;

        for (let i = 0; i < members.length; i += 1)
        {
            const member = members[i];
            if (!this.hasUniform(uniformName + "." + member.name))
            {
                const uni = new _cgl_shader_uniform_js__WEBPACK_IMPORTED_MODULE_7__/* .Uniform */ .n(this, member.type, uniformName + "." + member.name, member.v1, member.v2, member.v3, member.v4, uniformName, structName, member.name);
                uni.shaderType = "frag";
                uniforms[uniformName + "." + member.name] = uni;
            }
        }

        return uniforms;
    }

    /**
     * add a struct & its uniforms to the vertex shader
     * @param {String} structName name of the struct, i.e.: LightStruct
     * @param {String} uniformName name of the struct uniform in the shader, i.e.: lightUni
     * @param {Array} members array of objects containing the struct members. see example for structure
     * @returns {object}
     * @example
     * const shader = new CGL.Shader(cgl, 'MinimalMaterial');
     * shader.setSource(attachments.shader_vert, attachments.shader_frag);
     * shader.addUniformStructVert("Light", "uniformLight", [
     * { "type": "3f", "name": "position", "v1": null },
     * { "type": "4f", "name": "color", "v1": inR, v2: inG, v3: inB, v4: inAlpha }
     * ]);
     */
    addUniformStructVert(structName, uniformName, members)
    {
        const uniforms = {};

        if (!members) return uniforms;

        for (let i = 0; i < members.length; i += 1)
        {
            const member = members[i];
            if (!this.hasUniform(uniformName + "." + member.name))
            {
                const uni = new _cgl_shader_uniform_js__WEBPACK_IMPORTED_MODULE_7__/* .Uniform */ .n(this, member.type, uniformName + "." + member.name, member.v1, member.v2, member.v3, member.v4, uniformName, structName, member.name);
                uni.shaderType = "vert";
                uniforms[uniformName + "." + member.name] = uni;
            }
        }

        return uniforms;
    }

    /**
     * add a struct & its uniforms to the both shaders. PLEASE NOTE: it is not possible to add the same struct to both shaders when it contains ANY integer members.
     * @param {String} structName name of the struct, i.e.: LightStruct
     * @param {String} uniformName name of the struct uniform in the shader, i.e.: lightUni
     * @param {Array} members array of objects containing the struct members. see example for structure

     * @returns {Object}
     * @example
     * const shader = new CGL.Shader(cgl, 'MinimalMaterial');
     * shader.setSource(attachments.shader_vert, attachments.shader_frag);
     * shader.addUniformStructBoth("Light", "uniformLight", [
     * { "type": "3f", "name": "position", "v1": null },
     * { "type": "4f", "name": "color", "v1": inR, v2: inG, v3: inB, v4: inAlpha }
     * ]);
     */
    addUniformStructBoth(structName, uniformName, members)
    {
        const uniforms = {};

        if (!members) return uniforms;

        for (let i = 0; i < members.length; i += 1)
        {
            const member = members[i];
            if ((member.type === "2i" || member.type === "i" || member.type === "3i"))
                this._log.error("Adding an integer struct member to both shaders can potentially error. Please use different structs for each shader. Error occured in struct:", structName, " with member:", member.name, " of type:", member.type, ".");
            if (!this.hasUniform(uniformName + "." + member.name))
            {
                const uni = new _cgl_shader_uniform_js__WEBPACK_IMPORTED_MODULE_7__/* .Uniform */ .n(this, member.type, uniformName + "." + member.name, member.v1, member.v2, member.v3, member.v4, uniformName, structName, member.name);
                uni.shaderType = "both";
                uniforms[uniformName + "." + member.name] = uni;
            }
        }

        return uniforms;
    }

    /**
     * @param {String} vstr
     * @param {String} fstr
     */
    _createProgram(vstr, fstr)
    {
        this._cgl.printError("before _createprogram");

        const program = this._cgl.gl.createProgram();

        this.vshader = CglShader.createShader(this._cgl, vstr, this._cgl.gl.VERTEX_SHADER, this);
        this.fshader = CglShader.createShader(this._cgl, fstr, this._cgl.gl.FRAGMENT_SHADER, this);

        if (this.vshader && this.fshader)
        {
            this._cgl.gl.attachShader(program, this.vshader);
            this._cgl.gl.attachShader(program, this.fshader);

            this._linkProgram(program, vstr, fstr);
        }
        else
        {
            this._isValid = false;
            this._cgl.printError("shader _createProgram");
            this._log.error("could not link shaderprogram");
            return null;
        }

        this._cgl.printError("shader _createProgram");
        return program;
    }

    hasErrors()
    {
        return this._hasErrors;
    }

    /**
     * @param {any} program
     * @param {string} vstr
     * @param {string} fstr
     */
    _linkProgram(program, vstr, fstr)
    {
        this._cgl.printError("before _linkprogram");

        if (this._feedBackNames.length > 0)
        {
            this._cgl.gl.transformFeedbackVaryings(program, this._feedBackNames, this._cgl.gl.SEPARATE_ATTRIBS);
            // INTERLEAVED_ATTRIBS
            // SEPARATE_ATTRIBS
        }

        this._cgl.gl.linkProgram(program);
        this._cgl.printError("gl.linkprogram");
        this._isValid = true;
        this._hasErrors = false;

        if (this._cgl.patch.config.glValidateShader !== false)
        {
            this._cgl.gl.validateProgram(program);

            if (!this._cgl.gl.getProgramParameter(program, this._cgl.gl.VALIDATE_STATUS))
            {
                // validation failed
                this._log.log("shaderprogram validation failed...");

                this._cgl.gl.getProgramInfoLog(program);
            }

            if (!this._cgl.gl.getProgramParameter(program, this._cgl.gl.LINK_STATUS))
            {
                this._hasErrors = true;

                const infoLogFrag = this._cgl.gl.getShaderInfoLog(this.fshader);
                const infoLogVert = this._cgl.gl.getShaderInfoLog(this.vshader);

                if (this.logError)
                    this._log.error(this._name + " shader linking fail...");
                else
                    this._log.warn(this._name + " shader linking fail...");

                if (infoLogFrag) this._log.warn(this._cgl.gl.getShaderInfoLog(this.fshader));
                if (infoLogVert) this._log.warn(this._cgl.gl.getShaderInfoLog(this.vshader));

                this._cgl.gl.getProgramInfoLog(program);
                if (!CABLES.UI) this._log.log(this);
                this._isValid = false;

                this._cgl.printError("shader link err");
            }
        }
    }

    getProgram()
    {
        return this._program;
    }

    /**
     * @param {any[]} names
     */
    setFeedbackNames(names)
    {
        this.setWhyCompile("setFeedbackNames");
        this._feedBackNames = names;
    }

    /**
      * adds attribute definition to shader header without colliding with other shader modules...
     * when attrFrag is defined, vertex shader will output this attribute to the fragment shader
     * @param {Object} attr {type:x,name:x,[nameFrag:x]}
     * @return {Object}
     */
    addAttribute(attr)
    {
        for (let i = 0; i < this._attributes.length; i++)
        {
            if (this._attributes[i].name == attr.name && this._attributes[i].nameFrag == attr.nameFrag) return;
        }
        this._attributes.push(attr);

        this.setWhyCompile("addAttribute");
    }

    bindTextures()
    {
        this._bindTextures();
    }

    _bindTextures()
    {
        if (this._textureStackTex.length > this._cgl.maxTextureUnits)
        {
            this._log.warn("[shader._bindTextures] too many textures bound", this._textureStackTex.length + "/" + this._cgl.maxTextureUnits);
        }

        // for (let i = this._textureStackTex.length + 1; i < this._cgl.maxTextureUnits; i++) this._cgl.setTexture(i, null);

        for (let i = 0; i < this._textureStackTex.length; i++)
        {
            // this._log.log(this._textureStackTex.length, i);
            if (!this._textureStackTex[i] && !this._textureStackTexCgl[i])
            {
                this._log.warn("no texture for pushtexture", this._name);
            }
            else
            {
                let t = this._textureStackTex[i];
                if (this._textureStackTexCgl[i])
                {
                    t = this._textureStackTexCgl[i].tex || CGL.Texture.getEmptyTexture(this._cgl).tex;
                }

                let bindOk = true;

                if (!this._textureStackUni[i])
                {
                    // throw(new Error('no uniform given to texturestack'));
                    this._log.warn("no uniform for pushtexture", this._name);
                    bindOk = this._cgl.setTexture(i, t, this._textureStackType[i]);
                }
                else
                {
                    this._textureStackUni[i].setValue(i);
                    bindOk = this._cgl.setTexture(i, t, this._textureStackType[i]);

                    // this._log.log(bindOk, i, t, this._textureStackType[i]);
                }
                if (!bindOk) this._log.warn("tex bind failed", this.getName(), this._textureStackUni[i]);
            }
        }
    }

    /**
     * @param {Uniform} uni
     * @param {Texture} tex
     */
    setUniformTexture(uni, tex)
    {
        tex = tex || _cgl_texture_js__WEBPACK_IMPORTED_MODULE_8__/* .Texture */ .g.getTempTexture(this._cgl);
        for (let i = 0; i < this._textureStackUni.length; i++)
            if (this._textureStackUni[i] == uni)
            {
                const old = this._textureStackTex[i] || this._textureStackTexCgl[i];
                if (tex.hasOwnProperty("tex"))
                {
                    this._textureStackTexCgl[i] = tex;
                    this._textureStackTex[i] = null;
                }
                else
                {
                    this._textureStackTexCgl[i] = null;
                    this._textureStackTex[i] = tex;
                }

                // this._textureStackTex[i] = tex;
                // this._cgl.setTexture(i, tex, this._textureStackType[i]);
                return old;
            }
        return null;
    }

    /**
     * push a texture on the stack. those textures will be bound when binding the shader. texture slots are automatically set
     * @param {Uniform} uniform texture uniform
     * @param {Texture} t texture
     * @param {number} type texture type, can be ignored when TEXTURE_2D
     */
    pushTexture(uniform, t, type)
    {
        if (!uniform)
        {
            // this._log.log("pushtexture: no uniform given to texturestack", "shader:"+this._name,uniform,t,type);
            return;
        }
        if (!t)
        {
            // if(uniform)this._log.warn("pushtexture: no tex","shader:"+this._name," uniform:"+uniform.name);
            return;
        }
        if (!t.hasOwnProperty("tex") && !(t instanceof WebGLTexture))
        {
            this._log.warn(new Error("invalid texture").stack);

            this._log.warn("[cgl_shader] invalid texture...", t);
            return;
        }

        this._textureStackUni.push(uniform);

        if (t.hasOwnProperty("tex"))
        {
            this._textureStackTexCgl.push(t);
            this._textureStackTex.push(null);
        }
        else
        {
            this._textureStackTexCgl.push(null);
            this._textureStackTex.push(t);
        }

        this._textureStackType.push(type);
    }

    /**
     * pop last texture
     */
    popTexture()
    {
        this._textureStackUni.pop();
        this._textureStackTex.pop();
        this._textureStackTexCgl.pop();
        this._textureStackType.pop();
    }

    /**
     * pop all textures
     */
    popTextures()
    {
        this._textureStackTex.length =
        this._textureStackTexCgl.length =
        this._textureStackType.length =
        this._textureStackUni.length = 0;
    }

    getMaterialId()
    {
        return this._materialId;
    }

    getInfo()
    {
        const info = {};
        info.name = this._name;
        // info.modules = JSON.parse(JSON.stringify(this._modules));
        // info.defines = JSON.parse(JSON.stringify(this._defines));
        info.defines = this.getDefines();
        info.hasErrors = this.hasErrors();

        return info;
    }

    getDefaultFragmentShader(r, g, b, a)
    {
        return getDefaultFragmentShader(r, g, b, a);
    }

    getDefaultVertexShader()
    {
        return getDefaultVertexShader();
    }
}

// --------------------------

CglShader.getDefaultVertexShader = getDefaultVertexShader;
CglShader.getDefaultFragmentShader = getDefaultFragmentShader;

CglShader.getErrorFragmentShader = function ()
{
    return ""
        + _constants_js__WEBPACK_IMPORTED_MODULE_0__.nl + "void main()"
        + _constants_js__WEBPACK_IMPORTED_MODULE_0__.nl + "{"
        + _constants_js__WEBPACK_IMPORTED_MODULE_0__.nl + "   float g=mod((gl_FragCoord.y+gl_FragCoord.x),50.0)/50.0;"
        + _constants_js__WEBPACK_IMPORTED_MODULE_0__.nl + "   g= step(0.1,g);"
        + _constants_js__WEBPACK_IMPORTED_MODULE_0__.nl + "   outColor = vec4( g+0.5, 0.0, 0.0, 1.0);"
        + _constants_js__WEBPACK_IMPORTED_MODULE_0__.nl + "}";
};

/**
 * @param {CglContext} cgl
 * @param {String} str
 * @param {number} type
 * @param {CglShader} cglShader
 * @returns {CglShader}
 */
CglShader.createShader = function (cgl, str, type, cglShader)
{
    if (cgl.aborted) return;

    const shader = cgl.gl.createShader(type);
    cgl.gl.shaderSource(shader, str);
    cgl.gl.compileShader(shader);

    if (!cgl.gl.getShaderParameter(shader, cgl.gl.COMPILE_STATUS))
    {
        cglShader.error = { "str": str, "infoLog": cgl.gl.getShaderInfoLog(shader) };

        if (CABLES.UI) gui.emitEvent("ShaderError", cglShader);

        if (!cglShader.error.infoLog)
        {
            cglShader._log.warn("empty shader info log", this._name);
            return;
        }
        cglShader.setSource(CglShader.getDefaultVertexShader(), CglShader.getErrorFragmentShader());
    }
    return shader;
};




/***/ }),

/***/ 960:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   y: () => (/* binding */ ShaderLibMods)
/* harmony export */ });
/* harmony import */ var _cgl_shader_uniform_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(923);
/* harmony import */ var _cgl_textureeffect_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(771);
/* harmony import */ var _cgl_texture_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(70);




/** @type {Object} */
const ShaderLibMods = {
    "CGL.BLENDMODES": function ()
    {
        this.name = "blendmodes";
        this.srcHeadFrag = _cgl_textureeffect_js__WEBPACK_IMPORTED_MODULE_0__/* .TextureEffect */ .p.getBlendCode();
    },

    "CGL.BLENDMODES3": function ()
    {
        this.name = "blendmodes3";
        this.srcHeadFrag = _cgl_textureeffect_js__WEBPACK_IMPORTED_MODULE_0__/* .TextureEffect */ .p.getBlendCode(3);
    },

    "CGL.LUMINANCE": function ()
    {
        this.name = "luminance";
        this.srcHeadFrag = "".endl()
            + "float cgl_luminance(vec3 c)".endl()
            + "{".endl()
            + "    return dot(vec3(0.2126,0.7152,0.0722),c);".endl()
            + "}".endl();
    },

    // quite good random numbers, but somehow don't work in ANGLE
    "CGL.RANDOM_OLD": function ()
    {
        this.name = "randomNumber";
        this.srcHeadFrag = "".endl()
            + "float cgl_random(vec2 co)".endl()
            + "{".endl()
            + "    return fract(sin(dot(co.xy ,vec2(12.9898,4.1414))) * 432758.5453);".endl()
            + "}".endl()
            + "vec3 cgl_random3(vec2 co)".endl()
            + "{".endl()
            + "    return vec3( cgl_random(co),cgl_random(co+0.5711),cgl_random(co+1.5711));".endl()
            + "}";
    },

    // low quality generative ranodm numbers
    "CGL.RANDOM_LOW": function ()
    {
        this.name = "randomNumber";
        this.srcHeadFrag = "".endl()
            + "float cgl_random(vec2 co)".endl()
            + "{".endl()
            + "    return fract(sin(dot(co.xy ,vec2(12.9898,4.1414))) * 358.5453);".endl()
            + "}".endl()
            + "vec3 cgl_random3(vec2 co)".endl()
            + "{".endl()
            + "    return vec3( cgl_random(co),cgl_random(co+0.5711),cgl_random(co+1.5711));".endl()
            + "}";
    },

    "CGL.RANDOM_TEX": function ()
    {
        this.name = "randomNumbertex";

        this.srcHeadFrag = "".endl()
            + "UNI sampler2D CGLRNDTEX;".endl()
            + "float cgl_random(vec2 co)".endl()
            + "{".endl()
            + "    return texture(CGLRNDTEX,co*5711.0).r;".endl()
            + "}".endl()
            + "vec3 cgl_random3(vec2 co)".endl()
            + "{".endl()
            + "    return texture(CGLRNDTEX,co*5711.0).rgb;".endl()
            + "}";

        this.initUniforms = function (shader)
        {
            return [new _cgl_shader_uniform_js__WEBPACK_IMPORTED_MODULE_1__/* .Uniform */ .n(shader, "t", "CGLRNDTEX", 7)];
        };

        this.onBind = function (cgl, shader)
        {
            _cgl_texture_js__WEBPACK_IMPORTED_MODULE_2__/* .Texture */ .g.getRandomTexture(cgl);
            cgl.setTexture(7, _cgl_texture_js__WEBPACK_IMPORTED_MODULE_2__/* .Texture */ .g.getRandomTexture(cgl).tex);
        };
    }

};


/***/ }),

/***/ 923:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   n: () => (/* binding */ Uniform)
/* harmony export */ });
/* harmony import */ var _cg_cg_uniform_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(475);




/**
 * Shader uniforms
 *
 * types:
 * <pre>
 * f    - float
 * 2f   - vec2
 * 3f   - vec3
 * 4f   - vec4
 * i    - integer
 * t    - texture
 * m4   - mat4, 4x4 float matrix
 * f[]  - array of floats
 * 2f[] - array of float vec2
 * 3f[] - array of float vec3
 * 4f[] - array of float vec4
 * </pre>
 *
 * @namespace external:CGL
 * @class
 * @param {CgShader} shader
 * @param {String} [type=f]
 * @param {String} name
 * @param {Number|Port} value  can be a Number,Matrix or Port
 * @example
 * // bind float uniform called myfloat and initialize with value 1.0
 * const unir=new CGL.Uniform(shader,'f','myfloat',1.0);
 * unir.setValue(1.0);
 *
 * // bind float uniform called myfloat and automatically set it to input port value
 * const myPort=op.inFloat("input");
 * const pv=new CGL.Uniform(shader,'f','myfloat',myPort);
 *
 */

// export const Uniform(__shader, __type, __name, _value, _port2, _port3, _port4, _structUniformName, _structName, _propertyName)

class Uniform extends _cg_cg_uniform_js__WEBPACK_IMPORTED_MODULE_0__/* .CgUniform */ .v
{
    constructor(__shader, __type, __name, _value, _port2, _port3, _port4, _structUniformName, _structName, _propertyName)
    {
        super(__shader, __type, __name, _value, _port2, _port3, _port4, _structUniformName, _structName, _propertyName);
        this._loc = -1;
        this._cgl = __shader._cgl;
    }

    get name()
    {
        return this._name;
    }

    copy(newShader)
    {
        const uni = new Uniform(newShader, this._type, this._name, this._value, this._port2, this._port3, this._port4, this._structUniformName, this._structName, this._propertyName);
        uni.shaderType = this.shaderType;
        return uni;
    }

    /**
     * returns type as glsl type string. e.g. 'f' returns 'float'
     * @function getGlslTypeString
     * @memberof Uniform
     * @instance
     * @return {string} type as string
     */
    getGlslTypeString()
    {
        return Uniform.glslTypeString(this._type);
    }

    _isValidLoc()
    {
        return this._loc != -1;// && this._loc != null;
    }

    resetLoc()
    {
        this._loc = -1;
        this.needsUpdate = true;
    }

    bindTextures() {}

    getLoc()
    {
        return this._loc;
    }

    updateFromPort4f()
    {
        this._value[0] = this._port.get();
        this._value[1] = this._port2.get();
        this._value[2] = this._port3.get();
        this._value[3] = this._port4.get();
        this.setValue(this._value);
    }

    updateFromPort3f()
    {
        this._value[0] = this._port.get();
        this._value[1] = this._port2.get();
        this._value[2] = this._port3.get();
        this.setValue(this._value);
    }

    updateFromPort2f()
    {
        this._value[0] = this._port.get();
        this._value[1] = this._port2.get();
        this.setValue(this._value);
    }

    updateFromPort()
    {
        this.setValue(this._port.get());
    }

    updateValueF()
    {
        if (!this._isValidLoc()) this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name);
        else this.needsUpdate = false;

        this._shader.getCgl().gl.uniform1f(this._loc, this._value);
        this._cgl.profileData.profileUniformCount++;
    }

    setValueF(v)
    {
        if (v != this._value)
        {
            this.needsUpdate = true;
            this._value = v;
        }
    }

    updateValueI()
    {
        if (!this._isValidLoc()) this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name);
        else this.needsUpdate = false;

        this._shader.getCgl().gl.uniform1i(this._loc, this._value);
        this._cgl.profileData.profileUniformCount++;
    }

    updateValue2I()
    {
        if (!this._value) return;

        if (!this._isValidLoc())
        {
            this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name);
            this._cgl.profileData.profileShaderGetUniform++;
            this._cgl.profileData.profileShaderGetUniformName = this._name;
        }

        this._shader.getCgl().gl.uniform2i(this._loc, this._value[0], this._value[1]);

        this.needsUpdate = false;
        this._cgl.profileData.profileUniformCount++;
    }

    updateValue3I()
    {
        if (!this._value) return;
        if (!this._isValidLoc())
        {
            this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name);
            this._cgl.profileData.profileShaderGetUniform++;
            this._cgl.profileData.profileShaderGetUniformName = this._name;
        }

        this._shader.getCgl().gl.uniform3i(this._loc, this._value[0], this._value[1], this._value[2]);
        this.needsUpdate = false;
        this._cgl.profileData.profileUniformCount++;
    }

    updateValue4I()
    {
        if (!this._isValidLoc())
        {
            this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name);
            this._cgl.profileData.profileShaderGetUniform++;
            this._cgl.profileData.profileShaderGetUniformName = this._name;
        }
        this._shader.getCgl().gl.uniform4i(this._loc, this._value[0], this._value[1], this._value[2], this._value[3]);
        this._cgl.profileData.profileUniformCount++;
    }

    setValueI(v)
    {
        if (v != this._value)
        {
            this.needsUpdate = true;
            this._value = v;
        }
    }

    setValue2I(v)
    {
        if (!v) return;
        if (!this._oldValue)
        {
            this._oldValue = [v[0] - 1, 1];
            this.needsUpdate = true;
        }
        else if (v[0] != this._oldValue[0] || v[1] != this._oldValue[1])
        {
            this._oldValue[0] = v[0];
            this._oldValue[1] = v[1];
            this.needsUpdate = true;
        }

        this._value = v;
    }

    setValue3I(v)
    {
        if (!v) return;
        if (!this._oldValue)
        {
            this._oldValue = [v[0] - 1, 1, 2];
            this.needsUpdate = true;
        }
        else if (v[0] != this._oldValue[0] || v[1] != this._oldValue[1] || v[2] != this._oldValue[2])
        {
            this._oldValue[0] = v[0];
            this._oldValue[1] = v[1];
            this._oldValue[2] = v[2];
            this.needsUpdate = true;
        }

        this._value = v;
    }

    setValue4I(v)
    {
        this.needsUpdate = true;
        this._value = v || vec4.create();
    }

    updateValueBool()
    {
        if (!this._isValidLoc()) this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name);
        else this.needsUpdate = false;
        this._shader.getCgl().gl.uniform1i(this._loc, this._value ? 1 : 0);

        this._cgl.profileData.profileUniformCount++;
    }

    setValueBool(v)
    {
        if (v != this._value)
        {
            this.needsUpdate = true;
            this._value = v;
        }
    }

    setValueArray4F(v)
    {
        this.needsUpdate = true;
        this._value = v;
    }

    updateValueArray4F()
    {
        if (!this._isValidLoc()) this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name);
        else this.needsUpdate = false;

        if (!this._value) return;
        this._shader.getCgl().gl.uniform4fv(this._loc, this._value);
        this._cgl.profileData.profileUniformCount++;
    }

    setValueArray3F(v)
    {
        this.needsUpdate = true;
        this._value = v;
    }

    updateValueArray3F()
    {
        if (!this._isValidLoc()) this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name);
        else this.needsUpdate = false;

        if (!this._value) return;
        this._shader.getCgl().gl.uniform3fv(this._loc, this._value);
        this._cgl.profileData.profileUniformCount++;
    }

    setValueArray2F(v)
    {
        this.needsUpdate = true;
        this._value = v;
    }

    updateValueArray2F()
    {
        if (!this._isValidLoc()) this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name);
        else this.needsUpdate = false;

        if (!this._value) return;
        this._shader.getCgl().gl.uniform2fv(this._loc, this._value);
        this._cgl.profileData.profileUniformCount++;
    }

    setValueArrayF(v)
    {
        this.needsUpdate = true;
        this._value = v;
    }

    updateValueArrayF()
    {
        if (!this._isValidLoc()) this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name);
        else this.needsUpdate = false;

        if (!this._value) return;
        this._shader.getCgl().gl.uniform1fv(this._loc, this._value);
        this._cgl.profileData.profileUniformCount++;
    }

    setValueArrayT(v)
    {
        this.needsUpdate = true;
        this._value = v;
    }

    updateValue3F()
    {
        if (!this._value) return;
        if (!this._isValidLoc())
        {
            this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name);
            this._cgl.profileData.profileShaderGetUniform++;
            this._cgl.profileData.profileShaderGetUniformName = this._name;
        }

        this._shader.getCgl().gl.uniform3f(this._loc, this._value[0], this._value[1], this._value[2]);
        this.needsUpdate = false;
        this._cgl.profileData.profileUniformCount++;
    }

    setValue3F(v)
    {
        if (!v) return;
        if (!this._oldValue)
        {
            this._oldValue = [v[0] - 1, 1, 2];
            this.needsUpdate = true;
        }
        else if (v[0] != this._oldValue[0] || v[1] != this._oldValue[1] || v[2] != this._oldValue[2])
        {
            this._oldValue[0] = v[0];
            this._oldValue[1] = v[1];
            this._oldValue[2] = v[2];
            this.needsUpdate = true;
        }

        this._value = v;
    }

    updateValue2F()
    {
        if (!this._value) return;

        if (!this._isValidLoc())
        {
            this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name);
            this._cgl.profileData.profileShaderGetUniform++;
            this._cgl.profileData.profileShaderGetUniformName = this._name;
        }

        this._shader.getCgl().gl.uniform2f(this._loc, this._value[0], this._value[1]);
        this.needsUpdate = false;
        this._cgl.profileData.profileUniformCount++;
    }

    setValue2F(v)
    {
        if (!v) return;
        if (!this._oldValue)
        {
            this._oldValue = [v[0] - 1, 1];
            this.needsUpdate = true;
        }
        else if (v[0] != this._oldValue[0] || v[1] != this._oldValue[1])
        {
            this._oldValue[0] = v[0];
            this._oldValue[1] = v[1];
            this.needsUpdate = true;
        }
        this._value = v;
    }

    updateValue4F()
    {
        if (!this._isValidLoc())
        {
            this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name);
            this._cgl.profileData.profileShaderGetUniform++;
            this._cgl.profileData.profileShaderGetUniformName = this._name;
        }

        if (!this._value)
        {
            this._log.warn("no value for uniform", this._name, this);
            this._value = [0, 0, 0, 0];
        }

        this.needsUpdate = false;
        this._shader.getCgl().gl.uniform4f(this._loc, this._value[0], this._value[1], this._value[2], this._value[3]);
        this._cgl.profileData.profileUniformCount++;
    }

    setValue4F(v)
    {
        if (typeof this.value == "number") this.value = vec4.create(); // this should not be needed, but somehow it crashes with some shadermods

        if (!v) return;
        if (!this._oldValue)
        {
            this._oldValue = [v[0] - 1, 1, 2, 3];
            this.needsUpdate = true;
        }
        else if (v[0] != this._oldValue[0] || v[1] != this._oldValue[1] || v[2] != this._oldValue[2] || v[3] != this._oldValue[3])
        {
            this._oldValue[0] = v[0];
            this._oldValue[1] = v[1];
            this._oldValue[2] = v[2];
            this.needsUpdate = true;
        }

        this._value = v;
    }

    updateValueM4()
    {
        if (!this._isValidLoc())
        {
            this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name);
            this._cgl.profileData.profileShaderGetUniform++;
            this._cgl.profileData.profileShaderGetUniformName = this._name;
        }
        if (!this._value || this._value.length % 16 != 0) return console.log("this.name", this._name, this._value);

        this._shader.getCgl().gl.uniformMatrix4fv(this._loc, false, this._value);
        this._cgl.profileData.profileUniformCount++;
    }

    setValueM4(v)
    {
        this.needsUpdate = true;
        this._value = v || mat4.create();
    }

    updateValueArrayT()
    {
        if (!this._isValidLoc()) this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name);
        else this.needsUpdate = false;

        if (!this._value) return;
        this._shader.getCgl().gl.uniform1iv(this._loc, this._value);
        this._cgl.profileData.profileUniformCount++;
    }

    updateValueT()
    {
        if (!this._isValidLoc())
        {
            this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name);
            this._cgl.profileData.profileShaderGetUniform++;
            this._cgl.profileData.profileShaderGetUniformName = this._name;
        }

        this._cgl.profileData.profileUniformCount++;
        this._shader.getCgl().gl.uniform1i(this._loc, this._value);
        this.needsUpdate = false;
    }

    setValueT(v)
    {
        this.needsUpdate = true;
        this._value = v;
    }
}

Uniform.glslTypeString = (t) =>
{
    if (t == "f") return "float";
    if (t == "b") return "bool";
    if (t == "i") return "int";
    if (t == "2i") return "ivec2";
    if (t == "2f") return "vec2";
    if (t == "3f") return "vec3";
    if (t == "4f") return "vec4";
    if (t == "m4") return "mat4";

    if (t == "t") return "sampler2D";
    if (t == "tc") return "samplerCube";

    if (t == "3f[]") return null; // ignore this for now...
    if (t == "m4[]") return null; // ignore this for now...
    if (t == "f[]") return null; // ignore this for now...

    console.warn("[CGL UNIFORM] unknown glsl type string ", t);
};

/**
 * @function setValue
 * @memberof Uniform
 * @instance
 * @param {Number|Array|Matrix|Texture} value
 */


/***/ }),

/***/ 273:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   S: () => (/* binding */ MESHES)
/* harmony export */ });
/* harmony import */ var _cg_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(331);
/* harmony import */ var _cgl_mesh_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(264);



const MESHES = {};

MESHES.getSimpleRect = function (cgl, name, size = 1.0)
{
    const geom = new _cg_index_js__WEBPACK_IMPORTED_MODULE_0__/* .Geometry */ .V(name);

    geom.vertices = [1.0 * size, 1.0 * size, 0.0, -1.0 * size, 1.0 * size, 0.0, 1.0 * size, -1.0 * size, 0.0, -1.0 * size, -1.0 * size, 0.0];
    geom.texCoords = [1.0, 1.0, 0.0, 1.0, 1.0, 0.0, 0.0, 0.0];
    geom.verticesIndices = [0, 1, 2, 2, 1, 3];
    geom.vertexNormals = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0];

    return cgl.createMesh(geom);
};

MESHES.getSimpleCube = function (cgl, name)
{
    const geom = new _cg_index_js__WEBPACK_IMPORTED_MODULE_0__/* .Geometry */ .V(name);
    geom.vertices = [-1, -1, 1, 1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, -1, 1, -1, -1, 1, 1, -1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1, 1, -1, 1, 1, -1, -1, -1, 1, -1, -1, 1, -1, 1, -1, -1, 1, 1, -1, -1, 1, -1, 1, 1, 1, 1, 1, 1, -1, -1, -1, -1, -1, -1, 1, -1, 1, 1, -1, 1, -1];
    geom.setTexCoords([0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0,]);
    geom.verticesIndices = [0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13, 14, 12, 14, 15, 16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23];
    geom.vertexNormals = new Float32Array([0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0]);
    geom.tangents = new Float32Array([0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1]);
    geom.biTangents = new Float32Array([-1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1]);

    return new _cgl_mesh_js__WEBPACK_IMPORTED_MODULE_1__/* .Mesh */ .e(cgl, geom);
};




/***/ }),

/***/ 308:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   G: () => (/* binding */ CglContext)
/* harmony export */ });
/* unused harmony export BLENDS */
/* harmony import */ var cables_shared_client__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(849);
/* harmony import */ var cables__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(562);
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(997);
/* harmony import */ var _cgl_shader_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(24);
/* harmony import */ var _cg_cg_context_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(628);
/* harmony import */ var _cgl_mesh_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(264);
/* harmony import */ var _cgl_texture_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(70);










const BLENDS = {
    "BLEND_NONE": 0,
    "BLEND_NORMAL": 1,
    "BLEND_ADD": 2,
    "BLEND_SUB": 3,
    "BLEND_MUL": 4,
};

/**
 * cables gl context/state manager
 * @class
 * @namespace external:CGL
 * @hideconstructor
 */
// const Context(_patch)
class CglContext extends _cg_cg_context_js__WEBPACK_IMPORTED_MODULE_0__/* .CgContext */ .A
{

    /**
     * @param {Patch} _patch
     */
    constructor(_patch)
    {
        super(_patch);

        this.gApi = _cg_cg_context_js__WEBPACK_IMPORTED_MODULE_0__/* .CgContext */ .A.API_WEBGL;
        this.aborted = false;

        /** @deprecated */
        this.pushMvMatrix = this.pushModelMatrix; // deprecated and wrong... still used??
        /** @deprecated */
        this.popMvMatrix = this.popmMatrix = this.popModelMatrix;// deprecated and wrong... still used??

        this._log = new cables_shared_client__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A("cgl_context", { "onError": _patch.config.onError });

        this.glVersion = 0;
        this.glUseHalfFloatTex = false;
        this.clearCanvasTransparent = true;
        this.clearCanvasDepth = true;
        this.debugOneFrame = false;
        this.checkGlErrors = false; // true is slow // false should be default...
        this.maxTextureUnits = 0;
        this.maxVaryingVectors = 0;
        this.currentProgram = null;
        this._hadStackError = false;
        this.glSlowRenderer = false;
        this._isSafariCrap = false;

        this.temporaryTexture = null;

        /** @type {WebGL2RenderingContext} */
        this.gl = null;

        this._cursor = "auto";
        this._currentCursor = "";

        this._viewPortStack = [];
        this._glFrameBufferStack = [];
        this._frameBufferStack = [];
        this._shaderStack = [];
        this._stackDepthTest = [];
        this.mainloopOp = null;
        this._stackBlendMode = [];
        this._stackBlendModePremul = [];
        this._stackBlend = [];
        this._stackDepthFunc = [];
        this._stackCullFaceFacing = [];
        this._stackCullFace = [];
        this._stackDepthWrite = [];
        this._stackDepthTest = [];
        this._stackStencil = [];

        this._simpleShader = new _cgl_shader_js__WEBPACK_IMPORTED_MODULE_2__/* .Shader */ .M(this, "simpleshader");
        this._simpleShader.setModules(["MODULE_VERTEX_POSITION", "MODULE_COLOR", "MODULE_BEGIN_FRAG", "MODULE_VERTEX_MODELVIEW"]);
        this._simpleShader.setSource(_cgl_shader_js__WEBPACK_IMPORTED_MODULE_2__/* .Shader */ .M.getDefaultVertexShader(), _cgl_shader_js__WEBPACK_IMPORTED_MODULE_2__/* .Shader */ .M.getDefaultFragmentShader());

        this._currentShader = this._simpleShader;

        this._oldCanvasWidth = -1;
        this._oldCanvasHeight = -1;
        this._enabledExtensions = {};

        this.errorShader = null;
    }

    // set pixelDensity(p)
    // {
    //     this._pixelDensity = p;
    // }

    // get pixelDensity()
    // {
    //     return this._pixelDensity;
    // }

    get viewPort()
    {
        if (this._viewPortStack.length > 3)
        {
            const l = this._viewPortStack.length;

            return [
                this._viewPortStack[l - 4],
                this._viewPortStack[l - 3],
                this._viewPortStack[l - 2],
                this._viewPortStack[l - 1]
            ];
        }
        else
        {
            // workaround pre viewport stack times / or+and initial value...

            return this._viewPort;
        }
    }

    get mvMatrix() // deprecate
    {
        return this.mMatrix;
    }

    set mvMatrix(m) // deprecate
    {
        this.mMatrix = m;
    }

    /**
     * @param {HTMLCanvasElement} canv
     */
    _setCanvas(canv)
    {
        if (!canv) this._log.stack("_setCanvas undef");

        if (!this.patch.config.canvas) this.patch.config.canvas = {};
        if (!this.patch.config.canvas.hasOwnProperty("preserveDrawingBuffer")) this.patch.config.canvas.preserveDrawingBuffer = true;
        if (!this.patch.config.canvas.hasOwnProperty("premultipliedAlpha")) this.patch.config.canvas.premultipliedAlpha = false;
        if (!this.patch.config.canvas.hasOwnProperty("alpha")) this.patch.config.canvas.alpha = false;

        this.patch.config.canvas.stencil = true;

        if (this.patch.config.hasOwnProperty("clearCanvasColor")) this.clearCanvasTransparent = this.patch.config.clearCanvasColor;
        if (this.patch.config.hasOwnProperty("clearCanvasDepth")) this.clearCanvasDepth = this.patch.config.clearCanvasDepth;

        // safari stuff..........
        if (/^((?!chrome|android).)*safari/i.test(navigator.userAgent) && (navigator.userAgent.match(/iPhone/i)))
        {
            this._isSafariCrap = true;
            this.glUseHalfFloatTex = true;
        }

        if (!this.patch.config.canvas.forceWebGl1) this.gl = canv.getContext("webgl2", this.patch.config.canvas);

        if (!this.gl || this.gl.isContextLost())
        {
            this.aborted = true;
            this._log.error("NO_WEBGL", "sorry, could not initialize WebGL. Please check if your Browser supports WebGL or try to restart your browser.");
            return;
        }

        if (this.gl.getParameter(this.gl.VERSION) != "WebGL 1.0")
        {
            this.glVersion = 2;
        }
        else
        {
            this.gl = canv.getContext("webgl", this.patch.config.canvas) || canv.getContext("experimental-webgl", this.patch.config.canvas);
            this.glVersion = 1;

            // safari
            // if (/^((?!chrome|android).)*safari/i.test(navigator.userAgent) && (navigator.userAgent.match(/iPhone/i)))
            // {
            //     this.glUseHalfFloatTex = true;
            // }

            // ios
            // @ts-ignore
            if (/iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream)
            {
                if (!this.patch.config.canvas.hasOwnProperty("powerPreference")) this.patch.config.canvas.powerPreference = "high-performance";
            }

            this.enableExtension("OES_standard_derivatives");
            // this.enableExtension("GL_OES_standard_derivatives");
            const instancingExt = this.enableExtension("ANGLE_instanced_arrays") || this.gl;
            if (instancingExt.vertexAttribDivisorANGLE)
            {
                this.gl.vertexAttribDivisor = instancingExt.vertexAttribDivisorANGLE.bind(instancingExt);
                this.gl.drawElementsInstanced = instancingExt.drawElementsInstancedANGLE.bind(instancingExt);
            }
        }

        const dbgRenderInfo = this.enableExtension("WEBGL_debug_renderer_info");
        if (dbgRenderInfo)
        {
            this.glRenderer = this.gl.getParameter(dbgRenderInfo.UNMASKED_RENDERER_WEBGL);
            if (this.glRenderer === "Google SwiftShader") this.glSlowRenderer = true;
        }

        this.canvas.addEventListener("webglcontextlost", (event) =>
        {
            if (this.aborted) return this._log.warn("[cgl_state] aborted context lost... can be ignored...");
            this._log.error("canvas lost...", event);
            this.emitEvent("webglcontextlost");
            this.aborted = true;
        });

        this.maxAnisotropic = 0;
        if (this.enableExtension("EXT_texture_filter_anisotropic"))
            this.maxAnisotropic = this.gl.getParameter(this.enableExtension("EXT_texture_filter_anisotropic").MAX_TEXTURE_MAX_ANISOTROPY_EXT);

        this.maxVaryingVectors = this.gl.getParameter(this.gl.MAX_VARYING_VECTORS);
        this.maxTextureUnits = this.gl.getParameter(this.gl.MAX_TEXTURE_IMAGE_UNITS);
        this.maxTexSize = this.gl.getParameter(this.gl.MAX_TEXTURE_SIZE);
        this.maxUniformsFrag = this.gl.getParameter(this.gl.MAX_FRAGMENT_UNIFORM_VECTORS);
        this.maxUniformsVert = this.gl.getParameter(this.gl.MAX_VERTEX_UNIFORM_VECTORS);
        this.maxSamples = 0;
        if (this.gl.MAX_SAMPLES) this.maxSamples = this.gl.getParameter(this.gl.MAX_SAMPLES);

        if (this.glVersion == 1)
        {
            this.enableExtension("OES_standard_derivatives");
            const instancingExt = this.enableExtension("ANGLE_instanced_arrays") || this.gl;

            if (instancingExt.vertexAttribDivisorANGLE)
            {
                this.gl.vertexAttribDivisor = instancingExt.vertexAttribDivisorANGLE.bind(instancingExt);
                this.gl.drawElementsInstanced = instancingExt.drawElementsInstancedANGLE.bind(instancingExt);
            }
        }

        this.DEPTH_FUNCS = [
            this.gl.NEVER,
            this.gl.ALWAYS,
            this.gl.LESS,
            this.gl.LEQUAL,
            this.gl.GREATER,
            this.gl.GEQUAL,
            this.gl.EQUAL,
            this.gl.NOTEQUAL
        ];
        this.CULL_MODES = [
            null,
            this.gl.BACK,
            this.gl.FRONT,
            this.gl.FRONT_AND_BACK
        ];
    }

    getInfo()
    {
        return {
            "glVersion": this.glVersion,
            "glRenderer": this.glRenderer,
            "glUseHalfFloatTex": this.glUseHalfFloatTex,
            "maxVaryingVectors": this.maxVaryingVectors,
            "maxTextureUnits": this.maxTextureUnits,
            "maxTexSize": this.maxTexSize,
            "maxUniformsFrag": this.maxUniformsFrag,
            "maxUniformsVert": this.maxUniformsVert,
            "maxSamples": this.maxSamples
        };
    }

    /**
     * @function popViewPort
     * @memberof Context
     * @instance
     * @description pop viewPort stack
     */
    popViewPort()
    {
        this._viewPortStack.pop();
        this._viewPortStack.pop();
        this._viewPortStack.pop();
        this._viewPortStack.pop();

        if (this._viewPortStack.length == 0)
            this.setViewPort(0, 0, this.canvasWidth, this.canvasHeight);
        else
            this.setViewPort(this._viewPortStack[this._viewPort.length - 4], this._viewPortStack[this._viewPort.length - 3], this._viewPortStack[this._viewPort.length - 2], this._viewPortStack[this._viewPort.length - 1]);
    }

    /**
     * @function pushViewPort
     * @memberof Context
     * @instance
     * @description push a new viewport onto stack
     * @param {Number} x
     * @param {Number} y
     * @param {Number} w
     * @param {Number} h
     */

    pushViewPort(x, y, w, h)
    {
        this._viewPortStack.push(x, y, w, h);
        this.setViewPort(x, y, w, h);
    }

    // old
    getViewPort()
    {
        return this._viewPort;
    }

    // old
    resetViewPort()
    {
        this.gl.viewport(this._viewPort[0], this._viewPort[1], this._viewPort[2], this._viewPort[3]);
    }

    // old
    /**
     * @param {number} x
     * @param {number} y
     * @param {number} w
     * @param {number} h
     */
    setViewPort(x, y, w, h)
    {
        this._viewPort[0] = Math.round(x);
        this._viewPort[1] = Math.round(y);
        this._viewPort[2] = Math.round(w);
        this._viewPort[3] = Math.round(h);
        this.gl.viewport(this._viewPort[0], this._viewPort[1], this._viewPort[2], this._viewPort[3]);
    }

    /**
     * @param {function} cb
     * @param {boolean} doScreenshotClearAlpha
     * @param {string} mimeType
     * @param {number} quality
     */
    screenShot(cb, doScreenshotClearAlpha, mimeType, quality)
    {
        if (doScreenshotClearAlpha)
        {
            this.gl.clearColor(1, 1, 1, 1);
            this.gl.colorMask(false, false, false, true);
            this.gl.clear(this.gl.COLOR_BUFFER_BIT);
            this.gl.colorMask(true, true, true, true);
        }

        if (this.canvas && this.canvas.toBlob)
        {
            this.canvas.toBlob(
                (blob) =>
                {
                    if (cb) cb(blob);
                    else this._log.log("no screenshot callback...");
                }, mimeType, quality);
        }
    }

    endFrame()
    {
        if (this.patch.isEditorMode()) CABLES.GL_MARKER.drawMarkerLayer(this);

        this.setPreviousShader();

        if (this._vMatrixStack.length() > 0) this.logStackError("view matrix stack length !=0 at end of rendering...");
        if (this._mMatrixStack.length() > 0) this.logStackError("mvmatrix stack length !=0 at end of rendering...");
        if (this._pMatrixStack.length() > 0) this.logStackError("pmatrix stack length !=0 at end of rendering...");
        if (this._glFrameBufferStack.length > 0) this.logStackError("glFrameBuffer stack length !=0 at end of rendering...");
        if (this._stackDepthTest.length > 0) this.logStackError("depthtest stack length !=0 at end of rendering...");
        if (this._stackDepthWrite.length > 0) this.logStackError("depthwrite stack length !=0 at end of rendering...");
        if (this._stackDepthFunc.length > 0) this.logStackError("depthfunc stack length !=0 at end of rendering...");
        if (this._stackBlend.length > 0) this.logStackError("blend stack length !=0 at end of rendering...");
        if (this._stackBlendMode.length > 0) this.logStackError("blendMode stack length !=0 at end of rendering...");
        if (this._shaderStack.length > 0) this.logStackError("this._shaderStack length !=0 at end of rendering...");
        if (this._stackCullFace.length > 0) this.logStackError("this._stackCullFace length !=0 at end of rendering...");
        if (this._stackCullFaceFacing.length > 0) this.logStackError("this._stackCullFaceFacing length !=0 at end of rendering...");
        if (this._viewPortStack.length > 0) this.logStackError("viewport stack length !=0 at end of rendering...");

        this._frameStarted = false;

        if (this._oldCanvasWidth != this.canvasWidth || this._oldCanvasHeight != this.canvasHeight)
        {
            this._oldCanvasWidth = this.canvasWidth;
            this._oldCanvasHeight = this.canvasHeight;
            this.emitEvent(_cg_cg_context_js__WEBPACK_IMPORTED_MODULE_0__/* .CgContext */ .A.EVENT_RESIZE);
        }

        if (this._cursor != this._currentCursor)
        {
            this._currentCursor = this.canvas.style.cursor = this._cursor;
        }

        this.emitEvent("endframe");

        this.fpsCounter.endFrame();
    }

    logStackError(str)
    {
        if (!this._hadStackError)
        {
            this._hadStackError = true;
            this._log.warn("[" + this.canvas.id + "]: ", str);
        }
    }

    // shader stack
    getShader()
    {
        if (this._currentShader) if (!this.tempData || ((this.tempData.renderOffscreen === true) == this._currentShader.offScreenPass) === true) return this._currentShader;

        for (let i = this._shaderStack.length - 1; i >= 0; i--) if (this._shaderStack[i]) if (this.tempData.renderOffscreen == this._shaderStack[i].offScreenPass) return this._shaderStack[i];
    }

    getDefaultShader()
    {
        return this._simpleShader;
    }

    /**
     * @deprecated
     * @param {Shader} s
     */
    setShader(s)
    {
        this.pushShader(s);
    }

    /**
     * push a shader to the shader stack
     * @function pushShader
     * @memberof Context
     * @instance
     * @param {Shader} shader
     * @function
     */
    pushShader(shader)
    {
        if (this.tempData.forceShaderMods)
        {
            for (let i = 0; i < this.tempData.forceShaderMods.length; i++)
            {
                // if (!currentShader.forcedMod && currentShader != this.tempData.forceShaderMods[i])
                // {
                //     currentShader.forcedMod = this.tempData.forceShaderMods[i];
                shader = this.tempData.forceShaderMods[i].bind(shader, false);
                // }
                // return currentShader;
                // if (this.tempData.forceShaderMods[i].currentShader() && shader != this.tempData.forceShaderMods[i].currentShader().shader)
            }
        }

        this._shaderStack.push(shader);
        this._currentShader = shader;
    }

    popShader()
    {
        this.setPreviousShader();
    }

    /**
     * pop current used shader from shader stack
     * @function popShader
     * @memberof Context
     * @instance
     * @function
     */
    setPreviousShader()
    {
        if (this.tempData.forceShaderMods)
        {
            for (let i = 0; i < this.tempData.forceShaderMods.length; i++)
            {
                // const a =
                this.tempData.forceShaderMods[i].unbind(false);
                // if (a) return;
                // this.popShader();
            }
        }

        if (this._shaderStack.length === 0) throw new Error("Invalid shader stack pop!");
        this._shaderStack.pop();
        this._currentShader = this._shaderStack[this._shaderStack.length - 1];
    }

    /**
     * push a framebuffer to the framebuffer stack
     * @function pushGlFrameBuffer
     * @memberof Context
     * @instance
     * @param {Object} fb framebuffer
     * @function
     */
    pushGlFrameBuffer(fb)
    {
        this._glFrameBufferStack.push(fb);
    }

    /**
     * pop framebuffer stack
     * @function popGlFrameBuffer
     * @memberof Context
     * @instance
     * @returns {Object} current framebuffer or null
     */
    popGlFrameBuffer()
    {
        if (this._glFrameBufferStack.length == 0) return null;
        this._glFrameBufferStack.pop();
        return this._glFrameBufferStack[this._glFrameBufferStack.length - 1];
    }

    /**
     * get current framebuffer
     * @function getCurrentFrameBuffer
     * @memberof Context
     * @instance
     * @returns {Object} current framebuffer or null
     */
    getCurrentGlFrameBuffer()
    {
        if (this._glFrameBufferStack.length === 0) return null;
        return this._glFrameBufferStack[this._glFrameBufferStack.length - 1];
    }

    /**
     * push a framebuffer to the framebuffer stack
     * @function pushGlFrameBuffer
     * @memberof Context
     * @instance
     * @param {Framebuffer2} fb framebuffer
     */
    pushFrameBuffer(fb)
    {
        this._frameBufferStack.push(fb);
    }

    /**
     * pop framebuffer stack
     * @function popFrameBuffer
     * @memberof Context
     * @instance
     * @returns {Framebuffer2} current framebuffer or null
     */
    popFrameBuffer()
    {
        if (this._frameBufferStack.length == 0) return null;
        this._frameBufferStack.pop();
        return this._frameBufferStack[this._frameBufferStack.length - 1];
    }

    /**
     * get current framebuffer
     * @function getCurrentFrameBuffer
     * @memberof Context
     * @instance
     * @returns {Framebuffer2} current framebuffer or null
     */
    getCurrentFrameBuffer()
    {
        if (this._frameBufferStack.length === 0) return null;
        return this._frameBufferStack[this._frameBufferStack.length - 1];
    }

    renderStart(cgl, identTranslate, identTranslateView)
    {
        this.fpsCounter.startFrame();
        this.pushDepthTest(true);
        this.pushDepthWrite(true);
        this.pushDepthFunc(cgl.gl.LEQUAL);
        this.pushCullFaceFacing(cgl.gl.BACK);
        this.pushCullFace(false);

        // if (this.clearCanvasTransparent)
        // {
        //     cgl.gl.clearColor(0, 0, 0, 0);
        //     cgl.gl.clear(cgl.gl.COLOR_BUFFER_BIT);
        // }
        // if (this.clearCanvasDepth) cgl.gl.clear(cgl.gl.DEPTH_BUFFER_BIT);

        cgl.setViewPort(0, 0, cgl.canvasWidth, cgl.canvasHeight);

        this._startMatrixStacks(identTranslate, identTranslateView);

        cgl.pushBlendMode(_constants_js__WEBPACK_IMPORTED_MODULE_3__/* .CONSTANTS */ .a.BLEND_MODES.BLEND_NORMAL, false);

        for (let i = 0; i < this._textureslots.length; i++) this._textureslots[i] = null;

        this.pushShader(this._simpleShader);

        this._frameStarted = true;

        this._execOneTimeCallbacks();

        for (let i = 0; i < this._textureslots.length; i++)
        {
            this.gl.activeTexture(this.gl.TEXTURE0 + i);
            this.gl.bindTexture(this.gl.TEXTURE_2D, null);
            this._textureslots[i] = null;
        }

        this.emitEvent("beginFrame");
    }

    /**
     * @param {CglContext} cgl
     */
    renderEnd(cgl)
    {
        this._endMatrixStacks();

        this.popDepthTest();
        this.popDepthWrite();
        this.popDepthFunc();
        this.popCullFaceFacing();
        this.popCullFace();
        this.popBlend();
        this.popBlendMode();

        cgl.endFrame();

        this.emitEvent("endFrame");
    }

    /**
     * @param {number} slot
     */
    getTexture(slot)
    {
        return this._textureslots[slot];
    }

    hasFrameStarted()
    {
        return this._frameStarted;
    }

    /**
     * log warning to console if the rendering of one frame has not been started / handy to check for async problems
     * @function checkFrameStarted
     * @memberof Context
     * @param {string} string
     * @instance
     */
    checkFrameStarted(string)
    {
        if (!this._frameStarted)
        {
            this._log.warn("frame not started " + string);

            Error.stackTraceLimit = 25;
            cables__WEBPACK_IMPORTED_MODULE_4__.logStack();
            this.patch.printTriggerStack();
        }
    }

    /**
     * @param {number} slot
     * @param {WebGLTexture} t
     * @param {undefined} [type]
     */
    setTexture(slot, t, type)
    {
        this.checkFrameStarted("cgl setTexture");

        if (t === null) t = _cgl_texture_js__WEBPACK_IMPORTED_MODULE_5__/* .Texture */ .g.getEmptyTexture(this).tex;

        if (this._textureslots[slot] != t)
        {
            this.gl.activeTexture(this.gl.TEXTURE0 + slot);
            this.gl.bindTexture(type || this.gl.TEXTURE_2D, t);
            this._textureslots[slot] = t;
        }

        return true;
    }

    fullScreen()
    {
        if (this.canvas.requestFullscreen) this.canvas.requestFullscreen();
        else if (this.canvas.mozRequestFullScreen) this.canvas.mozRequestFullScreen();
        else if (this.canvas.webkitRequestFullscreen) this.canvas.webkitRequestFullscreen();
        else if (this.canvas.msRequestFullscreen) this.canvas.msRequestFullscreen();
    }

    /**
     * @param {string} [str]
     */
    printError(str)
    {
        if (!this.checkGlErrors) return;
        let found = false;
        let error = this.gl.getError();

        if (error != this.gl.NO_ERROR)
        {
            let errStr = "";
            if (error == this.gl.OUT_OF_MEMORY) errStr = "OUT_OF_MEMORY";
            if (error == this.gl.INVALID_ENUM) errStr = "INVALID_ENUM";
            if (error == this.gl.INVALID_OPERATION) errStr = "INVALID_OPERATION";
            if (error == this.gl.INVALID_FRAMEBUFFER_OPERATION) errStr = "INVALID_FRAMEBUFFER_OPERATION";
            if (error == this.gl.INVALID_VALUE) errStr = "INVALID_VALUE";
            if (error == this.gl.CONTEXT_LOST_WEBGL)
            {
                this.aborted = true;
                errStr = "CONTEXT_LOST_WEBGL";
            }
            if (error == this.gl.NO_ERROR) errStr = "NO_ERROR";

            found = true;

            this._log.warn("gl error [" + this.canvas.id + "]: ", str, error, errStr);

            if (this.canvas.id.includes("glGuiCanvas"))
                if (!this._loggedGlError)
                {
                    this.patch.printTriggerStack();
                    this._log.stack("glerror");
                    this._loggedGlError = true;
                }
        }
        error = this.gl.getError();

        return found;
    }

    _dispose()
    {
        this._simpleShader.dispose();
        this.gl = null;
    }

    // state depthtest

    /**
     * push depth testing enabled state
     * @function pushDepthTest
     * @param {Boolean} enabled
     * @memberof Context
     * @instance
     */

    pushDepthTest(enabled)
    {
        this._stackDepthTest.push(enabled);
        if (!enabled) this.gl.disable(this.gl.DEPTH_TEST);
        else this.gl.enable(this.gl.DEPTH_TEST);
    }

    /**
     * current state of depth testing
     * @function stateCullFace
     * @returns {Boolean} enabled
     * @memberof Context
     * @instance
     */
    stateDepthTest()
    {
        return this._stackDepthTest[this._stackDepthTest.length - 1];
    }

    /**
     * pop depth testing state
     * @function popCullFace
     * @memberof Context
     * @instance
     */
    popDepthTest()
    {
        this._stackDepthTest.pop();

        if (!this._stackDepthTest[this._stackDepthTest.length - 1]) this.gl.disable(this.gl.DEPTH_TEST);
        else this.gl.enable(this.gl.DEPTH_TEST);
    }

    // --------------------------------------
    // state depthwrite

    /**
     * push depth write enabled state
     * @function pushDepthTest
     * @param {Boolean} enabled
     * @memberof Context
     * @instance
     */
    pushDepthWrite(enabled)
    {
        enabled = enabled || false;
        this._stackDepthWrite.push(enabled);
        this.gl.depthMask(enabled);
    }

    /**
     * current state of depth writing
     * @function stateDepthWrite
     * @returns {Boolean} enabled
     * @memberof Context
     * @instance
     */
    stateDepthWrite()
    {
        return this._stackDepthWrite[this._stackDepthWrite.length - 1];
    }

    /**
     * pop depth writing state
     * @function popDepthWrite
     * @memberof Context
     * @instance
     */
    popDepthWrite()
    {
        this._stackDepthWrite.pop();
        this.gl.depthMask(this._stackDepthWrite[this._stackDepthWrite.length - 1] || false);
    }

    // --------------------------------------
    // state CullFace

    /**
     * push face culling face enabled state
     * @function pushCullFace
     * @param {Boolean} enabled
     * @memberof Context
     * @instance
     */
    pushCullFace(enabled)
    {
        this._stackCullFace.push(enabled);

        if (enabled) this.gl.enable(this.gl.CULL_FACE);
        else this.gl.disable(this.gl.CULL_FACE);
    }

    /**
     * current state of face culling
     * @function stateCullFace
     * @returns {Boolean} enabled
     * @memberof Context
     * @instance
     */
    stateCullFace()
    {
        return this._stackCullFace[this._stackCullFace.length - 1];
    }

    /**
     * pop face culling enabled state
     * @function popCullFace
     * @memberof Context
     * @instance
     */
    popCullFace()
    {
        this._stackCullFace.pop();

        if (this._stackCullFace[this._stackCullFace.length - 1]) this.gl.enable(this.gl.CULL_FACE);
        else this.gl.disable(this.gl.CULL_FACE);
    }

    // --------------------------------------
    // state CullFace Facing

    /**
     * push face culling face side
     * @function pushCullFaceFacing
     * @param {Number} face - cgl.gl.FRONT_AND_BACK, cgl.gl.BACK or cgl.gl.FRONT
     * @memberof Context
     * @instance
     */

    pushCullFaceFacing(face)
    {
        this._stackCullFaceFacing.push(face);
        this.gl.cullFace(this._stackCullFaceFacing[this._stackCullFaceFacing.length - 1]);
    }

    /**
     * current state of face culling side
     * @function stateCullFaceFacing
     * @returns {Boolean} enabled
     * @memberof Context
     * @instance
     */
    stateCullFaceFacing()
    {
        return this._stackCullFaceFacing[this._stackCullFaceFacing.length - 1];
    }

    /**
     * pop face culling face side
     * @function popCullFaceFacing
     * @memberof Context
     * @instance
     */
    popCullFaceFacing()
    {
        this._stackCullFaceFacing.pop();
        if (this._stackCullFaceFacing.length > 0) this.gl.cullFace(this._stackCullFaceFacing[this._stackCullFaceFacing.length - 1]);
    }

    // --------------------------------------
    // state depthfunc

    /**
     * enable / disable depth testing
     * like `gl.depthFunc(boolean);`
     * @function pushDepthFunc
     * @memberof Context
     * @instance
     * @param {Boolean} f depthtesting
     */
    pushDepthFunc(f)
    {
        this._stackDepthFunc.push(f);
        this.gl.depthFunc(f);
    }

    /**
     * current state of blend
     * @function stateDepthFunc
     * @memberof Context
     * @instance
     * @returns {Boolean} depth testing enabled/disabled
     */
    stateDepthFunc()
    {
        if (this._stackDepthFunc.length > 0) return this._stackDepthFunc[this._stackDepthFunc.length - 1];
        return false;
    }

    /**
     * pop depth testing and set the previous state
     * @function popDepthFunc
     * @memberof Context
     * @instance
     */
    popDepthFunc()
    {
        this._stackDepthFunc.pop();
        if (this._stackDepthFunc.length > 0) this.gl.depthFunc(this._stackDepthFunc[this._stackDepthFunc.length - 1]);
    }

    // --------------------------------------
    // state blending

    /**
     * enable / disable blend
     * like gl.enable(gl.BLEND); / gl.disable(gl.BLEND);
     * @function pushBlend
     * @memberof Context
     * @instance
     * @param {boolean} b blending
     */
    pushBlend(b)
    {
        this._stackBlend.push(b);
        if (!b) this.gl.disable(this.gl.BLEND);
        else this.gl.enable(this.gl.BLEND);
    }

    /**
     * pop blend state and set the previous state
     * @function popBlend
     * @memberof Context
     * @instance
     */
    popBlend()
    {
        this._stackBlend.pop();

        if (!this._stackBlend[this._stackBlend.length - 1]) this.gl.disable(this.gl.BLEND);
        else this.gl.enable(this.gl.BLEND);
    }

    /**
     * current state of blend
     * @function stateBlend
     * @returns {boolean} blending enabled/disabled
     * @memberof Context
     * @instance
     */
    stateBlend()
    {
        return this._stackBlend[this._stackBlend.length - 1];
    }

    /**
     * push and switch to predefined blendmode (CONSTANTS.BLEND_MODES.BLEND_NONE,CONSTANTS.BLEND_MODES.BLEND_NORMAL,CONSTANTS.BLEND_MODES.BLEND_ADD,CONSTANTS.BLEND_MODES.BLEND_SUB,CONSTANTS.BLEND_MODES.BLEND_MUL)
     * @function pushBlendMode
     * @memberof Context
     * @instance
     * @param {Number} blendMode
     * @param {Boolean} premul premultiplied mode
     */
    pushBlendMode(blendMode, premul)
    {
        this._stackBlendMode.push(blendMode);
        this._stackBlendModePremul.push(premul);

        const n = this._stackBlendMode.length - 1;

        this.pushBlend(this._stackBlendMode[n] !== _constants_js__WEBPACK_IMPORTED_MODULE_3__/* .CONSTANTS */ .a.BLEND_MODES.BLEND_NONE);
        this._setBlendMode(this._stackBlendMode[n], this._stackBlendModePremul[n]);
    }

    /**
     * pop predefined blendmode / switch back to previous blendmode
     * @function popBlendMode
     * @memberof Context
     * @instance
     */
    popBlendMode()
    {
        this._stackBlendMode.pop();
        this._stackBlendModePremul.pop();

        const n = this._stackBlendMode.length - 1;

        this.popBlend();

        if (n >= 0) this._setBlendMode(this._stackBlendMode[n], this._stackBlendModePremul[n]);
    }

    // --------------------------------------
    // state stencil

    /**
     * enable / disable stencil testing

    * @function pushStencil
    * @memberof Context
    * @instance
    * @param {Boolean} b enable
    */
    pushStencil(b)
    {
        this._stackStencil.push(b);
        if (!b) this.gl.disable(this.gl.STENCIL_TEST);
        else this.gl.enable(this.gl.STENCIL_TEST);
    }

    /**
     * pop stencil test state and set the previous state
     * @function popStencil
     * @memberof Context
     * @instance
     */
    popStencil()
    {
        this._stackStencil.pop();

        if (!this._stackStencil[this._stackStencil.length - 1]) this.gl.disable(this.gl.STENCIL_TEST);
        else this.gl.enable(this.gl.STENCIL_TEST);
    }

    // --------------------------------------

    glGetAttribLocation(prog, name)
    {
        const l = this.gl.getAttribLocation(prog, name);
        // if (l == -1)
        // {
        //     this._log.warn("get attr loc -1 ", name);
        // }
        return l;
    }

    /**
     * should an op now draw helpermeshes
     * @param {Op} op
     */
    shouldDrawHelpers(op)
    {
        if (this.tempData.shadowPass) return false;
        if (!op.patch.isEditorMode()) return false;
        return gui.shouldDrawOverlay;
    }

    _setBlendMode(blendMode, premul)
    {
        const gl = this.gl;

        if (blendMode == _constants_js__WEBPACK_IMPORTED_MODULE_3__/* .CONSTANTS */ .a.BLEND_MODES.BLEND_NONE)
        {
            // this.gl.disable(this.gl.BLEND);
        }
        else if (blendMode == _constants_js__WEBPACK_IMPORTED_MODULE_3__/* .CONSTANTS */ .a.BLEND_MODES.BLEND_ADD)
        {
            if (premul)
            {
                gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
                gl.blendFuncSeparate(gl.ONE, gl.ONE, gl.ONE, gl.ONE);
            }
            else
            {
                gl.blendEquation(gl.FUNC_ADD);
                gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
            }
        }
        else if (blendMode == _constants_js__WEBPACK_IMPORTED_MODULE_3__/* .CONSTANTS */ .a.BLEND_MODES.BLEND_SUB)
        {
            if (premul)
            {
                gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
                gl.blendFuncSeparate(gl.ZERO, gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ONE_MINUS_SRC_ALPHA);
            }
            else
            {
                gl.blendEquation(gl.FUNC_ADD);
                gl.blendFunc(gl.ZERO, gl.ONE_MINUS_SRC_COLOR);
            }
        }
        else if (blendMode == _constants_js__WEBPACK_IMPORTED_MODULE_3__/* .CONSTANTS */ .a.BLEND_MODES.BLEND_MUL)
        {
            if (premul)
            {
                gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
                gl.blendFuncSeparate(gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA);
            }
            else
            {
                gl.blendEquation(gl.FUNC_ADD);
                gl.blendFunc(gl.ZERO, gl.SRC_COLOR);
            }
        }
        else if (blendMode == _constants_js__WEBPACK_IMPORTED_MODULE_3__/* .CONSTANTS */ .a.BLEND_MODES.BLEND_NORMAL)
        {
            if (premul)
            {
                gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
                gl.blendFuncSeparate(gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
            }
            else
            {
                gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
                gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
            }
        }
        else
        {
            this._log.log("setblendmode: unknown blendmode");
        }
    }

    /**
     * @param {Geometry} geom
     * @param {CglMeshOptions} options
     */
    createMesh(geom, options)
    {
        if (cables__WEBPACK_IMPORTED_MODULE_4__.isNumeric(options))options = { "glPrimitive": options }; // old constructor fallback...
        return new _cgl_mesh_js__WEBPACK_IMPORTED_MODULE_6__/* .Mesh */ .e(this, geom, options);
    }

    /**
     * set cursor
     * @function setCursor
     * @memberof Context
     * @instance
     * @param {String} str css cursor string
     */
    setCursor(str)
    {
        this._cursor = str;
    }

    /**
     * enable a webgl extension
     * @function enableExtension
     * @memberof Context
     * @instance
     * @param {String} name extension name
     * @returns {Object} extension object or null
     */
    enableExtension(name)
    {
        if (!this.gl) return null;

        if (this._enabledExtensions.hasOwnProperty(name))
            return this._enabledExtensions[name];

        const o = this.gl.getExtension(name);
        this._enabledExtensions[name] = o;

        if (!o) this._log.warn("[cgl_state] extension not available " + name);

        return o;
    }

    getErrorShader()
    {
        if (this.errorShader) return this.errorShader;

        this.errorShader = new _cgl_shader_js__WEBPACK_IMPORTED_MODULE_2__/* .Shader */ .M(this, "errormaterial");
        this.errorShader.setSource(_cgl_shader_js__WEBPACK_IMPORTED_MODULE_2__/* .Shader */ .M.getDefaultVertexShader(), _cgl_shader_js__WEBPACK_IMPORTED_MODULE_2__/* .Shader */ .M.getErrorFragmentShader());
        return this.errorShader;
    }

}


/***/ }),

/***/ 70:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   g: () => (/* binding */ Texture)
/* harmony export */ });
/* harmony import */ var cables_shared_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(849);
/* harmony import */ var cables__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(562);
/* harmony import */ var _cg_cg_texture_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(356);





const DEFAULT_TEXTURE_SIZE = 8;

const log = new cables_shared_client__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A("cgl_texture");

/**
 * A Texture
 * @namespace external:CGL
 * @class
 * @param {CglContext} __cgl cgl
 * @param {Object} options
 * @hideconstructor
 * @example
 * // generate a 256x256 pixel texture of random colors
 * const size=256;
 * const data = new Uint8Array(size*size*4);
 *
 * for(var x=0;x<size*size*4;x++) data[ x*4+3]=255;
 *
 * const tex=new CGL.Texture(cgl);
 * tex.initFromData(data,size,size,CGL.Texture.FILTER_NEAREST,CGL.Texture.WRAP_REPEAT);
 */
class Texture extends _cg_cg_texture_js__WEBPACK_IMPORTED_MODULE_1__/* .CgTexture */ .U
{

    /**
     * @param {CglContext} __cgl
     */
    constructor(__cgl, options = {})
    {
        super(options);
        if (!__cgl) throw new Error("no cgl");

        this._cgl = __cgl;
        this._log = new cables_shared_client__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A("tex");
        this.tex = this._cgl.gl.createTexture();
        this.loading = false;
        this.flip = true;
        this.flipped = false;
        this.shadowMap = false;
        this.deleted = false;
        this.image = null;
        this.anisotropic = 0;
        this.filter = Texture.FILTER_NEAREST;
        this.wrap = Texture.WRAP_CLAMP_TO_EDGE;
        this.texTarget = this._cgl.gl.TEXTURE_2D;
        if (options && options.type) this.texTarget = options.type;
        this.textureType = Texture.TYPE_DEFAULT;
        this.unpackAlpha = true;
        this._fromData = true;

        this._glDataType = -1;
        this._glInternalFormat = -1;
        this._glDataFormat = -1;

        if (options)
        {
            if (options.isDepthTexture) this.textureType = Texture.TYPE_DEPTH;
            if (options.isFloatingPointTexture === true) this.textureType = Texture.TYPE_FLOAT;

            if ("textureType" in options) this.textureType = options.textureType;
            if ("filter" in options) this.filter = options.filter;
            if ("wrap" in options) this.wrap = options.wrap;
            if ("unpackAlpha" in options) this.unpackAlpha = options.unpackAlpha;
            if ("flip" in options) this.flip = options.flip;
            if ("shadowMap" in options) this.shadowMap = options.shadowMap;
            if ("anisotropic" in options) this.anisotropic = options.anisotropic;
        }
        else
        {
            options = {};
        }

        if (!options.pixelFormat && options.isFloatingPointTexture) this.pixelFormat = Texture.PFORMATSTR_RGBA32F;

        if (this.textureType == Texture.TYPE_DEPTH) this.pixelFormat = Texture.PFORMATSTR_DEPTH;

        this._cgl.profileData.profileTextureNew++;

        this.setFormat(Texture.setUpGlPixelFormat(this._cgl, this.pixelFormat));
        this._cgl.profileData.addHeavyEvent("texture created", this.name, options.width + "x" + options.height);

        this.setSize(options.width, options.height);
        this.getInfoOneLine();
    }

    isFloatingPoint()
    {
        return Texture.isPixelFormatFloat(this.pixelFormat);
    }

    /**
     * returns true if otherTexture has same options (width/height/filter/wrap etc)
     * @function compareSettings
     * @memberof Texture
     * @instance
     * @param {Texture} tex otherTexture
     * @returns {Boolean}
     */
    compareSettings(tex)
    {
    // if (!tex) { this._log.warn("compare: no tex"); return false; }
    // if (tex.width != this.width) this._log.warn("tex.width not equal", tex.width, this.width);
    // if (tex.height != this.height) this._log.warn("tex.height not equal", tex.height, this.height);
    // if (tex.filter != this.filter) this._log.warn("tex.filter not equal");
    // if (tex.wrap != this.wrap) this._log.warn("tex.wrap not equal");
    // if (tex.textureType != this.textureType) this._log.warn("tex.textureType not equal");
    // if (tex.unpackAlpha != this.unpackAlpha) this._log.warn("tex.unpackAlpha not equal");
    // if (tex.anisotropic != this.anisotropic) this._log.warn("tex.anisotropic not equal");
    // if (tex.shadowMap != this.shadowMap) this._log.warn("tex.shadowMap not equal");
    // if (tex.texTarget != this.texTarget) this._log.warn("tex.texTarget not equal");
    // if (tex.flip != this.flip) this._log.warn("tex.flip not equal");

        if (!tex) return false;
        return (
            tex.width == this.width &&
            tex.height == this.height &&
            tex.filter == this.filter &&
            tex.wrap == this.wrap &&
            tex.textureType == this.textureType &&
            tex.unpackAlpha == this.unpackAlpha &&
            tex.anisotropic == this.anisotropic &&
            tex.shadowMap == this.shadowMap &&
            tex.texTarget == this.texTarget &&
            tex.flip == this.flip
        );
    }

    /**
     * returns a new texture with the same settings (does not copy texture itself)
     * @function clone
     * @memberof Texture
     * @instance
     * @returns {Texture}
     */
    clone()
    {
        const newTex = new Texture(this._cgl, {
            "name": this.name,
            "filter": this.filter,
            "anisotropic": this.anisotropic,
            "wrap": this.wrap,
            "textureType": this.textureType,
            "pixelFormat": this.pixelFormat,
            "unpackAlpha": this.unpackAlpha,
            "flip": this.flip,
            "width": this.width,
            "height": this.height,
        });

        this._cgl.profileData.addHeavyEvent("texture created", this.name, this.width + "x" + this.height);

        if (!this.compareSettings(newTex))
        {
            this._log.error("Cloned texture settings do not compare!");
            this._log.error(this);
            this._log.error(newTex);
        }

        return newTex;
    }

    /**
     * @param {object} o
     */
    setFormat(o)
    {
        this.pixelFormat = o.pixelFormat;
        this._glDataFormat = o.glDataFormat;
        this._glInternalFormat = o.glInternalFormat;
        this._glDataType = o.glDataType;
    }

    /**
     * set pixel size of texture
     * @function setSize
     * @memberof Texture
     * @instance
     * @param {Number} w width
     * @param {Number} h height
     */
    setSize(w, h)
    {
        if (this._cgl.aborted) return;
        if (w != w || w <= 0 || !w) w = DEFAULT_TEXTURE_SIZE;
        if (h != h || h <= 0 || !h) h = DEFAULT_TEXTURE_SIZE;

        if (w > this._cgl.maxTexSize || h > this._cgl.maxTexSize) this._log.error("texture size too big! " + w + "x" + h + " / max: " + this._cgl.maxTexSize);

        w = Math.min(w, this._cgl.maxTexSize);
        h = Math.min(h, this._cgl.maxTexSize);

        w = Math.floor(w);
        h = Math.floor(h);
        if (this.width == w && this.height == h) return;

        w = this._cgl.checkTextureSize(w);
        h = this._cgl.checkTextureSize(h);

        this.width = w;
        this.height = h;
        this.deleted = false;

        this.setFormat(Texture.setUpGlPixelFormat(this._cgl, this.pixelFormat));

        this.shortInfoString = this.getInfoOneLine();// w + "x" + h + "";

        this._cgl.gl.bindTexture(this.texTarget, this.tex);
        this._cgl.profileData.profileTextureResize++;

        const uarr = null;

        this._cgl.gl.texImage2D(this.texTarget, 0, this._glInternalFormat, w, h, 0, this._glDataFormat, this._glDataType, uarr);

        this._setFilter();

        this.updateMipMap();

        this._cgl.gl.bindTexture(this.texTarget, null);
    }

    /**
     * @function initFromData
     * @memberof Texture
     * @instance
     * @description create texturem from rgb data
     * @param {Array<Number>} data rgb color array [r,g,b,a,r,g,b,a,...]
     * @param {Number} w width
     * @param {Number} h height
     * @param {Number} filter
     * @param {Number} wrap
     */
    initFromData(data, w, h, filter, wrap)
    {
        this.filter = filter;
        this.wrap = wrap;
        if (filter == undefined) this.filter = Texture.FILTER_LINEAR;
        if (wrap == undefined) this.wrap = Texture.WRAP_CLAMP_TO_EDGE;
        this.width = w;
        this.height = h;
        this._fromData = true;
        this.deleted = false;

        if (this.height > this._cgl.maxTexSize || this.width > this._cgl.maxTexSize)
        {
            const t = CGL.Texture.getTempTexture(this._cgl);
            this.width = t.width;
            this.height = t.height;
            this.tex = t.tex;
            this._log.warn("[cgl_texture] texture size too big!", this.width, this.height, this._cgl.maxTexSize);
            return;
        }

        if (this.flip) this._cgl.gl.pixelStorei(this._cgl.gl.UNPACK_FLIP_Y_WEBGL, this.flip);

        this._cgl.gl.bindTexture(this.texTarget, this.tex);

        this.setFormat(Texture.setUpGlPixelFormat(this._cgl, this.pixelFormat));

        this._cgl.gl.texImage2D(this.texTarget, 0, this._glInternalFormat, w, h, 0, this._glDataFormat, this._glDataType, data);

        this._setFilter();
        this.updateMipMap();

        if (this.flip) this._cgl.gl.pixelStorei(this._cgl.gl.UNPACK_FLIP_Y_WEBGL, false);
        this._cgl.gl.bindTexture(this.texTarget, null);
    }

    updateMipMap()
    {
        if ((this._cgl.glVersion == 2 || this.isPowerOfTwo()) && this.filter == Texture.FILTER_MIPMAP)
        {
            this._cgl.gl.generateMipmap(this.texTarget);
            this._cgl.profileData.profileGenMipMap++;
        }
    }

    /**
     * set texture data from an image/canvas object
     * @function initTexture
     * @memberof Texture
     * @instance
     * @param {Object} img image
     * @param {Number} filter
     */
    initTexture(img, filter = null)
    {
        this._cgl.printError("before initTexture");
        this._cgl.checkFrameStarted("texture inittexture");
        this._fromData = false;

        this._cgl.gl.pixelStorei(this._cgl.gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, this.unpackAlpha);
        if (img.width || img.videoWidth) this.width = img.videoWidth || img.width;
        if (img.height || img.videoHeight) this.height = img.videoHeight || img.height;

        if (filter !== null) this.filter = filter; // todo: can we remove this filter param?

        if (img.height > this._cgl.maxTexSize || img.width > this._cgl.maxTexSize)
        {
            const t = CGL.Texture.getTempTexture(this._cgl);
            this.width = t.width;
            this.height = t.height;
            this.tex = t.tex;
            this._log.warn("[cgl_texture] texture size too big!", img.width, img.height, this._cgl.maxTexSize);
            return;
        }

        this._cgl.gl.bindTexture(this.texTarget, this.tex);

        this.deleted = false;
        this.flipped = !this.flip;
        if (this.flipped) this._cgl.gl.pixelStorei(this._cgl.gl.UNPACK_FLIP_Y_WEBGL, this.flipped);

        this.setFormat(Texture.setUpGlPixelFormat(this._cgl, this.pixelFormat));

        this._cgl.gl.texImage2D(this.texTarget, 0, this._glInternalFormat, this._glDataFormat, this._glDataType, img);

        this._setFilter();
        this.updateMipMap();

        this._cgl.gl.bindTexture(this.texTarget, null);
        this._cgl.gl.pixelStorei(this._cgl.gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
        if (this.flipped) this._cgl.gl.pixelStorei(this._cgl.gl.UNPACK_FLIP_Y_WEBGL, false);

        this.getInfoOneLine();
        this._cgl.printError("initTexture");
    }

    /**
     * delete texture. use this when texture is no longer needed
     * @function delete
     * @memberof Texture
     * @instance
     */
    dispose()
    {
        this.delete();
    }

    delete()
    {
        if (this.loading)
        {
            // cant delete texture when still loading
            // setTimeout(this.delete.bind(this), 50);
            return;
        }

        this.deleted = true;
        this.width = 0;
        this.height = 0;
        this._cgl.profileData.profileTextureDelete++;
        this._cgl.gl.deleteTexture(this.tex);
        this.image = null;

        this.tex = null;
    }

    /**
     * @function isPowerOfTwo
     * @memberof Texture
     * @instance
     * @description return true if texture width and height are both power of two
     * @return {Boolean}
     */
    isPowerOfTwo()
    {
        return Texture.isPowerOfTwo(this.width) && Texture.isPowerOfTwo(this.height);
    }

    printInfo()
    {
        log.log(this.getInfo());
    }

    getInfoReadable()
    {
        const info = this.getInfo();
        let html = "";

        info.name = info.name.substr(0, info.name.indexOf("?rnd="));

        for (const i in info)
        {
            html += "* " + i + ":  **" + info[i] + "**\n";
        }

        return html;
    }

    getInfoOneLine()
    {
        let txt = "" + this.width + "x" + this.height;
        txt += " ";
        // if (this.textureType === CGL.Texture.TYPE_FLOAT) txt += " 32bit"; else txt += " 8bit";
        // if (this.textureType === CGL.Texture.TYPE_FLOAT) txt += " 32bit"; else txt += " 8bit";
        txt += this.pixelFormat;

        if (this.filter === Texture.FILTER_NEAREST) txt += " nearest";
        if (this.filter === Texture.FILTER_LINEAR) txt += " linear";
        if (this.filter === Texture.FILTER_MIPMAP) txt += " mipmap";

        if (this.wrap === Texture.WRAP_CLAMP_TO_EDGE) txt += " clamp";
        if (this.wrap === Texture.WRAP_REPEAT) txt += " repeat";
        if (this.wrap === Texture.WRAP_MIRRORED_REPEAT) txt += " repeatmir";

        this.shortInfoString = txt;

        return txt;
    }

    getInfoOneLineShort()
    {
        let txt = "" + this.width + "x" + this.height;
        // if (this.textureType === CGL.Texture.TYPE_FLOAT) txt += " 32bit"; else txt += " 8bit";
        txt += " ";
        txt += this.pixelFormat;

        this.shortInfoString = txt;

        return txt;
    }

    getInfo()
    {
        return Texture.getTexInfo(this);
    }

    _setFilter()
    {
        this._cgl.printError("before _setFilter");

        if (!this._fromData)
        {
            this._cgl.gl.pixelStorei(this._cgl.gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, this.unpackAlpha);
        }

        if (this.shadowMap)
        {
            this._cgl.gl.texParameteri(this._cgl.gl.TEXTURE_2D, this._cgl.gl.TEXTURE_COMPARE_MODE, this._cgl.gl.COMPARE_REF_TO_TEXTURE);
            this._cgl.gl.texParameteri(this._cgl.gl.TEXTURE_2D, this._cgl.gl.TEXTURE_COMPARE_FUNC, this._cgl.gl.LEQUAL);
        }

        if (this.textureType == Texture.TYPE_FLOAT && this.filter == Texture.FILTER_MIPMAP)
        {
            this.filter = Texture.FILTER_LINEAR;
            this._log.stack("texture: HDR and mipmap filtering at the same time is not possible");
        }

        if (this._cgl.glVersion == 1 && !this.isPowerOfTwo())
        {
            this._cgl.gl.texParameteri(this.texTarget, this._cgl.gl.TEXTURE_MAG_FILTER, this._cgl.gl.NEAREST);
            this._cgl.gl.texParameteri(this.texTarget, this._cgl.gl.TEXTURE_MIN_FILTER, this._cgl.gl.NEAREST);

            this._cgl.gl.texParameteri(this.texTarget, this._cgl.gl.TEXTURE_WRAP_S, this._cgl.gl.CLAMP_TO_EDGE);
            this._cgl.gl.texParameteri(this.texTarget, this._cgl.gl.TEXTURE_WRAP_T, this._cgl.gl.CLAMP_TO_EDGE);

            this.filter = Texture.FILTER_NEAREST;
            this.wrap = Texture.WRAP_CLAMP_TO_EDGE;
        }
        else
        {
            if (this.wrap == Texture.WRAP_CLAMP_TO_EDGE)
            {
                this._cgl.gl.texParameteri(this.texTarget, this._cgl.gl.TEXTURE_WRAP_S, this._cgl.gl.CLAMP_TO_EDGE);
                this._cgl.gl.texParameteri(this.texTarget, this._cgl.gl.TEXTURE_WRAP_T, this._cgl.gl.CLAMP_TO_EDGE);
            }
            else if (this.wrap == Texture.WRAP_REPEAT)
            {
                this._cgl.gl.texParameteri(this.texTarget, this._cgl.gl.TEXTURE_WRAP_S, this._cgl.gl.REPEAT);
                this._cgl.gl.texParameteri(this.texTarget, this._cgl.gl.TEXTURE_WRAP_T, this._cgl.gl.REPEAT);
            }
            else if (this.wrap == Texture.WRAP_MIRRORED_REPEAT)
            {
                this._cgl.gl.texParameteri(this.texTarget, this._cgl.gl.TEXTURE_WRAP_S, this._cgl.gl.MIRRORED_REPEAT);
                this._cgl.gl.texParameteri(this.texTarget, this._cgl.gl.TEXTURE_WRAP_T, this._cgl.gl.MIRRORED_REPEAT);
            }

            if (this.filter == Texture.FILTER_NEAREST)
            {
                this._cgl.gl.texParameteri(this.texTarget, this._cgl.gl.TEXTURE_MAG_FILTER, this._cgl.gl.NEAREST);
                this._cgl.gl.texParameteri(this.texTarget, this._cgl.gl.TEXTURE_MIN_FILTER, this._cgl.gl.NEAREST);
            }
            else if (this.filter == Texture.FILTER_LINEAR)
            {
                this._cgl.gl.texParameteri(this.texTarget, this._cgl.gl.TEXTURE_MIN_FILTER, this._cgl.gl.LINEAR);
                this._cgl.gl.texParameteri(this.texTarget, this._cgl.gl.TEXTURE_MAG_FILTER, this._cgl.gl.LINEAR);
            }
            else if (this.filter == Texture.FILTER_MIPMAP)
            {
                this._cgl.gl.texParameteri(this.texTarget, this._cgl.gl.TEXTURE_MAG_FILTER, this._cgl.gl.LINEAR);
                this._cgl.gl.texParameteri(this.texTarget, this._cgl.gl.TEXTURE_MIN_FILTER, this._cgl.gl.LINEAR_MIPMAP_LINEAR);
            }
            else
            {
                this._log.log("unknown texture filter!", this.filter);
                throw new Error("unknown texture filter!" + this.filter);
            }

            if (this.anisotropic)
            {
                const ext = this._cgl.enableExtension("EXT_texture_filter_anisotropic");

                if (this._cgl.maxAnisotropic)
                {
                    const aniso = Math.min(this._cgl.maxAnisotropic, this.anisotropic);
                    this._cgl.gl.texParameterf(this._cgl.gl.TEXTURE_2D, ext.TEXTURE_MAX_ANISOTROPY_EXT, aniso);
                }
            }
        }
        this.getInfoOneLine();
        this._cgl.printError("_setFilter");
    }
}

/**
 * @function load
 * @static
 * @memberof Texture
 * @description load an image from an url
 * @param {CglContext} cgl
 * @param {String} url
 * @param {Function} finishedCallback
 * @param {Object} settings
 * @return {Texture}
 */
Texture.load = function (cgl, url, finishedCallback, settings)
{
    if (!url) return finishedCallback({ "error": true });
    let loadingId = null;
    if (!cgl.patch.loading.existByName(url)) loadingId = cgl.patch.loading.start("cgl.texture", url);

    const texture = new Texture(cgl);
    texture.name = url;

    texture.image = new Image();
    texture.image.crossOrigin = "anonymous";
    texture.loading = true;

    if (settings && settings.hasOwnProperty("filter")) texture.filter = settings.filter;
    if (settings && settings.hasOwnProperty("flip")) texture.flip = settings.flip;
    if (settings && settings.hasOwnProperty("wrap")) texture.wrap = settings.wrap;
    if (settings && settings.hasOwnProperty("anisotropic")) texture.anisotropic = settings.anisotropic;
    if (settings && settings.hasOwnProperty("unpackAlpha")) texture.unpackAlpha = settings.unpackAlpha;
    if (settings && settings.hasOwnProperty("pixelFormat")) texture.pixelFormat = settings.pixelFormat;

    texture.image.onabort = texture.image.onerror = (e) =>
    {
        console.warn("[cgl.texture.load] error loading texture", url, e);
        texture.loading = false;
        if (loadingId) cgl.patch.loading.finished(loadingId);
        const error = { "error": true };
        if (finishedCallback) finishedCallback(error, texture);
    };

    texture.image.onload = function (e)
    {
        cgl.addNextFrameOnceCallback(() =>
        {
            texture.initTexture(texture.image);
            if (loadingId) cgl.patch.loading.finished(loadingId);
            texture.loading = false;

            if (finishedCallback) finishedCallback(null, texture);
        });
    };
    texture.image.src = url;

    return texture;
};

/**
 * @static
 * @function getTempTexture
 * @memberof Texture
 * @description returns the default temporary texture (grey diagonal stipes)
 // * @param {CglContext} cgl
 * @return {Texture}
 */
Texture.getTempTexture = function (cgl)
{
    if (!cgl) console.error("[getTempTexture] no cgl!");
    if (!cgl.tempTexture) cgl.tempTexture = Texture.getTemporaryTexture(cgl, 256, Texture.FILTER_LINEAR, Texture.REPEAT);
    return cgl.tempTexture;
};

/**
 * @static
 * @function getErrorTexture
 * @memberof Texture
 * @description returns the default temporary texture (grey diagonal stipes)
 * @param {CglContext} cgl
 * @return {Texture}
 */
Texture.getErrorTexture = function (cgl)
{
    if (!cgl) console.error("[getTempTexture] no cgl!");
    if (!cgl.errorTexture) cgl.errorTexture = Texture.getTemporaryTexture(cgl, 256, Texture.FILTER_LINEAR, Texture.REPEAT, 1, 0.2, 0.2);
    return cgl.errorTexture;
};

/**
 * @function getEmptyTexture
 * @memberof Texture
 * @instance
 * @param cgl
 * @param fp
 * @description returns a reference to a small empty (transparent) texture
 * @return {Texture}
 */
Texture.getEmptyTexture = function (cgl, fp)
{
    if (fp) return Texture.getEmptyTextureFloat(cgl);
    if (!cgl) console.error("[getEmptyTexture] no cgl!");
    if (cgl.tempTextureEmpty) return cgl.tempTextureEmpty;

    let size = 8;

    cgl.tempTextureEmpty = new Texture(cgl, { "name": "emptyTexture" });
    const data = Texture.getDefaultTextureData("empty", size);

    cgl.tempTextureEmpty.initFromData(data, size, size, Texture.FILTER_NEAREST, Texture.WRAP_REPEAT);

    return cgl.tempTextureEmpty;
};

/**
 * @function getEmptyTextureFloat
 * @memberof Texture
 * @instance
 * @param cgl
 * @description returns a reference to a small empty (transparent) 32bit texture
 * @return {Texture}
 */
Texture.getEmptyTextureFloat = function (cgl)
{
    if (!cgl) console.error("[getEmptyTextureFloat] no cgl!");
    if (cgl.tempTextureEmptyFloat) return cgl.tempTextureEmptyFloat;

    cgl.tempTextureEmptyFloat = new Texture(cgl, { "name": "emptyTexture", "isFloatingPointTexture": true });
    const data = new Float32Array(8 * 8 * 4).fill(1);
    for (let i = 0; i < 8 * 8 * 4; i += 4) data[i + 3] = 0;

    cgl.tempTextureEmptyFloat.initFromData(data, 8, 8, Texture.FILTER_NEAREST, Texture.WRAP_REPEAT);

    return cgl.tempTextureEmptyFloat;
};

/**
 * @function getRandomTexture
 * @memberof Texture
 * @static
 * @param cgl
 * @description returns a reference to a random texture
 * @return {Texture}
 */
Texture.getRandomTexture = function (cgl)
{
    if (!cgl) console.error("[getRandomTexture] no cgl!");
    if (cgl.randomTexture) return cgl.randomTexture;

    const size = 256;
    const data = Texture.getDefaultTextureData("randomUInt", size);

    cgl.randomTexture = new Texture(cgl);
    cgl.randomTexture.initFromData(data, size, size, Texture.FILTER_NEAREST, Texture.WRAP_REPEAT);

    return cgl.randomTexture;
};

/**
 * @function getRandomFloatTexture
 * @memberof Texture
 * @static
 * @param cgl
 * @description returns a reference to a texture containing random numbers between -1 and 1
 * @return {Texture}
 */
Texture.getRandomFloatTexture = function (cgl)
{
    if (!cgl) console.error("[getRandomTexture] no cgl!");
    if (cgl.getRandomFloatTexture) return cgl.getRandomFloatTexture;

    const size = 256;
    const data = Texture.getDefaultTextureData("randomFloat", size);

    cgl.getRandomFloatTexture = new Texture(cgl, { "isFloatingPointTexture": true });
    cgl.getRandomFloatTexture.initFromData(data, size, size, Texture.FILTER_NEAREST, Texture.WRAP_REPEAT);

    return cgl.getRandomFloatTexture;
};

/**
 * @function getBlackTexture
 * @memberof Texture
 * @static
 * @param {CglContext} cgl
 * @description returns a reference to a black texture
 * @return {Texture}
 */
Texture.getBlackTexture = function (cgl)
{
    if (cgl.blackTexture) return cgl.blackTexture;

    const size = 8;
    const data = Texture.getDefaultTextureData("color", size, { "r": 0, "g": 0, "b": 0 });

    cgl.blackTexture = new Texture(cgl);
    cgl.blackTexture.initFromData(data, size, size, Texture.FILTER_NEAREST, Texture.WRAP_REPEAT);

    return cgl.blackTexture;
};

/**
 * @function getEmptyCubemapTexture
 * @memberof Texture
 * @static
 * @param cgl
 * @description returns an empty cubemap texture with rgba = [0, 0, 0, 0]
 * @return {Texture}
 */
Texture.getEmptyCubemapTexture = function (cgl)
{
    const faces = [
        cgl.gl.TEXTURE_CUBE_MAP_POSITIVE_X,
        cgl.gl.TEXTURE_CUBE_MAP_NEGATIVE_X,
        cgl.gl.TEXTURE_CUBE_MAP_POSITIVE_Y,
        cgl.gl.TEXTURE_CUBE_MAP_NEGATIVE_Y,
        cgl.gl.TEXTURE_CUBE_MAP_POSITIVE_Z,
        cgl.gl.TEXTURE_CUBE_MAP_NEGATIVE_Z
    ];

    const tex = cgl.gl.createTexture();
    const target = cgl.gl.TEXTURE_CUBE_MAP;
    const filter = Texture.FILTER_NEAREST;
    const wrap = Texture.WRAP_CLAMP_TO_EDGE;
    const width = 8;
    const height = 8;

    cgl.profileData.profileTextureNew++;

    cgl.gl.bindTexture(target, tex);
    cgl.profileData.profileTextureResize++;

    for (let i = 0; i < 6; i += 1)
    {
        const data = new Uint8Array(8 * 8 * 4);

        cgl.gl.texImage2D(faces[i], 0, cgl.gl.RGBA, 8, 8, 0, cgl.gl.RGBA, cgl.gl.UNSIGNED_BYTE, data);
        cgl.gl.texParameteri(target, cgl.gl.TEXTURE_MAG_FILTER, cgl.gl.NEAREST);
        cgl.gl.texParameteri(target, cgl.gl.TEXTURE_MIN_FILTER, cgl.gl.NEAREST);

        cgl.gl.texParameteri(target, cgl.gl.TEXTURE_WRAP_S, cgl.gl.CLAMP_TO_EDGE);
        cgl.gl.texParameteri(target, cgl.gl.TEXTURE_WRAP_T, cgl.gl.CLAMP_TO_EDGE);
    }

    cgl.gl.bindTexture(target, null);

    return {
        "id": cables__WEBPACK_IMPORTED_MODULE_2__.uuid(),
        "tex": tex,
        "cubemap": tex,
        "width": width,
        "height": height,
        "filter": filter,
        "wrap": wrap,
        "unpackAlpha": true,
        "flip": true,
        "_fromData": true,
        "name": "emptyCubemapTexture",
        "anisotropic": 0,
    };
};

Texture.getTempGradientTexture = function (cgl) // deprecated...
{
    if (!cgl) console.error("[getTempGradientTexture] no cgl!");
    return Texture.getTempTexture(cgl);
};

Texture.getTemporaryTexture = function (cgl, size, filter, wrap, r, g, b)
{
    const data = Texture.getDefaultTextureData("stripes", 256, { "r": r, "g": g, "b": b });
    const temptex = new Texture(cgl);
    temptex.initFromData(data, size, size, filter, wrap);
    return temptex;
};

/**
 * @static
 * @function createFromImage
 * @memberof Texture
 * @description create texturem from image data (e.g. image or canvas)
 * @param {CglContext} cgl
 * @param {Object} img image
 * @param {Object} options
 */
Texture.createFromImage = function (cgl, img, options)
{
    options = options || {};
    const texture = new Texture(cgl, options);
    texture.flip = false;
    texture.image = img;
    texture.width = img.videoWidth || img.width || 8;
    texture.height = img.videoHeight || img.height || 8;
    if (options.hasOwnProperty("wrap"))texture.wrap = options.wrap;

    texture.initTexture(img, options.filter);

    return texture;
};

// deprecated!
Texture.fromImage = function (cgl, img, filter, wrap)
{
    console.error("deprecated texture from image...");

    const texture = new Texture(cgl);
    texture.flip = false;
    if (filter) texture.filter = filter;
    if (wrap) texture.wrap = wrap;
    texture.image = img;
    texture.initTexture(img);
    return texture;
};

/**
 * @static
 * @function isPowerOfTwo
 * @memberof Texture
 * @description returns true if x is power of two
 * @param {Number} x
 * @return {Boolean}
 */
Texture.isPowerOfTwo = function (x)
{
    return x == 1 || x == 2 || x == 4 || x == 8 || x == 16 || x == 32 || x == 64 || x == 128 || x == 256 || x == 512 || x == 1024 || x == 2048 || x == 4096 || x == 8192 || x == 16384;
};

Texture.getTexInfo = function (tex)
{
    const obj = {};

    obj.name = tex.name;
    obj["power of two"] = tex.isPowerOfTwo();
    obj.size = tex.width + " x " + tex.height;

    let targetString = tex.texTarget;
    if (tex.texTarget == tex._cgl.gl.TEXTURE_2D) targetString = "TEXTURE_2D";
    obj.target = targetString;

    obj.unpackAlpha = tex.unpackAlpha;

    if (tex.cubemap)obj.cubemap = true;

    if (tex.textureType == Texture.TYPE_FLOAT) obj.textureType = "TYPE_FLOAT";
    if (tex.textureType == Texture.TYPE_HALF_FLOAT) obj.textureType = "TYPE_HALF_FLOAT";
    else if (tex.textureType == Texture.TYPE_DEPTH) obj.textureType = "TYPE_DEPTH";
    else if (tex.textureType == Texture.TYPE_DEFAULT) obj.textureType = "TYPE_DEFAULT";
    else obj.textureType = "UNKNOWN " + this.textureType;

    if (tex.wrap == Texture.WRAP_CLAMP_TO_EDGE) obj.wrap = "CLAMP_TO_EDGE";
    else if (tex.wrap == Texture.WRAP_REPEAT) obj.wrap = "WRAP_REPEAT";
    else if (tex.wrap == Texture.WRAP_MIRRORED_REPEAT) obj.wrap = "WRAP_MIRRORED_REPEAT";
    else obj.wrap = "UNKNOWN";

    if (tex.filter == Texture.FILTER_NEAREST) obj.filter = "FILTER_NEAREST";
    else if (tex.filter == Texture.FILTER_LINEAR) obj.filter = "FILTER_LINEAR";
    else if (tex.filter == Texture.FILTER_MIPMAP) obj.filter = "FILTER_MIPMAP";
    else obj.filter = "UNKNOWN";

    obj.pixelFormat = tex.pixelFormat || "unknown";

    return obj;
};

Texture.setUpGlPixelFormat = function (cgl, pixelFormatStr)
{
    const o = {};

    if (!pixelFormatStr)
    {
        cgl._log.error("no pixelformatstr!");
        cgl._log.log(new Error());
        pixelFormatStr = Texture.PFORMATSTR_RGBA8UB;
    }

    o.pixelFormatBase = pixelFormatStr;
    o.pixelFormat = pixelFormatStr;
    o.glDataType = cgl.gl.UNSIGNED_BYTE;
    o.glInternalFormat = cgl.gl.RGBA8;
    o.glDataFormat = cgl.gl.RGBA;

    let floatDatatype = cgl.gl.FLOAT;

    if (cgl.glUseHalfFloatTex)
    {
        if (pixelFormatStr == Texture.PFORMATSTR_RGBA32F) pixelFormatStr = Texture.PFORMATSTR_RGBA16F;
        if (pixelFormatStr == Texture.PFORMATSTR_RG32F) pixelFormatStr = Texture.PFORMATSTR_RG16F;
        if (pixelFormatStr == Texture.PFORMATSTR_R32F) pixelFormatStr = Texture.PFORMATSTR_R16F;
    }

    if (pixelFormatStr.includes("16bit"))
    {
        if (cgl.glVersion == 2)
        {
            // cgl.enableExtension("OES_texture_half_float");
            const hasExt = cgl.enableExtension("EXT_color_buffer_half_float");

            if (!hasExt)
            {
                console.warn("no 16bit extension, fallback to 32bit", pixelFormatStr);
                // fallback to 32 bit?
                if (pixelFormatStr == Texture.PFORMATSTR_RGBA16F) pixelFormatStr = Texture.PFORMATSTR_RGBA32F;
                if (pixelFormatStr == Texture.PFORMATSTR_RGB16F) pixelFormatStr = Texture.PFORMATSTR_RGB32F;
                if (pixelFormatStr == Texture.PFORMATSTR_RG16F) pixelFormatStr = Texture.PFORMATSTR_RG32F;
                if (pixelFormatStr == Texture.PFORMATSTR_R16F) pixelFormatStr = Texture.PFORMATSTR_R32F;
            }
            else
            {
                floatDatatype = cgl.gl.HALF_FLOAT;
            }
        }
    }

    if (cgl.glVersion == 1)
    {
        o.glInternalFormat = cgl.gl.RGBA;

        if (pixelFormatStr == Texture.PFORMATSTR_RGBA16F || pixelFormatStr == Texture.PFORMATSTR_RG16F || pixelFormatStr == Texture.PFORMATSTR_R16F)
        {
            const ext = cgl.enableExtension("OES_texture_half_float");
            if (!ext) throw new Error("no half float texture extension");

            floatDatatype = ext.HALF_FLOAT_OES;
        }
    }

    if (pixelFormatStr == Texture.PFORMATSTR_RGBA8UB)
    {
    }
    else if (pixelFormatStr == Texture.PFORMATSTR_RGB565)
    {
        o.glInternalFormat = cgl.gl.RGB565;
        o.glDataFormat = cgl.gl.RGB;
    }
    else if (pixelFormatStr == Texture.PFORMATSTR_R8UB)
    {
        o.glInternalFormat = cgl.gl.R8;
        o.glDataFormat = cgl.gl.RED;
    }
    else if (pixelFormatStr == Texture.PFORMATSTR_RG8UB)
    {
        o.glInternalFormat = cgl.gl.RG8;
        o.glDataFormat = cgl.gl.RG;
    }
    else if (pixelFormatStr == Texture.PFORMATSTR_RGB8UB)
    {
        o.glInternalFormat = cgl.gl.RGB8;
        o.glDataFormat = cgl.gl.RGB;
    }
    else if (pixelFormatStr == Texture.PFORMATSTR_SRGBA8)
    {
        o.glInternalFormat = cgl.gl.SRGB8_ALPHA8;
    }

    else if (pixelFormatStr == Texture.PFORMATSTR_R32F)
    {
        o.glInternalFormat = cgl.gl.R32F;
        o.glDataFormat = cgl.gl.RED;
        o.glDataType = floatDatatype;
    }
    else if (pixelFormatStr == Texture.PFORMATSTR_R16F)
    {
        o.glInternalFormat = cgl.gl.R16F;
        o.glDataType = floatDatatype;
        o.glDataFormat = cgl.gl.RED;
    }
    else if (pixelFormatStr == Texture.PFORMATSTR_RG16F)
    {
        o.glInternalFormat = cgl.gl.RG16F;
        o.glDataType = floatDatatype;
        o.glDataFormat = cgl.gl.RG;
    }
    else if (pixelFormatStr == Texture.PFORMATSTR_RGBA16F)
    {
        if (cgl.glVersion == 1) o.glInternalFormat = cgl.gl.RGBA;
        else o.glInternalFormat = cgl.gl.RGBA16F;
        o.glDataType = floatDatatype;
    }
    else if (pixelFormatStr == Texture.PFORMATSTR_R11FG11FB10F)
    {
        o.glInternalFormat = cgl.gl.R11F_G11F_B10F;
        o.glDataType = floatDatatype;
        o.glDataFormat = cgl.gl.RGB;
    }
    else if (pixelFormatStr == Texture.PFORMATSTR_RGBA32F)
    {
        if (cgl.glVersion == 1) o.glInternalFormat = cgl.gl.RGBA;
        else o.glInternalFormat = cgl.gl.RGBA32F;
        o.glDataType = floatDatatype;
    }
    else if (pixelFormatStr == Texture.PFORMATSTR_DEPTH)
    {
        if (cgl.glVersion == 1)
        {
            o.glInternalFormat = cgl.gl.DEPTH_COMPONENT;
            o.glDataType = cgl.gl.UNSIGNED_SHORT;
            o.glDataFormat = cgl.gl.DEPTH_COMPONENT;
        }
        else
        {
            o.glInternalFormat = cgl.gl.DEPTH_COMPONENT32F;
            o.glDataType = cgl.gl.FLOAT;
            o.glDataFormat = cgl.gl.DEPTH_COMPONENT;
        }
    }
    else
    {
        log.log("unknown pixelformat ", pixelFormatStr);
    }

    /// //////

    if (pixelFormatStr.includes("32bit") || pixelFormatStr == Texture.PFORMATSTR_R11FG11FB10F)
    {
        if (cgl.glVersion == 2) cgl.enableExtension("EXT_color_buffer_float");
        if (cgl.glVersion == 2) cgl.enableExtension("EXT_float_blend");

        cgl.enableExtension("OES_texture_float_linear"); // yes, i am sure, this is a webgl 1 and 2 ext
    }

    o.numColorChannels = Texture.getPixelFormatNumChannels(pixelFormatStr);

    if (!o.glDataType || !o.glInternalFormat || !o.glDataFormat) log.log("pixelformat wrong ?!", pixelFormatStr, o.glDataType, o.glInternalFormat, o.glDataFormat, this);

    return o;
};

Texture.getPixelFormatNumChannels =
    (pxlFrmtStr) =>
    {
        if (pxlFrmtStr.startsWith("RGBA")) return 4;
        if (pxlFrmtStr.startsWith("RGB")) return 3;
        if (pxlFrmtStr.startsWith("RG")) return 2;
        return 1;
    };

Texture.isPixelFormatFloat =
    (pxlFrmtStr) =>
    {
        return (pxlFrmtStr || "").includes("float");
    };

Texture.isPixelFormatHalfFloat =
    (pxlFrmtStr) =>
    {
        return (pxlFrmtStr || "").includes("float") && (pxlFrmtStr || "").includes("16bit");
    };


/***/ }),

/***/ 771:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   p: () => (/* binding */ TextureEffect)
/* harmony export */ });
/* harmony import */ var cables_shared_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(849);
/* harmony import */ var _cgl_texture_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(70);
/* harmony import */ var _cgl_simplerect_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(273);




class TextureEffect
{
    constructor(cgl, options)
    {
        this._cgl = cgl;
        this._log = new cables_shared_client__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A("cgl_TextureEffect");

        if (!cgl.TextureEffectMesh) this.createMesh();

        this._textureSource = null;
        this._options = options;
        this.name = options.name || "unknown";

        this.imgCompVer = 0;
        this.aspectRatio = 1;
        this._textureTarget = null; // new CGL.Texture(this._cgl,opts);
        this._frameBuf = this._cgl.gl.createFramebuffer();
        this._frameBuf2 = this._cgl.gl.createFramebuffer();
        this._renderbuffer = this._cgl.gl.createRenderbuffer();
        this._renderbuffer2 = this._cgl.gl.createRenderbuffer();
        this.switched = false;
        this.depth = false;
    }

    dispose()
    {
        if (this._renderbuffer) this._cgl.gl.deleteRenderbuffer(this._renderbuffer);
        if (this._frameBuf) this._cgl.gl.deleteFramebuffer(this._frameBuf);
        if (this._renderbuffer2) this._cgl.gl.deleteRenderbuffer(this._renderbuffer2);
        if (this._frameBuf2) this._cgl.gl.deleteFramebuffer(this._frameBuf2);
    }

    getWidth()
    {
        return this._textureSource.width;
    }

    getHeight()
    {
        return this._textureSource.height;
    }

    setSourceTexture(tex)
    {
        if (tex === null)
        {
            this._textureSource = new _cgl_texture_js__WEBPACK_IMPORTED_MODULE_1__/* .Texture */ .g(this._cgl);
            this._textureSource.setSize(16, 16);
        }
        else
        {
            this._textureSource = tex;
        }

        if (!this._textureSource.compareSettings(this._textureTarget))
        {
            if (this._textureTarget) this._textureTarget.delete();

            this._textureTarget = this._textureSource.clone();

            this._cgl.profileData.profileEffectBuffercreate++;

            this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, this._frameBuf);

            this._cgl.gl.bindRenderbuffer(this._cgl.gl.RENDERBUFFER, this._renderbuffer);

            // if(tex.textureType==CGL.Texture.TYPE_FLOAT) this._cgl.gl.renderbufferStorage(this._cgl.gl.RENDERBUFFER,this._cgl.gl.RGBA32F, this._textureSource.width,this._textureSource.height);
            // else this._cgl.gl.renderbufferStorage(this._cgl.gl.RENDERBUFFER,this._cgl.gl.RGBA8, this._textureSource.width,this._textureSource.height);

            if (this.depth) this._cgl.gl.renderbufferStorage(this._cgl.gl.RENDERBUFFER, this._cgl.gl.DEPTH_COMPONENT16, this._textureSource.width, this._textureSource.height);
            this._cgl.gl.framebufferTexture2D(this._cgl.gl.FRAMEBUFFER, this._cgl.gl.COLOR_ATTACHMENT0, this._cgl.gl.TEXTURE_2D, this._textureTarget.tex, 0);
            if (this.depth) this._cgl.gl.framebufferRenderbuffer(this._cgl.gl.FRAMEBUFFER, this._cgl.gl.DEPTH_ATTACHMENT, this._cgl.gl.RENDERBUFFER, this._renderbuffer);

            // this._cgl.gl.framebufferTexture2D(this._cgl.gl.FRAMEBUFFER, this._cgl.gl.COLOR_ATTACHMENT0, this._cgl.gl.TEXTURE_2D, this._textureTarget.tex, 0);

            this._cgl.gl.bindTexture(this._cgl.gl.TEXTURE_2D, null);
            this._cgl.gl.bindRenderbuffer(this._cgl.gl.RENDERBUFFER, null);
            this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, null);

            this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, this._frameBuf2);

            this._cgl.gl.bindRenderbuffer(this._cgl.gl.RENDERBUFFER, this._renderbuffer2);

            // if(tex.textureType==CGL.Texture.TYPE_FLOAT) this._cgl.gl.renderbufferStorage(this._cgl.gl.RENDERBUFFER,this._cgl.gl.RGBA32F, this._textureSource.width,this._textureSource.height);
            // else this._cgl.gl.renderbufferStorage(this._cgl.gl.RENDERBUFFER,this._cgl.gl.RGBA8, this._textureSource.width,this._textureSource.height);

            if (this.depth) this._cgl.gl.renderbufferStorage(this._cgl.gl.RENDERBUFFER, this._cgl.gl.DEPTH_COMPONENT16, this._textureSource.width, this._textureSource.height);
            this._cgl.gl.framebufferTexture2D(this._cgl.gl.FRAMEBUFFER, this._cgl.gl.COLOR_ATTACHMENT0, this._cgl.gl.TEXTURE_2D, this._textureSource.tex, 0);

            if (this.depth) this._cgl.gl.framebufferRenderbuffer(this._cgl.gl.FRAMEBUFFER, this._cgl.gl.DEPTH_ATTACHMENT, this._cgl.gl.RENDERBUFFER, this._renderbuffer2);

            // this._cgl.gl.framebufferTexture2D(this._cgl.gl.FRAMEBUFFER, this._cgl.gl.COLOR_ATTACHMENT0, this._cgl.gl.TEXTURE_2D, this._textureSource.tex, 0);

            this._cgl.gl.bindTexture(this._cgl.gl.TEXTURE_2D, null);
            this._cgl.gl.bindRenderbuffer(this._cgl.gl.RENDERBUFFER, null);
            this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, null);
        }

        this.aspectRatio = this._textureSource.width / this._textureSource.height;
    }

    continueEffect()
    {
        this._cgl.pushDepthTest(false);
        this._cgl.pushModelMatrix();
        this._cgl.pushPMatrix();
        // todo why two pushs?

        this._cgl.pushViewPort(0, 0, this.getCurrentTargetTexture().width, this.getCurrentTargetTexture().height);

        mat4.perspective(this._cgl.pMatrix, 45, this.getCurrentTargetTexture().width / this.getCurrentTargetTexture().height, 0.1, 1100.0); // todo: why?

        this._cgl.pushPMatrix();
        mat4.identity(this._cgl.pMatrix);

        this._cgl.pushViewMatrix();
        mat4.identity(this._cgl.vMatrix);

        this._cgl.pushModelMatrix();
        mat4.identity(this._cgl.mMatrix);
    }

    startEffect(bgTex)
    {
        if (!this._textureTarget)
        {
            this._log.warn("effect has no target");
            return;
        }

        this.switched = false;

        this.continueEffect();

        if (bgTex)
        {
            this._bgTex = bgTex;
        }
        this._countEffects = 0;
    }

    endEffect()
    {
        this._cgl.popDepthTest();
        this._cgl.popModelMatrix();

        this._cgl.popPMatrix();
        this._cgl.popModelMatrix();
        this._cgl.popViewMatrix();

        this._cgl.popPMatrix();
        this._cgl.popViewPort();
    }

    bind()
    {
        if (this._textureSource === null)
        {
            this._log.warn("no base texture set!");
            return;
        }

        if (!this.switched)
        {
            this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, this._frameBuf);
            this._cgl.pushGlFrameBuffer(this._frameBuf);
        }
        else
        {
            this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, this._frameBuf2);
            this._cgl.pushGlFrameBuffer(this._frameBuf2);
        }
    }

    finish()
    {
        if (this._textureSource === null)
        {
            this._log.warn("no base texture set!");
            return;
        }

        this._cgl.TextureEffectMesh.render(this._cgl.getShader());

        this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, this._cgl.popGlFrameBuffer());

        this._cgl.profileData.profileTextureEffect++;

        if (this._textureTarget.filter == _cgl_texture_js__WEBPACK_IMPORTED_MODULE_1__/* .Texture */ .g.FILTER_MIPMAP)
        {
            if (!this.switched)
            {
                this._cgl.gl.bindTexture(this._cgl.gl.TEXTURE_2D, this._textureTarget.tex);
                this._textureTarget.updateMipMap();
            }
            else
            {
                this._cgl.gl.bindTexture(this._cgl.gl.TEXTURE_2D, this._textureSource.tex);
                this._textureSource.updateMipMap();
            }

            this._cgl.gl.bindTexture(this._cgl.gl.TEXTURE_2D, null);
        }

        this.switched = !this.switched;
        this._countEffects++;
    }

    getCurrentTargetTexture()
    {
        if (this.switched) return this._textureSource;
        return this._textureTarget;
    }

    getCurrentSourceTexture()
    {
        if (this._countEffects == 0 && this._bgTex) return this._bgTex;

        if (this.switched) return this._textureTarget;
        return this._textureSource;
    }

    delete()
    {
        if (this._textureTarget) this._textureTarget.delete();
        if (this._textureSource) this._textureSource.delete();
        this._cgl.gl.deleteRenderbuffer(this._renderbuffer);
        this._cgl.gl.deleteFramebuffer(this._frameBuf);
    }

    createMesh()
    {
        this._cgl.TextureEffectMesh = _cgl_simplerect_js__WEBPACK_IMPORTED_MODULE_2__/* .MESHES */ .S.getSimpleRect(this._cgl, "texEffectRect");
    }

    // ---------------------------------------------------------------------------------
}

TextureEffect.checkOpNotInTextureEffect = function (op)
{
    if (!op.patch.cgl) return true;
    if (op.uiAttribs.error && !op.patch.cgl.currentTextureEffect)
    {
        op.setUiError("textureeffect", null);
        return true;
    }
    if (!op.patch.cgl.currentTextureEffect) return true;

    if (op.patch.cgl.currentTextureEffect && !op.uiAttribs.error)
    {
        op.setUiError("textureeffect", "This op can not be a child of a ImageCompose/texture effect! imagecompose should only have textureeffect childs.", 0);
        return false;
    }

    if (op.patch.cgl.currentTextureEffect) return false;
    return true;
};

TextureEffect.checkOpInEffect = function (op, minver)
{
    minver = minver || 0;

    if (op.patch.cgl.currentTextureEffect)
    {
        if (op.uiAttribs.uierrors && op.patch.cgl.currentTextureEffect.imgCompVer >= minver)
        {
            op.setUiError("texeffect", null);
            return true;
        }

        if (minver && op.patch.cgl.currentTextureEffect.imgCompVer < minver)
        {
            op.setUiError("texeffect", "This op must be a child of an ImageCompose op with version >=" + minver + " <span class=\"button-small\" onclick=\"gui.patchView.downGradeOp('" + op.id + "','" + op.name + "')\">Downgrade</span> to previous version", 1);
        }
    }

    if (op.patch.cgl.currentTextureEffect) return true;

    if (!op.patch.cgl.currentTextureEffect && (!op.uiAttribs.uierrors || op.uiAttribs.uierrors.length == 0))
    {
        op.setUiError("texeffect", "This op must be a child of an ImageCompose op! More infos <a href=\"https://cables.gl/docs/image_composition/image_composition.html\" target=\"_blank\">here</a>. ", 1);
        return false;
    }

    if (!op.patch.cgl.currentTextureEffect) return false;
    return true;
};

TextureEffect.getBlendCode = function (ver)
{
    let src = "".endl()
        + "vec3 _blend(vec3 base,vec3 blend)".endl()
        + "{".endl()
        + "   vec3 colNew=blend;".endl()
        + "   #ifdef BM_MULTIPLY".endl()
        + "       colNew=base*blend;".endl()
        + "   #endif".endl()
        + "   #ifdef BM_MULTIPLY_INV".endl()
        + "       colNew=base* vec3(1.0)-blend;".endl()
        + "   #endif".endl()
        + "   #ifdef BM_AVERAGE".endl()
        + "       colNew=((base + blend) / 2.0);".endl()
        + "   #endif".endl()
        + "   #ifdef BM_ADD".endl()
        + "       colNew=min(base + blend, vec3(1.0));".endl()
        + "   #endif".endl()
        + "   #ifdef BM_SUBTRACT_ONE".endl()
        + "       colNew=max(base + blend - vec3(1.0), vec3(0.0));".endl()
        + "   #endif".endl()

        + "   #ifdef BM_SUBTRACT".endl()
        + "       colNew=base - blend;".endl()
        + "   #endif".endl()

        + "   #ifdef BM_DIFFERENCE".endl()
        + "       colNew=abs(base - blend);".endl()
        + "   #endif".endl()
        + "   #ifdef BM_NEGATION".endl()
        + "       colNew=(vec3(1.0) - abs(vec3(1.0) - base - blend));".endl()
        + "   #endif".endl()
        + "   #ifdef BM_EXCLUSION".endl()
        + "       colNew=(base + blend - 2.0 * base * blend);".endl()
        + "   #endif".endl()
        + "   #ifdef BM_LIGHTEN".endl()
        + "       colNew=max(blend, base);".endl()
        + "   #endif".endl()
        + "   #ifdef BM_DARKEN".endl()
        + "       colNew=min(blend, base);".endl()
        + "   #endif".endl()
        + "   #ifdef BM_OVERLAY".endl()
        + "      #define BlendOverlayf(base, blend)  (base < 0.5 ? (2.0 * base * blend) : (1.0 - 2.0 * (1.0 - base) * (1.0 - blend)))"
            // .endl()+'       #define BlendOverlay(base, blend)       Blend(base, blend, BlendOverlayf)'
            //    .endl()+'      colNew=Blend(base, blend, BlendOverlayf);'
            .endl()
        + "      colNew=vec3(BlendOverlayf(base.r, blend.r),BlendOverlayf(base.g, blend.g),BlendOverlayf(base.b, blend.b));".endl()
        + "   #endif".endl()
        + "   #ifdef BM_SCREEN".endl()
        + "      #define BlendScreenf(base, blend)       (1.0 - ((1.0 - base) * (1.0 - blend)))"
            // .endl()+'       #define BlendScreen(base, blend)        Blend(base, blend, BlendScreenf)'
            // .endl()+'      colNew=Blend(base, blend, BlendScreenf);'
            .endl()
        + "      colNew=vec3(BlendScreenf(base.r, blend.r),BlendScreenf(base.g, blend.g),BlendScreenf(base.b, blend.b));".endl()
        + "   #endif".endl()
        + "   #ifdef BM_SOFTLIGHT".endl()
        + "      #define BlendSoftLightf(base, blend)    ((blend < 0.5) ? (2.0 * base * blend + base * base * (1.0 - 2.0 * blend)) : (sqrt(base) * (2.0 * blend - 1.0) + 2.0 * base * (1.0 - blend)))"
            // .endl()+'       #define BlendSoftLight(base, blend)     Blend(base, blend, BlendSoftLightf)'
            //    .endl()+'      colNew=Blend(base, blend, BlendSoftLightf);'
            .endl()
        + "      colNew=vec3(BlendSoftLightf(base.r, blend.r),BlendSoftLightf(base.g, blend.g),BlendSoftLightf(base.b, blend.b));".endl()
        + "   #endif".endl()
        + "   #ifdef BM_HARDLIGHT".endl()
        + "      #define BlendOverlayf(base, blend)  (base < 0.5 ? (2.0 * base * blend) : (1.0 - 2.0 * (1.0 - base) * (1.0 - blend)))"
            // .endl()+'       #define BlendOverlay(base, blend)       Blend(base, blend, BlendOverlayf)'
            // .endl()+'      colNew=Blend(blend, base, BlendOverlayf);'
            .endl()
        + "      colNew=vec3(BlendOverlayf(base.r, blend.r),BlendOverlayf(base.g, blend.g),BlendOverlayf(base.b, blend.b));".endl()
        + "   #endif".endl()
        + "   #ifdef BM_COLORDODGE".endl()
        + "      #define BlendColorDodgef(base, blend)   ((blend == 1.0) ? blend : min(base / (1.0 - blend), 1.0))"
            // .endl()+'      colNew=Blend(base, blend, BlendColorDodgef);'
            .endl()
        + "      colNew=vec3(BlendColorDodgef(base.r, blend.r),BlendColorDodgef(base.g, blend.g),BlendColorDodgef(base.b, blend.b));".endl()
        + "   #endif".endl()
        + "   #ifdef BM_COLORBURN".endl()
        + "      #define BlendColorBurnf(base, blend)    ((blend == 0.0) ? blend : max((1.0 - ((1.0 - base) / blend)), 0.0))"
            // .endl()+'      colNew=Blend(base, blend, BlendColorBurnf);'
            .endl()
        + "      colNew=vec3(BlendColorBurnf(base.r, blend.r),BlendColorBurnf(base.g, blend.g),BlendColorBurnf(base.b, blend.b));".endl()
        + "   #endif".endl()

        + "   return colNew;".endl()
        + "}".endl();

    if (!ver)
        src += "vec4 cgl_blend(vec4 oldColor,vec4 newColor,float amount)".endl()
                + "{".endl()
                    + "vec4 col=vec4( _blend(oldColor.rgb,newColor.rgb) ,1.0);".endl()
                    + "col=vec4( mix( col.rgb, oldColor.rgb ,1.0-oldColor.a*amount),1.0);".endl()
                    + "return col;".endl()
                + "}".endl();

    if (ver >= 3)
        src += "vec4 cgl_blendPixel(vec4 base,vec4 col,float amount)".endl() +
                "{".endl() +

                "#ifdef BM_MATH_ADD".endl() +
                "   return vec4(base.rgb+col.rgb*amount,1.0);".endl() +
                "#endif".endl() +

                "#ifdef BM_MATH_SUB".endl() +
                "   return vec4(base.rgb-col.rgb*amount,1.0);".endl() +
                "#endif".endl() +

                "#ifdef BM_MATH_MUL".endl() +
                "   return vec4(base.rgb*col.rgb*amount,1.0);".endl() +
                "#endif".endl() +

                "#ifdef BM_MATH_DIV".endl() +
                "   return vec4(base.rgb/col.rgb*amount,1.0);".endl() +
                "#endif".endl() +

                    "#ifndef BM_MATH".endl() +
                        "vec3 colNew=_blend(base.rgb,col.rgb);".endl() +

                        "float newA=clamp(base.a+(col.a*amount),0.,1.);".endl() +

                        "#ifdef BM_ALPHAMASKED".endl() +
                            "newA=base.a;".endl() +
                        "#endif".endl() +

                        "return vec4(".endl() +
                            "mix(colNew,base.rgb,1.0-(amount*col.a)),".endl() +
                            "newA);".endl() +

                    "#endif".endl() +
    "}".endl();

    return src;
};

TextureEffect.onChangeBlendSelect = function (shader, blendName, maskAlpha = false)
{
    blendName = String(blendName);
    shader.toggleDefine("BM_NORMAL", blendName == "normal");
    shader.toggleDefine("BM_MULTIPLY", blendName == "multiply");
    shader.toggleDefine("BM_MULTIPLY_INV", blendName == "multiply invert");
    shader.toggleDefine("BM_AVERAGE", blendName == "average");
    shader.toggleDefine("BM_ADD", blendName == "add");
    shader.toggleDefine("BM_SUBTRACT_ONE", blendName == "subtract one");
    shader.toggleDefine("BM_SUBTRACT", blendName == "subtract");
    shader.toggleDefine("BM_DIFFERENCE", blendName == "difference");
    shader.toggleDefine("BM_NEGATION", blendName == "negation");
    shader.toggleDefine("BM_EXCLUSION", blendName == "exclusion");
    shader.toggleDefine("BM_LIGHTEN", blendName == "lighten");
    shader.toggleDefine("BM_DARKEN", blendName == "darken");
    shader.toggleDefine("BM_OVERLAY", blendName == "overlay");
    shader.toggleDefine("BM_SCREEN", blendName == "screen");
    shader.toggleDefine("BM_SOFTLIGHT", blendName == "softlight");
    shader.toggleDefine("BM_HARDLIGHT", blendName == "hardlight");
    shader.toggleDefine("BM_COLORDODGE", blendName == "color dodge");
    shader.toggleDefine("BM_COLORBURN", blendName == "color burn");

    shader.toggleDefine("BM_MATH_ADD", blendName == "Math Add");
    shader.toggleDefine("BM_MATH_SUB", blendName == "Math Subtract");
    shader.toggleDefine("BM_MATH_MUL", blendName == "Math Multiply");
    shader.toggleDefine("BM_MATH_DIV", blendName == "Math Divide");

    shader.toggleDefine("BM_MATH", blendName.indexOf("Math ") == 0);

    shader.toggleDefine("BM_ALPHAMASKED", maskAlpha);
};

TextureEffect.AddBlendSelect = function (op, name, defaultMode)
{
    const p = op.inValueSelect(name || "Blend Mode", [
        "normal", "lighten", "darken", "multiply", "multiply invert", "average", "add", "subtract", "difference", "negation", "exclusion", "overlay", "screen", "color dodge", "color burn", "softlight", "hardlight", "subtract one",
        "Math Add",
        "Math Subtract",
        "Math Multiply",
        "Math Divide",

    ], defaultMode || "normal");
    return p;
};

TextureEffect.AddBlendAlphaMask = function (op, name, defaultMode)
{
    const p = op.inSwitch(name || "Alpha Mask", ["Off", "On"], defaultMode || "Off");
    return p;
};

TextureEffect.setupBlending = function (op, shader, blendPort, amountPort, alphaMaskPort)
{
    const onChange = () =>
    {
        let maskAlpha = false;
        if (alphaMaskPort) maskAlpha = alphaMaskPort.get() == "On";
        TextureEffect.onChangeBlendSelect(shader, blendPort.get(), maskAlpha);

        let str = blendPort.get();
        if (str == "normal") str = null;
        else if (str == "multiply") str = "mul";
        else if (str == "multiply invert") str = "mulinv";
        else if (str == "lighten") str = "light";
        else if (str == "darken") str = "darken";
        else if (str == "average") str = "avg";
        else if (str == "subtract one") str = "sub one";
        else if (str == "subtract") str = "sub";
        else if (str == "difference") str = "diff";
        else if (str == "negation") str = "neg";
        else if (str == "exclusion") str = "exc";
        else if (str == "overlay") str = "ovl";
        else if (str == "color dodge") str = "dodge";
        else if (str == "color burn") str = "burn";
        else if (str == "softlight") str = "soft";
        else if (str == "hardlight") str = "hard";
        else if (str == "Math Add") str = "+";
        else if (str == "Math Subtract") str = "-";
        else if (str == "Math Multiply") str = "*";
        else if (str == "Math Divide") str = "/";

        op.setUiAttrib({ "extendTitle": str });
    };
    op.setPortGroup("Blending", [blendPort, amountPort, alphaMaskPort]);

    let maskAlpha = false;

    blendPort.onChange = onChange;
    if (alphaMaskPort)
    {
        alphaMaskPort.onChange = onChange;
        maskAlpha = alphaMaskPort.get() == "On";
    }

    TextureEffect.onChangeBlendSelect(shader, blendPort.get(), maskAlpha);
};


/***/ }),

/***/ 997:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ CONSTANTS),
/* harmony export */   nl: () => (/* binding */ nl)
/* harmony export */ });
const SHADER = {
    // default attributes
    "SHADERVAR_VERTEX_POSITION": "vPosition",
    "SHADERVAR_VERTEX_NUMBER": "attrVertIndex",
    "SHADERVAR_VERTEX_NORMAL": "attrVertNormal",
    "SHADERVAR_VERTEX_TEXCOORD": "attrTexCoord",
    "SHADERVAR_INSTANCE_MMATRIX": "instMat",
    "SHADERVAR_VERTEX_COLOR": "attrVertColor",

    "SHADERVAR_INSTANCE_INDEX": "instanceIndex",

    // default uniforms
    "SHADERVAR_UNI_PROJMAT": "projMatrix",
    "SHADERVAR_UNI_VIEWMAT": "viewMatrix",
    "SHADERVAR_UNI_MODELMAT": "modelMatrix",
    "SHADERVAR_UNI_NORMALMAT": "normalMatrix",
    "SHADERVAR_UNI_INVVIEWMAT": "inverseViewMatrix",
    "SHADERVAR_UNI_INVPROJMAT": "invProjMatrix",
    "SHADERVAR_UNI_MATERIALID": "materialId",
    "SHADERVAR_UNI_OBJECTID": "objectId",

    "SHADERVAR_UNI_VIEWPOS": "camPos",
};

const BLEND_MODES = {
    "BLEND_NONE": 0,
    "BLEND_NORMAL": 1,
    "BLEND_ADD": 2,
    "BLEND_SUB": 3,
    "BLEND_MUL": 4,
};

const RAD2DEG = 180.0 / Math.PI;
const DEG2RAD = Math.PI / 180.0;

const CONSTANTS = {
    "MATH": {
        "DEG2RAD": DEG2RAD,
        "RAD2DEG": RAD2DEG,
    },
    "SHADER": SHADER,
    "BLEND_MODES": BLEND_MODES,
};
const nl = "\n";// newline



/***/ }),

/***/ 772:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  Rq: () => (/* binding */ cgl_CGL)
});

// UNUSED EXPORTS: Framebuffer2, Geometry, Mesh, Shader, Texture, Uniform

// EXTERNAL MODULE: ./src/core/anim.js
var anim = __webpack_require__(344);
// EXTERNAL MODULE: ../shared/client/src/logger.js
var logger = __webpack_require__(849);
// EXTERNAL MODULE: ./src/corelibs/cgl/cgl_texture.js
var cgl_texture = __webpack_require__(70);
;// CONCATENATED MODULE: ./src/corelibs/cgl/cgl_framebuffer2.js




class Framebuffer2
{

    /**
     * @param {CglContext} cgl
     * @param {number} w
     * @param {number} h
     * @param {object} options
     */
    constructor(cgl, w, h, options)
    {
        this._log = new logger/* default */.A("cgl_framebuffer2");
        if (cgl.glVersion == 1) this._log.error("framebuffer2 used on webgl1");
        this.Framebuffer2DrawTargetsDefault = null;
        this.Framebuffer2BlittingFramebuffer = null;
        this.Framebuffer2FinalFramebuffer = null;
        this._cgl = cgl;

        this._cgl.printError("before framebuffer2 constructor");

        this._width = 0;
        this._height = 0;
        this.valid = true;

        this._depthRenderbuffer = null;
        this._frameBuffer = null;
        this._textureFrameBuffer = null;
        this._colorRenderbuffers = [];
        this._drawTargetArray = [];
        this._disposed = false;

        if (!this.Framebuffer2BlittingFramebuffer) this.Framebuffer2BlittingFramebuffer = cgl.gl.createFramebuffer();
        if (!this.Framebuffer2FinalFramebuffer) this.Framebuffer2FinalFramebuffer = cgl.gl.createFramebuffer();

        if (!this.Framebuffer2DrawTargetsDefault) this.Framebuffer2DrawTargetsDefault = [cgl.gl.COLOR_ATTACHMENT0];

        this._options = options || {
            "isFloatingPointTexture": false,
        };

        this.name = this._options.name || "unknown";

        this._cgl.profileData.addHeavyEvent("framebuffer create", this.name);

        if (!this._options.hasOwnProperty("numRenderBuffers")) this._options.numRenderBuffers = 1;
        if (!this._options.hasOwnProperty("depth")) this._options.depth = true;
        if (!this._options.hasOwnProperty("clear")) this._options.clear = true;
        if (!this._options.hasOwnProperty("multisampling"))
        {
            this._options.multisampling = false;
            this._options.multisamplingSamples = 0;
        }

        if (this._options.multisamplingSamples)
        {
            if (this._cgl.glSlowRenderer) this._options.multisamplingSamples = 0;
            if (!this._cgl.gl.MAX_SAMPLES) this._options.multisamplingSamples = 0;
            else this._options.multisamplingSamples = Math.min(this._cgl.maxSamples, this._options.multisamplingSamples);
        }

        if (!this._options.hasOwnProperty("filter")) this._options.filter = cgl_texture/* Texture */.g.FILTER_LINEAR;
        if (!this._options.hasOwnProperty("wrap")) this._options.wrap = cgl_texture/* Texture */.g.WRAP_REPEAT;

        this._numRenderBuffers = this._options.numRenderBuffers;
        this._colorTextures = [];

        this.clearColors = [];
        for (let i = 0; i < this._numRenderBuffers; i++) this.clearColors.push([0, 0, 0, 1]);

        if (!options.pixelFormat)
        {
            if (options.isFloatingPointTexture) this._options.pixelFormat = cgl_texture/* Texture */.g.PFORMATSTR_RGBA32F;
            else this._options.pixelFormat = cgl_texture/* Texture */.g.PFORMATSTR_RGBA8UB;
        }

        for (let i = 0; i < this._numRenderBuffers; i++)
        {
            this._colorTextures[i] = new cgl_texture/* Texture */.g(cgl, {
                "name": "fb2 " + this.name + " " + i,
                "isFloatingPointTexture": this._options.isFloatingPointTexture,
                "anisotropic": this._options.anisotropic || 0,
                "pixelFormat": this._options.pixelFormat,
                "filter": this._options.filter,
                "wrap": this._options.wrap,
            });
        }

        let fil = cgl_texture/* Texture */.g.FILTER_NEAREST;
        if (this._options.shadowMap) fil = cgl_texture/* Texture */.g.FILTER_LINEAR;

        const defaultTexSize = 512;

        if (this._options.depth)
        {
            this._textureDepth = new cgl_texture/* Texture */.g(cgl,
                {
                    "name": "fb2 depth " + this.name,
                    "isDepthTexture": true,
                    "filter": fil,
                    "shadowMap": this._options.shadowMap || false,
                    "width": w || defaultTexSize,
                    "height": h || defaultTexSize,
                });
        }

        if (cgl.aborted) return;

        this.setSize(w || defaultTexSize, h || defaultTexSize);

        this._cgl.printError("framebuffer2 constructor");
    }

    getWidth()
    {
        return this._width;
    }

    getHeight()
    {
        return this._height;
    }

    getGlFrameBuffer()
    {
        return this._frameBuffer;
    }

    getDepthRenderBuffer()
    {
        return this._depthRenderbuffer;
    }

    getTextureColor()
    {
        return this._colorTextures[0];
    }

    getTextureColorNum(i)
    {
        return this._colorTextures[i];
    }

    getTextureDepth()
    {
        return this._textureDepth;
    }

    setFilter(f)
    {
        for (let i = 0; i < this._numRenderBuffers; i++)
        {
            this._colorTextures[i].filter = f;
            this._colorTextures[i].setSize(this._width, this._height);
        }
    }

    delete()
    {
        this.dispose();
    }

    dispose()
    {
        this._disposed = true;
        let i = 0;
        for (i = 0; i < this._numRenderBuffers; i++) this._colorTextures[i].delete();
        // this._texture.delete();
        if (this._textureDepth) this._textureDepth.delete();
        for (i = 0; i < this._numRenderBuffers; i++) this._cgl.gl.deleteRenderbuffer(this._colorRenderbuffers[i]);
        this._cgl.gl.deleteRenderbuffer(this._depthRenderbuffer);
        this._cgl.gl.deleteFramebuffer(this._frameBuffer);
        this._cgl.gl.deleteFramebuffer(this._textureFrameBuffer);
    }

    /**
     * @param {number} w
     * @param {number} h
     */
    setSize(w, h)
    {
        if (this._disposed) return this._log.warn("disposed framebuffer setsize...");
        this._cgl.profileData.addHeavyEvent("framebuffer resize", this.name);

        let i = 0;

        this._width = this._cgl.checkTextureSize(w);
        this._height = this._cgl.checkTextureSize(h);

        this._cgl.profileData.profileFrameBuffercreate++;

        if (this._frameBuffer)
        {
            for (i = 0; i < this._numRenderBuffers; i++) this._cgl.gl.deleteRenderbuffer(this._colorRenderbuffers[i]);
            // this._cgl.gl.deleteRenderbuffer(this._colorRenderbuffer);
            this._cgl.gl.deleteRenderbuffer(this._depthRenderbuffer);
            this._cgl.gl.deleteFramebuffer(this._frameBuffer);
            this._cgl.gl.deleteFramebuffer(this._textureFrameBuffer);
        }

        this._frameBuffer = this._cgl.gl.createFramebuffer();
        this._textureFrameBuffer = this._cgl.gl.createFramebuffer();

        const depth = this._options.depth;

        for (i = 0; i < this._numRenderBuffers; i++)
        {
            this._colorTextures[i].setSize(this._width, this._height);
        }

        for (i = 0; i < this._numRenderBuffers; i++)
        {
            const renderBuffer = this._cgl.gl.createRenderbuffer();

            // color renderbuffer

            this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, this._frameBuffer);
            this._cgl.gl.bindRenderbuffer(this._cgl.gl.RENDERBUFFER, renderBuffer);

            const info = cgl_texture/* Texture */.g.setUpGlPixelFormat(this._cgl, this._options.pixelFormat);
            let internFormat = info.glInternalFormat;

            // if (this._options.isFloatingPointTexture)
            // {
            if (CGL.Texture.isPixelFormatHalfFloat(info.pixelFormat))
            {
                if (!this._cgl.enableExtension("OES_texture_float_linear"))
                {
                    this._options.filter = cgl_texture/* Texture */.g.FILTER_NEAREST;
                    this.setFilter(this._options.filter);
                }
            }
            else if (CGL.Texture.isPixelFormatFloat(info.pixelFormat))
            {
                if (!this._cgl.enableExtension("OES_texture_float_linear"))
                {
                    this._log.warn("no linear pixelformat,using nearest");
                    this._options.filter = cgl_texture/* Texture */.g.FILTER_NEAREST;
                    this.setFilter(this._options.filter);
                }
            }
            // else if (info.pixelFormat == Texture.PFORMATSTR_RGBA32F || info.pixelFormat == Texture.PFORMATSTR_R11FG11FB10F
            // else if (info.pixelFormat == Texture.PFORMATSTR_RGBA32F || info.pixelFormat == Texture.PFORMATSTR_R11FG11FB10F
            // else if (info.pixelFormat == Texture.PFORMATSTR_RG16F)
            // {
            //     const extcb = this._cgl.enableExtension("EXT_color_buffer_float");

            //     if (!this._cgl.enableExtension("OES_texture_float_linear"))
            //     {
            //         console.log("no linear pixelformat,switching to nearest");
            //         this._options.filter = Texture.FILTER_NEAREST;
            //         this.setFilter(this._options.filter);
            //     }
            // }
            // }

            if (this._options.multisampling && this._options.multisamplingSamples)
            {
                this._cgl.gl.renderbufferStorageMultisample(this._cgl.gl.RENDERBUFFER, this._options.multisamplingSamples, internFormat, this._width, this._height);
            }
            else
            {
                this._cgl.gl.renderbufferStorage(this._cgl.gl.RENDERBUFFER, internFormat, this._width, this._height);
            }

            this._cgl.gl.framebufferRenderbuffer(this._cgl.gl.FRAMEBUFFER, this._cgl.gl.COLOR_ATTACHMENT0 + i, this._cgl.gl.RENDERBUFFER, renderBuffer);
            this._colorRenderbuffers[i] = renderBuffer;
        }

        // this._cgl.gl.bindFramebuffer(this._cgl.gl.DRAW_FRAMEBUFFER, this._textureFrameBuffer);
        this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, this._textureFrameBuffer);

        for (i = 0; i < this._numRenderBuffers; i++)
        {
            this._cgl.gl.framebufferTexture2D(this._cgl.gl.FRAMEBUFFER, this._cgl.gl.COLOR_ATTACHMENT0 + i, this._cgl.gl.TEXTURE_2D, this._colorTextures[i].tex, 0);
        }

        if (this._options.depth)
        {
            this._cgl.gl.framebufferTexture2D(this._cgl.gl.FRAMEBUFFER, this._cgl.gl.DEPTH_ATTACHMENT, this._cgl.gl.TEXTURE_2D, this._textureDepth.tex, 0);
        }

        // depth renderbuffer

        this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, this._frameBuffer);

        let depthType = this._cgl.gl.DEPTH_COMPONENT32F;

        if (this._cgl.glSlowRenderer) depthType = this._cgl.gl.DEPTH_COMPONENT16;
        if (depth)
        {
            this._textureDepth.setSize(this._width, this._height);
            this._depthRenderbuffer = this._cgl.gl.createRenderbuffer();

            this._cgl.gl.bindRenderbuffer(this._cgl.gl.RENDERBUFFER, this._depthRenderbuffer);
            if (this._options.isFloatingPointTexture)
            {
                if (this._options.multisampling) this._cgl.gl.renderbufferStorageMultisample(this._cgl.gl.RENDERBUFFER, this._options.multisamplingSamples, depthType, this._width, this._height);
                else this._cgl.gl.renderbufferStorage(this._cgl.gl.RENDERBUFFER, depthType, this._width, this._height);
            }
            else if (this._options.multisampling)
            {
                this._cgl.gl.renderbufferStorageMultisample(this._cgl.gl.RENDERBUFFER, this._options.multisamplingSamples, depthType, this._width, this._height);
            // this._cgl.gl.renderbufferStorage(this._cgl.gl.RENDERBUFFER,depthType, this._width, this._height);
            }
            else
            {
                this._cgl.gl.renderbufferStorage(this._cgl.gl.RENDERBUFFER, depthType, this._width, this._height);
            }

            this._cgl.gl.framebufferRenderbuffer(this._cgl.gl.FRAMEBUFFER, this._cgl.gl.DEPTH_ATTACHMENT, this._cgl.gl.RENDERBUFFER, this._depthRenderbuffer);
        }

        // this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, null);
        // this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, this._textureFrameBuffer);

        this._drawTargetArray.length = 0;
        for (i = 0; i < this._numRenderBuffers; i++) this._drawTargetArray.push(this._cgl.gl.COLOR_ATTACHMENT0 + i);

        // this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, null);

        if (!this._cgl.gl.isFramebuffer(this._textureFrameBuffer)) this._log.warn("invalid framebuffer");// throw new Error("Invalid framebuffer");
        const status = this._cgl.gl.checkFramebufferStatus(this._cgl.gl.FRAMEBUFFER);

        if (status != this._cgl.gl.FRAMEBUFFER_COMPLETE)
        {
            this._log.error("framebuffer incomplete: " + this.name, this);
            this._log.log("options", this._options);
            this._log.log("options pixelformat", this._options.pixelFormat);

            switch (status)
            {
            case this._cgl.gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
                this._log.warn("FRAMEBUFFER_INCOMPLETE_ATTACHMENT...", this);
                throw new Error("Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_ATTACHMENT");
            case this._cgl.gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
                this._log.warn("FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT");
                throw new Error("Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT");
            case this._cgl.gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
                this._log.warn("FRAMEBUFFER_INCOMPLETE_DIMENSIONS");
                throw new Error("Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_DIMENSIONS");
            case this._cgl.gl.FRAMEBUFFER_UNSUPPORTED:
                this._log.warn("FRAMEBUFFER_UNSUPPORTED");
                throw new Error("Incomplete framebuffer: FRAMEBUFFER_UNSUPPORTED");
            default:
                this.valid = false;
                this._log.error("incomplete framebuffer", status, this._frameBuffer);
                this._cgl.printError();

                this._frameBuffer = null;
                // debugger;
                throw new Error("Incomplete framebuffer: " + status);

        // throw("Incomplete framebuffer: " + status);
            }
        }

        this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, null);
        this._cgl.gl.bindRenderbuffer(this._cgl.gl.RENDERBUFFER, null);

    // this._cgl.printError("fb setsize");
    }

    renderStart()
    {
        if (this._disposed) return this._log.warn("disposed framebuffer renderStart...");
        this._cgl.checkFrameStarted("fb2 renderstart");
        this._cgl.pushModelMatrix(); // needed ??

        this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, this._frameBuffer);
        this._cgl.pushGlFrameBuffer(this._frameBuffer);
        this._cgl.pushFrameBuffer(this);

        this._cgl.pushPMatrix();
        this._cgl.pushViewPort(0, 0, this._width, this._height);

        this._cgl.gl.drawBuffers(this._drawTargetArray);

        if (this._options.clear)
        {
            this._cgl.gl.clearColor(0, 0, 0, 0);
            this._cgl.gl.clear(this._cgl.gl.COLOR_BUFFER_BIT | this._cgl.gl.DEPTH_BUFFER_BIT);
        }
    }

    clear()
    {
        if (this._numRenderBuffers <= 1)
        {
            this._cgl.gl.bindFramebuffer(this._cgl.gl.READ_FRAMEBUFFER, this._frameBuffer);
            this._cgl.gl.bindFramebuffer(this._cgl.gl.DRAW_FRAMEBUFFER, this._textureFrameBuffer);
        }
        else this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, this._frameBuffer);

        this._cgl.gl.drawBuffers(this._drawTargetArray);

        for (let i = 0; i < this._numRenderBuffers; i++)
        {
            this._cgl.gl.framebufferTexture2D(this._cgl.gl.FRAMEBUFFER, this._cgl.gl.COLOR_ATTACHMENT0 + i, this._cgl.gl.TEXTURE_2D, this._colorTextures[i].tex, 0);
            this._cgl.gl.clearBufferfv(this._cgl.gl.COLOR, i, this.clearColors[i]);
        }
        this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, null);
    }

    renderEnd()
    {
        if (this._disposed) return this._log.warn("disposed framebuffer renderEnd...");
        this._cgl.popPMatrix();

        this._cgl.profileData.profileFramebuffer++;

        if (this._numRenderBuffers <= 1)
        {
            this._cgl.gl.bindFramebuffer(this._cgl.gl.READ_FRAMEBUFFER, this._frameBuffer);
            this._cgl.gl.bindFramebuffer(this._cgl.gl.DRAW_FRAMEBUFFER, this._textureFrameBuffer);

            this._cgl.gl.clearBufferfv(this._cgl.gl.COLOR, 0, [0.0, 0.0, 0.0, 1.0]);
            this._cgl.gl.blitFramebuffer(0, 0, this._width, this._height, 0, 0, this._width, this._height, this._cgl.gl.COLOR_BUFFER_BIT | this._cgl.gl.DEPTH_BUFFER_BIT, this._cgl.gl.NEAREST);
        }
        else
        {
            this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, this.Framebuffer2BlittingFramebuffer);
            this._cgl.gl.framebufferRenderbuffer(this._cgl.gl.FRAMEBUFFER, this._cgl.gl.DEPTH_ATTACHMENT, this._cgl.gl.RENDERBUFFER, this._depthRenderbuffer);

            this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, this.Framebuffer2FinalFramebuffer);
            this._cgl.gl.framebufferTexture2D(this._cgl.gl.FRAMEBUFFER, this._cgl.gl.DEPTH_ATTACHMENT, this._cgl.gl.TEXTURE_2D, this._textureDepth.tex, 0);

            for (let i = 0; i < this._numRenderBuffers; i++)
            {
                this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, this.Framebuffer2BlittingFramebuffer);
                this._cgl.gl.framebufferRenderbuffer(this._cgl.gl.FRAMEBUFFER, this._cgl.gl.COLOR_ATTACHMENT0, this._cgl.gl.RENDERBUFFER, this._colorRenderbuffers[i]);

                this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, this.Framebuffer2FinalFramebuffer);
                this._cgl.gl.framebufferTexture2D(this._cgl.gl.FRAMEBUFFER, this._cgl.gl.COLOR_ATTACHMENT0, this._cgl.gl.TEXTURE_2D, this._colorTextures[i].tex, 0);

                this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, null);

                this._cgl.gl.bindFramebuffer(this._cgl.gl.READ_FRAMEBUFFER, this.Framebuffer2BlittingFramebuffer);
                this._cgl.gl.bindFramebuffer(this._cgl.gl.DRAW_FRAMEBUFFER, this.Framebuffer2FinalFramebuffer);

                // this._cgl.gl.clearBufferfv(this._cgl.gl.COLOR, i, [0.0, 0.0, 0.0, 1.0]);

                let flags = this._cgl.gl.COLOR_BUFFER_BIT;
                if (i == 0) flags |= this._cgl.gl.DEPTH_BUFFER_BIT;

                this._cgl.gl.blitFramebuffer(0, 0, this._width, this._height, 0, 0, this._width, this._height, flags, this._cgl.gl.NEAREST);
            }
        }

        this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, this._cgl.popGlFrameBuffer());
        this._cgl.popFrameBuffer();

        this._cgl.popModelMatrix();
        this._cgl.popViewPort();

        if (this._colorTextures[0].filter == cgl_texture/* Texture */.g.FILTER_MIPMAP)
        {
            for (let i = 0; i < this._numRenderBuffers; i++)
            {
                this._cgl.gl.bindTexture(this._cgl.gl.TEXTURE_2D, this._colorTextures[i].tex);
                this._colorTextures[i].updateMipMap();
                this._cgl.gl.bindTexture(this._cgl.gl.TEXTURE_2D, null);
            }
        }
    }
}

;// CONCATENATED MODULE: ./src/corelibs/cgl/cgl_marker.js
/** @type {function}
 * @deprecated
*/
const Marker = function (_cgl) // deprecated...
{
    this.draw = function (cgl, _size, depthTest) {};
};

/** @type {function}
 * @deprecated
*/
const WirePoint = function (cgl) // deprecated...
{
    this.render = function (_cgl, _size) {};
};

/** @type {function}
 * @deprecated
*/
const WireCube = function (cgl) // deprecated...
{
    this.render = function (_cgl, sizeX, sizeY, sizeZ) {};
};

// EXTERNAL MODULE: ./src/corelibs/cgl/cgl_mesh.js
var cgl_mesh = __webpack_require__(264);
// EXTERNAL MODULE: ./src/corelibs/cgl/cgl_shader_uniform.js
var cgl_shader_uniform = __webpack_require__(923);
// EXTERNAL MODULE: ./src/corelibs/cgl/cgl_shader_lib.js
var cgl_shader_lib = __webpack_require__(960);
;// CONCATENATED MODULE: ./src/corelibs/cgl/cgl_unicolorshader.js


class UniColorShader
{
    constructor(_cgl)
    {
        this.shader = new CGL.Shader(_cgl, "markermaterial");

        const frag = ""
            .endl() + "void main()"
            .endl() + "{"
            .endl() + "    outColor = vec4(color.rgb,1.0);"
            .endl() + "}";

        const vert = ""
            .endl() + "IN vec3 vPosition;"
            .endl() + "UNI mat4 projMatrix;"
            .endl() + "UNI mat4 mvMatrix;"

            .endl() + "void main()"
            .endl() + "{"
            .endl() + "   gl_Position = projMatrix * mvMatrix * vec4(vPosition,1.0);"
            .endl() + "}";

        this.shader.setSource(vert, frag);
        this.coloruni = this.shader.addUniformFrag("4f", "color", [1, 0.777, 1, 1]);
    }

    setColor(r, g, b, a)
    {
        this.coloruni.set(r, g, b, a);
    }
}

// EXTERNAL MODULE: ./src/corelibs/cgl/cgl_shader.js
var cgl_shader = __webpack_require__(24);
// EXTERNAL MODULE: ./src/corelibs/cgl/cgl_simplerect.js
var cgl_simplerect = __webpack_require__(273);
;// CONCATENATED MODULE: ./src/corelibs/cgl/cgl_utils.js
/**
 * @namespace CGL
 */

/**
 * multiply to get radians from degree, e.g. `360 * CGL.DEG2RAD`
 * @const {Number}
 * @memberof CGL
 * @static
 */
const DEG2RAD = Math.PI / 180.0;

/**
 * to get degrees from radians, e.g. `3.14 * CGL.RAD2DEG`
 * @const {number}
 * @memberof CGL
 */
const RAD2DEG = 180.0 / Math.PI;

const onLoadingAssetsFinished = null; // deprecated / remove later

/**
 * get normalized mouse wheel delta (including browser specific adjustment)
 * @function getWheelDelta
 * @static
 * @memberof CGL
 * @param {MouseEvent} event
 * @return {Number} normalized delta
 */
const isWindows = window.navigator.userAgent.includes("Windows");
const getWheelDelta_ = function (event)
{
    let normalized;
    if (event.wheelDelta)
    {
        // chrome
        normalized = (event.wheelDelta % 120) - 0 == -0 ? event.wheelDelta / 120 : event.wheelDelta / 30;
        normalized *= -1.5;
        if (isWindows) normalized *= 2;
    }
    else
    {
        // firefox
        let d = event.deltaY;
        if (event.shiftKey) d = event.deltaX;
        const rawAmmount = d || event.detail;
        normalized = -(rawAmmount % 3 ? rawAmmount * 10 : rawAmmount / 3);
        normalized *= -3;
    }

    if (normalized > 20) normalized = 20;
    if (normalized < -20) normalized = -20;

    return normalized;
};

const getWheelSpeed = getWheelDelta_;
const getWheelDelta = getWheelDelta_;

// EXTERNAL MODULE: ./src/corelibs/cgl/cgl_textureeffect.js
var cgl_textureeffect = __webpack_require__(771);
// EXTERNAL MODULE: ./src/corelibs/cgl/constants.js
var constants = __webpack_require__(997);
// EXTERNAL MODULE: ./src/corelibs/cgl/cgl_profiledata.js
var cgl_profiledata = __webpack_require__(460);
// EXTERNAL MODULE: ./src/corelibs/cg/cg_geom.js
var cg_geom = __webpack_require__(331);
// EXTERNAL MODULE: ./src/corelibs/cg/cg_boundingbox.js
var cg_boundingbox = __webpack_require__(982);
// EXTERNAL MODULE: ./src/corelibs/cg/cg_matrixstack.js
var cg_matrixstack = __webpack_require__(868);
// EXTERNAL MODULE: ./src/corelibs/cgl/cgl_state.js
var cgl_state = __webpack_require__(308);
;// CONCATENATED MODULE: ./src/corelibs/cgl/index.js

















const cgl_CGL = {
    "Framebuffer2": Framebuffer2,
    "Geometry": cg_geom/* Geometry */.V,
    "BoundingBox": cg_boundingbox/* BoundingBox */.I,
    "Marker": Marker,
    "WirePoint": WirePoint,
    "WireCube": WireCube,
    "MatrixStack": cg_matrixstack/* MatrixStack */.u,
    "Mesh": cgl_mesh/* Mesh */.e,
    "MESH": cgl_mesh/* MESH */.C,
    "ShaderLibMods": cgl_shader_lib/* ShaderLibMods */.y,
    "Shader": cgl_shader/* Shader */.M,
    "Uniform": cgl_shader_uniform/* Uniform */.n,
    "MESHES": cgl_simplerect/* MESHES */.S,
    "getWheelSpeed": getWheelSpeed,
    "getWheelDelta": getWheelDelta,
    "Context": cgl_state/* CglContext */.G,
    "Texture": cgl_texture/* Texture */.g,
    "TextureEffect": cgl_textureeffect/* TextureEffect */.p,
    "onLoadingAssetsFinished": onLoadingAssetsFinished,
    "ProfileData": cgl_profiledata/* ProfileData */.E,
    "UniColorShader": UniColorShader,
    ...constants/* CONSTANTS */.a.BLEND_MODES,
    ...constants/* CONSTANTS */.a.SHADER,
    ...constants/* CONSTANTS */.a.MATH,
    ...constants/* CONSTANTS */.a.BLEND_MODES,
};

window.CABLES = window.CABLES || {};
window.CABLES.CGL = window.CABLES.CGL || cgl_CGL;
window.CGL = window.CGL || cgl_CGL;

/**
 * @param {number} time
 * @param {quat} q
 * @param {Anim} animx
 * @param {Anim} animy
 * @param {Anim} animz
 * @param {Anim} animw
 */
anim/* Anim */.k.slerpQuaternion = function (time, q, animx, animy, animz, animw)
{
    if (!anim/* Anim */.k.slerpQuaternion.q1)
    {
        anim/* Anim */.k.slerpQuaternion.q1 = quat.create();
        anim/* Anim */.k.slerpQuaternion.q2 = quat.create();
    }

    const i1 = animx.getKeyIndex(time);
    let i2 = i1 + 1;
    if (i2 >= animx.keys.length) i2 = animx.keys.length - 1;

    if (i1 == i2)
    {
        quat.set(q, animx.keys[i1].value, animy.keys[i1].value, animz.keys[i1].value, animw.keys[i1].value);
    }
    else
    {
        const key1Time = animx.keys[i1].time;
        const key2Time = animx.keys[i2].time;
        const perc = (time - key1Time) / (key2Time - key1Time);

        quat.set(anim/* Anim */.k.slerpQuaternion.q1, animx.keys[i1].value, animy.keys[i1].value, animz.keys[i1].value, animw.keys[i1].value);

        quat.set(anim/* Anim */.k.slerpQuaternion.q2, animx.keys[i2].value, animy.keys[i2].value, animz.keys[i2].value, animw.keys[i2].value);

        quat.slerp(q, anim/* Anim */.k.slerpQuaternion.q1, anim/* Anim */.k.slerpQuaternion.q2, perc);
    }
    return q;
};




/***/ }),

/***/ 626:
/***/ ((__unused_webpack___webpack_module__, __unused_webpack___webpack_exports__, __webpack_require__) => {

"use strict";

// UNUSED EXPORTS: CGP

// EXTERNAL MODULE: ../shared/client/src/logger.js
var logger = __webpack_require__(849);
// EXTERNAL MODULE: ./src/corelibs/cg/cg_context.js
var cg_context = __webpack_require__(628);
// EXTERNAL MODULE: ./src/corelibs/cg/cg_texture.js
var cg_texture = __webpack_require__(356);
// EXTERNAL MODULE: ./node_modules/gl-matrix/esm/mat4.js
var mat4 = __webpack_require__(684);
// EXTERNAL MODULE: ./src/core/timer.js
var timer = __webpack_require__(920);
// EXTERNAL MODULE: ./src/corelibs/cg/cg_uniform.js
var cg_uniform = __webpack_require__(475);
;// CONCATENATED MODULE: ./src/corelibs/cgp/cgp_uniform.js




class CgpUniform extends cg_uniform/* CgUniform */.v
{

    /** @type {CgpContext} */
    #cgp = null;

    /** @type {GPUBuffer} */
    gpuBuffer = null;

    gpuBufferChanged = false;

    /**
     * Description
     * @param {CgpShader} __shader
     * @param {string} __type
     * @param {string} __name
     * @param {any} _value
     * @param {any} _port2
     * @param {any} _port3
     * @param {any} _port4
     */
    constructor(__shader, __type, __name, _value, _port2, _port3, _port4)
    {
        super(__shader, __type, __name, _value, _port2, _port3, _port4);
        this.#cgp = __shader._cgp;

        if (!_value || (_value.get && !_value.get()))
        {
            // if (this.getType() == "m4") this._value = mat4.create();
            if (this.getType() == "t")
            {
                this._value = this.#cgp.getEmptyTexture();
            }
            // else if (this.getType() == "2f") this._value = [0, 0];
            // else if (this.getType() == "4f") this._value = [0, 1, 0, 1];
            // else if (this.getType() == "3f") this._value = [0, 1, 0];
        }

    }

    getInfo()
    {
        return { "name": this.name, "type": this.type, "value": this.getValue() };
    }

    updateValueF() { }

    updateValueArrayF() {}

    setValueArrayF(v)
    {
        this.needsUpdate = true;
        this._value = v;
    }

    setValueF(v)
    {
        this.needsUpdate = true;
        this._value = v;
    }

    updateValue2F() { }

    setValue2F(v)
    {
        this.needsUpdate = true;
        this._value = v;
    }

    updateValue3F() { }

    setValue3F(v)
    {
        this.needsUpdate = true;
        this._value = v;
    }

    updateValue4F() { }

    setValue4F(v)
    {
        if (v[0] == undefined)
        {
            this._log.stack("uniform value undefined");
            console.error("uniform value undefined");
        }
        this.needsUpdate = true;
        this._value = v;
    }

    setValueT(v)
    {
        // if (this._value != v)
        //     this._shader.needsPipelineUpdate = "texture changed"; // todo really needed ? change binding instead?

        this.needsUpdate = true;
        this._value = v;
    }

    updateValueM4(v) {}

    setValueM4(v)
    {
        this.needsUpdate = true;
        this._value = v;
    }

    setValueAny(v)
    {
        this.needsUpdate = true;
        this._value = v;
    }

    updateValueAny() {}

    updateValueT() {}

    /**
     * @param {GPUBuffer} b
     */
    setGpuBuffer(b)
    {
        this.gpuBufferChanged = true;
        this.gpuBuffer = b;
    }

    copyToBuffer(buff, pos = 0)
    {
        if (this._type == "f")
        {
            buff[pos] = this._value;
        }
        else if (this._type == "t")
        {
        }
        else if (this._type == "4f")
        {
            buff[pos] = this._value[0];
            buff[pos + 1] = this._value[1];
            buff[pos + 2] = this._value[2];
            buff[pos + 3] = this._value[3];
        }
        else if (this._type == "2f")
        {
            buff[pos] = this._value[0];
            buff[pos + 1] = this._value[1];
        }
        else if (this._type == "3f")
        {
            buff[pos] = this._value[0];
            buff[pos + 1] = this._value[1];
            buff[pos + 2] = this._value[2];
        }
        else if (this._type == "f[]")
        {
            for (let i = 0; i < this._value.length; i++)
                buff[pos + i] = this._value[i];
        }
        else if (this._type == "m4")
        {
            for (let i = 0; i < 16; i++)
                buff[pos + i] = this._value[i];
        }
        else
        {
            this._log.warn("uniform copy to buffer unknown", this._type);
        }
    }

    getWgslTypeStr()
    {
        if (this._type == "m4") return "mat4x4f";
        if (this._type == "4f") return "vec4f";
        if (this._type == "3f") return "vec3f";
        if (this._type == "2f") return "vec2f";
        if (this._type == "f") return "f32";
        if (this._type == "f[]") return "array<vec4f>";
        if (this._type == "i") return "int";
        if (this._type == "sampler") return "sampler";
        if (this._type == "t") return "texture_2d<f32>";
        this._log.warn("unknown type getWgslTypeStr", this._type);
        return "???";
    }

    getSizeBytes()
    {
        const bytesPerFloat = 4;
        const bytesPerInt = 4;
        if (this._type == "t") return 4;
        if (this._type == "sampler") return 4;
        if (this._type == "f") return 1 * bytesPerFloat;
        if (this._type == "2f") return 2 * bytesPerFloat;
        if (this._type == "3f") return 3 * bytesPerFloat;
        if (this._type == "4f") return 4 * bytesPerFloat;
        if (this._type == "f[]") return this._value.length * bytesPerFloat;
        if (this._type == "m4") return 4 * 4 * bytesPerFloat;
        if (this._type == "i") return 1 * bytesPerInt;
        if (this._type == "2i") return 2 * bytesPerInt;

        this._log.warn("unknown type getSizeBytes", this._type);
        return 4;
    }

    /**
     * @param {CgpShader} shader
     */
    copy(shader)
    {
        const uni = new CgpUniform(shader, this._type, this._name, this._value, this._port2, this._port3, this._port4);
        uni.shaderType = this.shaderType;

        // console.log(this._name, this._value, uni._value);

        return uni;
    }

}

;// CONCATENATED MODULE: ./src/corelibs/cg/preproc.js
/**
 * @param {string} str
 * @param {object} vars
 */
function preproc(str, vars)
{
    if (!str)
    {
        console.warn("shader preproc no shader code given");
    }
    str = str || "";
    const lines = str.split("\n");
    const outLines = [];
    let stack = [];

    for (let i = 0; i < lines.length; i++)
    {
        let line = lines[i].trim();
        let parts = line.split(" ");

        if (line.startsWith("#ifdef "))
        {
            const s = vars[parts[1]];
            stack.push({ "state": s });
            continue;
        }
        if (line.startsWith("#ifndef "))
        {
            const s = vars[parts[1]];
            stack.push({ "state": !s });
            continue;
        }
        if (line.startsWith("#endif"))
        {
            stack.pop();
            continue;
        }
        const state = stack[stack.length - 1];

        if (line.startsWith("#else"))
        {
            state.state = !state.state;
            continue;
        }

        if (!state || state.state)
        {
            outLines.push(lines[i]);
        }
    }

    return outLines.join("\n");
}

// EXTERNAL MODULE: ./src/corelibs/cg/cg_shader.js
var cg_shader = __webpack_require__(694);
;// CONCATENATED MODULE: ./src/corelibs/cgp/binding/bindgroup.js




class BindGroup
{

    /** @type {Array<GPUBindGroup>} */
    #gpuBindGroups = [];

    /** @type {Array<Binding>} */
    #bindings = [];

    name = "";

    needsPipelineUpdate = false;

    bla = 1;

    /** @type {CgpContext} */
    #cgp;

    /**
     * @param {CgpContext} cgp
     * @param {string} name
     */
    constructor(cgp, name)
    {
        this.#cgp = cgp;
        this.name = name;
    }

    /**
     * @returns {GPUBindGroup}
     */
    // get gpuBindgroup()
    // {
    //     if (!this.#gpuBindGroup)
    //     {
    //         this.create();
    //     }
    //     // console.log(this.#gpuBindGroup);
    //     return this.#gpuBindGroup;
    // }

    /**
     * @param {Binding} b
     * @returns {boolean}
     */
    hasBinding(b)
    {
        return this.#bindings.includes(b);
    }

    /**
     * @param {string} n
     * @returns {Binding}
     */
    getBindingByName(n)
    {

        for (let i = 0; i < this.#bindings.length; i++)
        {
            if (this.#bindings[i].name == n) return this.#bindings[i];
        }
    }

    /**
     * @param {Binding} b
     */
    removeBinding(b)
    {
        const idx = this.#bindings.indexOf(b);
        this.#bindings.splice(idx, 1);
    }

    /**
     * @param {Binding} b
     * @returns {Binding}
     */
    addBinding(b)
    {
        const oldBinding = this.getBindingByName(b.name);
        if (oldBinding) this.removeBinding(oldBinding);
        b.needsRebuildBindgroup = true;
        b.bindNum = this.#bindings.length;
        this.#bindings.push(b);

        return b;
    }

    // /**
    //  * @param {CgpShader} shader
    //  */
    // bind(shader)
    // {
    //     shader.setBindgroup(this);
    // }

    /**
     * @param {CgpShader} [shader]
     */
    getLayoutEntries(shader)
    {
        const arr = [];
        for (let i = 0; i < this.#bindings.length; i++)
        {
            arr.push(this.#bindings[i].getLayoutEntry(shader));
        }

        if (arr.length == 0)
        {
            // console.log("nooooooooooooooooooooooo");
        }
        return arr;
    }

    /**
     * @returns {Array<GPUBindGroupEntry>}
     * @param {number} inst
     */
    getEntries(inst)
    {
        const arr = [];
        for (let i = 0; i < this.#bindings.length; i++)
        {
            arr.push(this.#bindings[i].getBindgroupEntry(inst));
        }

        if (arr.length == 0)
        {
            // console.log("nooooooooooooooooooooooo");
        }
        return arr;
    }

    /**
     * @param {CgpShader} [shader]
     */
    getLayout(shader)
    {
        // console.log(this.getLayoutEntries(shader));

        /** @type {GPUBindGroupLayout} */
        const bindGroupLayout = this.#cgp.device.createBindGroupLayout(
            {
                "label": "bindgrouplayout " + this.name,
                "entries": this.getLayoutEntries(shader),
            });

        return bindGroupLayout;
    }

    /**
     * @param {number} inst
     */
    create(inst)
    {

        /** @type {GPUBindGroupDescriptor} */
        const bg = {
            "label": " " + this.name + " i" + inst,
            "layout": this.getLayout(),
            "entries": this.getEntries(inst)
        };

        this.#cgp.profileData.count("bindgroup created", this.name);

        // if (bindingGroupEntries.length != this.bindingGroupLayoutEntries.length)
        // {
        //     this.#log.error("bindingGroupEntries.length!= this.bindingGroupLayoutEntries.length", bindingGroupEntries.length, this.bindingGroupLayoutEntries.length);
        //     this.#rebuildNumBindingGroups = true;
        //     this.#isValid = false;
        //     return;
        // }

        try
        {
            this.#gpuBindGroups[inst] = this.#cgp.device.createBindGroup(bg);
            this.needsRebuildBindgroup = true;

        }
        catch (e)
        {
            console.log(bg);
            console.error(e);
        }

        this.updateValues(inst);
    }

    /**
     * @param {number} inst
     */
    updateValues(inst)
    {
        for (let i = 0; i < this.#bindings.length; i++)
        {
            this.#bindings[i].updateValues(inst);
        }
    }

    /**
     * @param {number} inst
     * @param {GPURenderPassEncoder|GPUComputePassEncoder} passEnc
     */
    bind(inst = 0, passEnc = null, idx = 0)
    {
        for (let i = 0; i < this.#bindings.length; i++)
            if (this.#bindings[i].needsRebuildBindgroup)
            {
                // console.log("rebuild bg");
                this.create(inst);
                this.#bindings[i].needsRebuildBindgroup = false;
                this.#gpuBindGroups = [];
                // todo: dispose
            }

        if (!this.#gpuBindGroups[inst]) this.create(inst);
        (passEnc || this.#cgp.passEncoder).setBindGroup(idx, this.#gpuBindGroups[inst]);
    }

    /**
     * @param {CgpShader} shader
     * @param {number} idx
     */
    getShaderHeaderCode(shader, idx)
    {
        const srcs = { "vertex": "", "fragment": "", "compute": "" };

        this.#cgp.profileData.count("bindgroup shadercode", this.name);
        for (let i = 0; i < this.#bindings.length; i++)
        {
            const bind = this.#bindings[i];
            let src = "";
            src += bind.getShaderHeaderCode(shader, idx);
            if (bind.stage & GPUShaderStage.VERTEX)srcs.vertex += src;
            else if (bind.stage === GPUShaderStage.FRAGMENT)srcs.fragment += src;
            else if (bind.stage & GPUShaderStage.COMPUTE)srcs.compute += src;
        }

        return srcs;
    }

    /**
     * @param {CgpShader} shader
     */
    copy(shader)
    {
        const newBg = new BindGroup(this.#cgp, this.name);
        for (let i = 0; i < this.#bindings.length; i++)
        {
            newBg.addBinding(this.#bindings[i].copy(shader));
        }
        return newBg;
    }

    setBindingNums()
    {

        for (let i = 0; i < this.#bindings.length; i++)
        {
            this.#bindings[i].setBindNum(i);
        }
    }

    getInfo()
    {
        const o = { "name": this.name, "bindings": [] };
        for (let i = 0; i < this.#bindings.length; i++)
        {
            o.bindings.push(this.#bindings[i].getInfo());
        }
        return o;
    }
}

// EXTERNAL MODULE: ./src/core/utils.js + 1 modules
var utils = __webpack_require__(562);
// EXTERNAL MODULE: ./src/corelibs/cgl/constants.js
var constants = __webpack_require__(997);
;// CONCATENATED MODULE: ./src/corelibs/cgp/binding/binding.js






class Binding
{
    id = utils.simpleId();
    name = "";
    bindNum = 0;
    stage = GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT;
    define = "";
    log = new logger/* default */.A("binding");
    needsRebuildBindgroup = false;

    /** @type {CgpContext} */
    cgp = null;

    /**
     * Description
     * @param {CgpContext} cgp
     * @param {string} name
     * @param {object} options
     */
    constructor(cgp, name, options)
    {
        this.cgp = cgp;
        this.name = name;
        if (!name) this.log.error("no binding name given");
        this.options = options || {};
        if (options.hasOwnProperty("stage")) this.stage = options.stage;
    }

    /**
     * @param {number} _inst
     */
    getResource(_inst)
    {
        // overwrite
        return null;
    }

    /**
     * @param {number} i
     */
    setBindNum(i)
    {
        if (this.bindNum != i) this.needsRebuildBindgroup = true;
        this.bindNum = i;
    }

    /**
     * @returns {GPUBindGroupLayoutEntry}
     * @param {CgpShader} _shader
     */
    getLayoutEntry(_shader)
    {
        this.log.warn("unknown binding type?", this);
        return null;
    }

    /**
     * @returns {GPUBindGroupEntry}
     * @param {number} inst
     */
    getBindgroupEntry(inst)
    {
        let label = "layout " + this.name + " [" + this.constructor.name;
        label += "]";

        return {
            "binding": this.bindNum,
            "resource": this.getResource(inst)
        };
    }

    /** @param {CgpShader} _shader */
    isActiveByDefine(_shader)
    {
        if (!this.define) return true;
        // if (this.define && !shader.hasDefine(this.define)) return false;
        return true;
    }

    /** @param {number} _inst */
    updateValues(_inst)
    {
        // overwrite
    }

    /**
     * @param {CgpShader} _shader
     * @param {number} _bindGroupNum
     * @returns {String}
     */
    getShaderHeaderCode(_shader, _bindGroupNum)
    {
        return "//getShaderHeaderCode function not emplemented " + constants.nl;
    }

    /**
     * @param {CgpShader} _shader
     * @returns {Binding}
     */
    copy(_shader)
    {
        // implenented in inheriting classes
        return null;
    }

    getInfo()
    {
        const o = { "name": this.name, "id": this.id, "class": this.constructor.name };
        return o;
    }
}

// EXTERNAL MODULE: ../shared/client/src/eventtarget.js + 2 modules
var eventtarget = __webpack_require__(125);
;// CONCATENATED MODULE: ./src/corelibs/cgp/cgp_gpubuffer.js




/** @typedef GPUBufferOptions
 * @property {number} [length]
 * @property {GPUBufferDescriptor} [buffCfg]
*/

class CgpGguBuffer extends eventtarget/* default */.A
{
    #name = "unknown";

    /** @type {CgpContext} */
    #cgp = null;

    /** @type {GPUBuffer} */
    #gpuBuffer = null;

    /** @type {GPUBufferDescriptor} */
    buffCfg = null;

    #length = 0;
    id = utils.shortId();
    floatArr = null;
    needsUpdate = true;
    #log;

    // static BINDINGTYPE_STORAGE = "storage";
    // static BINDINGTYPE_UNIFORM = "uniform";
    // static BINDINGTYPE_READONLY_STORAGE = "read-only-storage";

    /**
     * Description
     * @param {CgpContext} cgp
     * @param {String} name
     * @param {Array} data=null
     * @param {GPUBufferOptions} options={}
     */
    constructor(cgp, name, data = null, options = {})
    {
        super();
        this.#log = new logger/* default */.A("cgpGpubuffer");
        if (!cgp.supported) return;

        this.#name = name;
        // this.setData([0, 0, 0, 0]);

        this.buffCfg = options.buffCfg || {};
        if (data) this.setData(data);
        if (options.length) this.setLength(options.length);

        this.buffCfg.usage = this.buffCfg.usage || (GPUBufferUsage.COPY_DST | GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC);
        this.updateGpuBuffer(cgp);
    }

    /**
     * @param {Array} arr
     */
    setData(arr)
    {
        this.floatArr = new Float32Array(arr);
        this.setLength(this.floatArr.length);

        this.needsUpdate = true;
    }

    /**
     * @param {number} s
     */
    setLength(s)
    {
        this.#length = s;
        if (!this.floatArr || s != this.floatArr.length)
        {
            this.floatArr = new Float32Array(this.#length);
            this.needsUpdate = true;
        }
    }

    /**
     * @param {number} flag
     */
    hasUsage(flag)
    {
        return (this.buffCfg.usage & flag) === flag;
    }

    /** @param {CgpContext} cgp */
    updateGpuBuffer(cgp = null)
    {
        if (cgp) this.#cgp = cgp;
        if (!this.#cgp || !this.#cgp.device)
        {
            this.#log.warn("no cgp...", this.#name, this.#cgp);
            return;
        }

        this.#cgp.pushErrorScope("updateGpuBuffer");
        if (!this.#gpuBuffer || this.buffCfg.mappedAtCreation)
        {
            this.buffCfg = /** @type {GPUBufferDescriptor} */(this.buffCfg || {});
            this.buffCfg.label = "gpuBuffer-" + this.#name;
            if (!this.buffCfg.hasOwnProperty("size") && this.floatArr) this.buffCfg.size = this.floatArr.length * 4;

            this.#gpuBuffer = this.#cgp.device.createBuffer(this.buffCfg);
        }

        if (this.floatArr)
        {
            if (this.buffCfg.mappedAtCreation)
            {
                new Float32Array(this.#gpuBuffer.getMappedRange()).set(this.floatArr);
                this.#gpuBuffer.unmap();

            }
            else

                this.#cgp.device.queue.writeBuffer(
                    this.#gpuBuffer,
                    0,
                    this.floatArr.buffer,
                    this.floatArr.byteOffset,
                    this.floatArr.byteLength
                );
        }

        this.#cgp.popErrorScope();

        this.needsUpdate = false;
    }

    get name()
    {
        return this.#name;
    }

    /** @returns {GPUBuffer} */
    get gpuBuffer()
    {
        if (!this.#gpuBuffer || this.needsUpdate) this.updateGpuBuffer();

        return this.#gpuBuffer;
    }

    get length()
    {
        return this.#length;
    }

    getSizeBytes()
    {
        return this.floatArr.length * 4;
    }

    dispose()
    {
        // setTimeout(() =>
        // {
        //     if (this._gpuBuffer) this._gpuBuffer.destroy();
        // }, 100);
    }
}

;// CONCATENATED MODULE: ./src/corelibs/cgp/binding/binding_uniform.js






/** @extends Binding */
class BindingUniform extends Binding
{

    /** @type {Array<CgpUniform>} */
    #uniforms = [];

    /** @type {Array<CgpGguBuffer>} */
    cgpBuffer = [];

    /**
     * Description
     * @param {CgpContext} cgp
     * @param {string} name
     * @param {object} options
     */
    constructor(cgp, name, options)
    {
        super(cgp, name, options);

        console.log("new binding uniform", this.id);
    }

    /**
     * @param {CgpShader} shader
     * @returns {Binding}
     */
    copy(shader)
    {
        const b = new BindingUniform(this.cgp, this.name, this.options);
        console.log("copybinuni", this.id, b.id);
        b.stage = this.stage;

        for (let i = 0; i < this.#uniforms.length; i++)
        {
            let foundWorldUni = false;
            for (let j = 0; j < shader.worldUniforms.length; j++)
            {
                if (shader.worldUniforms[j].getName() == this.#uniforms[i].getName())
                {
                    b.addUniform(shader.worldUniforms[j]);
                    foundWorldUni = true;
                }
            }
            if (!foundWorldUni) b.addUniform(this.#uniforms[i]);
        }

        return b;
    }

    /**
     * @param {CgpUniform} u
     */
    addUniform(u)
    {
        this.#uniforms.push(u);
        this.needsRebuildBindgroup = true;
        console.log(this.#uniforms, this);
        return u;
    }

    /**
     * @returns {GPUBindingResource}
     * @param {number} inst
     */
    getResource(inst)
    {
        this.updateBuffer(inst);
        return {
            "buffer": this.cgpBuffer[inst].gpuBuffer,
        };
    }

    getSizeBytes()
    {
        let size = 0;
        for (let i = 0; i < this.#uniforms.length; i++)
            size += this.#uniforms[i].getSizeBytes();

        return size;
    }

    /**
     * @param {string} name
     */
    getUniform(name)
    {
        for (let i = 0; i < this.#uniforms.length; i++)
        {
            if (this.#uniforms[i].name == name) return this.#uniforms[i];
        }
        return null;
    }

    /**
     * @param {string} name
     */
    removeUniformByName(name)
    {
        for (let i = 0; i < this.#uniforms.length; i++)
            if (this.#uniforms[i].name == name)
            {
                this.needsRebuildBindgroup = true;
                return this.#uniforms.splice(i, 1);
            }
    }

    /**
     * @param {number} inst
     */
    createBuffer(inst)
    {
        let buffCfg = {
            "label": this.name,
            "size": this.getSizeBytes(),
            "usage": GPUBufferUsage.COPY_DST | GPUBufferUsage.UNIFORM
        };

        this.cgpBuffer[inst] = new CgpGguBuffer(this.cgp, this.name + " buff", null, { "buffCfg": buffCfg });
    }

    pipelineUpdated()
    {
        this.needsRebuildBindgroup = false;
    }

    needsPipeUpdate()
    {
        return this.needsRebuildBindgroup;
    }

    /**
     * @param {number} inst
     */
    updateBuffer(inst)
    {
        let info = { "name": this.#uniforms.length + " uniforms", "stage ": CgpShader.getStageString(this.stage), "uniforms": [] };

        let s = this.getSizeBytes() / 4;
        info.s = this.getSizeBytes();
        if (s == 16)s = 16;
        if (!this.cgpBuffer[inst])
        {
            this.createBuffer(inst);
            // console.log("no cpubuff? ", s, this.#uniforms);
            // return;
        }
        this.cgpBuffer[inst].setLength(s);

        let off = 0;
        for (let i = 0; i < this.#uniforms.length; i++)
        {
            this.#uniforms[i].copyToBuffer(this.cgpBuffer[inst].floatArr, off);

            if (this.#uniforms[i].gpuBufferChanged)
                console.log("un changed", this.cgpBuffer[inst].floatArr);

            info.uniforms.push(this.#uniforms[i].getInfo());

            off += this.#uniforms[i].getSizeBytes() / 4;
        }
        if (this.cgp.branchProfiler) this.cgp.branchProfiler.push("binding update buff", CgpShader.getStageString(this.stage), { "info": info });

        this.cgpBuffer[inst].updateGpuBuffer();

        if (this.cgp.branchProfiler) this.cgp.branchProfiler.pop();
    }

    /**
     * @param {CgpShader} shader
     * @param {number} bindGroupNum
     */
    getShaderHeaderCode(shader, bindGroupNum)
    {
        this.cgp.profileData.count("shadercode uni", this.name);
        let str = "";
        let typeStr = "";
        let name = this.name;

        str += "//   [binding_uniform] - \"" + this.name + "\" " + this.id + " uniforms:" + this.#uniforms.length + "\n";

        if (!this.isActiveByDefine(shader))
        {
            str += "// " + typeStr + " " + this.name + ": excluded because define " + this.define + "\n";
            return str;
        }

        if (this.#uniforms.length > 1)
        {
            typeStr = "strct_" + name;

            str += "struct " + typeStr + "\n";
            str += "{\n";
            // if (this.#uniforms.length == 0) str += "placehoder:1.";
            // else
            for (let i = 0; i < this.#uniforms.length; i++)
            {
                str += "    " + this.#uniforms[i].name + ": " + this.#uniforms[i].getWgslTypeStr();
                if (i != this.#uniforms.length - 1)str += ",";
                str += "\n";
            }
            str += "};\n";

        }
        else if (this.#uniforms.length == 1)
        {
            typeStr = this.#uniforms[0].getWgslTypeStr();
            name = this.#uniforms[0].name;
        }
        else if (this.#uniforms.length == 0)
        {
            return str;
            // typeStr = "float";
            // name = "placeholder";
        }

        // console.log("shadercode uniforms", this.#uniforms[0].name);
        str += "@group(" + bindGroupNum + ") ";
        str += "@binding(" + this.bindNum + ") ";

        str += "var<uniform> ";
        str += name + ": " + typeStr + ";\n";

        // console.log(str);
        return str + "\n";
    }

    /** @returns {GPUBindGroupLayoutEntry} */
    getLayoutEntry()
    {
        return {
            "visibility": this.stage,
            "binding": this.bindNum,
            "minBindingSize": this.getSizeBytes(),
            "hasDynamicOffset": 0,
            "buffer": {}
        };
    }

    /**
     * @param {number} inst
     */
    updateValues(inst)
    {
        for (let i = 0; i < this.#uniforms.length; i++)
        {
            // if (this.#uniforms[i].needsUpdate)
        }
        return this.updateBuffer(inst);

    }

    getInfo()
    {
        const o = { "name": this.name, "id": this.id, "stage": this.stage, "class": this.constructor.name, "uniforms": [] };

        for (let i = 0; i < this.#uniforms.length; i++)
        {
            o.uniforms.push(this.#uniforms[i].getInfo());
        }
        return o;
    }
}

;// CONCATENATED MODULE: ./src/corelibs/cgp/binding/binding_sampler.js



/** @extends Binding */
class BindingSampler extends Binding
{

    /** @type {GPUSamplerDescriptor} */
    smplDesc = {
        "addressModeU": "mirror-repeat",
        "addressModeV": "mirror-repeat",
        "magFilter": "linear",
        "minFilter": "linear",
        "mipmapFilter": "linear",
    };

    /** @type {GPUSampler} */
    sampler = null;

    constructor(cgp, name, options)
    {
        super(cgp, name, options);
        this.sampler = this.cgp.device.createSampler(this.smplDesc);

    }

    copy()
    {
        const b = new BindingSampler(this.cgp, this.name, this.options);
        return b;
    }

    getResource()
    {
        return this.sampler;
    }

    /** @returns {GPUBindGroupLayoutEntry} */
    getLayoutEntry()
    {
        return {
            "visibility": this.stage,
            "binding": this.bindNum,
            "sampler": {}
        };
    }

    /**
     * @param {CgpShader} shader
     * @param {number} bindGroupNum
     */
    getShaderHeaderCode(shader, bindGroupNum)
    {
        let str = "@group(" + bindGroupNum + ") @binding(" + this.bindNum + ") ";
        str += "var " + this.name + ": sampler;".endl();
        return str;
    }
}

;// CONCATENATED MODULE: ./src/corelibs/cgp/binding/binding_texture.js





/** @extends {Binding} */
class BindingTexture extends Binding
{

    /** @type {GPUSampler} */
    sampler = null;
    uniform = null;

    /**
     * @param {CgpContext} cgp
     * @param {string} name
     * @param {object} options
     */
    constructor(cgp, name, options)
    {
        super(cgp, name, options);

        /** @type {CgpUniform} */
        this.uniform = options.uniform;

        if (this.uniform.port)
        {
            this.uniform.port.on("change", () =>
            {
                this.needsRebuildBindgroup = true;
            });
        }

        console.log(this.uniform);
    }

    copy()
    {
        const b = new BindingTexture(this.cgp, this.name, this.options);
        return b;
    }

    getResource()
    {
        if (this.uniform.getValue() && this.uniform.getValue().gpuTexture) return this.uniform.getValue().gpuTexture.createView();
        else return this.cgp.getDefaultTexture().createView();
    }

    /** @returns {GPUBindGroupLayoutEntry} */
    getLayoutEntry()
    {
        return {
            "visibility": this.stage,
            "binding": this.bindNum,
            "texture": {}
        };
    }

    /**
     * @param {CgpShader} _shader
     * @param {number} bindGroupNum
     */
    getShaderHeaderCode(_shader, bindGroupNum)
    {
        let str = "@group(" + bindGroupNum + ") @binding(" + this.bindNum + ") ";
        str += "var " + this.name + ": " + this.uniform.getWgslTypeStr() + ";\n";
        return str;
    }
}

;// CONCATENATED MODULE: ./src/corelibs/cgp/cgp_shader.js













/** @typedef CgpShaderOptions
 * @property {Boolean} [compute]
 * @property {String} [entryPoint]
 */

class CgpShader extends cg_shader/* CgShader */.U
{

    #lastCompileReason = "first";

    /** @type {CgpUniform} */
    uniModelMatrix;

    /** @type {CgpUniform} */
    uniViewMatrix;

    /** @type {CgpUniform} */
    uniProjMatrix;

    /**
     * @type {GPUCompilationInfo}
     */
    compilationInfo;

    /**
     * @param {CgpContext} _cgp
     * @param {String} _name
     * @param {CgpShaderOptions} options={}
     */
    constructor(_cgp, _name, options = {})
    {
        super();
        if (!_cgp) throw new Error("shader constructed without cgp " + _name);
        this._log = new logger/* default */.A("cgp_shader");
        this._cgp = _cgp;
        this._name = _name;
        this.options = options;
        this.options.compute = this.options.compute || false;

        if (!_name) this._log.stack("no shader name given");
        this._name = _name || "unknown";
        this.gpuShaderModule = null;
        this.frameUsageCounter = 0;
        this.lastFrameUsageCounter = -2;
        this.frameUsageFrame = -1;

        this._bindingIndexCount = 0;
        this.compileCount = 0;
        this.worldUniforms = [];

        this.defaultBindGroup = new BindGroup(_cgp, this._name);
        this.modsBindGroup = new BindGroup(_cgp, this._name);

        /** @type {Array<BindGroup>} */
        this.bindGroups = [this.defaultBindGroup, this.modsBindGroup];

        if (!this.options.compute)
        {
            // this.bindingWorld = new BindingUniform(_cgp, "world", { "stage": GPUShaderStage.VERTEX });
            // this.defaultBindGroup.addBinding(this.bindingWorld);

            this.defaultUniBindingVert = new BindingUniform(_cgp, "uniVert", { "stage": GPUShaderStage.VERTEX });
            this.defaultBindGroup.addBinding(this.defaultUniBindingVert);

            this.defaultUniBindingFrag = new BindingUniform(_cgp, "uniFrag", { "stage": GPUShaderStage.FRAGMENT });
            this.defaultBindGroup.addBinding(this.defaultUniBindingFrag);
        }
        else
        {
            this.defaultUniBindingCompute = new BindingUniform(_cgp, "uniCompute", { "stage": GPUShaderStage.COMPUTE });
            this.defaultBindGroup.addBinding(this.defaultUniBindingCompute);
        }

        if (!this.options.compute)
        {
            this.uniModelMatrix = this.addUniform(new CgpUniform(this, "m4", "modelMatrix"), GPUShaderStage.VERTEX);
            this.uniViewMatrix = this.addUniform(new CgpUniform(this, "m4", "viewMatrix"), GPUShaderStage.VERTEX);
            this.uniProjMatrix = this.addUniform(new CgpUniform(this, "m4", "projMatrix"), GPUShaderStage.VERTEX);
            this.uniNormalMatrix = this.addUniform(new CgpUniform(this, "m4", "normalMatrix"), GPUShaderStage.VERTEX);
            this.uniModelViewMatrix = this.addUniform(new CgpUniform(this, "m4", "modelViewMatrix"), GPUShaderStage.VERTEX);
            this._tempNormalMatrix = mat4.create();
            this._tempModelViewMatrix = mat4.create();
            this.worldUniforms.push(this.uniModelMatrix, this.uniViewMatrix, this.uniProjMatrix, this.uniNormalMatrix, this.uniModelViewMatrix);
        }

        this._src = "";

        this._cgp.on("deviceChange", () =>
        {
            this.gpuShaderModule = null;
            this.setWhyCompile("device changed");
        });
    }

    reInit()
    {

    }

    /** @returns {boolean} */
    isValid()
    {
        return this._isValid;
    }

    getName()
    {
        return this._name;
    }

    incFrameUsageCount()
    {
        if (this.frameUsageFrame != this._cgp.frame)
        {
            this.lastFrameUsageCounter = this.frameUsageCounter;
            this.frameUsageCounter = 0;
        }
        else this.frameUsageCounter++;
        this.frameUsageFrame = this._cgp.frame;

        return this.frameUsageCounter;
    }

    getNewBindingGroupIndex()
    {
        return ++this._bindingIndexCount;
    }

    /**
     * @param {String} src
     */
    setSource(src)
    {
        this._src = src;
        this.setWhyCompile("Source changed");
    }

    /**
     * @param {import("../cg/cg_shader.js").ShaderModule} mod
     * @param {string} src
     */
    _replaceModPrefixes(mod, src)
    {
        return src.replace(/MOD_/g, mod.prefix);
    }

    /**
     * @param {String} vs
     * @param {{}} defs
     */
    _replaceMods(vs, defs)
    {
        let srcHeadVert = "";
        for (let i = 0; i < this._moduleNames.length; i++)
        {
            let srcVert = "";

            for (let j = 0; j < this._modules.length; j++)
            {
                const mod = this._modules[j];
                if (mod.name == this._moduleNames[i])
                {
                    srcHeadVert += constants.nl + constants.nl + "//---- MOD: group:" + mod.group + ": idx:" + j + " - prfx:" + mod.prefix + " - " + mod.title + " ------" + constants.nl;

                    srcVert += constants.nl + constants.nl + "//---- MOD: " + mod.title + " / " + mod.priority + " ------" + constants.nl;

                    if (mod.attributes)
                        for (let k = 0; k < mod.attributes.length; k++)
                        {
                            const r = this._getAttrSrc(mod.attributes[k], false);
                            if (r.srcHeadVert)srcHeadVert += r.srcHeadVert;
                            if (r.srcVert)srcVert += r.srcVert;
                        }

                    srcHeadVert += mod.srcHead || "";
                    srcVert += mod.srcBody || "";

                    srcHeadVert += constants.nl + "//---- end mod ------" + constants.nl;

                    srcVert += constants.nl + "//---- end mod ------" + constants.nl;

                    srcVert = this._replaceModPrefixes(mod, srcVert);
                    srcHeadVert = this._replaceModPrefixes(mod, srcHeadVert);

                }
            }

            srcVert = preproc(srcVert, defs);
            vs = vs.replace("{{" + this._moduleNames[i] + "}}", srcVert);
        }

        srcHeadVert = preproc(srcHeadVert, defs);
        vs = vs.replace("{{MODULES_HEAD}}", srcHeadVert);
        return vs;
    }

    /**
     * @param {string} src
     */
    _replaceVertexOutputs(src = "")
    {
        const strVertOut = "{{VERTEX_OUTPUT";
        const posVertOut = src.indexOf(strVertOut);
        if (posVertOut > -1)
        {
            try
            {
                let str = src.substring(posVertOut + strVertOut.length, posVertOut + 100);
                let endPos = str.indexOf("}}");
                let startNum = parseInt(str.substring(0, endPos));

                for (let j = 0; j < this._modules.length; j++)
                {
                    if (!this._modules[j].outputs) continue;
                    let outs = this._modules[j].outputs;
                    let l = 0;
                    while (outs.indexOf("@location(" + l + ")") > -1)
                    {
                        outs = outs.replaceAll("@location(" + l + ")", "@location(" + (l + startNum) + ")");
                    }
                    outs = this._replaceModPrefixes(this._modules[j], outs);
                    src = src.replaceAll(strVertOut + " " + startNum + "}}", outs);
                }

            }
            catch (e)
            {
                console.log(e);
            }
        }
        return src;
    }

    getDefines()
    {
        return this._defines;
    }

    getProcessedSource()
    {
        const defs = {};
        for (let i = 0; i < this._defines.length; i++)
            defs[this._defines[i][0]] = this._defines[i][1] || true;

        let src = "";
        src += preproc(this._src, defs);

        let strDefs = "";
        for (let i = 0; i < this._defines.length; i++)
            strDefs += "// #define " + this._defines[i] + "\n";

        let bindingsHeadVert = "";
        let bindingsHeadFrag = "";
        let bindingsHeadCompute = "";

        for (let i = 0; i < this.bindGroups.length; i++)
        {
            const src = this.bindGroups[i].getShaderHeaderCode(this, i);
            bindingsHeadFrag += src.fragment || "";
            bindingsHeadVert += src.vertex || "";
            bindingsHeadCompute += src.compute || "";
        }

        if (this.options.compute)
            src = bindingsHeadCompute + "\n\n////////////////\n\n" + src;
        else
            src = bindingsHeadFrag + "\n\n////////////////\n\n" + bindingsHeadVert + "\n\n////////////////\n\n" + src;

        src = this._replaceMods(src, defs);

        src = this._replaceVertexOutputs(src);

        const strVertOut = "{{VERTEX_OUTPUT";
        const posVertOut = src.indexOf(strVertOut);
        if (posVertOut > -1)
        {
            try
            {
                let str = src.substring(posVertOut + strVertOut.length, posVertOut + 100);
                let endPos = str.indexOf("}}");
                let startNum = parseInt(str.substring(0, endPos));
                let locCode = "@location(" + (startNum) + ") pos:vec4f, // generated";

                src = src.replaceAll(strVertOut + " " + startNum + "}}", locCode);
            }
            catch (e)
            {
                console.log(e);
            }
        }
        src = strDefs + "\n" + src;

        let srcHead = "//" + constants.nl + "// ";
        if (this.options.compute)srcHead += "Compute ";
        else srcHead += "Render ";

        srcHead += "Shader: " + this._name + " - " + this.id + constants.nl;
        srcHead += "//" + constants.nl;

        return srcHead + src;
    }

    compile()
    {
        this._isValid = true;
        this._cgp.pushErrorScope("cgp_shader " + this._name);

        if (this._cgp.branchProfiler) this._cgp.branchProfiler.push("shadercompile", this._name, { "info": this.getInfo() });

        this._cgp.profileData.count("shader compile", this._name);
        this.gpuShaderModule = this._cgp.device.createShaderModule({ "code": this.getProcessedSource(), "label": this._name });

        this.gpuShaderModule.getCompilationInfo().then((compInfo) =>
        {
            this.compilationInfo = compInfo;
            if (compInfo.messages.length > 0)
            {
                let hasErrors = false;
                for (const msg of compInfo.messages)
                {
                    switch (msg.type)
                    {
                    case "error":
                        console.error("Shader " + msg.type + " at line " + msg.lineNum + ":" + msg.linePos + " :" + msg.message);
                        hasErrors = true;
                    case "warning":
                        console.warn("Shader " + msg.type + " at line " + msg.lineNum + ":" + msg.linePos + " :" + msg.message);
                        break;
                    case "info":
                        console.info("Shader " + msg.type + " at line " + msg.lineNum + ":" + msg.linePos + " :" + msg.message);
                        break;
                    }
                }
                if (hasErrors)
                {
                    console.log("has errrrrrrrrrr");
                    CABLES.UI.showShaderErrorCgp(this, compInfo, this.getProcessedSource());
                }

            }
        });

        this._cgp.popErrorScope(this.error.bind(this));

        this.#lastCompileReason = this._compileReason;

        this.lastCompile = (0,timer/* now */.tB)();
        // console.log("#lastCompileReason", this.#lastCompileReason);

        this.emitEvent("compiled", this._compileReason);
        this._needsRecompile = false;
        this._compileReason = "none";
        this.compileCount++;

        if (this._cgp.branchProfiler) this._cgp.branchProfiler.pop();
    }

    error(e)
    {
        this._isValid = false;
    }

    bind(passEnc = null)
    {

        this.incFrameUsageCount();
        if (!this.options.compute)
        {
            this.uniModelMatrix.setValue(this._cgp.mMatrix);
            this.uniViewMatrix.setValue(this._cgp.vMatrix);
            this.uniProjMatrix.setValue(this._cgp.pMatrix);

            // mat4.invert(this._tempNormalMatrix, this._cgp.mMatrix);
            // mat4.transpose(this._tempNormalMatrix, this._tempNormalMatrix);
            mat4.mul(this._tempModelViewMatrix, this._cgp.vMatrix, this._cgp.mMatrix);
            this.uniModelViewMatrix.setValue(this._tempModelViewMatrix);

            mat4.copy(this._tempNormalMatrix, this._cgp.mMatrix);
            mat4.invert(this._tempNormalMatrix, this._tempNormalMatrix);
            mat4.transpose(this._tempNormalMatrix, this._tempNormalMatrix);

            // cpu billboarding?
            // this._tempModelViewMatrix[0 * 4 + 0] = 1.0;
            // this._tempModelViewMatrix[0 * 4 + 1] = 0.0;
            // this._tempModelViewMatrix[0 * 4 + 2] = 0.0;

            // // #ifndef BILLBOARDING_CYLINDRIC
            // this._tempModelViewMatrix[1 * 4 + 0] = 0.0;
            // this._tempModelViewMatrix[1 * 4 + 1] = 1.0;
            // this._tempModelViewMatrix[1 * 4 + 2] = 0.0;
            // // #endif

            // this._tempModelViewMatrix[2 * 4 + 0] = 0.0;
            // this._tempModelViewMatrix[2 * 4 + 1] = 0.0;
            // this._tempModelViewMatrix[2 * 4 + 2] = 1.0;

            this.uniNormalMatrix.setValue(this._tempNormalMatrix);
        }

        for (let i = 0; i < this.bindGroups.length; i++)
        {
            this.bindGroups[i].updateValues(this.frameUsageCounter);
            this.bindGroups[i].bind(this.frameUsageCounter, passEnc, i);
        }
        if (this._needsRecompile) this.compile();
    }

    /**
     * @param {number} stage
     * @returns {BindingUniform}
     */
    getDefaultUniBinding(stage)
    {
        let binding = this.defaultUniBindingFrag;
        if (stage == GPUShaderStage.VERTEX) binding = this.defaultUniBindingVert;
        if (this.options.compute && stage == GPUShaderStage.COMPUTE) binding = this.defaultUniBindingCompute;
        return binding;
    }

    pipelineUpdated()
    {

        if (this.defaultUniBindingFrag) this.defaultUniBindingFrag.pipelineUpdated();
        if (this.defaultUniBindingVert) this.defaultUniBindingVert.pipelineUpdated();
        if (this.defaultUniBindingCompute) this.defaultUniBindingCompute.pipelineUpdated();
    }

    bindingsNeedPipeUpdate()
    {
        return (
            (this.defaultUniBindingFrag && this.defaultUniBindingFrag.needsPipeUpdate()) ||
            (this.defaultUniBindingVert && this.defaultUniBindingVert.needsPipeUpdate()) ||
            (this.defaultUniBindingCompute && this.defaultUniBindingCompute.needsPipeUpdate())
        );
    }

    /**
     * @param {String} name
     * @param {number} stage
     */
    hasUniformInStage(name, stage)
    {
        let binding = this.getDefaultUniBinding(stage);

        // console.log("bindingget uni", stage, binding, CgpShader.getStageString(stage));
        if (!binding) return false;
        return !!binding.getUniform(name);
    }

    /**
     * @param {String} name
     */
    hasUniform(name)
    {
        return this.hasUniformInStage(name, GPUShaderStage.FRAGMENT) || this.hasUniformInStage(name, GPUShaderStage.VERTEX) || this.hasUniformInStage(name, GPUShaderStage.COMPUTE);
    }

    /**
     * @param {CgpUniform} u
     * @param {number} stage
     * @returns {CgpUniform}
     */
    addUniform(u, stage)
    {
        const binding = this.getDefaultUniBinding(stage);
        if (u.type == "t") this.defaultBindGroup.addBinding(new BindingTexture(this._cgp, u.name, { "uniform": u }));
        else if (u.type == "sampler") this.defaultBindGroup.addBinding(new BindingSampler(this._cgp, u.name, { "uniform": u }));
        else
        {
            binding.addUniform(u);
        }

        this.needsPipelineUpdate = "add uniform";
        console.log("adduni2", this._name, u.name, this.id, binding, CgpShader.getStageString(stage));
        console.log("code", binding.getShaderHeaderCode(this, 0));

        // if (!this.defaultBindGroup.hasBinding(binding)) this.defaultBindGroup.addBinding(binding);
        return u;
    }

    removeUniformByName(name)
    {
        const binding = this.getDefaultUniBinding(stage);
        binding.removeUniformByName(name);

    }

    /**
     * copy current shader
     * @returns newShader
     */
    copy()
    {
        this.bind();
        const shader = new CgpShader(this._cgp, this._name + " copy", this.options);
        console.log("copyyyyyy", this.id, shader.id);
        shader.setSource(this._src);

        shader._modules = JSON.parse(JSON.stringify(this._modules));
        shader._defines = JSON.parse(JSON.stringify(this._defines));

        shader._moduleNames = this._moduleNames;

        shader.bindGroups = [];
        for (let i = 0; i < this.bindGroups.length; i++)
        {
            const bg = this.bindGroups[i].copy(shader);
            shader.bindGroups.push(bg);

            if (this.bindGroups[i] == this.defaultBindGroup) shader.defaultBindGroup = bg;
            // if (this.bindGroups[i] == this.modsBindGroup) shader.modsBindGroup = bg;
            bg.setBindingNums();
        }

        shader.setWhyCompile("copy");
        shader.compile();
        return shader;
    }

    dispose()
    {

    }

    /**
     * @param {number} stage
     */
    static getStageString(stage)
    {
        if (stage == GPUShaderStage.FRAGMENT) return "frag";
        if (stage == GPUShaderStage.VERTEX) return "vertex";
        if (stage == (GPUShaderStage.FRAGMENT | GPUShaderStage.VERTEX)) return "frag+vertex";
        if (stage == (GPUShaderStage.FRAGMENT | GPUShaderStage.VERTEX | GPUShaderStage.COMPUTE)) return "frag+vertex+comp";
        if (stage == GPUShaderStage.COMPUTE) return "compute";

        return "unknown" + stage;
    }

    getInfo()
    {
        const o = {
            "class": this.constructor.name,
            "id": this.id,
            "name": this._name,
            "needsPipelineUpdate": this.needsPipelineUpdate,
            "frameUsageCounter": this.lastFrameUsageCounter,
            "lastCompileReason": this.#lastCompileReason,
            "compileCount": this.compileCount,
            "defines": this._defines,
            "isCompute": this.options.compute,
            "modules": [],
            "bindgroups": []
        };

        for (let i = 0; i < this.bindGroups.length; i++)
        {
            o.bindgroups.push(this.bindGroups[i].getInfo());
        }

        for (let i = 0; i < this._modules.length; i++)
        {
            o.modules.push(this._modules[i].title + " " + this._modules[i].name + " " + this._modules[i].group);
            // console.log(this._modules[i]);
        }

        return o;
    }

    copyUniformValues(orig)
    {

    }
}

;// CONCATENATED MODULE: ./src/corelibs/cgp/cgp_texture.js




class Texture extends cg_texture/* CgTexture */.U
{
    #log = new logger/* default */.A("cgp_texture");

    /** @type {CgpContext} */
    #cgp = null;

    /** @type {GPUTexture} */
    gpuTexture = null;

    /** @type {GPUTextureDescriptor} */
    gpuTextureDescriptor = null;
    name = "unknown";
    width = 8;
    height = 8;
    textureType = "???";

    samplerDesc = {};

    /**
    * @param {CgpContext} _cgp
    * @param {Object} options={}
    */
    constructor(_cgp, options = {})
    {
        super(options);
        options = options || {};

        this.#cgp = _cgp;
        if (!this.#cgp) throw new Error("no cgp");

        if (options.name) this.name = options.name;
        if (options.height && options.width) this.setSize(options.width, options.height);

        this.#cgp.on("deviceChange", () =>
        {
        });
        this.samplerDesc = {
            "addressModeU": options.wrap || options.addressModeU || "clamp-to-edge",
            "addressModeV": options.wrap || options.addressModeV || "clamp-to-edge",
            "magFilter": options.magFilter || options.filter || "linear",
            "minFilter": options.minFilter || options.filter || "linear",
        };

    }

    /**
     * @param {Number} w
     * @param {Number} h
     */
    setSize(w, h)
    {
        this.width = w;
        this.height = h;
    }

    /**
     * set texture data from an image/canvas object
     * @function initTexture
     * @memberof Texture
     * @instance
     * @param {Object} img image
     * @param {Number} filter
     */
    initTexture(img, filter)
    {
        this.width = img.width;
        this.height = img.height;

        const textureType = "rgba8unorm";

        this.#cgp.pushErrorScope("inittexture", { "logger": this.#log });

        this.gpuTextureDescriptor = {

            "size": { "width": img.width, "height": img.height },
            "format": textureType,
            // "sampleCount": 4,
            "usage": GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT
        };

        this.gpuTexture = this.#cgp.device.createTexture(this.gpuTextureDescriptor);
        this.#cgp.device.queue.copyExternalImageToTexture({ "source": img }, { "texture": this.gpuTexture }, this.gpuTextureDescriptor.size);

        this.#cgp.popErrorScope();

        return this.gpuTexture;
    }

    dispose()
    {
        console.log("todo dispose");
    }

    getInfo()
    {
        const obj = {};

        obj.name = this.name || "???";
        obj.size = this.width + " x " + this.height;

        obj.textureType = this.textureType;

        return obj;
    }

    createView()
    {
        if (!this.gpuTexture)
        {
            console.log("no gputexture...");
            return null;
        }
        return this.gpuTexture.createView();
    }

    getSampler()
    {
        // "clamp-to-edge"
        // "repeat"
        // "mirror-repeat"

        return this.samplerDesc;
    }

    /**
     * @function initFromData
     * @memberof Texture
     * @instance
     * @description create texturem from rgb data
     * @param {ArrayBuffer} data rgb color array [r,g,b,a,r,g,b,a,...]
     * @param {Number} w width
     * @param {Number} h height
     * @param {Number} filter
     * @param {Number} wrap
     */
    initFromData(data, w, h, filter, wrap)
    {
        if (!w || !h) this.#log.error("texture size is 0");
        this.width = w;
        this.height = h;
        this.gpuTexture = this.#cgp.device.createTexture(
            {
                "size": [w, h],
                "format": "rgba8unorm",
                "usage": GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT,
            });

        this.#cgp.device.queue.writeTexture(
            { "texture": this.gpuTexture },
            data,
            { "bytesPerRow": w * 4 },
            { "width": w, "height": h });
    }

    /**
     * @param {any} v
     */
    setWrap(v)
    {
        this.samplerDesc.addressModeU = this.samplerDesc.addressModeV = v;
    }

    /**
     * @param {any} v
     */
    setFilter(v)
    {
        this.samplerDesc.minFilter = this.samplerDesc.magFilter = v;
    }
}

/**
 * @function load
 * @static
 * @memberof Texture
 * @description load an image from an url
 * @param {CgpContext} cgp
 * @param {String} url
 * @param {Function} onFinished
 * @param {Object} settings
 */
Texture.load = function (cgp, url, onFinished, settings)
{
    fetch(url).then((response) =>
    {
        const texture = new Texture(cgp, { "name": url });

        response.blob().then((blob) =>
        {
            createImageBitmap(blob).then((imgBitmap) =>
            {
                texture.initTexture(imgBitmap);
                if (onFinished)onFinished(texture);
                else console.log("Texture.load no onFinished callback");
            }).catch((err) =>
            {
                if (onFinished)onFinished(cgp.getErrorTexture());
            });
        });
    });
};

;// CONCATENATED MODULE: ./src/corelibs/cgp/cgp_pipeline.js
/// <reference types="@webgpu/types" />




class Pipeline
{
    static TYPE_RENDER = 0;
    static TYPE_COMPUTE = 1;

    #log = new logger/* default */.A("pipeline");
    name = "";

    /** @type {CgpContext} */
    #cgp = null;
    #isValid = true;

    /** @type {string} */
    presentationFormat = null;

    /** @type {GPURenderPipelineDescriptor} */
    #pipeCfg = null;

    /** @type {GPUBindGroupLayout} */
    bindGroupLayout = null;

    /** @type {Array<string>} */
    #shaderListeners = [];
    #type = -1;
    lastRebuildReason = "first";
    rebuildCount = 0;
    profile = false;

    /** @type {Array<GPUBindGroupLayoutEntry>} */
    bindingGroupLayoutEntries = [];

    /**
     * Description
     * @param {CgpContext} _cgp
     * @param {String} name
     * @param {Number} type
     */
    constructor(_cgp, name, type = 0)
    {
        if (!_cgp) throw new Error("Pipeline constructed without cgp " + name);
        this.name = name;
        this.#cgp = _cgp;
        this.#type = type;

        // this.#cgp.on("deviceChange", () =>
        // {
        //     this.#renderPipeline = null;
        // });
    }

    get passEncoder()
    {
        return this.#cgp.passEncoder;
    }

    get log()
    {
        return this.#log;
    }

    get cgp()
    {
        return this.#cgp;
    }

    get isValid() { return this.#isValid; }

    /**
     * @param {String} name
     */
    setName(name)
    {
        this.name = name;
    }

    // setShaderListener(oldShader, newShader)
    // {
    //     for (let i = 0; i < this.#shaderListeners.length; i++) oldShader.off(this.#shaderListeners[i]);
    //     this.#shaderListeners = [];
    //     this.#shaderListeners.push(
    //         newShader.on("compiled", (/** @type {string} */ reason) =>
    //         {
    //             this.needsRebuildReason = "shader compiled: " + reason || "???";
    //         }));
    // }

    getInfo()
    {
        const info = {
            "class": this.constructor.name,
            "name": this.name,
            "rebuildReason": this.lastRebuildReason,
            "rebuildCount": this.rebuildCount,
            // "numBindgroups": this.#bindingInstances.length,
            "bindingGroupLayoutEntries": this.bindingGroupLayoutEntries,
        };

        if (this.#type == Pipeline.TYPE_COMPUTE)info.type = "COMPUTE";
        if (this.#type == Pipeline.TYPE_RENDER)info.type = "RENDER";

        return info;
    }

    pushDebug()
    {
        this.#cgp.currentPipeDebug =
        {
            "name": this.name,
            "rebuildreason": this.lastRebuildReason,
            "rebuildCount": this.rebuildCount,
            "cfg": this.#pipeCfg,
            "bindingGroupLayoutEntries": this.bindingGroupLayoutEntries
        };
    }

    /**
     * @param {CgpShader} shader
     */
    _bindUniforms(shader)
    {
        shader.bind();
    }

    dispose()
    {
        // todo...
    }

}

;// CONCATENATED MODULE: ./src/corelibs/cgp/cgp_renderpipeline.js
/// <reference types="@webgpu/types" />





class RenderPipeline extends Pipeline
{
    static DEPTH_COMPARE_FUNCS_STRINGS = ["never", "less", "equal", "lessequal", "greater", "notequal", "greaterequal", "always"];

    #isValid = true;

    /** @type {string} */
    presentationFormat = null;

    /** @type {GPURenderPipelineDescriptor} */
    #pipeCfg = null;

    /** @type {GPURenderPipeline} */
    #renderPipeline = null;

    /** @type {GPUBindGroupLayout} */
    bindGroupLayout = null;

    /** @type {GPURenderPassEncoder} */
    #passEncoder;

    // #shaderListeners = [];
    #old = {};
    #type = RenderPipeline.TYPE_RENDER;
    lastRebuildReason = "first";
    #rebuildNumBindingGroups = false;
    #compileCount = -1;

    /**
     * Description
     * @param {CgpContext} _cgp
     * @param {String} name
     */
    constructor(_cgp, name)
    {
        super(_cgp, name, Pipeline.TYPE_RENDER);
    }

    /**
     * @param {CgpShader} shader
     * @param {CgpMesh} mesh
     */
    setPipeline(shader, mesh = null)
    {
        if (this.#type == RenderPipeline.TYPE_RENDER)
        {
            if (!mesh)
            {
                this.log.log("pipeline unknown mesh");
                return;
            }
        }
        if (!shader)
        {
            this.log.log("pipeline unknown shader");
            return;
        }

        if (this.cgp.branchProfiler) this.cgp.branchProfiler.push("setPipeline", this.name, { "info": this.getInfo(), "shader": shader.getInfo() });

        let needsRebuildReason = "";
        if (!this.#renderPipeline) needsRebuildReason = "no renderpipeline";
        if (!this.#pipeCfg)needsRebuildReason = "no pipecfg";
        if (this.#old.mesh != mesh)needsRebuildReason = "no mesh";
        if (this.#old.shader != shader)
        {
            // this.setShaderListener(this.#old.shader, shader);
            needsRebuildReason = "shader changed";
        }

        if (shader.needsPipelineUpdate)
        {
            needsRebuildReason = "shader needs update: " + shader.needsPipelineUpdate;
            shader.needsPipelineUpdate = "";
        }

        if (this.#type == RenderPipeline.TYPE_RENDER && mesh.needsPipelineUpdate)
        {
            needsRebuildReason = "mesh needs update";
            mesh.needsPipelineUpdate = false;
        }

        if (this.bindingGroupLayoutEntries.length != shader.defaultBindGroup.getLayoutEntries(shader).length)
        {
            needsRebuildReason = "num bindgroup layouts wrong...";
        }

        if (shader.bindingsNeedPipeUpdate())
        {
            console.log("binding needs uptate");
            needsRebuildReason = "bindings needs update";
            this.needsRebuildBindgroup = true;
        }

        // if (this.#rebuildNumBindingGroups)
        // {
        //     needsRebuildReason = "num bindgroups wrong...";
        // }

        if (this.#pipeCfg)
        {
            this.#pipeCfg =/** @type {GPURenderPipelineDescriptor} */ (this.#pipeCfg || {});
            if (this.#pipeCfg.depthStencil.depthWriteEnabled != this.cgp.stateDepthWrite())
                needsRebuildReason = "depth changed";

            if (this.#pipeCfg.fragment.targets[0].blend != this.cgp.stateBlend())
            {
                needsRebuildReason = "blend changed";
                this.#pipeCfg.fragment.targets[0].blend = this.cgp.stateBlend();
            }

            if (this.#pipeCfg.depthStencil.depthCompare != this.cgp.getDepthCompare())
                needsRebuildReason = "depth compare changed";

            if (this.#pipeCfg.primitive.cullMode != this.cgp.stateCullFaceFacing())
                needsRebuildReason = "cullmode change";

            if (this.#pipeCfg.multisample.count != this.cgp.stateMultisampling())
                needsRebuildReason = "multisample change";

        }
        if (this.#compileCount != shader.compileCount)
        {
            needsRebuildReason = "shader compiled " + shader.compileCount;
        }

        this.pushDebug();

        if (needsRebuildReason != "")
        {
            this.cgp.profileData.addHeavyEvent("pipeline created", this.name, needsRebuildReason);
            this.lastRebuildReason = needsRebuildReason;
            this.rebuildCount++;
            this.cgp.pushErrorScope("createPipeline", { "logger": this.log });

            this.#rebuildNumBindingGroups = false;

            this.#pipeCfg = this.getPipelineObject(shader);

            this.#old.device = this.cgp.device;
            this.#old.shader = shader;
            this.#old.mesh = mesh;
            this.#isValid = true;
            this.#compileCount = shader.compileCount;
            shader.pipelineUpdated();

            try
            {

                this.#renderPipeline = this.cgp.device.createRenderPipeline(this.#pipeCfg);

            }
            catch (e)
            {

                console.error("pipe error catch...", e.message, this.#pipeCfg);
                this.#isValid = false;
            }

            this.cgp.popErrorScope(
                () =>
                {
                    console.log("this.#pipeCfg", this.#pipeCfg);
                });
        }

        if (this.#renderPipeline && this.#isValid)
        {
            this.cgp.pushErrorScope("setpipeline", { "logger": this.log });

            let passEnc = this.cgp.passEncoder;

            // if (this.#type != RenderPipeline.TYPE_RENDER) passEnc = this.#passEncoder;

            if (this.cgp.branchProfiler) this.cgp.branchProfiler.push("pipe updateUniforms", this.name, { "shader": shader.getInfo() });

            /// ///////////////////

            shader.bind();
            passEnc.setPipeline(this.#renderPipeline);

            if (this.cgp.branchProfiler) this.cgp.branchProfiler.pop();

            this.cgp.popErrorScope();
        }
        if (this.cgp.branchProfiler) this.cgp.branchProfiler.pop();

    }

    /**
     * @param {CgpShader} shader
     * @returns {GPURenderPipelineDescriptor}
     */
    getPipelineObject(shader)
    {

        this.bindingGroupLayoutEntries = [];
        this.bindingGroupLayoutEntries = shader.defaultBindGroup.getLayoutEntries(shader);

        const bindGroupLayouts = [shader.defaultBindGroup.getLayout(shader)];

        /** @type {GPUPipelineLayout} */
        const pipelineLayout = this.cgp.device.createPipelineLayout({
            "label": "pipe layout " + this.name,
            "bindGroupLayouts": bindGroupLayouts
        });

        /** @type {Array<GPUVertexBufferLayout>} */
        let buffers = [
            // position
            {
                "arrayStride": 3 * 4, // 3 floats, 4 bytes each
                "attributes": [
                    { "shaderLocation": 0, "offset": 0, "format": "float32x3" },
                ],
            },
            // texcoords
            {
                "arrayStride": 2 * 4, // 2 floats, 4 bytes each
                "attributes": [
                    { "shaderLocation": 2, "offset": 0, "format": "float32x2", },
                ],
            },
            // normals
            {
                "arrayStride": 3 * 4, // 3 floats, 4 bytes each
                "attributes": [
                    { "shaderLocation": 1, "offset": 0, "format": "float32x3" },
                ],
            }];

        /** @type {GPURenderPipelineDescriptor} */
        let pipeCfg = {
            "label": this.name,
            "layout": pipelineLayout,

            "primitive": {
                "topology": "triangle-list",
                "cullMode": this.cgp.stateCullFaceFacing(), // back/none/front
            // "point-list",
            // "line-list",
            // "line-strip",
            // "triangle-list",
            // "triangle-strip"
            },
            "multisample": {
                "count": this.cgp.stateMultisampling(),
                "alphaToCoverageEnabled": false // Enable if using alpha testing
            },
            "depthStencil": {
                "depthWriteEnabled": this.cgp.stateDepthWrite(),
                "depthCompare": this.cgp.getDepthCompare(),
                "format": "depth24plus",

            },
            "vertex":
            {
                "module": shader.gpuShaderModule,
                "entryPoint": "myVSMain",
                "buffers": buffers
            },
            "fragment":
            {
                "module": shader.gpuShaderModule,
                "entryPoint": "myFSMain",
                "targets": [
                    {
                        "format": this.cgp.presentationFormat,
                        "blend": this.cgp.stateBlend()
                    },
                ],
            }
        };
        return pipeCfg;
    }

    dispose()
    {
        // todo...
    }

}

// EXTERNAL MODULE: ./src/corelibs/cg/cg_mesh.js
var cg_mesh = __webpack_require__(434);
;// CONCATENATED MODULE: ./src/corelibs/cgp/cgp_mesh.js





class CgpMesh extends cg_mesh/* CgMesh */.w
{
    #log = new logger/* default */.A("cgl_mesh");
    needsPipelineUpdate = false;

    /**
     * @param {any} _cgp
     * @param {any} __geom
     */
    constructor(_cgp, __geom)
    {
        super();

        this.cgp = _cgp;
        this._geom = null;
        this.numIndex = 0;
        this.instances = 1;

        this._pipe = new RenderPipeline(this.cgp, "pipe mesh " + __geom.name);
        this._numNonIndexed = 0;
        this._positionBuffer = null;

        this._attributes = [];

        if (__geom) this.setGeom(__geom);
    }

    /**
     * @param {GPUDevice} device
     * @param {any} data
     * @param {any} usage
     */
    _createBuffer(device, data, usage)
    {
        let bo = {
            "size": data.byteLength,
            "usage": usage,
            "mappedAtCreation": true,
        };
        const buffer = device.createBuffer(bo);
        const dst = new data.constructor(buffer.getMappedRange());
        dst.set(data);
        buffer.unmap();
        return buffer;
    }

    /**
     * @function setGeom
     * @memberof Mesh
     * @instance
     * @description set geometry for mesh
     * @param {Geometry} geom geometry
     */
    setGeom(geom)
    {
        this.needsPipelineUpdate = true;
        this._geom = geom;
        this._disposeAttributes();

        this._positionBuffer = this._createBuffer(this.cgp.device, new Float32Array(geom.vertices), GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST);

        let vi = geom.verticesIndices;
        if (!geom.isIndexed()) vi = Array.from(Array(geom.vertices.length / 3).keys());
        this._numIndices = vi.length;
        this._indicesBuffer = this._createBuffer(this.cgp.device, new Uint32Array(vi), GPUBufferUsage.INDEX | GPUBufferUsage.COPY_DST);

        if (geom.texCoords && geom.texCoords.length) this.setAttribute("texCoords", geom.texCoords, 2);
        if (geom.vertexNormals && geom.vertexNormals.length) this.setAttribute("normals", geom.vertexNormals, 3);

        this.setAttribute("normals", geom.vertexNormals, 3);
    }

    _disposeAttributes()
    {
        this.needsPipelineUpdate = true;
        for (let i = 0; i < this._attributes.length; i++) this._attributes[i].buffer.destroy();
        this._attributes.length = 0;
    }

    dispose()
    {
        this._disposeAttributes();
    }

    /**
     * @function setAttribute
     * @description update attribute
     * @memberof Mesh
     * @instance
     * @param {String} name attribute name
     * @param {Array} array data
     * @param {Number} itemSize
     * @param {Object} options
     */
    setAttribute(name, array, itemSize, options = {})
    {
        if (!array)
        {
            this.#log.error("mesh addAttribute - no array given! " + name);
            throw new Error();
        }

        let instanced = false;
        if (options.instanced) instanced = options.instanced;

        const buffer = this._createBuffer(this.cgp.device, new Float32Array(array), GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST);

        const attr = {
            "buffer": buffer,
            "name": name,
            "instanced": instanced,
        };
        this._attributes.push(attr);

        return attr;
    }

    /**
     * @param {CgpShader} shader
     */
    render(shader)
    {
        if (!this._positionBuffer) return;
        if (this.instances <= 0) return;

        if (this.cgp.branchProfiler) this.cgp.branchProfiler.push("mesh.render()", "geom " + this._geom.name);

        shader = shader || this.cgp.getShader();
        if (shader)shader.bind();

        if (!shader || !shader.isValid)
        {
            // this.status = "shader invalid";
            return;
        }

        this._pipe.setName("mesh.render " + this._geom.name + " " + shader.getName() + " " + shader.id);
        this._pipe.setPipeline(shader, this);

        if (this._pipe.isValid)
        {
            if (this.cgp.branchProfiler) this.cgp.branchProfiler.push("mesh.render().draw", "geom " + this._geom.name, {
                "geom": this._geom.getInfo(),
                "shader": shader.getInfo(),
                "numAttributes": this._attributes.length
            });

            this.cgp.passEncoder.setVertexBuffer(0, this._positionBuffer);
            for (let i = 0; i < this._attributes.length; i++)
                this.cgp.passEncoder.setVertexBuffer(i + 1, this._attributes[i].buffer);

            this.cgp.passEncoder.setIndexBuffer(this._indicesBuffer, "uint32");

            this.cgp.profileData.count("draw mesh", this._name);
            if (this._numNonIndexed)
                this.cgp.passEncoder.draw(this._numIndices, this.instances);
            else
                this.cgp.passEncoder.drawIndexed(this._numIndices, this.instances);

            if (this.cgp.branchProfiler) this.cgp.branchProfiler.pop();
        }
        else
        {
            if (this.cgp.branchProfiler)
            {
                this.cgp.branchProfiler.push("mesh invalid pipeline ", "geom " + this._geom.name);
                this.cgp.branchProfiler.pop();
            }
        }

        if (this.cgp.branchProfiler) this.cgp.branchProfiler.pop();

        // if (shader)shader.unbind();
    }
}

;// CONCATENATED MODULE: ./src/corelibs/cgp/cgp_state.js









// https://github.com/greggman/webgpu-utils
// https://developer.chrome.com/blog/from-webgl-to-webgpu/
// https://gpuweb.github.io/gpuweb/explainer/

// eslint-disable-next-line no-restricted-syntax
const defaultShaderSrcVert = `
struct MyVSInput
{
    @location(0) position: vec3<f32>,
    @location(1) normal: vec3<f32>,
    @location(2) texcoord: vec2<f32>,
};

struct MyVSOutput
{
    @builtin(position) position: vec4<f32>,
    @location(0) normal: vec3<f32>,
    @location(1) texcoord: vec2<f32>,
};

@vertex
fn myVSMain(v: MyVSInput) -> MyVSOutput
{
    var vsOut: MyVSOutput;
    var pos =vec4<f32>(v.position, 1.0);

    var mvMatrix=uniVert.viewMatrix * uniVert.modelMatrix;
    vsOut.position = uniVert.projMatrix * mvMatrix * pos;

    vsOut.normal = v.normal;
    vsOut.texcoord = v.texcoord;
    return vsOut;
}

@fragment
fn myFSMain(v: MyVSOutput) -> @location(0) vec4<f32>
{
    return vec4<f32>(.5,.5,.5,1.0);
}
`;

/**
 * cables webgpu context/state manager
 * @class
 * @namespace external:CGP
 * @hideconstructor
 */
class CgpContext extends cg_context/* CgContext */.A
{

    branchProfiler = null;

    /**
     * @param {Patch} _patch
     */
    constructor(_patch)
    {
        super(_patch);
        this.patch = _patch;

        this.lastErrorMsg = "";

        this._log = new logger/* default */.A("WebGpuContext");
        this.gApi = cg_context/* CgContext */.A.API_WEBGPU;
        this._viewport = [0, 0, 256, 256];
        this._shaderStack = [];
        this._simpleShader = null;
        this.frame = 0;
        this.catchErrors = true;

        this._stackCullFaceFacing = [];
        this._stackDepthTest = [];
        this._stackCullFace = [];
        this._stackDepthFunc = [];
        this._stackDepthWrite = [];
        this._stackErrorScope = [];
        this._stackBlend = [];
        this._stackErrorScopeLogs = [];
        this._stackMultisampling = [];

        this.currentPipeDebug = null;
        this.canvasAttachments = [];

        /** @type {GPUDevice} */
        this.device = null;

        /** @type {GPURenderPassEncoder} */
        this.passEncoder = null;

        this._defaultBlend = {
            "color": {
                "operation": "add",
                "srcFactor": "one",
                "dstFactor": "zero",
            },
            "alpha": {
                "operation": "add",
                "srcFactor": "one",
                "dstFactor": "zero",
            },
        };

        this.DEPTH_FUNCS = [
            "never",
            "always",
            "less",
            "less-equal",
            "greater",
            "greater-equal",
            "equal",
            "not-equal"
        ];

        this.CULL_MODES = [
            "none",
            "back",
            "front",
            "none" // both does not exist in webgpu
        ];

        /** @type {GPUTextureFormat} */
        this.presentationFormat = "bgra8unorm";
    }

    get supported()
    {
        return !!navigator.gpu;
    }

    /// ////////////////////

    /**
     * Description
     * @param {any} cgp
     * @param {any} identTranslate
     * @param {any} identTranslateView
     * @returns {any}
     */
    renderStart(cgp, identTranslate, identTranslateView)
    {

        this.frame++;
        this.pushErrorScope("cgpstate internal", { "scope": "internal" });
        this.pushErrorScope("cgpstate out-of-memory", { "scope": "out-of-memory" });

        if (!this._simpleShader)
        {
            this._simpleShader = new CgpShader(this, "simple default shader");
            this._simpleShader.setSource(defaultShaderSrcVert);

            this._simpleShader.addUniform(new CgpUniform(this._simpleShader, "4f", "color", [1, 1, 0, 1]), GPUShaderStage.FRAGMENT);
        }

        this.fpsCounter.startFrame();

        this._startMatrixStacks(identTranslate, identTranslateView);
        this.setViewPort(0, 0, this.canvasWidth, this.canvasHeight);

        this.pushShader(this._simpleShader);
        this.pushDepthTest(true);
        this.pushDepthWrite(true);
        this.pushDepthFunc("less-equal");

        this.pushBlend(this._defaultBlend);

        this._execOneTimeCallbacks();

        this.emitEvent("beginFrame");
    }

    renderEnd()
    {
        this._endMatrixStacks();

        this.popShader();
        this.popDepthFunc();
        this.popDepthWrite();
        this.popDepthTest();

        this.popErrorScope();
        this.popErrorScope();

        if (this._stackErrorScope.length > 0)console.log("error scope stack length invalid...");
        this._stackErrorScope.length = 0;

        this.emitEvent("endFrame");
        this.fpsCounter.endFrame();
    }

    /**
     * @param {number} x
     * @param {number} [y]
     * @param {undefined} [w]
     * @param {undefined} [h]
     */
    setViewPort(x, y, w, h)
    {
        this._viewport = [x, y, w, h];
    }

    /**
     * @function getViewPort
     * @memberof Context
     * @instance
     * @description get current gl viewport
     * @returns {Array} array [x,y,w,h]
     */
    getViewPort()
    {
        return this._viewPort;
    }

    /**
     * @param {Geometry} geom
     * @param {any} glPrimitive
     * @returns {CgpMesh}
     */
    createMesh(geom, glPrimitive)
    {
        return new CgpMesh(this, geom);
    }

    /**
     * @function popViewPort
     * @memberof Context
     * @instance
     * @description pop viewPort stack
     */
    popViewPort()
    {
        this._viewPortStack.pop();

        if (this._viewPortStack.length == 0)
            this._viewPort = [0, 0, this.canvasWidth, this.canvasHeight];
        else
            this.setViewPort(this._viewPortStack[this._viewPort.length - 1]);
    }

    /**
     * @function pushViewPort
     * @memberof Context
     * @instance
     * @description push a new viewport onto stack
     * @param {Number} x
     * @param {Number} y
     * @param {Number} w
     * @param {Number} h
     */

    pushViewPort(x, y, w, h)
    {
        this._viewPortStack.push([x, y, w, h]);
        this._viewPort = [x, y, w, h];
    }

    /**
     * push a shader to the shader stack
     * @function pushShader
     * @memberof Context
     * @instance
     * @param {Object} shader
     * @function
    */
    pushShader(shader)
    {
        this._shaderStack.push(shader);
        // currentShader = shader;
    }

    /**
     * pop current used shader from shader stack
     * @function popShader
     * @memberof Context
     * @instance
     * @function
     */
    popShader()
    {
        if (this._shaderStack.length === 0) throw new Error("Invalid shader stack pop!");
        this._shaderStack.pop();
        // currentShader = this._shaderStack[this._shaderStack.length - 1];
    }

    getShader()
    {
        return this._shaderStack[this._shaderStack.length - 1];
    }

    /**
     * @param {GPUDevice} device
     */
    setDevice(device)
    {
        this.device = device;

        if (this._emptyTexture) this._emptyTexture = this._emptyTexture.dispose();
        if (this._defaultTexture) this._defaultTexture = this._defaultTexture.dispose();
        if (this._errorTexture) this._errorTexture = this._errorTexture.dispose();

        this.emitEvent("deviceChange");
    }

    /**
     * @typedef ErrorScopeOptions
     * @property {Logger} [logger]
     * @property {GPUErrorFilter} [scope]
    */

    /**
     * @param {String} name
     * @param {ErrorScopeOptions} options
     */
    pushErrorScope(name, options = { })
    {
        if (this.catchErrors)
        {
            this._stackErrorScope.push(name);
            this._stackErrorScopeLogs.push(options.logger || null);
            this.device.pushErrorScope(options.scope || "validation");
        }
    }

    /**
     * @param {Function} [cb]
     */
    popErrorScope(cb)
    {
        if (this.catchErrors)
        {
            const name = this._stackErrorScope.pop();
            const logger = this._stackErrorScopeLogs.pop();
            this.device.popErrorScope().then((error) =>
            {
                if (error)
                {
                    if (this.lastErrorMsg == error.message)
                    {
                        // this._log.warn("last error once more...");
                    }
                    else
                    {
                        (logger || this._log).error(error.constructor.name, "in ERROR SCOPE:", name);
                        (logger || this._log).error(error.message);
                    }
                    this.lastErrorMsg = error.message;

                    if (cb)cb(error);
                }
            });
        }
    }

    /**
     * push depth testing enabled state
     * @function pushDepthTest
     * @param {Boolean} b enabled
     * @memberof Context
     * @instance
     */
    pushDepthTest(b)
    {
        this._stackDepthTest.push(b);
    }

    getDepthCompare()
    {
        let depthComp = this.stateDepthFunc();
        if (!this.stateDepthTest())depthComp = "always";
        return depthComp;
    }

    /**
     * current state of depth testing
     * @function stateDepthTest
     * @returns {Boolean} enabled
     * @memberof Context
     * @instance
     */
    stateDepthTest()
    {
        return this._stackDepthTest[this._stackDepthTest.length - 1];
    }

    /**
     * pop depth testing state
     * @function popDepthTest
     * @memberof Context
     * @instance
     */
    popDepthTest()
    {
        this._stackDepthTest.pop();
    }

    // --------------------------------------
    // state depthwrite

    /**
     * push depth write enabled state
     * @function pushDepthWrite
     * @param {Boolean} b enabled
     * @memberof Context
     * @instance
     */
    pushDepthWrite(b)
    {
        b = b || false;
        this._stackDepthWrite.push(b);
    }

    /**
     * current state of depth writing
     * @returns {Boolean} enabled
     * @memberof Context
     * @instance
     */
    stateDepthWrite()
    {
        return this._stackDepthWrite[this._stackDepthWrite.length - 1];
    }

    /**
     * pop depth writing state
     * @memberof Context
     * @instance
     */
    popDepthWrite()
    {
        this._stackDepthWrite.pop();
    }

    // --------------------------------------
    // state depthfunc

    /**
     * @function pushDepthFunc
     * @memberof Context
     * @instance
     * @param {GPUCompareFunction} depthFunc depth compare func
     */
    pushDepthFunc(depthFunc)
    {
        this._stackDepthFunc.push(depthFunc);
    }

    /**
     * @function stateDepthFunc
     * @memberof Context
     * @instance
     * @returns {GPUCompareFunction}
     */
    stateDepthFunc()
    {
        if (this._stackDepthFunc.length > 0) return this._stackDepthFunc[this._stackDepthFunc.length - 1];
        return "less";
    }

    /**
     * pop depth compare func
     * @function popDepthFunc
     * @memberof Context
     * @instance
     */
    popDepthFunc()
    {
        this._stackDepthFunc.pop();
    }

    // --------------------------------------
    // state CullFace

    /**
     * push face culling face enabled state
     * @function pushCullFace
     * @param {Boolean} b enabled
     * @memberof Context
     * @instance
     */
    pushCullFace(b)
    {
        this._stackCullFace.push(b);
    }

    // --------------------------------------
    // state multisambling
    /**
     * @returns {number}
     */
    stateMultisampling()
    {
        return this._stackMultisampling[this._stackMultisampling.length - 1];
    }

    /**
     * @param {number} samples
     */
    pushMultisampling(samples)
    {
        this._stackMultisampling.push(samples);
    }

    popMultisampling()
    {
        this._stackMultisampling.pop();
    }

    // --------------------------------------
    // state CullFace Facing

    /**
     * push face culling face side
     * @param {string} b
     * @instance
     */
    pushCullFaceFacing(b)
    {
        this._stackCullFaceFacing.push(b);
    }

    /**
     * current state of face culling side
     * @returns {string}
     */
    stateCullFaceFacing()
    {
        return this._stackCullFaceFacing[this._stackCullFaceFacing.length - 1];
    }

    /**
     * pop face culling face side
     * @function popCullFaceFacing
     * @memberof Context
     * @instance
     */
    popCullFaceFacing()
    {
        this._stackCullFaceFacing.pop();
    }

    pushBlend(b)
    {
        this._stackBlend.push(b);
    }

    popBlend()
    {
        this._stackBlend.pop();
    }

    /**
     * @returns {GPUBlendComponent}
     */
    stateBlend()
    {
        return this._stackBlend[this._stackBlend.length - 1];
    }

    getEmptyTexture()
    {
        if (this._emptyTexture) return this._emptyTexture;
        const size = 8;
        this._emptyTexture = new Texture(this, {});
        this._emptyTexture.initFromData(cg_texture/* CgTexture */.U.getDefaultTextureData("empty", size), size, size);
        return this._emptyTexture;
    }

    getErrorTexture()
    {
        // if (this._errorTexture) return this._errorTexture;
        const size = 256;
        this._errorTexture = new Texture(this, {});
        this._errorTexture.initFromData(cg_texture/* CgTexture */.U.getDefaultTextureData("stripes", size, { "r": 1, "g": 0, "b": 0 }), size, size);
        return this._errorTexture;
    }

    getDefaultTexture()
    {
        if (this._defaultTexture) return this._defaultTexture;
        const size = 256;
        this._defaultTexture = new Texture(this, {});
        this._defaultTexture.initFromData(cg_texture/* CgTexture */.U.getDefaultTextureData("stripes", size), size, size);
        return this._defaultTexture;
    }

    /**
     * @param {function} cb
     * @param {boolean} _doScreenshotClearAlpha
     * @param {string} mimeType
     * @param {number} quality
     */
    screenShot(cb, _doScreenshotClearAlpha, mimeType, quality)
    {
        if (this.canvas && this.canvas.toBlob)
        {
            this.canvas.toBlob((blob) =>
            {
                if (cb) cb(blob);
                else this._log.log("no screenshot callback...");
            }, mimeType, quality);
        }

    }

}

// EXTERNAL MODULE: ./src/corelibs/cgl/cgl_simplerect.js
var cgl_simplerect = __webpack_require__(273);
;// CONCATENATED MODULE: ./src/corelibs/cgp/cgp_canvasattachment.js


class WebGpuCanvasAttachment
{

    /** @type {HTMLCanvasElement} */
    #canvas = null;

    /** @type {CgpContext} */
    #cgp = null;

    /** @type {GPUCanvasContext} */
    #ctx = null;

    /**
     * @param {CgpContext} cgp
     */
    constructor(cgp)
    {
        this.#cgp = cgp;
        this.#canvas = document.createElement("canvas");
        this.#canvas.id = "webgpucanvasOut";
        this.#canvas.style.width = 128 + "px";
        this.#canvas.style.height = 128 + "px";
    }

    get canvas()
    {
        return this.#canvas;
    }

    /**
     * @param {function} cb
     */
    render(cb)
    {

        const canvas = this.#cgp.canvas;
        if (this.#canvas.width != canvas.width || this.#canvas.height != canvas.height)
        {
            this.#canvas.style.width = canvas.width + "px";
            this.#canvas.style.height = canvas.height + "px";
            this.#canvas.width = canvas.width;
            this.#canvas.height = canvas.height;
        }

        if (!this.#ctx)
        {
            this.#ctx = this.#canvas.getContext("webgpu");

            if (!this.#ctx)
                return console.log("no context", this.#canvas, this.#ctx);
            this.#ctx.configure({
                "device": this.#cgp.device,
                "format": this.#cgp.presentationFormat
            });

        }

        // const cgp = this.#cgp;
        // cgp.canvasInfo.depthTextureView = this.#ctx.createView();

        this.#cgp.renderPassDescriptor = {
            "label": "preview renderpass",
            "colorAttachments": [
                {
                    "view": this.#ctx.getCurrentTexture().createView(),
                    "loadOp": "clear",
                    "storeOp": "store",
                },

            ],
            "depthStencilAttachment": {
                "view": this.#cgp.canvasInfo.depthTextureView,
                "depthClearValue": 1,
                "depthLoadOp": "clear",
                "depthStoreOp": "store",
            },
        };

        // make a render pass encoder to encode render specific commands
        this.#cgp.passEncoder = this.#cgp.commandEncoder.beginRenderPass(this.#cgp.renderPassDescriptor);
        this.#cgp.textureView = this.#ctx.getCurrentTexture().createView();
        this.#cgp.renderStart();

        cb();

        this.#cgp.tempPrevCanvas = this.#canvas;

        this.#cgp.renderEnd();
        this.#cgp.passEncoder.end();

    }

}

;// CONCATENATED MODULE: ./src/corelibs/cgp/binding/binding_storagebuffer.js





/** @extends Binding */
class BindingStorage extends Binding
{

    /** @type {CgpGguBuffer} */
    cgpbuffer = null;
    bindingType = "read-only-storage";

    /**
     * Description
     * @param {CgpContext} cgp
     * @param {string} name
     * @param {object} options
     */
    constructor(cgp, name, options)
    {
        super(cgp, name, options);
        this.cgpbuffer = options.cgpBuffer || new CgpGguBuffer(cgp, "temp", [0, 0, 0, 0]);
    }

    copy()
    {
        const b = new BindingStorage(this.cgp, this.name, this.options);
        return b;
    }

    /**
     * @returns {GPUBindingResource}
     * @param {number} _inst
     */
    getResource(_inst)
    {
        return {
            "buffer": this.cgpbuffer.gpuBuffer,
        };
    }

    /**
     * @returns {GPUBindGroupLayoutEntry}
     * @param {CgpShader} [_shader]
     */
    getLayoutEntry(_shader = null)
    {

        /** @type {GPUBufferBindingType} */
        let access = "read-only-storage";

        if (this.stage & GPUShaderStage.COMPUTE)
            if (this.cgpbuffer.hasUsage(GPUBufferUsage.COPY_SRC) && this.cgpbuffer.hasUsage(GPUBufferUsage.COPY_DST)) access = "storage";
        // else if (this.cgpbuffer.hasUsage(GPUBufferUsage.COPY_DST)) access = "write-only-storage";

        return {
            "visibility": this.stage,
            "binding": this.bindNum,
            // "minBindingSize": this.getSizeBytes(),
            // "hasDynamicOffset": 0,
            "buffer": {
                "type": access
            } };
    }

    /**
     * @param {CgpShader} _shader
     * @param {number} bindGroupNum
     */
    getShaderHeaderCode(_shader, bindGroupNum)
    {
        this.cgp.profileData.count("shadercode storage", this.name);
        let str = "";

        let access = "read";

        if (this.stage & GPUShaderStage.COMPUTE)
            if (this.cgpbuffer.hasUsage(GPUBufferUsage.COPY_SRC) && this.cgpbuffer.hasUsage(GPUBufferUsage.COPY_DST)) access = "read_write";
            else if (this.cgpbuffer.hasUsage(GPUBufferUsage.COPY_DST)) access = "write";

        str += "@group(" + bindGroupNum + ") ";
        str += "@binding(" + this.bindNum + ") ";

        str += "var<storage," + access + "> ";
        let typeStr = "array<f32>";
        str += this.name + ": " + typeStr + ";\n";

        return str + "\n";
    }
}

;// CONCATENATED MODULE: ./src/corelibs/cgp/cgp_computepipeline.js
/// <reference types="@webgpu/types" />





class ComputePipeline extends Pipeline
{

    #isValid = true;

    /** @type {string} */
    presentationFormat = null;

    /** @type {GPUComputePipelineDescriptor} */
    #pipeCfg = null;

    /** @type {GPUComputePipeline} */
    #computePipeline = null;

    /** @type {GPUBindGroupLayout} */
    bindGroupLayout = null;

    /** @type {GPUComputePassEncoder} */
    #computePassEncoder;

    #shaderListeners = [];
    #old = {};
    #errorCount = 0;
    lastRebuildReason = "first";
    rebuildCount = 0;
    profile = false;
    #rebuildNumBindingGroups = false;

    /**
     * Description
     * @param {CgpContext} _cgp
     * @param {String} name
     */
    constructor(_cgp, name)
    {
        super(_cgp, name, Pipeline.TYPE_COMPUTE);
    }

    /**
     * @param {CgpShader} shader
     * @param {CgpMesh} mesh
     */
    setPipeline(shader, mesh = null)
    {
        if (!shader)
        {
            this.log.log("pipeline unknown shader");
            return;
        }

        let needsRebuildReason = "";
        if (!this.#pipeCfg)needsRebuildReason = "no pipecfg";
        if (this.#old.mesh != mesh)needsRebuildReason = "no mesh";
        if (this.#old.shader != shader)
        {
            needsRebuildReason = "shader changed";
        }

        if (shader.needsPipelineUpdate)
        {
            needsRebuildReason = "shader needs update: " + shader.needsPipelineUpdate;
            shader.needsPipelineUpdate = "";
        }

        if (this.#rebuildNumBindingGroups)
        {
            needsRebuildReason = "num bindgroups wrong...";
        }

        this.pushDebug();

        if (needsRebuildReason != "")
        {
            this.cgp.profileData.count("pipeline created", this.name);

            this.lastRebuildReason = needsRebuildReason;
            this.rebuildCount++;
            // console.log("needsRebuildReason");
            this.cgp.pushErrorScope("createPipeline", { "logger": this.log });

            this.#rebuildNumBindingGroups = false;

            this.#pipeCfg = this.getPipelineObject(shader);
            console.log(this.#pipeCfg);

            this.#old.device = this.cgp.device;
            this.#old.shader = shader;
            this.#old.mesh = mesh;
            this.#isValid = true;
            console.log(this.#pipeCfg);
            try
            {
                this.#computePipeline = this.cgp.device.createComputePipeline(this.#pipeCfg);
            }
            catch (e)
            {
                console.error("pipe error catch...", e.message, this.#pipeCfg);
                this.#isValid = false;
            }

            this.cgp.popErrorScope(
                () =>
                {
                    console.log("this.#pipeCfg", this.#pipeCfg);
                });
        }

        if (this.cgp.branchProfiler) this.cgp.branchProfiler.pop();

    }

    /**
     * @param {CgpShader} shader
     * @returns {GPUComputePipelineDescriptor}
     */
    getPipelineObject(shader)
    {

        /** @type {Array<GPUBindGroupLayoutEntry>} */
        this.bindingGroupLayoutEntries = [];
        this.bindingGroupLayoutEntries = shader.defaultBindGroup.getLayoutEntries(shader);

        const bindGroupLayouts = [shader.defaultBindGroup.getLayout(shader)];

        /** @type {GPUPipelineLayout} */
        const pipelineLayout = this.cgp.device.createPipelineLayout({
            "label": "pipe layout " + this.name,
            "bindGroupLayouts": bindGroupLayouts
        });

        /** @type {GPUComputePipelineDescriptor} */
        let pipeCfg = {
            "label": this.name,
            "layout": pipelineLayout,
            "compute":
            {
                "module": shader.gpuShaderModule,
                "entryPoint": shader.options.entryPoint || "main"
            }
        };
        console.log("pipecft", pipeCfg, bindGroupLayouts);

        return pipeCfg;
    }

    /**
     * @param {CgpShader} shader
     * @param {Array} workGroups
     */
    compute(shader, workGroups = [8, 8])
    {
        if (!shader.gpuShaderModule) shader.compile();

        /** @type {GPUCommandEncoder} */
        const commandEncoder = this.cgp.device.createCommandEncoder();

        this.#computePassEncoder = commandEncoder.beginComputePass({ "label": "computepass " + shader.getName() });

        // if (!this.#computePipeline)
        this.setPipeline(shader);

        if (!this.#computePipeline)
        {
            this.log.warn("no render pipe");
            return;
        }

        this.#computePassEncoder.setPipeline(this.#computePipeline);
        shader.bind(this.#computePassEncoder);

        if (workGroups.length == 1) this.#computePassEncoder.dispatchWorkgroups(workGroups[0] || 8);
        else if (workGroups.length == 2) this.#computePassEncoder.dispatchWorkgroups(workGroups[0] || 8, workGroups[1] || 8);
        else if (workGroups.length == 3) this.#computePassEncoder.dispatchWorkgroups(workGroups[0] || 8, workGroups[1] || 8, workGroups[2] || 8);
        else console.log("workgroups length wrong,,,");

        this.#computePassEncoder.end();

        this.cgp.profileData.count("compute pipe", this.name);
        // console.log("llllllll", shader.defaultBindGroup.getLayout());
        const gpuCommands = commandEncoder.finish();
        this.cgp.device.queue.submit([gpuCommands]);
        this.pushDebug();
        // const entry = shader.bindingsVert[i].getBindingGroupEntry(shader.bindingCounter);
        // this._passEncoder = commandEncoder.beginComputePass();
        // this._passEncoder.setPipeline(computePipeline);
        // this.#passEncoder.setBindGroup(0, shader.defaultBindGroupshader.defaultBindGroup;
        // outBuff.setRef(gpuBuff);

    }

    dispose()
    {
        // todo...
    }

}

;// CONCATENATED MODULE: ./src/corelibs/cgp/cgp_shadermodifier.js





/**
 * @typedef UniformDescrip
 * @property {string} name
 * @property {string} type
 * @property {number} stage
 * @property {any} v1
 * @property {any} v2
 * @property {any} v3
 * @property {any} v4
 */

class ShaderModifier
{
    onBind = null;

    /**
     * @param {CgpContext} cgl
     * @param {string} name
     * @param {object} options
     */
    constructor(cgl, name, options)
    {

        /** @type {CgpContext} */
        this._cgl = cgl;
        this._name = name;
        this._origShaders = {};

        /** @type {Array<UniformDescrip>} */
        this._uniforms = [];
        this._structUniforms = [];
        this._definesToggled = {};
        this._defines = {};
        this._mods = [];
        this._textures = [];

        /** @type {object} */
        this._boundShader = null;
        this._changedDefines = true;
        this._changedUniforms = true;
        this._modulesChanged = false;
        this.needsTexturePush = false;

        /** @type {CgpShader} */
        this._lastShader = null;
        this._attributes = [];
        if (options && options.opId) this.opId = options.opId;

    }

    /**
     * @param {CgpShader} curShader
     * @param {boolean} pushShader
     */
    bind(curShader, pushShader = true)
    {
        const shader = curShader || this._cgl.getShader();
        if (!shader) return;

        this._boundShader = this._origShaders[shader.id];
        let missingMod = false;

        if (this._boundShader && this._lastShader != this._boundShader.shader) // shader changed since last bind
        {
            if (!this._boundShader.shader.hasModule(this._mods[0].id)) missingMod = true;
        }

        if (missingMod) console.warn("copy because  (missingMod)");
        if (!this._boundShader) console.warn("copy because  (!this._boundShader)");
        else if (shader.lastCompile != this._boundShader.lastCompile) console.warn("copy because  shader.lastCompile");
        if (this._modulesChanged) console.warn("copy because  this._modulesChanged");
        if (shader._needsRecompile) console.warn("copy because  shader._needsRecompile ", shader._compileReason);

        if (missingMod || !this._boundShader || shader.lastCompile != this._boundShader.lastCompile || this._modulesChanged || shader._needsRecompile)
        {
            if (this._boundShader) this._boundShader.shader.dispose();
            if (shader._needsRecompile) shader.compile();
            this.needsTexturePush = true;

            this._boundShader = this._origShaders[shader.id] =
            {
                "lastCompile": shader.lastCompile,
                "orig": shader,
                "shader": shader.copy()
            };

            console.log("mod shaderrrrrrrrrrr", shader.getName(), this._boundShader.shader.getName());

            this._addModulesToShader(this._boundShader.shader);
            this._updateDefinesShader(this._boundShader.shader);
            this._updateUniformsShader(this._boundShader.shader);
        }

        this._boundShader.wireframe = shader.wireframe;
        if (this._changedDefines) this._updateDefines();
        if (this._changedUniforms) this._updateUniforms();

        if (pushShader)
        {
            this._cgl.pushShader(this._boundShader.shader);
            // console.log(this._boundShader.shader.id);
        }

        // this._boundShader.shader.copyUniformValues(this._boundShader.orig);

        if (this.needsTexturePush)
        {
            for (let j = 0; j < this._textures.length; j++)
            {
                const uniformName = this._textures[j][0];
                const tex = this._textures[j][1];
                const texType = this._textures[j][2];

                if (this._getUniform(uniformName))
                {
                    const name = this.getPrefixedName(uniformName);
                    const uni = this._boundShader.shader.getUniform(name);

                    if (uni) this._boundShader.shader.pushTexture(uni, tex, texType);
                }
            }

            this.needsTexturePush = false;
            this._textures.length = 0;
        }

        this._modulesChanged = false;

        this._boundShader.shader.fromMod = this;

        if (this.onBind) this.onBind(this._boundShader.shader);

        return this._boundShader.shader;
    }

    /**
     * @param {boolean} popShader
     */
    unbind(popShader = true)
    {
        if (this._boundShader)
            if (popShader) this._cgl.popShader();

        this._boundShader = null;
    }

    /**
     * @param {CgpShader} shader
     */
    _addModulesToShader(shader)
    {
        let firstMod;

        if (this._mods.length > 1) firstMod = this._mods[0];

        for (let i = 0; i < this._mods.length; i++) shader.addModule(this._mods[i], firstMod);
    }

    /**
     * @param {import("../cg/cg_shader.js").ShaderModule} mod
     */
    _removeModulesFromShader(mod)
    {
        for (const j in this._origShaders) this._origShaders[j].shader.removeModule(mod);
    }

    /**
     * @param {import("../cg/cg_shader.js").ShaderModule} mod
     */
    addModule(mod)
    {
        this._mods.push(mod);
        this._modulesChanged = true;
    }

    /**
     * @param {string} title
     */
    removeModule(title)
    {
        const indicesToRemove = [];

        let found = false;
        for (let i = 0; i < this._mods.length; i++)
        {
            if (this._mods[i].title == title)
            {
                found = true;
                this._removeModulesFromShader(this._mods[i]);
                indicesToRemove.push(i);
            }
        }

        // * go in reverse order so the indices of the mods stay the same
        for (let j = indicesToRemove.length - 1; j >= 0; j -= 1)
            this._mods.splice(indicesToRemove[j], 1);

        this._modulesChanged = true;
    }

    /**
     * @param {CgpShader} shader
     */
    _updateUniformsShader(shader)
    {
        for (let i = 0; i < this._uniforms.length; i++)
        {
            const uni = this._uniforms[i];
            const name = this.getPrefixedName(uni.name);

            if (!shader.hasUniform(name))
            {
                console.log("shadermod uni ", name, shader.id, uni.stage);
                const u = new CgpUniform(shader, uni.type, name, uni.v1, uni.v2, uni.v3, uni.v4);

                console.log(uni);
                shader.addUniform(u, uni.stage);
            }
        }
    }

    _updateUniforms()
    {
        for (const j in this._origShaders)
            this._updateUniformsShader(this._origShaders[j].shader);

        this._changedUniforms = false;
    }

    /**
     * @param {CgShader} shader
     * @param {string} uniformName
     * @param {number} value
     */
    _setUniformValue(shader, uniformName, value)
    {
        const uniform = shader.getUniform(uniformName);

        if (uniform) uniform.setValue(value);
    }

    /**
     * @param {string} name
     * @param {number} value
     */
    setUniformValue(name, value)
    {
        const uni = this._getUniform(name);
        if (!uni) return;

        const defineName = this.getPrefixedName(name);

        for (const j in this._origShaders)
        {
            this._setUniformValue(this._origShaders[j].shader, defineName, value);
        }
    }

    /**
     * @param {string} name
     */
    hasUniform(name)
    {
        return !!this._getUniform(name);
    }

    /**
     * @param {string} name
     */
    _getUniform(name)
    {
        for (let i = 0; i < this._uniforms.length; i++)
        {
            if (this._uniforms[i].name == name) return this._uniforms[i];
        }
        return null;
    }

    /**
     * @param {number} stage
     * @param {string} name
     * @param {string} type
     * @param {any} valOrPort
     * @param {any} v2
     * @param {any} v3
     * @param {any} v4
     */
    addUniform(stage, type, name, valOrPort, v2, v3, v4)
    {
        if (!this._getUniform(name))
        {
            this._uniforms.push(
                {
                    "name": name,
                    "stage": stage,
                    "type": type,
                    "v1": valOrPort,
                    "v2": v2,
                    "v3": v3,
                    "v4": v4,
                });
            this._changedUniforms = true;
        }
    }

    // addUniformFrag(type, name, valOrPort, v2, v3, v4)
    // {
    //     this.addUniform(type, name, valOrPort, v2, v3, v4, null, null, null, "frag");
    //     this._changedUniforms = true;
    // }

    // addUniformVert(type, name, valOrPort, v2, v3, v4)
    // {
    //     this.addUniform(type, name, valOrPort, v2, v3, v4, null, null, null, "vert");
    //     this._changedUniforms = true;
    // }

    // addUniformBoth(type, name, valOrPort, v2, v3, v4)
    // {
    //     this.addUniform(type, name, valOrPort, v2, v3, v4, null, null, null, "both");
    //     this._changedUniforms = true;
    // }

    // addUniformStruct(structName, uniformName, members, shaderType)
    // {
    //     for (let i = 0; i < members.length; i += 1)
    //     {
    //         const member = members[i];
    //         if ((member.type === "2i" || member.type === "i" || member.type === "3i") && shaderType === "both")
    //             console.error("Adding an integer struct member to both shaders can potentially error. Please use different structs for each shader. Error occured in struct:", structName, " with member:", member.name, " of type:", member.type, ".");

    //         if (!this._getUniform(uniformName + "." + member.name))
    //         {
    //             this.addUniform(
    //                 member.type,
    //                 uniformName + "." + member.name,
    //                 member.v1,
    //                 member.v2,
    //                 member.v3,
    //                 member.v4,
    //                 uniformName,
    //                 structName,
    //                 member.name,
    //                 shaderType
    //             );
    //         }
    //     }
    //     if (!this._getStructUniform(uniformName))
    //     {
    //         this._structUniforms.push({
    //             "structName": structName,
    //             "uniformName": uniformName,
    //             "members": members,
    //             "shaderType": shaderType,
    //         });
    //     }
    // }

    // addUniformStructVert(structName, uniformName, members)
    // {
    //     this.addUniformStruct(structName, uniformName, members, "vert");
    // }

    // addUniformStructFrag(structName, uniformName, members)
    // {
    //     this.addUniformStruct(structName, uniformName, members, "frag");
    // }

    // addUniformStructBoth(structName, uniformName, members)
    // {
    //     this.addUniformStruct(structName, uniformName, members, "both");
    // }

    addAttribute(attr)
    {
        for (let i = 0; i < this._attributes.length; i++)
        {
            if (this._attributes[i].name == attr.name && this._attributes[i].nameFrag == attr.nameFrag) return;
        }
        this._attributes.push(attr);
    }

    pushTexture(uniformName, tex, texType)
    {
        if (!tex) throw (new Error("no texture given to texturestack"));

        this._textures.push([uniformName, tex, texType]);
        this.needsTexturePush = true;
    }

    /**
     * @param {string} name
     * @param {CgShader} shader
     */
    _removeUniformFromShader(name, shader)
    {
        if (shader.hasUniform(name)) shader.removeUniform(name);
    }

    /**
     * @param {string} name
     */
    removeUniform(name)
    {
        if (this._getUniform(name))
        {
            for (let j = this._uniforms.length - 1; j >= 0; j -= 1)
            {
                const nameToRemove = name;

                if (this._uniforms[j].name == name)
                {
                    for (const k in this._origShaders)
                    {
                        this._removeUniformFromShader(
                            this.getPrefixedName(nameToRemove),
                            this._origShaders[k].shader
                        );
                    }

                    this._uniforms.splice(j, 1);
                }
            }
            this._changedUniforms = true;
        }
    }

    /**
     * @param {string} name
     */
    getPrefixedName(name)
    {
        const prefix = this._mods[0].group;
        if (prefix === undefined)
        {
            return;
        }
        if (name.startsWith("MOD_"))
        {
            name = name.substr("MOD_".length);
            name = "mod" + prefix + "_" + name;
        }
        return name;
    }

    /**
     * @param {CgpShader} shader
     */
    _updateDefinesShader(shader)
    {
        for (const i in this._defines)
        {
            const name = this.getPrefixedName(i);
            if (this._defines[i] !== null && this._defines[i] !== undefined) shader.define(name, this._defines[i]);
            else shader.removeDefine(name);
        }

        for (const i in this._definesToggled)
        {
            const name = this.getPrefixedName(i);
            shader.toggleDefine(name, this._definesToggled[i]);
        }
    }

    _updateDefines()
    {
        for (const j in this._origShaders) this._updateDefinesShader(this._origShaders[j].shader);

        this._changedDefines = false;
    }

    /**
     * @param {string | number} what
     * @param {boolean} value
     */
    define(what, value)
    {
        if (value === undefined)value = true;
        this._defines[what] = value;
        this._changedDefines = true;
    }

    /**
     * @param {string} name
     */
    removeDefine(name)
    {
        this._defines[name] = null;
        this._changedDefines = true;
    }

    /**
     * @param {string} name
     */
    hasDefine(name)
    {
        if (this._defines[name] !== null && this._defines[name] !== undefined) return true;
        return false;
    }

    /**
     * @param {string} name
     * @param {any} b
     */
    toggleDefine(name, b)
    {
        this._changedDefines = true;
        this._definesToggled[name] = b;
    }

    currentShader()
    {
        if (!this._boundShader) return null;
        return this._boundShader.shader;
    }

    dispose()
    {

    }
}



;// CONCATENATED MODULE: ./src/corelibs/cgp/index.js
















const CGP = {
    "Context": CgpContext,
    "Shader": CgpShader,
    "Mesh": CgpMesh,
    "Texture": Texture,
    "Uniform": CgpUniform,
    "MESHES": cgl_simplerect/* MESHES */.S,
    "GPUBuffer": CgpGguBuffer
};

window.CABLES = window.CABLES || {};
window.CABLES.CGP = window.CABLES.CGP || CGP;
window.CGP = window.CGP || CGP;

window.CGP.WebGpuCanvasAttachment = WebGpuCanvasAttachment;
window.CGP.RenderPipeline = RenderPipeline;
window.CGP.ComputePipeline = ComputePipeline;
window.CGP.ShaderModifier = ShaderModifier;

window.CGP.BindingStorage = BindingStorage;
window.CGP.BindingUniform = BindingUniform;
window.CGP.BindingTexture = BindingTexture;
window.CGP.BindingSampler = BindingSampler;




/***/ }),

/***/ 564:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* unused harmony exports WebAudio, WEBAUDIO */
/* harmony import */ var cables__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(440);
/** @namespace WEBAUDIO */



/**
 * Part of the Web Audio API, the AudioBuffer interface represents a short audio asset residing in memory.
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/AudioBuffer}
 */

/**
 * Part of the Web Audio API, the AudioNode interface is a generic interface for representing an audio processing module.
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/AudioNode}
 */

/**
 * The AudioContext interface represents an audio-processing graph built from audio modules linked together
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/AudioContext}
 */

class WebAudio
{

    constructor()
    {
        this.toneJsInitialized = false;
    }

    /**
     * Checks if a global audio context has been created and creates
     * it if necessary. This audio context can be used for native Web Audio as well as Tone.js ops.
     * Associates the audio context with Tone.js if it is being used
     * @param {Op} op - The operator which needs the Audio Context
     */
    createAudioContext(op)
    {
        window.AudioContext = window.AudioContext || window.webkitAudioContext;
        if (window.AudioContext)
        {
            if (!window.audioContext)
            {
                window.audioContext = new AudioContext();
            }
            // check if tone.js lib is being used
            if (window.Tone && !this.toneJsInitialized)
            {
                // set current audio context in tone.js, and discard potentially audio context created by tone
                if (Tone.setContext) Tone.setContext(window.audioContext, true);
                this.toneJsInitialized = true;
            }
        }
        else
        {
            if (op.patch.config.onError)op.logError("NO_WEBAUDIO", "Web Audio is not supported in this browser.");
            return;
        }
        return window.audioContext;
    }

    /**
     * Returns the audio context.
     * Before `createAudioContext` must have been called at least once.
     * It most cases you should use `createAudioContext`, which just returns the audio context
     * when it has been created already.
     */
    _getAudioContext()
    {
        return window.audioContext;
    }

    /**
     * Creates an audio in port for the op with name `portName`
     * When disconnected it will disconnect the previous connected audio node
     * from the op's audio node.
     * @param {Op} op - The operator to create the audio port in
     * @param {string} portName - The name of the port
     * @param {AudioNode} audioNode - The audionode incoming connections should connect to
     * @param {number} [inputChannelIndex=0] - If the audio node has multiple inputs, this is the index of the input channel to connect to
     * @returns {Port|undefined} - The newly created audio in port or `undefined` if there was an error
     */
    createAudioInPort(op, portName, audioNode, inputChannelIndex)
    {
        if (!op || !portName || !audioNode)
        {
            const msg = "ERROR: createAudioInPort needs three parameters, op, portName and audioNode";
            op.log(msg);
            throw new Error(msg);
            // return;
        }
        if (!inputChannelIndex)
        {
            inputChannelIndex = 0;
        }
        op.webAudio = op.webAudio || {};
        op.webAudio.audioInPorts = op.webAudio.audioInPorts || [];
        const port = op.inObject(portName);
        port.webAudio = {};
        port.webAudio.previousAudioInNode = null;
        port.webAudio.audioNode = audioNode;

        op.webAudio.audioInPorts[portName] = port;

        port.onChange = function ()
        {
            const audioInNode = port.get();
            // when port disconnected, disconnect audio nodes
            if (!audioInNode)
            {
                if (port.webAudio.previousAudioInNode)
                {
                    try
                    {
                        if (port.webAudio.previousAudioInNode.disconnect) port.webAudio.previousAudioInNode.disconnect(port.webAudio.audioNode, 0, inputChannelIndex);
                        op.setUiError("audioCtx", null);
                    }
                    catch (e)
                    {
                        try
                        {
                            port.webAudio.previousAudioInNode.disconnect(port.webAudio.audioNode);
                        }
                        catch (er)
                        {
                            op.log(
                                "Disconnecting audio node with in/out port index, as well as without in/out-port-index did not work ",
                                e,
                            );
                            if (e.printStackTrace)
                            {
                                e.printStackTrace();
                            }
                            throw e;
                        }
                    }
                }
            }
            else
            {
                try
                {
                    if (audioInNode.connect)
                    {
                        audioInNode.connect(port.webAudio.audioNode, 0, inputChannelIndex);
                        op.setUiError("audioCtx", null);
                    }
                    else op.setUiError("audioCtx", "The passed input is not an audio context. Please make sure you connect an audio context to the input.", 2);
                }
                catch (e)
                {
                    op.log("Error: Failed to connect web audio node!", e);
                    op.log("port.webAudio.audioNode", port.webAudio.audioNode);
                    op.log("audioInNode: ", audioInNode);
                    op.log("inputChannelIndex:", inputChannelIndex);
                    op.log("audioInNode.connect: ", audioInNode.connect);
                    throw e;
                }
            }
            port.webAudio.previousAudioInNode = audioInNode;
        };
        // TODO: Maybe add subtype to audio-node-object?
        return port;
    }

    /**
     * Creates an audio out port which takes care of (dis-)connecting on it’s own
     * @param {Op} op - The op to create an audio out port for
     * @param {string} portName - The name of the port to be created
     * @param {AudioNode} audioNode - The audio node to link to the port
     * @returns {(CABLES.Port|undefined)} - The newly created audio out port or `undefined` if there was an error
     */
    createAudioOutPort(op, portName, audioNode)
    {
        if (!op || !portName || !audioNode)
        {
            const msg = "ERROR: createAudioOutPort needs three parameters, op, portName and audioNode";
            op.log(msg);
            throw new Error(msg);
        }

        const port = op.outObject(portName);
        // TODO: Maybe add subtype to audio-node-object?
        port.set(audioNode);
        return port;
    }

    /**
     * Creates an audio param in port for the op with name portName.
     * The port accepts other audio nodes as signals as well as values (numbers)
     * When the port is disconnected it will disconnect the previous connected audio node
     * from the op's audio node and restore the number value set before.
     *
     * @deprecated
     * @param {Op} op - The operator to create an audio param input port for
     * @param {string} portName - The name of the port to create
     * @param audioNode
     * @param options
     * @param defaultValue
     * @returns {(CABLES.Port|undefined)} - The newly created port, which takes care of (dis-)connecting on its own, or `undefined` if there was an error
     */
    createAudioParamInPort(op, portName, audioNode, options, defaultValue)
    {
        if (!op || !portName || !audioNode)
        {
            op.log("ERROR: createAudioParamInPort needs three parameters, op, portName and audioNode");
            if (op && op.name) op.log("opname: ", op.name);
            op.log("portName", portName);
            op.log("audioNode: ", audioNode);
            return;
        }
        op.webAudio = op.webAudio || {};
        op.webAudio.audioInPorts = op.webAudio.audioInPorts || [];
        // var port = op.inObject(portName);
        const port = op.inDynamic(
            portName,
            [cables__WEBPACK_IMPORTED_MODULE_0__/* .CONSTANTS */ .a.OP.OP_PORT_TYPE_VALUE, cables__WEBPACK_IMPORTED_MODULE_0__/* .CONSTANTS */ .a.OP.OP_PORT_TYPE_OBJECT],
            options,
            defaultValue,
        );
        port.webAudio = {};
        port.webAudio.previousAudioInNode = null;
        port.webAudio.audioNode = audioNode;

        op.webAudio.audioInPorts[portName] = port;

        port.onChange = () =>
        {
            const audioInNode = port.get();
            const node = port.webAudio.audioNode;
            const audioCtx = this._getAudioContext();

            if (audioInNode != undefined)
            {
                if (typeof audioInNode === "object" && audioInNode.connect)
                {
                    try
                    {
                        audioInNode.connect(node);
                    }
                    catch (e)
                    {
                        op.log("Could not connect audio node: ", e);
                        if (e.printStackTrace)
                        {
                            e.printStackTrace();
                        }
                        throw e;
                    }
                    port.webAudio.previousAudioInNode = audioInNode;
                }
                else
                {
                    // tone.js audio param
                    if (node._param && node._param.minValue && node._param.maxValue)
                    {
                        if (audioInNode >= node._param.minValue && audioInNode <= node._param.maxValue)
                        {
                            try
                            {
                                if (node.setValueAtTime)
                                {
                                    node.setValueAtTime(audioInNode, audioCtx.currentTime);
                                }
                                else
                                {
                                    node.value = audioInNode;
                                }
                            }
                            catch (e)
                            {
                                op.log("Possible AudioParam problem with tone.js op: ", e);
                                if (e.printStackTrace)
                                {
                                    e.printStackTrace();
                                }
                                throw e;
                            }
                        }
                        else
                        {
                            op.log("Warning: The value for an audio parameter is out of range!");
                        }
                    } // native Web Audio param
                    else if (node.minValue && node.maxValue)
                    {
                        if (audioInNode >= node.minValue && audioInNode <= node.maxValue)
                        {
                            try
                            {
                                if (node.setValueAtTime)
                                {
                                    node.setValueAtTime(audioInNode, audioCtx.currentTime);
                                }
                                else
                                {
                                    node.value = audioInNode;
                                }
                            }
                            catch (e)
                            {
                                op.log(
                                    "AudioParam has minValue / maxValue defined, and value is in range, but setting the value failed! ",
                                    e,
                                );
                                if (e.printStackTrace)
                                {
                                    e.printStackTrace();
                                }
                                throw e;
                            }
                        }
                        else
                        {
                            op.log("Warning: The value for an audio parameter is out of range!");
                        }
                    } // no min-max values, try anyway
                    else
                    {
                        try
                        {
                            if (node.setValueAtTime)
                            {
                                node.setValueAtTime(audioInNode, audioCtx.currentTime);
                            }
                            else
                            {
                                node.value = audioInNode;
                            }
                        }
                        catch (e)
                        {
                            op.log("Possible AudioParam problem (without minValue / maxValue): ", e);
                            if (e.printStackTrace)
                            {
                                e.printStackTrace();
                            }
                            throw e;
                        }
                    }

                    if (port.webAudio.previousAudioInNode && port.webAudio.previousAudioInNode.disconnect)
                    {
                        try
                        {
                            port.webAudio.previousAudioInNode.disconnect(node);
                        }
                        catch (e)
                        {
                            op.log("Could not disconnect previous audio node: ", e);
                            throw e;
                        }
                        port.webAudio.previousAudioInNode = undefined;
                    }
                }
            }
            else
            {
                // disconnected
                if (port.webAudio.previousAudioInNode)
                {
                }
            }
        };
        return port;
    }

    /**
     * Loads an audio file and updates the loading indicators when cables is run in the editor.
     * @param {Patch} patch - The cables patch, when called from inside an op this is `op.patch`
     * @param {string} url - The url of the audio file to load
     * @param {function} onFinished - The callback to be called when the loading is finished, passes the AudioBuffer
     * @param {function} onError - The callback when there was an error loading the file, the rror message is passed
     * @param loadingTask
     * @see {@link https://developer.mozilla.org/de/docs/Web/API/AudioContext/decodeAudioData}
     */
    loadAudioFile(patch, url, onFinished, onError, loadingTask)
    {
        const audioContext = this.createAudioContext();

        if (!audioContext) onError(new Error("No Audiocontext"));

        let loadingId = null;
        if (loadingTask || loadingTask === undefined)
        {
            loadingId = patch.loading.start("audio", url);
            if (patch.isEditorMode()) gui.jobs().start({ "id": "loadaudio" + loadingId, "title": " loading audio (" + url + ")" });
        }
        const request = new XMLHttpRequest();

        if (!url) return;

        request.open("GET", url, true);
        request.responseType = "arraybuffer";

        request.onload = function ()
        {
            patch.loading.finished(loadingId);
            if (patch.isEditorMode()) gui.jobs().finish("loadaudio" + loadingId);

            audioContext.decodeAudioData(request.response, onFinished, onError).catch((e) =>
            {
                onError(e);
            });
        };
        request.send();
    }

    /**
     * Checks if the passed time is a valid time to be used in any of the Tone.js ops.
     * @deprecated
     * @param {(string|number)} t - The time to check
     * @returns {boolean} - True if time is valid, false if not
     */
    isValidToneTime(t)
    {
        try
        {
            const time = new Tone.Time(t);
        }
        catch (e)
        {
            return false;
        }
        return true;
    }

    /**
     * Checks if the passed note is a valid note to be used with Tone.js
     * @deprecated
     * @param {string} note - The note to be checked, e.g. `"C4"`
     * @returns {boolean} - True if the note is a valid note, false otherwise
     */
    isValidToneNote(note)
    {
        try
        {
            Tone.Frequency(note);
        }
        catch (e)
        {
            return false;
        }
        return true;
    }
}

const WEBAUDIO = new WebAudio();

window.CABLES = window.CABLES || {};
window.CABLES.WEBAUDIO = WEBAUDIO;




/***/ }),

/***/ 125:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  A: () => (/* binding */ Events)
});

;// CONCATENATED MODULE: ../shared/client/src/eventlistener.js
class EventListener
{

    /**
     * @param {Object} emitter
     * @param {string} id
     * @param {string} eventName
     * @param {Function} cb
     */
    constructor(emitter, id, eventName, cb)
    {
        this.targetObj = emitter;
        this.id = id;
        this.eventName = eventName;
        this.cb = cb;
    }

    remove()
    {
        this.targetObj.off(this.id);
    }
}

;// CONCATENATED MODULE: ../shared/client/src/helper.js
/**
 * Shared helper methods for cables uis
 */
class Helper
{
    constructor()
    {
        this._simpleIdCounter = 0;
    }

    /**
     * generate a random v4 uuid
     *
     * @return {string}
     */
    uuid()
    {
        let d = new Date().getTime();
        return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) =>
        {
            const r = (d + Math.random() * 16) % 16 | 0;
            d = Math.floor(d / 16);
            return (c === "x" ? r : (r & 0x3) | 0x8).toString(16);
        });
    }

    /**
     * checks value for !isNan and isFinite
     *
     * @param {string} n
     * @return {boolean}
     */
    isNumeric(n)
    {
        const nn = parseFloat(n);
        return !isNaN(nn) && isFinite(nn);
    }

    /**
     * generate a simple ID using an internal counter
     *
     * @return {Number} new id
     * @static
     */
    simpleId()
    {
        this._simpleIdCounter++;
        return this._simpleIdCounter;
    }

    pathLookup(obj, path)
    {
        const parts = path.split(".");
        if (parts.length == 1)
        {
            return obj[parts[0]];
        }
        return this.pathLookup(obj[parts[0]], parts.slice(1).join("."));
    }

}
/* harmony default export */ const helper = (new Helper());

// EXTERNAL MODULE: ../shared/client/src/logger.js
var logger = __webpack_require__(849);
;// CONCATENATED MODULE: ../shared/client/src/eventtarget.js




/**
 * add eventlistener functionality to classes
 */
class Events
{
    #eventLog = new logger/* default */.A("eventtarget");

    /** @type {Object<string,EventListener>} */
    #listeners = {};
    #logEvents = false;
    #logName = "";
    #eventCallbacks = {};
    #countErrorUnknowns = 0;
    eventsPaused = false;

    constructor()
    {
    }

    /**
     * @callback whatever
     * @param {...any} param
     */

    /**
     * add event listener
     * @param {string} eventName event name
     * @param {whatever} cb callback
     * @param {string} idPrefix prefix for id, default empty
     * @return {EventListener} eventlistener
     */
    on(eventName, cb, idPrefix = "")
    {
        const newId = (idPrefix || "") + helper.simpleId();

        const event = new EventListener(this, newId, eventName, cb);

        if (!this.#eventCallbacks[eventName]) this.#eventCallbacks[eventName] = [event];
        else this.#eventCallbacks[eventName].push(event);

        this.#listeners[event.id] = event;

        return event;
    }

    removeAllEventListeners()
    {
        for (const i in this.#listeners)
        {
            this.off(this.#listeners[i]);
        }
    }

    /**
     *
     * @param {string} which
     * @param {whatever} cb
     */
    addEventListener(which, cb, idPrefix = "")
    {
        return this.on(which, cb, idPrefix);
    }

    /**
     * check event listener registration
     * @param {string|EventListener} id event id
     * @param {whatever} cb callback - deprecated
     * @return {boolean}
     */
    hasEventListener(id, cb = null)
    {
        if (id && !cb)
        {
            if (typeof id == "string") // check by id
                return !!this.#listeners[id];
            else
                return !!this.#listeners[id.id];

        }
        else
        {
            this.#eventLog.warn("old eventtarget function haseventlistener!");
            if (id && cb)
            {
                if (this.#eventCallbacks[id])
                {
                    const idx = this.#eventCallbacks[id].indexOf(cb);
                    return idx !== -1;
                }
            }
        }
    }

    /**
     * check event listener by name
     * @param {string } eventName event name
     * @return {boolean}
     */
    hasListenerForEventName(eventName)
    {
        return this.#eventCallbacks[eventName] && this.#eventCallbacks[eventName].length > 0;
    }

    /** @deprecated */
    removeEventListener(id)
    {
        return this.off(id);
    }

    /**
     * remove event listener registration
     * @param {EventListener} listenerParam
     */
    off(listenerParam)
    {
        if (listenerParam === null || listenerParam === undefined)
        {
            this.#eventLog.warn("removeEventListener id null", listenerParam);
            return;
        }

        let id = listenerParam; // old off was using id strings directly, now uses eventlistener class
        // @ts-ignore
        if (listenerParam.eventName) id = listenerParam.id;

        if (typeof id != "string")
        {
            console.log("old function signature: removeEventListener! use listener id");
            return;
        }

        const event = this.#listeners[id];
        if (!event)
        {
            if (this.#countErrorUnknowns == 20) this.#eventLog.warn("stopped reporting unknown events");
            if (this.#countErrorUnknowns < 20) this.#eventLog.warn("could not find event...", id);
            this.#countErrorUnknowns++;
            return;
        }

        let removeCount = 0;

        let found = true;
        while (found)
        {
            found = false;
            let index = -1;
            for (let i = 0; i < this.#eventCallbacks[event.eventName].length; i++)
            {
                if (this.#eventCallbacks[event.eventName][i].id.indexOf(id) === 0) // this._eventCallbacks[event.eventName][i].id == which ||
                {
                    found = true;
                    index = i;
                }
            }

            if (index !== -1)
            {
                this.#eventCallbacks[event.eventName].splice(index, 1);
                delete this.#listeners[id];
                removeCount++;
            }
        }

        if (removeCount == 0)console.log("no events removed", event.eventName, id);

        return;
    }

    /**
     * enable/disable logging of events for the class
     *
     * @param {boolean} enabled
     * @param {string} logName
     */
    logEvents(enabled, logName)
    {
        this.#logEvents = enabled;
        this.#logName = logName;
    }

    /**
     * emit event
     *
     * @param {string} which event name
     * @param {*} param1
     * @param {*} param2
     * @param {*} param3
     * @param {*} param4
     * @param {*} param5
     * @param {*} param6
     */
    emitEvent(which, param1 = null, param2 = null, param3 = null, param4 = null, param5 = null, param6 = null, param7 = null, param8 = null)
    {
        if (this.eventsPaused) return;
        if (this.#logEvents) this.#eventLog.log("[event] ", this.#logName, which, this.#eventCallbacks);

        if (this.#eventCallbacks[which])
        {
            for (let i = 0; i < this.#eventCallbacks[which].length; i++)
            {
                if (this.#eventCallbacks[which][i])
                {
                    this.#eventCallbacks[which][i].cb(param1, param2, param3, param4, param5, param6, param7, param8);
                }
            }
        }
        else
        {
            if (this.#logEvents) this.#eventLog.log("[event] has no event callback", which, this.#eventCallbacks);
        }
    }
}


/***/ }),

/***/ 849:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ Logger)
/* harmony export */ });
/* eslint-disable no-console */
class Logger
{

    /**
     * @param {any} initiator
     * @param {Object} options
     */
    constructor(initiator, options)
    {
        this.initiator = initiator;
        this._options = options;
    }

    /**
     * @param {string} t
     */
    stack(t)
    {
        console.info("[" + this.initiator + "] ", t);
        console.log((new Error()).stack);
    }

    /**
     * @param {string} t
     */
    groupCollapsed(t)
    {
        if ((CABLES.UI && CABLES.UI.logFilter.filterLog({ "initiator": this.initiator, "level": 0 }, ...arguments)) || !CABLES.logSilent) console.log("[" + this.initiator + "]", ...arguments);

        console.groupCollapsed("[" + this.initiator + "] " + t);
    }

    /**
     * @param {any[][]} t
     */
    table(t)
    {
        console.table(t);
    }

    groupEnd()
    {
        console.groupEnd();
    }

    error()
    {
        if ((CABLES.UI && CABLES.UI.logFilter.filterLog({ "initiator": this.initiator, "level": 2 }, ...arguments)) || !CABLES.UI)
        {
            console.error("[" + this.initiator + "]", ...arguments);
        }

        if (this._options && this._options.onError)
        {
            this._options.onError(this.initiator, ...arguments);
            // console.log("emitevent onerror...");
            // CABLES.patch.emitEvent("onError", this.initiator, ...arguments);
            // CABLES.logErrorConsole("[" + this.initiator + "]", ...arguments);
        }
    }

    errorGui()
    {
        if (CABLES.UI) CABLES.UI.logFilter.filterLog({ "initiator": this.initiator, "level": 2 }, ...arguments);
    }

    warn()
    {
        if ((CABLES.UI && CABLES.UI.logFilter.filterLog({ "initiator": this.initiator, "level": 1 }, ...arguments)) || !CABLES.logSilent)
            console.warn("[" + this.initiator + "]", ...arguments);
    }

    verbose()
    {
        if ((CABLES.UI && CABLES.UI.logFilter.filterLog({ "initiator": this.initiator, "level": 0 }, ...arguments)) || !CABLES.logSilent)
            console.log("[" + this.initiator + "]", ...arguments);
    }

    info()
    {
        if ((CABLES.UI && CABLES.UI.logFilter.filterLog({ "initiator": this.initiator, "level": 0 }, ...arguments)) || !CABLES.logSilent)
            console.info("[" + this.initiator + "]", ...arguments);
    }

    log()
    {
        if ((CABLES.UI && CABLES.UI.logFilter.filterLog({ "initiator": this.initiator, "level": 0 }, ...arguments)) || !CABLES.logSilent)
            console.log("[" + this.initiator + "]", ...arguments);
    }

    logGui()
    {
        if (CABLES.UI) CABLES.UI.logFilter.filterLog({ "initiator": this.initiator, "level": 0 }, ...arguments);
    }

    userInteraction(text)
    {
        // this.log({ "initiator": "userinteraction", "text": text });
    }
}


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	__webpack_require__(748);
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	__webpack_require__(772);
/******/ 	__webpack_require__(626);
/******/ 	__webpack_require__(564);
/******/ 	var __webpack_exports__ = __webpack_require__(606);
/******/ 	var __webpack_export_target__ = (CABLES = typeof CABLES === "undefined" ? {} : CABLES);
/******/ 	for(var i in __webpack_exports__) __webpack_export_target__[i] = __webpack_exports__[i];
/******/ 	if(__webpack_exports__.__esModule) Object.defineProperty(__webpack_export_target__, "__esModule", { value: true });
/******/ 	
/******/ })()
;


var CABLES = CABLES || {}; CABLES.build = {"timestamp":1751991309701,"created":"2025-07-08T16:15:09.701Z","git":{"branch":"master","commit":"5ac55484344fd962b81b053230809aa18281d23f","date":"1751875203","message":"sidebar colorpicker opacity cables-gl/cables/issues/7458"}};
//# sourceMappingURL=cables.js.map

if(!CABLES.exportedPatches) CABLES.exportedPatches={};CABLES.exportedPatches['LH3vXR']={
    "_id": "68836421c15716b83f7e1c95",
    "ops": [
        {
            "id": "m12gvq4s6",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Max Pixel Density (DPR)",
                    "value": 2
                },
                {
                    "name": "FPS Limit",
                    "value": 0
                },
                {
                    "name": "Reduce FPS unfocussed",
                    "value": 0
                },
                {
                    "name": "Transparent",
                    "value": 0
                },
                {
                    "name": "Active",
                    "value": 1
                },
                {
                    "name": "Focus canvas",
                    "value": 1
                }
            ],
            "portsOut": [
                {
                    "name": "trigger",
                    "links": [
                        {
                            "portIn": "exe",
                            "portOut": "trigger",
                            "objIn": "lhxij3gc7",
                            "objOut": "m12gvq4s6"
                        }
                    ]
                },
                {
                    "name": "width",
                    "value": 1312.5
                },
                {
                    "name": "height",
                    "value": 1269
                },
                {
                    "name": "Pixel Density",
                    "value": 1.5
                }
            ],
            "objName": "Ops.Gl.MainLoop_v2"
        },
        {
            "id": "70unrfnot",
            "uiAttribs": {},
            "portsOut": [
                {
                    "name": "Result",
                    "links": [
                        {
                            "portIn": "Numbers_0",
                            "portOut": "Result",
                            "objIn": "ddmjl0ano",
                            "objOut": "70unrfnot"
                        },
                        {
                            "portIn": "Number",
                            "portOut": "Result",
                            "objIn": "0w0e4zzvn",
                            "objOut": "70unrfnot"
                        }
                    ]
                }
            ],
            "objName": "Ops.Ui.VizNumber"
        },
        {
            "id": "ttgztrbyf",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Variable",
                    "value": "BarCount"
                }
            ],
            "objName": "Ops.Vars.VarSetNumber_v2"
        },
        {
            "id": "31gddanb5",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Variable",
                    "value": "UsingRelativeHeight"
                }
            ],
            "objName": "Ops.Vars.VarSetNumber_v2"
        },
        {
            "id": "jw4e0lcga",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Boolean",
                    "value": 0
                }
            ],
            "portsOut": [
                {
                    "name": "Bool",
                    "links": [
                        {
                            "portIn": "Value",
                            "portOut": "Bool",
                            "objIn": "31gddanb5",
                            "objOut": "jw4e0lcga"
                        },
                        {
                            "portIn": "Numbers_2",
                            "portOut": "Bool",
                            "objIn": "ddmjl0ano",
                            "objOut": "jw4e0lcga"
                        }
                    ]
                }
            ],
            "objName": "Ops.Ui.VizBool"
        },
        {
            "id": "lhxij3gc7",
            "uiAttribs": {},
            "portsOut": [
                {
                    "name": "trigger 0",
                    "links": [
                        {
                            "portIn": "Trigger",
                            "portOut": "trigger 0",
                            "objIn": "vp7gvop3r",
                            "objOut": "lhxij3gc7"
                        }
                    ]
                },
                {
                    "name": "trigger 9",
                    "links": [
                        {
                            "portIn": "Trigger",
                            "portOut": "trigger 9",
                            "objIn": "nk7epn95s",
                            "objOut": "lhxij3gc7"
                        }
                    ]
                },
                {
                    "name": "trigger 14",
                    "links": [
                        {
                            "portIn": "Trigger",
                            "portOut": "trigger 14",
                            "objIn": "mm7fi4gro",
                            "objOut": "lhxij3gc7"
                        }
                    ]
                }
            ],
            "objName": "Ops.Trigger.Sequence"
        },
        {
            "id": "l2vvtdknu",
            "uiAttribs": {},
            "portsOut": [
                {
                    "name": "Result",
                    "links": [
                        {
                            "portIn": "Numbers_1",
                            "portOut": "Result",
                            "objIn": "ddmjl0ano",
                            "objOut": "l2vvtdknu"
                        },
                        {
                            "portIn": "Number",
                            "portOut": "Result",
                            "objIn": "orur9j4yj",
                            "objOut": "l2vvtdknu"
                        }
                    ]
                }
            ],
            "objName": "Ops.Ui.VizNumber"
        },
        {
            "id": "s24zmuvch",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Variable",
                    "value": "PointCount"
                }
            ],
            "objName": "Ops.Vars.VarSetNumber_v2"
        },
        {
            "id": "uz7eg8v9s",
            "uiAttribs": {},
            "portsOut": [
                {
                    "name": "Angle",
                    "links": [
                        {
                            "portIn": "Numbers_3",
                            "portOut": "Angle",
                            "objIn": "ddmjl0ano",
                            "objOut": "uz7eg8v9s"
                        }
                    ]
                },
                {
                    "name": "Description",
                    "value": "landscape-primary #71 WINORIENT:undefined"
                }
            ],
            "objName": "Ops.Devices.Mobile.ScreenOrientation"
        },
        {
            "id": "jaeenj1bq",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Portrait",
                    "value": 0
                },
                {
                    "name": "Landscape",
                    "value": 0
                }
            ],
            "portsOut": [
                {
                    "name": "Supported",
                    "value": 0
                },
                {
                    "name": "Locked",
                    "value": 0
                }
            ],
            "objName": "Ops.Devices.Mobile.LockOrientation"
        },
        {
            "id": "tycx201lf",
            "uiAttribs": {},
            "portsOut": [
                {
                    "name": "CSS Width",
                    "value": 875
                },
                {
                    "name": "CSS Height",
                    "value": 846
                },
                {
                    "name": "Pixel Ratio",
                    "value": 1.5
                },
                {
                    "name": "Pixel Width",
                    "links": [
                        {
                            "portIn": "number2",
                            "portOut": "Pixel Width",
                            "objIn": "4f9c7h99d",
                            "objOut": "tycx201lf"
                        }
                    ]
                },
                {
                    "name": "Pixel Height",
                    "links": [
                        {
                            "portIn": "number2",
                            "portOut": "Pixel Height",
                            "objIn": "xc9mql1oo",
                            "objOut": "tycx201lf"
                        }
                    ]
                },
                {
                    "name": "Aspect Ratio",
                    "value": 1.0342789598108748
                },
                {
                    "name": "Landscape",
                    "value": 1
                }
            ],
            "objName": "Ops.Gl.CanvasInfo_v3"
        },
        {
            "id": "78sw0ku4z",
            "uiAttribs": {},
            "portsOut": [
                {
                    "name": "Changed",
                    "links": [
                        {
                            "portIn": "Trigger",
                            "portOut": "Changed",
                            "objIn": "vzy144kac",
                            "objOut": "78sw0ku4z"
                        }
                    ]
                }
            ],
            "objName": "Ops.Trigger.TriggerOnChangeArray"
        },
        {
            "id": "ddmjl0ano",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Numbers",
                    "multiPortNum": 4
                },
                {
                    "name": "Numbers_4",
                    "value": 0,
                    "title": "add port"
                }
            ],
            "portsOut": [
                {
                    "name": "Result",
                    "links": [
                        {
                            "portIn": "Array",
                            "portOut": "Result",
                            "objIn": "78sw0ku4z",
                            "objOut": "ddmjl0ano"
                        }
                    ]
                },
                {
                    "name": "Num Values",
                    "value": 4
                }
            ],
            "objName": "Ops.Array.NumbersToArrayMultiPort"
        },
        {
            "id": "vzy144kac",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Named Trigger",
                    "value": "NeedRefresh"
                }
            ],
            "objName": "Ops.Trigger.TriggerSend"
        },
        {
            "id": "9zrqbdcdy",
            "uiAttribs": {},
            "portsOut": [
                {
                    "name": "Resized",
                    "links": [
                        {
                            "portIn": "Trigger",
                            "portOut": "Resized",
                            "objIn": "vzy144kac",
                            "objOut": "9zrqbdcdy"
                        }
                    ]
                }
            ],
            "objName": "Ops.Gl.TriggerOnCanvasResize"
        },
        {
            "id": "cl8vr1yh3",
            "uiAttribs": {},
            "portsOut": [
                {
                    "name": "Result",
                    "links": [
                        {
                            "portIn": "Value",
                            "portOut": "Result",
                            "objIn": "mzzu7irzb",
                            "objOut": "cl8vr1yh3"
                        },
                        {
                            "portIn": "Value",
                            "portOut": "Result",
                            "objIn": "gx0qmw1xj",
                            "objOut": "cl8vr1yh3"
                        }
                    ]
                }
            ],
            "objName": "Ops.Ui.VizNumber"
        },
        {
            "id": "mzzu7irzb",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Variable",
                    "value": "MarginHorizontal"
                }
            ],
            "objName": "Ops.Vars.VarSetNumber_v2"
        },
        {
            "id": "6z2a02pf7",
            "uiAttribs": {},
            "portsOut": [
                {
                    "name": "Result",
                    "links": [
                        {
                            "portIn": "Value",
                            "portOut": "Result",
                            "objIn": "fufkiemt8",
                            "objOut": "6z2a02pf7"
                        }
                    ]
                }
            ],
            "objName": "Ops.Ui.VizNumber"
        },
        {
            "id": "fufkiemt8",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Variable",
                    "value": "MarginVertical"
                }
            ],
            "objName": "Ops.Vars.VarSetNumber_v2"
        },
        {
            "id": "idfgp0w1t",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Scale index",
                    "value": 0
                },
                {
                    "name": "Scale",
                    "value": "Stretch"
                },
                {
                    "name": "Flip Y",
                    "value": 0
                },
                {
                    "name": "Flip X",
                    "value": 0
                }
            ],
            "objName": "Ops.Gl.Meshes.FullscreenRectangle_v2"
        },
        {
            "id": "x5wdstf9h",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "File",
                    "value": "assets/bg2.png",
                    "display": "file"
                },
                {
                    "name": "Filter index",
                    "value": 2
                },
                {
                    "name": "Filter",
                    "value": "mipmap"
                },
                {
                    "name": "Wrap index",
                    "value": 0
                },
                {
                    "name": "Wrap",
                    "value": "repeat"
                },
                {
                    "name": "Anisotropic index",
                    "value": 0
                },
                {
                    "name": "Anisotropic",
                    "value": "0"
                },
                {
                    "name": "Data Format index",
                    "value": 3
                },
                {
                    "name": "Data Format",
                    "value": "RGBA"
                },
                {
                    "name": "Flip",
                    "value": 0
                },
                {
                    "name": "Pre Multiplied Alpha",
                    "value": 0
                },
                {
                    "name": "Active",
                    "value": 1
                },
                {
                    "name": "Save Memory",
                    "value": 1
                },
                {
                    "name": "Add Cachebuster",
                    "value": 0
                }
            ],
            "portsOut": [
                {
                    "name": "Texture",
                    "links": [
                        {
                            "portIn": "Texture",
                            "portOut": "Texture",
                            "objIn": "idfgp0w1t",
                            "objOut": "x5wdstf9h"
                        }
                    ]
                },
                {
                    "name": "Width",
                    "value": 750
                },
                {
                    "name": "Height",
                    "value": 1040
                },
                {
                    "name": "Aspect Ratio",
                    "value": 0.7211538461538461
                },
                {
                    "name": "Loaded",
                    "value": 1
                },
                {
                    "name": "Loading",
                    "value": 0
                }
            ],
            "objName": "Ops.Gl.Texture_v2"
        },
        {
            "id": "rmxg689np",
            "uiAttribs": {},
            "portsOut": [
                {
                    "name": "trigger 0",
                    "links": [
                        {
                            "portIn": "render",
                            "portOut": "trigger 0",
                            "objIn": "0oj0tbtao",
                            "objOut": "rmxg689np"
                        }
                    ]
                },
                {
                    "name": "trigger 3",
                    "links": [
                        {
                            "portIn": "dobslg7sf",
                            "portOut": "trigger 3",
                            "objIn": "ulcz6fiks",
                            "objOut": "rmxg689np"
                        }
                    ]
                },
                {
                    "name": "trigger 4",
                    "links": [
                        {
                            "portIn": "dobslg7sf",
                            "portOut": "trigger 4",
                            "objIn": "u5j2xjuwv",
                            "objOut": "rmxg689np"
                        }
                    ]
                },
                {
                    "name": "trigger 6",
                    "links": [
                        {
                            "portIn": "dobslg7sf",
                            "portOut": "trigger 6",
                            "objIn": "tpwdgfvie",
                            "objOut": "rmxg689np"
                        }
                    ]
                },
                {
                    "name": "trigger 7",
                    "links": [
                        {
                            "portIn": "dobslg7sf",
                            "portOut": "trigger 7",
                            "objIn": "7kfqpc5qm",
                            "objOut": "rmxg689np"
                        }
                    ]
                },
                {
                    "name": "trigger 11",
                    "links": [
                        {
                            "portIn": "Render",
                            "portOut": "trigger 11",
                            "objIn": "mjsfpuud5",
                            "objOut": "rmxg689np"
                        }
                    ]
                }
            ],
            "objName": "Ops.Trigger.Sequence"
        },
        {
            "id": "zl7s3x2w2",
            "uiAttribs": {},
            "portsOut": [
                {
                    "name": "Result",
                    "links": [
                        {
                            "portIn": "Value",
                            "portOut": "Result",
                            "objIn": "euusn5dlp",
                            "objOut": "zl7s3x2w2"
                        }
                    ]
                }
            ],
            "objName": "Ops.Ui.VizNumber"
        },
        {
            "id": "euusn5dlp",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Variable",
                    "value": "Animation"
                }
            ],
            "objName": "Ops.Vars.VarSetNumber_v2"
        },
        {
            "id": "y0uj4w0yk",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Text",
                    "value": "Animation"
                },
                {
                    "name": "Min",
                    "value": 0
                },
                {
                    "name": "Max",
                    "value": 1
                },
                {
                    "name": "Step",
                    "value": 0.00001
                },
                {
                    "name": "Suffix",
                    "value": ""
                },
                {
                    "name": "Grey Out",
                    "value": 0
                },
                {
                    "name": "Visible",
                    "value": 1
                },
                {
                    "name": "Input",
                    "value": 1
                },
                {
                    "name": "Default",
                    "value": 1
                }
            ],
            "portsOut": [
                {
                    "name": "childs",
                    "links": [
                        {
                            "portIn": "link",
                            "portOut": "childs",
                            "objIn": "lhf4sbxmz",
                            "objOut": "y0uj4w0yk"
                        }
                    ]
                },
                {
                    "name": "Result",
                    "links": [
                        {
                            "portIn": "Number",
                            "portOut": "Result",
                            "objIn": "zl7s3x2w2",
                            "objOut": "y0uj4w0yk"
                        }
                    ]
                }
            ],
            "objName": "Ops.Sidebar.Slider_v3"
        },
        {
            "id": "dtlkxiwz1",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Visible",
                    "value": 1
                },
                {
                    "name": "Opacity",
                    "value": 1
                },
                {
                    "name": "Default Minimized",
                    "value": 1
                },
                {
                    "name": "Minimized Opacity",
                    "value": 0.5
                },
                {
                    "name": "Show undo button",
                    "value": 0
                },
                {
                    "name": "Show Minimize",
                    "value": 0
                },
                {
                    "name": "Title",
                    "value": "Control Panel"
                },
                {
                    "name": "Default CSS",
                    "value": 1
                }
            ],
            "portsOut": [
                {
                    "name": "childs",
                    "title": "Children",
                    "links": [
                        {
                            "portIn": "link",
                            "portOut": "childs",
                            "objIn": "0sj1rwg5b",
                            "objOut": "dtlkxiwz1"
                        }
                    ]
                },
                {
                    "name": "Opfened",
                    "value": false,
                    "title": "Opened"
                }
            ],
            "objName": "Ops.Sidebar.Sidebar"
        },
        {
            "id": "0w0e4zzvn",
            "uiAttribs": {},
            "portsOut": [
                {
                    "name": "Result",
                    "links": [
                        {
                            "portIn": "Value",
                            "portOut": "Result",
                            "objIn": "ttgztrbyf",
                            "objOut": "0w0e4zzvn"
                        }
                    ]
                }
            ],
            "objName": "Ops.Math.Floor"
        },
        {
            "id": "orur9j4yj",
            "uiAttribs": {},
            "portsOut": [
                {
                    "name": "Result",
                    "links": [
                        {
                            "portIn": "Value",
                            "portOut": "Result",
                            "objIn": "s24zmuvch",
                            "objOut": "orur9j4yj"
                        }
                    ]
                }
            ],
            "objName": "Ops.Math.Floor"
        },
        {
            "id": "ve0drgf1v",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Title",
                    "value": "Appearence Settings"
                }
            ],
            "objName": "Ops.Ui.Area"
        },
        {
            "id": "yeo4fykfw",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Stride",
                    "value": 0
                },
                {
                    "name": "Start Row",
                    "value": 0
                }
            ],
            "objName": "Ops.Ui.VizArrayTable"
        },
        {
            "id": "hkzq8twug",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Num Quadruplets",
                    "value": 1
                }
            ],
            "portsOut": [
                {
                    "name": "Array",
                    "links": [
                        {
                            "portIn": "Array",
                            "portOut": "Array",
                            "objIn": "yeo4fykfw",
                            "objOut": "hkzq8twug"
                        },
                        {
                            "portIn": "Value",
                            "portOut": "Array",
                            "objIn": "d9nq2rlh9",
                            "objOut": "hkzq8twug"
                        }
                    ]
                },
                {
                    "name": "Total Quadruplets",
                    "value": 1
                },
                {
                    "name": "Array length",
                    "value": 4
                }
            ],
            "objName": "Ops.Array.Array4"
        },
        {
            "id": "o4a90tzo0",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "value",
                    "value": "https://agalloch21.oss-cn-shanghai.aliyuncs.com/investment-art/imgset-20250725"
                }
            ],
            "portsOut": [
                {
                    "name": "String",
                    "links": [
                        {
                            "portIn": "Value",
                            "portOut": "String",
                            "objIn": "bce0xxlth",
                            "objOut": "o4a90tzo0"
                        }
                    ]
                }
            ],
            "objName": "Ops.String.String_v2"
        },
        {
            "id": "moozqarxu",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Title",
                    "value": "Generate Fake Data - Control Point"
                }
            ],
            "objName": "Ops.Ui.Area"
        },
        {
            "id": "n5w6guz1e",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Mode select index",
                    "value": 1
                },
                {
                    "name": "Mode select",
                    "value": "1,2,3,4"
                },
                {
                    "name": "Default Value",
                    "value": 0
                },
                {
                    "name": "Reverse",
                    "value": 0
                }
            ],
            "portsOut": [
                {
                    "name": "Array",
                    "links": [
                        {
                            "portIn": "In",
                            "portOut": "Array",
                            "objIn": "hnko1s7qw",
                            "objOut": "n5w6guz1e"
                        }
                    ]
                },
                {
                    "name": "Array length out",
                    "links": [
                        {
                            "portIn": "old max",
                            "portOut": "Array length out",
                            "objIn": "glqw4nn4b",
                            "objOut": "n5w6guz1e"
                        }
                    ]
                }
            ],
            "objName": "Ops.Array.Array_v3"
        },
        {
            "id": "sd2qxmw71",
            "uiAttribs": {},
            "portsOut": [
                {
                    "name": "trigger 1",
                    "links": [
                        {
                            "portIn": "render",
                            "portOut": "trigger 1",
                            "objIn": "ja9l5mf5h",
                            "objOut": "sd2qxmw71"
                        }
                    ]
                }
            ],
            "objName": "Ops.Trigger.Sequence"
        },
        {
            "id": "3xfrtdob4",
            "uiAttribs": {},
            "portsOut": [
                {
                    "name": "Number out",
                    "links": [
                        {
                            "portIn": "Array length",
                            "portOut": "Number out",
                            "objIn": "n5w6guz1e",
                            "objOut": "3xfrtdob4"
                        },
                        {
                            "portIn": "Array length",
                            "portOut": "Number out",
                            "objIn": "ju1fmevy0",
                            "objOut": "3xfrtdob4"
                        },
                        {
                            "portIn": "Array length",
                            "portOut": "Number out",
                            "objIn": "r5nnszh1a",
                            "objOut": "3xfrtdob4"
                        }
                    ]
                }
            ],
            "objName": "Ops.Number.Integer"
        },
        {
            "id": "glqw4nn4b",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "old min",
                    "value": 0
                },
                {
                    "name": "new min",
                    "value": -1
                },
                {
                    "name": "new max",
                    "value": 1
                },
                {
                    "name": "Easing index",
                    "value": 0
                },
                {
                    "name": "Easing",
                    "value": "Linear"
                }
            ],
            "portsOut": [
                {
                    "name": "result",
                    "links": [
                        {
                            "portIn": "Array 1",
                            "portOut": "result",
                            "objIn": "spbgyd0xt",
                            "objOut": "glqw4nn4b"
                        }
                    ]
                }
            ],
            "objName": "Ops.Array.MapRangeArray"
        },
        {
            "id": "hnko1s7qw",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Value",
                    "value": 0.5
                }
            ],
            "portsOut": [
                {
                    "name": "Result",
                    "links": [
                        {
                            "portIn": "array",
                            "portOut": "Result",
                            "objIn": "glqw4nn4b",
                            "objOut": "hnko1s7qw"
                        }
                    ]
                }
            ],
            "objName": "Ops.Array.ArraySum"
        },
        {
            "id": "spbgyd0xt",
            "uiAttribs": {},
            "portsOut": [
                {
                    "name": "Array out",
                    "links": [
                        {
                            "portIn": "Array",
                            "portOut": "Array out",
                            "objIn": "xm4ppijzz",
                            "objOut": "spbgyd0xt"
                        }
                    ]
                },
                {
                    "name": "Num Points",
                    "value": 10
                },
                {
                    "name": "Array length",
                    "links": [
                        {
                            "portIn": "Chunk Size",
                            "portOut": "Array length",
                            "objIn": "xm4ppijzz",
                            "objOut": "spbgyd0xt"
                        }
                    ]
                }
            ],
            "objName": "Ops.Array.ArrayPack3Simple"
        },
        {
            "id": "ju1fmevy0",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Mode select index",
                    "value": 0
                },
                {
                    "name": "Mode select",
                    "value": "Number"
                },
                {
                    "name": "Default Value",
                    "value": 0.5
                },
                {
                    "name": "Reverse",
                    "value": 0
                }
            ],
            "portsOut": [
                {
                    "name": "Array",
                    "links": [
                        {
                            "portIn": "Array 2",
                            "portOut": "Array",
                            "objIn": "spbgyd0xt",
                            "objOut": "ju1fmevy0"
                        }
                    ]
                },
                {
                    "name": "Array length out",
                    "value": 10
                }
            ],
            "objName": "Ops.Array.Array_v3"
        },
        {
            "id": "kptkkohg1",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Step",
                    "value": 0
                }
            ],
            "portsOut": [
                {
                    "name": "Trigger",
                    "links": [
                        {
                            "portIn": "render",
                            "portOut": "Trigger",
                            "objIn": "bc94gofoi",
                            "objOut": "kptkkohg1"
                        }
                    ]
                },
                {
                    "name": "Index",
                    "links": [
                        {
                            "portIn": "index",
                            "portOut": "Index",
                            "objIn": "hv71bbsp5",
                            "objOut": "kptkkohg1"
                        }
                    ]
                },
                {
                    "name": "Value 1",
                    "links": [
                        {
                            "portIn": "posX",
                            "portOut": "Value 1",
                            "objIn": "bc94gofoi",
                            "objOut": "kptkkohg1"
                        }
                    ]
                },
                {
                    "name": "Value 2",
                    "links": [
                        {
                            "portIn": "posY",
                            "portOut": "Value 2",
                            "objIn": "bc94gofoi",
                            "objOut": "kptkkohg1"
                        }
                    ]
                },
                {
                    "name": "Value 3",
                    "value": 0
                }
            ],
            "objName": "Ops.Array.Array3Iterator"
        },
        {
            "id": "bc94gofoi",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "posZ",
                    "value": 0
                },
                {
                    "name": "scale",
                    "value": 1
                },
                {
                    "name": "rotX",
                    "value": 0
                },
                {
                    "name": "rotY",
                    "value": 0
                },
                {
                    "name": "rotZ",
                    "value": 0
                }
            ],
            "portsOut": [
                {
                    "name": "trigger",
                    "links": [
                        {
                            "portIn": "render",
                            "portOut": "trigger",
                            "objIn": "7hny7d6b3",
                            "objOut": "bc94gofoi"
                        }
                    ]
                }
            ],
            "objName": "Ops.Graphics.Transform"
        },
        {
            "id": "k4ywtp7gk",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "innerRadius",
                    "value": 0
                },
                {
                    "name": "segments",
                    "value": 40
                },
                {
                    "name": "percent",
                    "value": 1
                },
                {
                    "name": "steps",
                    "value": 0
                },
                {
                    "name": "invertSteps",
                    "value": 0
                },
                {
                    "name": "mapping index",
                    "value": 0
                },
                {
                    "name": "mapping",
                    "value": "flat"
                },
                {
                    "name": "Spline",
                    "value": 0
                },
                {
                    "name": "Draw",
                    "title": "Render mesh"
                }
            ],
            "objName": "Ops.Graphics.Meshes.Circle_v3"
        },
        {
            "id": "vq7y0t0jh",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Coordinates index",
                    "value": 0
                },
                {
                    "name": "Coordinates",
                    "value": "-1 to 1"
                },
                {
                    "name": "Area index",
                    "value": 0
                },
                {
                    "name": "Area",
                    "value": "Canvas"
                },
                {
                    "name": "flip y",
                    "value": 1
                },
                {
                    "name": "right click prevent default",
                    "value": 1
                },
                {
                    "name": "Touch support",
                    "value": 1
                },
                {
                    "name": "Passive Events",
                    "value": 0
                },
                {
                    "name": "Active",
                    "value": 1
                }
            ],
            "portsOut": [
                {
                    "name": "x",
                    "links": [
                        {
                            "portIn": "Mouse X",
                            "portOut": "x",
                            "objIn": "six7lj3jb",
                            "objOut": "vq7y0t0jh"
                        }
                    ]
                },
                {
                    "name": "y",
                    "links": [
                        {
                            "portIn": "Mouse Y",
                            "portOut": "y",
                            "objIn": "six7lj3jb",
                            "objOut": "vq7y0t0jh"
                        }
                    ]
                },
                {
                    "name": "Button is down",
                    "links": [
                        {
                            "portIn": "Mouse Pressed",
                            "portOut": "Button is down",
                            "objIn": "six7lj3jb",
                            "objOut": "vq7y0t0jh"
                        }
                    ]
                },
                {
                    "name": "Mouse is hovering",
                    "value": 0
                },
                {
                    "name": "Movement X",
                    "value": 20
                },
                {
                    "name": "Movement Y",
                    "value": -22
                }
            ],
            "objName": "Ops.Devices.Mouse.Mouse_v3"
        },
        {
            "id": "x8f557387",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "value",
                    "value": 0.04
                }
            ],
            "portsOut": [
                {
                    "name": "result",
                    "links": [
                        {
                            "portIn": "radius",
                            "portOut": "result",
                            "objIn": "k4ywtp7gk",
                            "objOut": "x8f557387"
                        },
                        {
                            "portIn": "Radius",
                            "portOut": "result",
                            "objIn": "six7lj3jb",
                            "objOut": "x8f557387"
                        }
                    ]
                }
            ],
            "objName": "Ops.Number.Number"
        },
        {
            "id": "bv0mcibyb",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Array 3",
                    "value": 0
                },
                {
                    "name": "Array 4",
                    "value": 0
                },
                {
                    "name": "Array 5",
                    "value": 0
                },
                {
                    "name": "Array 6",
                    "value": 0
                },
                {
                    "name": "Array 7",
                    "value": 0
                },
                {
                    "name": "Array 8",
                    "value": 0
                }
            ],
            "portsOut": [
                {
                    "name": "Out Array",
                    "links": [
                        {
                            "portIn": "Control Point Array",
                            "portOut": "Out Array",
                            "objIn": "six7lj3jb",
                            "objOut": "bv0mcibyb"
                        }
                    ]
                }
            ],
            "objName": "Ops.Array.SwitchArrayOnTrigger"
        },
        {
            "id": "noq5d87qz",
            "uiAttribs": {},
            "portsOut": [
                {
                    "name": "Next",
                    "links": [
                        {
                            "portIn": "Trigger 1",
                            "portOut": "Next",
                            "objIn": "bv0mcibyb",
                            "objOut": "noq5d87qz"
                        },
                        {
                            "portIn": "Reset Point",
                            "portOut": "Next",
                            "objIn": "six7lj3jb",
                            "objOut": "noq5d87qz"
                        }
                    ]
                }
            ],
            "objName": "Ops.Trigger.TriggerButton"
        },
        {
            "id": "5iqp3hc5r",
            "uiAttribs": {},
            "portsOut": [
                {
                    "name": "Next",
                    "links": [
                        {
                            "portIn": "Trigger 2",
                            "portOut": "Next",
                            "objIn": "bv0mcibyb",
                            "objOut": "5iqp3hc5r"
                        },
                        {
                            "portIn": "Reset Point",
                            "portOut": "Next",
                            "objIn": "six7lj3jb",
                            "objOut": "5iqp3hc5r"
                        }
                    ]
                }
            ],
            "objName": "Ops.Trigger.TriggerButton"
        },
        {
            "id": "qt8la1lgl",
            "uiAttribs": {},
            "portsOut": [
                {
                    "name": "Next",
                    "links": [
                        {
                            "portIn": "Button",
                            "portOut": "Next",
                            "objIn": "auomhi2va",
                            "objOut": "qt8la1lgl"
                        }
                    ]
                }
            ],
            "objName": "Ops.Trigger.TriggerButton"
        },
        {
            "id": "jbtizveis",
            "uiAttribs": {},
            "portsOut": [
                {
                    "name": "Array 2 out",
                    "links": [
                        {
                            "portIn": "array 0",
                            "portOut": "Array 2 out",
                            "objIn": "3oxx3atx9",
                            "objOut": "jbtizveis"
                        },
                        {
                            "portIn": "array",
                            "portOut": "Array 2 out",
                            "objIn": "uc8xiteok",
                            "objOut": "jbtizveis"
                        }
                    ]
                },
                {
                    "name": "Array lengths",
                    "links": [
                        {
                            "portIn": "Array length",
                            "portOut": "Array lengths",
                            "objIn": "cvzahihkb",
                            "objOut": "jbtizveis"
                        }
                    ]
                }
            ],
            "objName": "Ops.Array.ArrayUnpack3"
        },
        {
            "id": "r5nnszh1a",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Mode select index",
                    "value": 0
                },
                {
                    "name": "Mode select",
                    "value": "Number"
                },
                {
                    "name": "Default Value",
                    "value": 0
                },
                {
                    "name": "Reverse",
                    "value": 0
                }
            ],
            "portsOut": [
                {
                    "name": "Array",
                    "links": [
                        {
                            "portIn": "Array 3",
                            "portOut": "Array",
                            "objIn": "spbgyd0xt",
                            "objOut": "r5nnszh1a"
                        }
                    ]
                },
                {
                    "name": "Array length out",
                    "value": 10
                }
            ],
            "objName": "Ops.Array.Array_v3"
        },
        {
            "id": "u04qwbpj9",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "old min",
                    "value": -1
                },
                {
                    "name": "old max",
                    "value": 1
                },
                {
                    "name": "new min",
                    "value": 0
                },
                {
                    "name": "new max",
                    "value": 1
                },
                {
                    "name": "Easing index",
                    "value": 0
                },
                {
                    "name": "Easing",
                    "value": "Linear"
                }
            ],
            "portsOut": [
                {
                    "name": "result",
                    "links": [
                        {
                            "portIn": "Array",
                            "portOut": "result",
                            "objIn": "7we47b2p1",
                            "objOut": "u04qwbpj9"
                        },
                        {
                            "portIn": "Array 1",
                            "portOut": "result",
                            "objIn": "dw95cjnda",
                            "objOut": "u04qwbpj9"
                        }
                    ]
                }
            ],
            "objName": "Ops.Array.MapRangeArray"
        },
        {
            "id": "v89fnjmky",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Mode index",
                    "value": 0
                },
                {
                    "name": "Mode",
                    "value": "A"
                },
                {
                    "name": "Random Seed ",
                    "value": 1.53
                },
                {
                    "name": "Integer",
                    "value": 0
                },
                {
                    "name": "Last == First",
                    "value": 0
                },
                {
                    "name": "Min A",
                    "value": -1
                },
                {
                    "name": "Max A",
                    "value": 1
                },
                {
                    "name": "Min B",
                    "value": -1
                },
                {
                    "name": "Max B",
                    "value": 1
                },
                {
                    "name": "Min C",
                    "value": -1
                },
                {
                    "name": "Max C",
                    "value": 1
                },
                {
                    "name": "Min D",
                    "value": -1
                },
                {
                    "name": "Max D",
                    "value": 1
                }
            ],
            "portsOut": [
                {
                    "name": "Array Out",
                    "links": [
                        {
                            "portIn": "In",
                            "portOut": "Array Out",
                            "objIn": "ju8nwjqyh",
                            "objOut": "v89fnjmky"
                        }
                    ]
                },
                {
                    "name": "Chunks Amount",
                    "value": 156
                },
                {
                    "name": "Array length",
                    "value": 156
                }
            ],
            "objName": "Ops.Array.RandomNumbersArray_v4"
        },
        {
            "id": "uc8xiteok",
            "uiAttribs": {},
            "portsOut": [
                {
                    "name": "length",
                    "links": [
                        {
                            "portIn": "Num Values",
                            "portOut": "length",
                            "objIn": "v89fnjmky",
                            "objOut": "uc8xiteok"
                        }
                    ]
                }
            ],
            "objName": "Ops.Array.ArrayLength_v2"
        },
        {
            "id": "3oxx3atx9",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Math function index",
                    "value": 0
                },
                {
                    "name": "Math function",
                    "value": "+"
                }
            ],
            "portsOut": [
                {
                    "name": "Array result",
                    "links": [
                        {
                            "portIn": "Array In",
                            "portOut": "Array result",
                            "objIn": "o4x33jlac",
                            "objOut": "3oxx3atx9"
                        }
                    ]
                },
                {
                    "name": "Array length",
                    "value": 156
                }
            ],
            "objName": "Ops.Array.ArrayMathArray"
        },
        {
            "id": "o4x33jlac",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Min",
                    "value": -1
                },
                {
                    "name": "Max",
                    "value": 1
                }
            ],
            "portsOut": [
                {
                    "name": "Array Out",
                    "links": [
                        {
                            "portIn": "array",
                            "portOut": "Array Out",
                            "objIn": "u04qwbpj9",
                            "objOut": "o4x33jlac"
                        }
                    ]
                }
            ],
            "objName": "Ops.Array.ArrayClamp"
        },
        {
            "id": "e8n5vctyx",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Variable",
                    "value": "APIDataList"
                }
            ],
            "objName": "Ops.Vars.VarSetArray_v2"
        },
        {
            "id": "ju8nwjqyh",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Value",
                    "value": 0.05
                }
            ],
            "portsOut": [
                {
                    "name": "Result",
                    "links": [
                        {
                            "portIn": "array 1",
                            "portOut": "Result",
                            "objIn": "3oxx3atx9",
                            "objOut": "ju8nwjqyh"
                        }
                    ]
                }
            ],
            "objName": "Ops.Array.ArrayMultiply"
        },
        {
            "id": "ppm25u0iq",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Play Timeline",
                    "value": 1
                }
            ],
            "portsOut": [
                {
                    "name": "Finished Initial Loading",
                    "value": 0
                },
                {
                    "name": "Loading",
                    "value": 1
                },
                {
                    "name": "Progress",
                    "value": 0.9987063389391979
                }
            ],
            "objName": "Ops.Cables.LoadingStatus_v2"
        },
        {
            "id": "mo2dnnp9q",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Text",
                    "value": "ShowControlPoint"
                },
                {
                    "name": "Input",
                    "value": 0
                },
                {
                    "name": "Default",
                    "value": 0
                },
                {
                    "name": "Grey Out",
                    "value": 0
                },
                {
                    "name": "Visible",
                    "value": 1
                }
            ],
            "portsOut": [
                {
                    "name": "childs",
                    "links": [
                        {
                            "portIn": "link",
                            "portOut": "childs",
                            "objIn": "bsa4lmzkh",
                            "objOut": "mo2dnnp9q"
                        }
                    ]
                },
                {
                    "name": "Value",
                    "links": [
                        {
                            "portIn": "Boolean",
                            "portOut": "Value",
                            "objIn": "9fwjcm5u6",
                            "objOut": "mo2dnnp9q"
                        }
                    ]
                }
            ],
            "objName": "Ops.Sidebar.Toggle_v4"
        },
        {
            "id": "9fwjcm5u6",
            "uiAttribs": {},
            "portsOut": [
                {
                    "name": "Bool",
                    "links": [
                        {
                            "portIn": "Active",
                            "portOut": "Bool",
                            "objIn": "six7lj3jb",
                            "objOut": "9fwjcm5u6"
                        },
                        {
                            "portIn": "bool 2",
                            "portOut": "Bool",
                            "objIn": "jd5zw3t0s",
                            "objOut": "9fwjcm5u6"
                        }
                    ]
                }
            ],
            "objName": "Ops.Ui.VizBool"
        },
        {
            "id": "zfhtag0pf",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Style index",
                    "value": 0
                },
                {
                    "name": "Style",
                    "value": "Tabs"
                },
                {
                    "name": "Text",
                    "value": "Switch"
                },
                {
                    "name": "Input",
                    "value": 0
                },
                {
                    "name": "Grey Out",
                    "value": 0
                },
                {
                    "name": "Default",
                    "value": 0
                }
            ],
            "portsOut": [
                {
                    "name": "childs",
                    "links": [
                        {
                            "portIn": "link",
                            "portOut": "childs",
                            "objIn": "ugl6i3wuk",
                            "objOut": "zfhtag0pf"
                        },
                        {
                            "portIn": "link",
                            "portOut": "childs",
                            "objIn": "m1cdqzq8n",
                            "objOut": "zfhtag0pf"
                        },
                        {
                            "portIn": "link",
                            "portOut": "childs",
                            "objIn": "st48yxkll",
                            "objOut": "zfhtag0pf"
                        },
                        {
                            "portIn": "link",
                            "portOut": "childs",
                            "objIn": "ejlcfuwwl",
                            "objOut": "zfhtag0pf"
                        }
                    ]
                },
                {
                    "name": "Index",
                    "links": [
                        {
                            "portIn": "number1",
                            "portOut": "Index",
                            "objIn": "ft7zfivju",
                            "objOut": "zfhtag0pf"
                        },
                        {
                            "portIn": "number1",
                            "portOut": "Index",
                            "objIn": "w4uyuc8q2",
                            "objOut": "zfhtag0pf"
                        },
                        {
                            "portIn": "number1",
                            "portOut": "Index",
                            "objIn": "qz2kfxayr",
                            "objOut": "zfhtag0pf"
                        },
                        {
                            "portIn": "number1",
                            "portOut": "Index",
                            "objIn": "zgsxki8uc",
                            "objOut": "zfhtag0pf"
                        }
                    ]
                },
                {
                    "name": "String",
                    "value": "Appearence"
                }
            ],
            "objName": "Ops.Sidebar.SideBarSwitch"
        },
        {
            "id": "rw2k8h691",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "text",
                    "value": "Appearence\nSegmentation\nFakeData\nDebug\n"
                },
                {
                    "name": "separator",
                    "value": ","
                },
                {
                    "name": "Numbers",
                    "value": 0
                },
                {
                    "name": "Trim",
                    "value": 0
                },
                {
                    "name": "Split Lines",
                    "value": 1
                }
            ],
            "portsOut": [
                {
                    "name": "array",
                    "links": [
                        {
                            "portIn": "Names",
                            "portOut": "array",
                            "objIn": "zfhtag0pf",
                            "objOut": "rw2k8h691"
                        }
                    ]
                },
                {
                    "name": "length",
                    "value": 4
                }
            ],
            "objName": "Ops.Array.StringToArray_v2"
        },
        {
            "id": "ft7zfivju",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "number2",
                    "value": 2
                }
            ],
            "portsOut": [
                {
                    "name": "result",
                    "links": [
                        {
                            "portIn": "Visible",
                            "portOut": "result",
                            "objIn": "st48yxkll",
                            "objOut": "ft7zfivju"
                        }
                    ]
                }
            ],
            "objName": "Ops.Math.Compare.Equals"
        },
        {
            "id": "st48yxkll",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Text",
                    "value": "Group"
                },
                {
                    "name": "Show Title",
                    "value": 0
                },
                {
                    "name": "Default Minimized",
                    "value": 0
                }
            ],
            "objName": "Ops.Sidebar.Group"
        },
        {
            "id": "lgsjjd1ud",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Variable",
                    "value": "Sidebar_FakeData"
                }
            ],
            "objName": "Ops.Vars.VarSetObject_v2"
        },
        {
            "id": "h9y39i7z1",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Variable",
                    "value": "Sidebar_FakeData"
                }
            ],
            "portsOut": [
                {
                    "name": "Value",
                    "links": [
                        {
                            "portIn": "link",
                            "portOut": "Value",
                            "objIn": "mo2dnnp9q",
                            "objOut": "h9y39i7z1"
                        }
                    ]
                }
            ],
            "objName": "Ops.Vars.VarGetObject_v2"
        },
        {
            "id": "ugl6i3wuk",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Text",
                    "value": "Group"
                },
                {
                    "name": "Show Title",
                    "value": 0
                },
                {
                    "name": "Default Minimized",
                    "value": 0
                }
            ],
            "portsOut": [
                {
                    "name": "childs",
                    "links": [
                        {
                            "portIn": "Value",
                            "portOut": "childs",
                            "objIn": "kf943ui8k",
                            "objOut": "ugl6i3wuk"
                        }
                    ]
                }
            ],
            "objName": "Ops.Sidebar.Group"
        },
        {
            "id": "kf943ui8k",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Variable",
                    "value": "Sidebar_Appearence"
                }
            ],
            "objName": "Ops.Vars.VarSetObject_v2"
        },
        {
            "id": "w4uyuc8q2",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "number2",
                    "value": 0
                }
            ],
            "portsOut": [
                {
                    "name": "result",
                    "links": [
                        {
                            "portIn": "Visible",
                            "portOut": "result",
                            "objIn": "ugl6i3wuk",
                            "objOut": "w4uyuc8q2"
                        }
                    ]
                }
            ],
            "objName": "Ops.Math.Compare.Equals"
        },
        {
            "id": "qz2kfxayr",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "number2",
                    "value": 1
                }
            ],
            "portsOut": [
                {
                    "name": "result",
                    "links": [
                        {
                            "portIn": "Visible",
                            "portOut": "result",
                            "objIn": "ejlcfuwwl",
                            "objOut": "qz2kfxayr"
                        }
                    ]
                }
            ],
            "objName": "Ops.Math.Compare.Equals"
        },
        {
            "id": "ejlcfuwwl",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Text",
                    "value": "Group"
                },
                {
                    "name": "Show Title",
                    "value": 0
                },
                {
                    "name": "Default Minimized",
                    "value": 0
                }
            ],
            "objName": "Ops.Sidebar.Group"
        },
        {
            "id": "fj4lu3ho7",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Variable",
                    "value": "Sidebar_Segmentation"
                }
            ],
            "objName": "Ops.Vars.VarSetObject_v2"
        },
        {
            "id": "ptyu2jpw2",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Text",
                    "value": "Load Settings"
                },
                {
                    "name": "Grey Out",
                    "value": 0
                },
                {
                    "name": "Visible",
                    "value": 1
                }
            ],
            "portsOut": [
                {
                    "name": "childs",
                    "links": [
                        {
                            "portIn": "link",
                            "portOut": "childs",
                            "objIn": "lld13ch4o",
                            "objOut": "ptyu2jpw2"
                        }
                    ]
                },
                {
                    "name": "Pressed Trigger",
                    "links": [
                        {
                            "portIn": "Trigger",
                            "portOut": "Pressed Trigger",
                            "objIn": "5iqp3hc5r",
                            "objOut": "ptyu2jpw2"
                        }
                    ]
                }
            ],
            "objName": "Ops.Sidebar.Button_v2"
        },
        {
            "id": "lld13ch4o",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Text",
                    "value": "Save Settings"
                },
                {
                    "name": "Grey Out",
                    "value": 0
                },
                {
                    "name": "Visible",
                    "value": 1
                }
            ],
            "portsOut": [
                {
                    "name": "childs",
                    "links": [
                        {
                            "portIn": "link",
                            "portOut": "childs",
                            "objIn": "oycw23itc",
                            "objOut": "lld13ch4o"
                        }
                    ]
                },
                {
                    "name": "Pressed Trigger",
                    "links": [
                        {
                            "portIn": "Trigger",
                            "portOut": "Pressed Trigger",
                            "objIn": "qt8la1lgl",
                            "objOut": "lld13ch4o"
                        }
                    ]
                }
            ],
            "objName": "Ops.Sidebar.Button_v2"
        },
        {
            "id": "oycw23itc",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Text",
                    "value": "Reset Settings"
                },
                {
                    "name": "Grey Out",
                    "value": 0
                },
                {
                    "name": "Visible",
                    "value": 1
                }
            ],
            "portsOut": [
                {
                    "name": "Pressed Trigger",
                    "links": [
                        {
                            "portIn": "Trigger",
                            "portOut": "Pressed Trigger",
                            "objIn": "noq5d87qz",
                            "objOut": "oycw23itc"
                        }
                    ]
                }
            ],
            "objName": "Ops.Sidebar.Button_v2"
        },
        {
            "id": "7we47b2p1",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Stride",
                    "value": 0
                },
                {
                    "name": "Start Row",
                    "value": 0
                }
            ],
            "objName": "Ops.Ui.VizArrayTable"
        },
        {
            "id": "4wgaae6rd",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Variable",
                    "value": "Sidebar_Appearence"
                }
            ],
            "portsOut": [
                {
                    "name": "Value",
                    "links": [
                        {
                            "portIn": "Link",
                            "portOut": "Value",
                            "objIn": "f8zl4itqi",
                            "objOut": "4wgaae6rd"
                        }
                    ]
                }
            ],
            "objName": "Ops.Vars.VarGetObject_v2"
        },
        {
            "id": "76oghcr63",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Text",
                    "value": "MarginVertical"
                },
                {
                    "name": "Min",
                    "value": 0
                },
                {
                    "name": "Max",
                    "value": 1
                },
                {
                    "name": "Step",
                    "value": 0.01
                },
                {
                    "name": "Suffix",
                    "value": ""
                },
                {
                    "name": "Grey Out",
                    "value": 1
                },
                {
                    "name": "Visible",
                    "value": 1
                },
                {
                    "name": "Default",
                    "value": 0.23937360178970912
                }
            ],
            "portsOut": [
                {
                    "name": "childs",
                    "links": [
                        {
                            "portIn": "link",
                            "portOut": "childs",
                            "objIn": "wyvzk7olm",
                            "objOut": "76oghcr63"
                        }
                    ]
                },
                {
                    "name": "Result",
                    "links": [
                        {
                            "portIn": "Number",
                            "portOut": "Result",
                            "objIn": "6z2a02pf7",
                            "objOut": "76oghcr63"
                        }
                    ]
                }
            ],
            "objName": "Ops.Sidebar.Slider_v3"
        },
        {
            "id": "kslrz7umn",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Text",
                    "value": "MarginHorizontal"
                },
                {
                    "name": "Min",
                    "value": 0
                },
                {
                    "name": "Max",
                    "value": 1
                },
                {
                    "name": "Step",
                    "value": 0.01
                },
                {
                    "name": "Suffix",
                    "value": ""
                },
                {
                    "name": "Grey Out",
                    "value": 0
                },
                {
                    "name": "Visible",
                    "value": 1
                },
                {
                    "name": "Input",
                    "value": 0
                },
                {
                    "name": "Default",
                    "value": 0
                }
            ],
            "portsOut": [
                {
                    "name": "childs",
                    "links": [
                        {
                            "portIn": "link",
                            "portOut": "childs",
                            "objIn": "76oghcr63",
                            "objOut": "kslrz7umn"
                        }
                    ]
                },
                {
                    "name": "Result",
                    "links": [
                        {
                            "portIn": "Number",
                            "portOut": "Result",
                            "objIn": "cl8vr1yh3",
                            "objOut": "kslrz7umn"
                        }
                    ]
                }
            ],
            "objName": "Ops.Sidebar.Slider_v3"
        },
        {
            "id": "bsa4lmzkh",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Label",
                    "value": "PointCount"
                },
                {
                    "name": "min",
                    "value": 2
                },
                {
                    "name": "max",
                    "value": 30
                },
                {
                    "name": "stepsize",
                    "value": 1
                },
                {
                    "name": "Default",
                    "value": 10
                },
                {
                    "name": "Values",
                    "value": 0
                },
                {
                    "name": "Grey Out",
                    "value": 0
                }
            ],
            "portsOut": [
                {
                    "name": "childs",
                    "links": [
                        {
                            "portIn": "link",
                            "portOut": "childs",
                            "objIn": "ptyu2jpw2",
                            "objOut": "bsa4lmzkh"
                        }
                    ]
                },
                {
                    "name": "value",
                    "links": [
                        {
                            "portIn": "Integer",
                            "portOut": "value",
                            "objIn": "3xfrtdob4",
                            "objOut": "bsa4lmzkh"
                        }
                    ]
                }
            ],
            "objName": "Ops.Sidebar.Incrementor_v2"
        },
        {
            "id": "lhf4sbxmz",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Text",
                    "value": "PointCount"
                },
                {
                    "name": "Min",
                    "value": 20
                },
                {
                    "name": "Max",
                    "value": 200
                },
                {
                    "name": "Step",
                    "value": 1
                },
                {
                    "name": "Suffix",
                    "value": ""
                },
                {
                    "name": "Grey Out",
                    "value": 0
                },
                {
                    "name": "Visible",
                    "value": 1
                },
                {
                    "name": "Input",
                    "value": 52
                },
                {
                    "name": "Default",
                    "value": 52
                }
            ],
            "portsOut": [
                {
                    "name": "childs",
                    "links": [
                        {
                            "portIn": "link",
                            "portOut": "childs",
                            "objIn": "ng15czuda",
                            "objOut": "lhf4sbxmz"
                        }
                    ]
                },
                {
                    "name": "Result",
                    "links": [
                        {
                            "portIn": "Number",
                            "portOut": "Result",
                            "objIn": "l2vvtdknu",
                            "objOut": "lhf4sbxmz"
                        }
                    ]
                }
            ],
            "objName": "Ops.Sidebar.Slider_v3"
        },
        {
            "id": "ng15czuda",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Text",
                    "value": "ImageCount"
                },
                {
                    "name": "Min",
                    "value": 0
                },
                {
                    "name": "Max",
                    "value": 100
                },
                {
                    "name": "Step",
                    "value": 1
                },
                {
                    "name": "Suffix",
                    "value": ""
                },
                {
                    "name": "Grey Out",
                    "value": 0
                },
                {
                    "name": "Visible",
                    "value": 1
                },
                {
                    "name": "Input",
                    "value": 13
                },
                {
                    "name": "Default",
                    "value": 13
                }
            ],
            "portsOut": [
                {
                    "name": "childs",
                    "links": [
                        {
                            "portIn": "link",
                            "portOut": "childs",
                            "objIn": "19h690pso",
                            "objOut": "ng15czuda"
                        }
                    ]
                },
                {
                    "name": "Result",
                    "links": [
                        {
                            "portIn": "Number",
                            "portOut": "Result",
                            "objIn": "70unrfnot",
                            "objOut": "ng15czuda"
                        }
                    ]
                }
            ],
            "objName": "Ops.Sidebar.Slider_v3"
        },
        {
            "id": "8jm4gkknw",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Text",
                    "value": "h0"
                },
                {
                    "name": "Min",
                    "value": 0
                },
                {
                    "name": "Max",
                    "value": 1
                },
                {
                    "name": "Step",
                    "value": 0.01
                },
                {
                    "name": "Suffix",
                    "value": ""
                },
                {
                    "name": "Grey Out",
                    "value": 0
                },
                {
                    "name": "Visible",
                    "value": 1
                },
                {
                    "name": "Input",
                    "value": 0.1
                },
                {
                    "name": "Default",
                    "value": 0.1
                }
            ],
            "portsOut": [
                {
                    "name": "childs",
                    "links": [
                        {
                            "portIn": "link",
                            "portOut": "childs",
                            "objIn": "rav60l2ev",
                            "objOut": "8jm4gkknw"
                        }
                    ]
                },
                {
                    "name": "Result",
                    "links": [
                        {
                            "portIn": "X",
                            "portOut": "Result",
                            "objIn": "hkzq8twug",
                            "objOut": "8jm4gkknw"
                        }
                    ]
                }
            ],
            "objName": "Ops.Sidebar.Slider_v3"
        },
        {
            "id": "rav60l2ev",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Text",
                    "value": "h1"
                },
                {
                    "name": "Min",
                    "value": 0
                },
                {
                    "name": "Max",
                    "value": 1
                },
                {
                    "name": "Step",
                    "value": 0.01
                },
                {
                    "name": "Suffix",
                    "value": ""
                },
                {
                    "name": "Grey Out",
                    "value": 0
                },
                {
                    "name": "Visible",
                    "value": 1
                },
                {
                    "name": "Input",
                    "value": 0.2
                },
                {
                    "name": "Default",
                    "value": 0.2
                }
            ],
            "portsOut": [
                {
                    "name": "childs",
                    "links": [
                        {
                            "portIn": "link",
                            "portOut": "childs",
                            "objIn": "41rfcvfbo",
                            "objOut": "rav60l2ev"
                        }
                    ]
                },
                {
                    "name": "Result",
                    "links": [
                        {
                            "portIn": "Y",
                            "portOut": "Result",
                            "objIn": "hkzq8twug",
                            "objOut": "rav60l2ev"
                        }
                    ]
                }
            ],
            "objName": "Ops.Sidebar.Slider_v3"
        },
        {
            "id": "41rfcvfbo",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Text",
                    "value": "h2"
                },
                {
                    "name": "Min",
                    "value": 0
                },
                {
                    "name": "Max",
                    "value": 1
                },
                {
                    "name": "Step",
                    "value": 0.01
                },
                {
                    "name": "Suffix",
                    "value": ""
                },
                {
                    "name": "Grey Out",
                    "value": 0
                },
                {
                    "name": "Visible",
                    "value": 1
                },
                {
                    "name": "Input",
                    "value": 0.4
                },
                {
                    "name": "Default",
                    "value": 0.4
                }
            ],
            "portsOut": [
                {
                    "name": "childs",
                    "links": [
                        {
                            "portIn": "link",
                            "portOut": "childs",
                            "objIn": "0id1zozdw",
                            "objOut": "41rfcvfbo"
                        }
                    ]
                },
                {
                    "name": "Result",
                    "links": [
                        {
                            "portIn": "Z",
                            "portOut": "Result",
                            "objIn": "hkzq8twug",
                            "objOut": "41rfcvfbo"
                        }
                    ]
                }
            ],
            "objName": "Ops.Sidebar.Slider_v3"
        },
        {
            "id": "0id1zozdw",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Text",
                    "value": "h3"
                },
                {
                    "name": "Min",
                    "value": 0
                },
                {
                    "name": "Max",
                    "value": 1
                },
                {
                    "name": "Step",
                    "value": 0.01
                },
                {
                    "name": "Suffix",
                    "value": ""
                },
                {
                    "name": "Grey Out",
                    "value": 0
                },
                {
                    "name": "Visible",
                    "value": 1
                },
                {
                    "name": "Input",
                    "value": 0.65
                },
                {
                    "name": "Default",
                    "value": 0.65
                }
            ],
            "portsOut": [
                {
                    "name": "childs",
                    "links": [
                        {
                            "portIn": "link",
                            "portOut": "childs",
                            "objIn": "ni2pau0dq",
                            "objOut": "0id1zozdw"
                        }
                    ]
                },
                {
                    "name": "Result",
                    "links": [
                        {
                            "portIn": "W",
                            "portOut": "Result",
                            "objIn": "hkzq8twug",
                            "objOut": "0id1zozdw"
                        }
                    ]
                }
            ],
            "objName": "Ops.Sidebar.Slider_v3"
        },
        {
            "id": "uu6rd7sdd",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Title",
                    "value": "Data Segmentation & Image Dataset"
                }
            ],
            "objName": "Ops.Ui.Area"
        },
        {
            "id": "ldpbhk7f0",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Title",
                    "value": "DebugPanel Root"
                }
            ],
            "objName": "Ops.Ui.Area"
        },
        {
            "id": "32fi9cvsj",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Variable",
                    "value": "Sidebar_Segmentation"
                }
            ],
            "portsOut": [
                {
                    "name": "Value",
                    "links": [
                        {
                            "portIn": "link",
                            "portOut": "Value",
                            "objIn": "8jm4gkknw",
                            "objOut": "32fi9cvsj"
                        }
                    ]
                }
            ],
            "objName": "Ops.Vars.VarGetObject_v2"
        },
        {
            "id": "nk7epn95s",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Named Trigger",
                    "value": "DisplayGraph"
                }
            ],
            "objName": "Ops.Trigger.TriggerSend"
        },
        {
            "id": "veutzoofv",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Title",
                    "value": "Sequence Root"
                }
            ],
            "objName": "Ops.Ui.Area"
        },
        {
            "id": "ekd0v63u5",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Named Trigger",
                    "value": "DisplayGraph"
                }
            ],
            "portsOut": [
                {
                    "name": "Triggered",
                    "links": [
                        {
                            "portIn": "exe",
                            "portOut": "Triggered",
                            "objIn": "rmxg689np",
                            "objOut": "ekd0v63u5"
                        },
                        {
                            "portIn": "Execute",
                            "portOut": "Triggered",
                            "objIn": "7wf3mhm2n",
                            "objOut": "ekd0v63u5"
                        }
                    ]
                }
            ],
            "objName": "Ops.Trigger.TriggerReceive"
        },
        {
            "id": "06q6r913s",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "bounds",
                    "value": 1
                },
                {
                    "name": "Axis index",
                    "value": 2
                },
                {
                    "name": "Axis",
                    "value": "None"
                },
                {
                    "name": "frustum near",
                    "value": -100
                },
                {
                    "name": "frustum far",
                    "value": 100
                }
            ],
            "portsOut": [
                {
                    "name": "Ratio",
                    "value": 1
                },
                {
                    "name": "Width",
                    "value": 2
                },
                {
                    "name": "Height",
                    "value": 2
                }
            ],
            "objName": "Ops.Gl.Orthogonal_v2"
        },
        {
            "id": "xzlglgj37",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "render",
                    "title": "Trigger"
                },
                {
                    "name": "Render Mesh",
                    "title": "Render"
                },
                {
                    "name": "width",
                    "value": 1
                },
                {
                    "name": "height",
                    "value": 1
                },
                {
                    "name": "pivot x index",
                    "value": 1
                },
                {
                    "name": "pivot x",
                    "value": "center"
                },
                {
                    "name": "pivot y index",
                    "value": 1
                },
                {
                    "name": "pivot y",
                    "value": "center"
                },
                {
                    "name": "axis index",
                    "value": 0
                },
                {
                    "name": "axis",
                    "value": "xy"
                },
                {
                    "name": "Flip TexCoord X",
                    "value": 0
                },
                {
                    "name": "Flip TexCoord Y",
                    "value": 1
                },
                {
                    "name": "num columns",
                    "value": 1
                },
                {
                    "name": "num rows",
                    "value": 1
                }
            ],
            "objName": "Ops.Graphics.Meshes.Rectangle_v4"
        },
        {
            "id": "i6n8udet1",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Direction index",
                    "value": 0
                },
                {
                    "name": "Direction",
                    "value": "Forward"
                }
            ],
            "portsOut": [
                {
                    "name": "Next",
                    "links": [
                        {
                            "portIn": "Execute",
                            "portOut": "Next",
                            "objIn": "zl7hzbiwy",
                            "objOut": "i6n8udet1"
                        }
                    ]
                },
                {
                    "name": "index",
                    "links": [
                        {
                            "portIn": "index",
                            "portOut": "index",
                            "objIn": "5ic1ol6j3",
                            "objOut": "i6n8udet1"
                        },
                        {
                            "portIn": "index",
                            "portOut": "index",
                            "objIn": "nlospknuv",
                            "objOut": "i6n8udet1"
                        },
                        {
                            "portIn": "index",
                            "portOut": "index",
                            "objIn": "ywqd7r8fx",
                            "objOut": "i6n8udet1"
                        },
                        {
                            "portIn": "index",
                            "portOut": "index",
                            "objIn": "22ekn7sem",
                            "objOut": "i6n8udet1"
                        },
                        {
                            "portIn": "Seed",
                            "portOut": "index",
                            "objIn": "7rjk438gj",
                            "objOut": "i6n8udet1"
                        },
                        {
                            "portIn": "x4u8fkg49",
                            "portOut": "index",
                            "objIn": "i9iwvbp5i",
                            "objOut": "i6n8udet1"
                        }
                    ]
                }
            ],
            "objName": "Ops.Trigger.Repeat_v2"
        },
        {
            "id": "znqta5g14",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "posZ",
                    "value": 0
                },
                {
                    "name": "scale",
                    "value": 1
                },
                {
                    "name": "rotX",
                    "value": 0
                },
                {
                    "name": "rotY",
                    "value": 0
                },
                {
                    "name": "rotZ",
                    "value": 0
                }
            ],
            "portsOut": [
                {
                    "name": "trigger",
                    "links": [
                        {
                            "portIn": "render",
                            "portOut": "trigger",
                            "objIn": "68zhtw1nv",
                            "objOut": "znqta5g14"
                        }
                    ]
                }
            ],
            "objName": "Ops.Graphics.Transform"
        },
        {
            "id": "68zhtw1nv",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "scale",
                    "value": 1
                },
                {
                    "name": "z",
                    "value": 1
                }
            ],
            "portsOut": [
                {
                    "name": "trigger",
                    "links": [
                        {
                            "portIn": "render",
                            "portOut": "trigger",
                            "objIn": "vgpk9buri",
                            "objOut": "68zhtw1nv"
                        }
                    ]
                }
            ],
            "objName": "Ops.Gl.Matrix.Scale"
        },
        {
            "id": "gfhvjg9lr",
            "uiAttribs": {},
            "portsOut": [
                {
                    "name": "Array 1 out",
                    "links": [
                        {
                            "portIn": "array",
                            "portOut": "Array 1 out",
                            "objIn": "5ic1ol6j3",
                            "objOut": "gfhvjg9lr"
                        }
                    ]
                },
                {
                    "name": "Array 2 out",
                    "links": [
                        {
                            "portIn": "array",
                            "portOut": "Array 2 out",
                            "objIn": "nlospknuv",
                            "objOut": "gfhvjg9lr"
                        }
                    ]
                },
                {
                    "name": "Array 3 out",
                    "links": [
                        {
                            "portIn": "array",
                            "portOut": "Array 3 out",
                            "objIn": "ywqd7r8fx",
                            "objOut": "gfhvjg9lr"
                        }
                    ]
                },
                {
                    "name": "Array 4 out",
                    "links": [
                        {
                            "portIn": "array",
                            "portOut": "Array 4 out",
                            "objIn": "22ekn7sem",
                            "objOut": "gfhvjg9lr"
                        }
                    ]
                },
                {
                    "name": "Array lengths",
                    "links": [
                        {
                            "portIn": "Repeats",
                            "portOut": "Array lengths",
                            "objIn": "i6n8udet1",
                            "objOut": "gfhvjg9lr"
                        }
                    ]
                }
            ],
            "objName": "Ops.Array.ArrayUnpack4"
        },
        {
            "id": "5ic1ol6j3",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Value Invalid Index",
                    "value": 0
                }
            ],
            "portsOut": [
                {
                    "name": "value",
                    "links": [
                        {
                            "portIn": "posX",
                            "portOut": "value",
                            "objIn": "znqta5g14",
                            "objOut": "5ic1ol6j3"
                        }
                    ]
                },
                {
                    "name": "Valid Index",
                    "value": 1
                }
            ],
            "objName": "Ops.Array.ArrayGetNumber"
        },
        {
            "id": "nlospknuv",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Value Invalid Index",
                    "value": 0
                }
            ],
            "portsOut": [
                {
                    "name": "value",
                    "links": [
                        {
                            "portIn": "posY",
                            "portOut": "value",
                            "objIn": "znqta5g14",
                            "objOut": "nlospknuv"
                        }
                    ]
                },
                {
                    "name": "Valid Index",
                    "value": 1
                }
            ],
            "objName": "Ops.Array.ArrayGetNumber"
        },
        {
            "id": "ywqd7r8fx",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Value Invalid Index",
                    "value": 0
                }
            ],
            "portsOut": [
                {
                    "name": "value",
                    "links": [
                        {
                            "portIn": "x",
                            "portOut": "value",
                            "objIn": "68zhtw1nv",
                            "objOut": "ywqd7r8fx"
                        }
                    ]
                },
                {
                    "name": "Valid Index",
                    "value": 1
                }
            ],
            "objName": "Ops.Array.ArrayGetNumber"
        },
        {
            "id": "22ekn7sem",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Value Invalid Index",
                    "value": 0
                }
            ],
            "portsOut": [
                {
                    "name": "value",
                    "links": [
                        {
                            "portIn": "y",
                            "portOut": "value",
                            "objIn": "68zhtw1nv",
                            "objOut": "22ekn7sem"
                        }
                    ]
                },
                {
                    "name": "Valid Index",
                    "value": 1
                }
            ],
            "objName": "Ops.Array.ArrayGetNumber"
        },
        {
            "id": "vgpk9buri",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "a",
                    "value": 0.293
                },
                {
                    "name": "colorizeTexture",
                    "value": 0
                },
                {
                    "name": "Alpha Mask Source index",
                    "value": 0
                },
                {
                    "name": "Alpha Mask Source",
                    "value": "Luminance"
                },
                {
                    "name": "Opacity TexCoords Transform",
                    "value": 0
                },
                {
                    "name": "Discard Transparent Pixels",
                    "value": 0
                },
                {
                    "name": "diffuseRepeatX",
                    "value": 1
                },
                {
                    "name": "diffuseRepeatY",
                    "value": 1
                },
                {
                    "name": "Tex Offset X",
                    "value": 0
                },
                {
                    "name": "Tex Offset Y",
                    "value": 0
                },
                {
                    "name": "Crop TexCoords",
                    "value": 0
                },
                {
                    "name": "billboard",
                    "value": 0
                }
            ],
            "portsOut": [
                {
                    "name": "trigger",
                    "links": [
                        {
                            "portIn": "render",
                            "portOut": "trigger",
                            "objIn": "xzlglgj37",
                            "objOut": "vgpk9buri"
                        }
                    ]
                }
            ],
            "objName": "Ops.Gl.Shader.BasicMaterial_v3"
        },
        {
            "id": "7rjk438gj",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Min",
                    "value": 0
                },
                {
                    "name": "Max",
                    "value": 1
                }
            ],
            "portsOut": [
                {
                    "name": "X",
                    "links": [
                        {
                            "portIn": "r",
                            "portOut": "X",
                            "objIn": "vgpk9buri",
                            "objOut": "7rjk438gj"
                        }
                    ]
                },
                {
                    "name": "Y",
                    "links": [
                        {
                            "portIn": "g",
                            "portOut": "Y",
                            "objIn": "vgpk9buri",
                            "objOut": "7rjk438gj"
                        }
                    ]
                },
                {
                    "name": "Z",
                    "links": [
                        {
                            "portIn": "b",
                            "portOut": "Z",
                            "objIn": "vgpk9buri",
                            "objOut": "7rjk438gj"
                        }
                    ]
                },
                {
                    "name": "W",
                    "value": 0.19817597873365847
                }
            ],
            "objName": "Ops.Math.RandomNumbers_v3"
        },
        {
            "id": "iqlgqsqyb",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "value",
                    "value": 1
                }
            ],
            "portsOut": [
                {
                    "name": "result",
                    "links": [
                        {
                            "portIn": "Boolean",
                            "portOut": "result",
                            "objIn": "4xgvq3mdg",
                            "objOut": "iqlgqsqyb"
                        }
                    ]
                }
            ],
            "objName": "Ops.Boolean.Boolean"
        },
        {
            "id": "4xgvq3mdg",
            "uiAttribs": {},
            "portsOut": [
                {
                    "name": "Result",
                    "links": [
                        {
                            "portIn": "Vertex Colors",
                            "portOut": "Result",
                            "objIn": "vgpk9buri",
                            "objOut": "4xgvq3mdg"
                        }
                    ]
                }
            ],
            "objName": "Ops.Boolean.Not"
        },
        {
            "id": "zgsxki8uc",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "number2",
                    "value": 3
                }
            ],
            "portsOut": [
                {
                    "name": "result",
                    "links": [
                        {
                            "portIn": "Visible",
                            "portOut": "result",
                            "objIn": "m1cdqzq8n",
                            "objOut": "zgsxki8uc"
                        }
                    ]
                }
            ],
            "objName": "Ops.Math.Compare.Equals"
        },
        {
            "id": "m1cdqzq8n",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Text",
                    "value": "Group"
                },
                {
                    "name": "Show Title",
                    "value": 0
                },
                {
                    "name": "Default Minimized",
                    "value": 0
                }
            ],
            "portsOut": [
                {
                    "name": "childs",
                    "links": [
                        {
                            "portIn": "Value",
                            "portOut": "childs",
                            "objIn": "hthfwe0ax",
                            "objOut": "m1cdqzq8n"
                        }
                    ]
                }
            ],
            "objName": "Ops.Sidebar.Group"
        },
        {
            "id": "hthfwe0ax",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Variable",
                    "value": "Sidebar_Debug"
                }
            ],
            "objName": "Ops.Vars.VarSetObject_v2"
        },
        {
            "id": "of9o9fxvv",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Variable",
                    "value": "Sidebar_Debug"
                }
            ],
            "portsOut": [
                {
                    "name": "Value",
                    "links": [
                        {
                            "portIn": "Link",
                            "portOut": "Value",
                            "objIn": "nhswn2lwb",
                            "objOut": "of9o9fxvv"
                        }
                    ]
                }
            ],
            "objName": "Ops.Vars.VarGetObject_v2"
        },
        {
            "id": "ipu3o3y9s",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Text",
                    "value": "ShowSpecific"
                },
                {
                    "name": "Input",
                    "value": 0
                },
                {
                    "name": "Default",
                    "value": 0
                },
                {
                    "name": "Grey Out",
                    "value": 0
                },
                {
                    "name": "Visible",
                    "value": 1
                }
            ],
            "portsOut": [
                {
                    "name": "childs",
                    "links": [
                        {
                            "portIn": "link",
                            "portOut": "childs",
                            "objIn": "fi0aiesu6",
                            "objOut": "ipu3o3y9s"
                        }
                    ]
                },
                {
                    "name": "Value",
                    "links": [
                        {
                            "portIn": "Value",
                            "portOut": "Value",
                            "objIn": "evj2ah90j",
                            "objOut": "ipu3o3y9s"
                        }
                    ]
                }
            ],
            "objName": "Ops.Sidebar.Toggle_v4"
        },
        {
            "id": "fi0aiesu6",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Label",
                    "value": "Index"
                },
                {
                    "name": "stepsize",
                    "value": 1
                },
                {
                    "name": "Default",
                    "value": 0
                },
                {
                    "name": "Values",
                    "value": 0
                },
                {
                    "name": "Grey Out",
                    "value": 0
                }
            ],
            "portsOut": [
                {
                    "name": "childs",
                    "links": [
                        {
                            "portIn": "link",
                            "portOut": "childs",
                            "objIn": "e5xmbewmk",
                            "objOut": "fi0aiesu6"
                        }
                    ]
                },
                {
                    "name": "value",
                    "links": [
                        {
                            "portIn": "Value",
                            "portOut": "value",
                            "objIn": "6ytucfqvs",
                            "objOut": "fi0aiesu6"
                        }
                    ]
                }
            ],
            "objName": "Ops.Sidebar.Incrementor_v2"
        },
        {
            "id": "cje2mluwf",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Title",
                    "value": "Debug"
                }
            ],
            "objName": "Ops.Ui.Area"
        },
        {
            "id": "e5xmbewmk",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Text",
                    "value": "ShowSegments"
                },
                {
                    "name": "Input",
                    "value": false
                },
                {
                    "name": "Default",
                    "value": 0
                },
                {
                    "name": "Grey Out",
                    "value": 0
                },
                {
                    "name": "Visible",
                    "value": 1
                }
            ],
            "portsOut": [
                {
                    "name": "childs",
                    "links": [
                        {
                            "portIn": "link",
                            "portOut": "childs",
                            "objIn": "z89wy56nd",
                            "objOut": "e5xmbewmk"
                        }
                    ]
                },
                {
                    "name": "Value",
                    "links": [
                        {
                            "portIn": "Render Mesh",
                            "portOut": "Value",
                            "objIn": "xzlglgj37",
                            "objOut": "e5xmbewmk"
                        },
                        {
                            "portIn": "bool 1",
                            "portOut": "Value",
                            "objIn": "jpcpnty47",
                            "objOut": "e5xmbewmk"
                        }
                    ]
                }
            ],
            "objName": "Ops.Sidebar.Toggle_v4"
        },
        {
            "id": "z89wy56nd",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Text",
                    "value": "ShowHighestPoints"
                },
                {
                    "name": "Input",
                    "value": 0
                },
                {
                    "name": "Default",
                    "value": 0
                },
                {
                    "name": "Grey Out",
                    "value": 0
                },
                {
                    "name": "Visible",
                    "value": 1
                }
            ],
            "portsOut": [
                {
                    "name": "childs",
                    "links": [
                        {
                            "portIn": "link",
                            "portOut": "childs",
                            "objIn": "835phmxeh",
                            "objOut": "z89wy56nd"
                        }
                    ]
                },
                {
                    "name": "Value",
                    "links": [
                        {
                            "portIn": "Value",
                            "portOut": "Value",
                            "objIn": "leuzuoble",
                            "objOut": "z89wy56nd"
                        }
                    ]
                }
            ],
            "objName": "Ops.Sidebar.Toggle_v4"
        },
        {
            "id": "835phmxeh",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Text",
                    "value": "ImageBorder"
                },
                {
                    "name": "Input",
                    "value": 0
                },
                {
                    "name": "Default",
                    "value": 0
                },
                {
                    "name": "Grey Out",
                    "value": 0
                },
                {
                    "name": "Visible",
                    "value": 1
                }
            ],
            "portsOut": [
                {
                    "name": "childs",
                    "links": [
                        {
                            "portIn": "link",
                            "portOut": "childs",
                            "objIn": "dx6tbw7x0",
                            "objOut": "835phmxeh"
                        }
                    ]
                },
                {
                    "name": "Value",
                    "links": [
                        {
                            "portIn": "Value",
                            "portOut": "Value",
                            "objIn": "8d05js0nc",
                            "objOut": "835phmxeh"
                        }
                    ]
                }
            ],
            "objName": "Ops.Sidebar.Toggle_v4"
        },
        {
            "id": "0sj1rwg5b",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Text",
                    "value": "To Right"
                },
                {
                    "name": "Input",
                    "value": 0
                },
                {
                    "name": "Default",
                    "value": 0
                },
                {
                    "name": "Grey Out",
                    "value": 0
                },
                {
                    "name": "Visible",
                    "value": 1
                }
            ],
            "portsOut": [
                {
                    "name": "childs",
                    "links": [
                        {
                            "portIn": "link",
                            "portOut": "childs",
                            "objIn": "zfhtag0pf",
                            "objOut": "0sj1rwg5b"
                        }
                    ]
                },
                {
                    "name": "Value",
                    "links": [
                        {
                            "portIn": "Side",
                            "portOut": "Value",
                            "objIn": "dtlkxiwz1",
                            "objOut": "0sj1rwg5b"
                        }
                    ]
                }
            ],
            "objName": "Ops.Sidebar.Toggle_v4"
        },
        {
            "id": "lk86313o6",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Text",
                    "value": "Save Settings"
                },
                {
                    "name": "Grey Out",
                    "value": 0
                },
                {
                    "name": "Visible",
                    "value": 1
                }
            ],
            "portsOut": [
                {
                    "name": "Pressed Trigger",
                    "links": [
                        {
                            "portIn": "Set Default",
                            "portOut": "Pressed Trigger",
                            "objIn": "kslrz7umn",
                            "objOut": "lk86313o6"
                        },
                        {
                            "portIn": "Set Default",
                            "portOut": "Pressed Trigger",
                            "objIn": "lhf4sbxmz",
                            "objOut": "lk86313o6"
                        },
                        {
                            "portIn": "Set Default",
                            "portOut": "Pressed Trigger",
                            "objIn": "ng15czuda",
                            "objOut": "lk86313o6"
                        },
                        {
                            "portIn": "Set Default",
                            "portOut": "Pressed Trigger",
                            "objIn": "76oghcr63",
                            "objOut": "lk86313o6"
                        },
                        {
                            "portIn": "Set Default",
                            "portOut": "Pressed Trigger",
                            "objIn": "d4a0fqbdw",
                            "objOut": "lk86313o6"
                        },
                        {
                            "portIn": "Set Default",
                            "portOut": "Pressed Trigger",
                            "objIn": "zjs755gma",
                            "objOut": "lk86313o6"
                        }
                    ]
                }
            ],
            "objName": "Ops.Sidebar.Button_v2"
        },
        {
            "id": "ni2pau0dq",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Text",
                    "value": "Save Settings"
                },
                {
                    "name": "Grey Out",
                    "value": 0
                },
                {
                    "name": "Visible",
                    "value": 1
                }
            ],
            "portsOut": [
                {
                    "name": "Pressed Trigger",
                    "links": [
                        {
                            "portIn": "Set Default",
                            "portOut": "Pressed Trigger",
                            "objIn": "8jm4gkknw",
                            "objOut": "ni2pau0dq"
                        },
                        {
                            "portIn": "Set Default",
                            "portOut": "Pressed Trigger",
                            "objIn": "rav60l2ev",
                            "objOut": "ni2pau0dq"
                        },
                        {
                            "portIn": "Set Default",
                            "portOut": "Pressed Trigger",
                            "objIn": "41rfcvfbo",
                            "objOut": "ni2pau0dq"
                        },
                        {
                            "portIn": "Set Default",
                            "portOut": "Pressed Trigger",
                            "objIn": "0id1zozdw",
                            "objOut": "ni2pau0dq"
                        }
                    ]
                }
            ],
            "objName": "Ops.Sidebar.Button_v2"
        },
        {
            "id": "0oj0tbtao",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "r",
                    "value": 1
                },
                {
                    "name": "g",
                    "value": 1
                },
                {
                    "name": "b",
                    "value": 1
                },
                {
                    "name": "a",
                    "value": 1
                }
            ],
            "portsOut": [
                {
                    "name": "trigger",
                    "links": [
                        {
                            "portIn": "render",
                            "portOut": "trigger",
                            "objIn": "idfgp0w1t",
                            "objOut": "0oj0tbtao"
                        }
                    ]
                }
            ],
            "objName": "Ops.Gl.ClearColor"
        },
        {
            "id": "egxde8xha",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Variable",
                    "value": "Animation"
                }
            ],
            "portsOut": [
                {
                    "name": "Value",
                    "links": [
                        {
                            "portIn": "value",
                            "portOut": "Value",
                            "objIn": "4zcbzllpa",
                            "objOut": "egxde8xha"
                        },
                        {
                            "portIn": "value",
                            "portOut": "Value",
                            "objIn": "t5i8caj1i",
                            "objOut": "egxde8xha"
                        },
                        {
                            "portIn": "value",
                            "portOut": "Value",
                            "objIn": "c7dgkdaf2",
                            "objOut": "egxde8xha"
                        },
                        {
                            "portIn": "value",
                            "portOut": "Value",
                            "objIn": "n9plnzsfh",
                            "objOut": "egxde8xha"
                        }
                    ]
                }
            ],
            "objName": "Ops.Vars.VarGetNumber_v2"
        },
        {
            "id": "okhjr8rv8",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Min",
                    "value": 0
                },
                {
                    "name": "Max",
                    "value": 1
                },
                {
                    "name": "Easing index",
                    "value": 11
                },
                {
                    "name": "Easing",
                    "value": "Sin Out"
                }
            ],
            "portsOut": [
                {
                    "name": "Result",
                    "links": [
                        {
                            "portIn": "Number 1",
                            "portOut": "Result",
                            "objIn": "xgx6xm8im",
                            "objOut": "okhjr8rv8"
                        },
                        {
                            "portIn": "Numbers_0",
                            "portOut": "Result",
                            "objIn": "qgyatuot6",
                            "objOut": "okhjr8rv8"
                        }
                    ]
                }
            ],
            "objName": "Ops.Math.Ease"
        },
        {
            "id": "4zcbzllpa",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "new min",
                    "value": 0
                },
                {
                    "name": "new max",
                    "value": 1
                },
                {
                    "name": "Easing index",
                    "value": 0
                },
                {
                    "name": "Easing",
                    "value": "Linear"
                },
                {
                    "name": "Clamp",
                    "value": 1
                }
            ],
            "portsOut": [
                {
                    "name": "result",
                    "links": [
                        {
                            "portIn": "Value",
                            "portOut": "result",
                            "objIn": "okhjr8rv8",
                            "objOut": "4zcbzllpa"
                        },
                        {
                            "portIn": "Numbers_0",
                            "portOut": "result",
                            "objIn": "96isg5d51",
                            "objOut": "4zcbzllpa"
                        }
                    ]
                }
            ],
            "objName": "Ops.Math.MapRange"
        },
        {
            "id": "c0getomgw",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Number",
                    "value": 0
                }
            ],
            "portsOut": [
                {
                    "name": "Result",
                    "links": [
                        {
                            "portIn": "old min",
                            "portOut": "Result",
                            "objIn": "4zcbzllpa",
                            "objOut": "c0getomgw"
                        }
                    ]
                }
            ],
            "objName": "Ops.Ui.VizNumber"
        },
        {
            "id": "swdey6thd",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Number",
                    "value": 1
                }
            ],
            "portsOut": [
                {
                    "name": "Result",
                    "links": [
                        {
                            "portIn": "old max",
                            "portOut": "Result",
                            "objIn": "4zcbzllpa",
                            "objOut": "swdey6thd"
                        }
                    ]
                }
            ],
            "objName": "Ops.Ui.VizNumber"
        },
        {
            "id": "xoznr4wei",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Min",
                    "value": 0
                },
                {
                    "name": "Max",
                    "value": 1
                },
                {
                    "name": "Easing index",
                    "value": 11
                },
                {
                    "name": "Easing",
                    "value": "Sin Out"
                }
            ],
            "portsOut": [
                {
                    "name": "Result",
                    "links": [
                        {
                            "portIn": "Number 2",
                            "portOut": "Result",
                            "objIn": "xgx6xm8im",
                            "objOut": "xoznr4wei"
                        },
                        {
                            "portIn": "Numbers_1",
                            "portOut": "Result",
                            "objIn": "qgyatuot6",
                            "objOut": "xoznr4wei"
                        }
                    ]
                }
            ],
            "objName": "Ops.Math.Ease"
        },
        {
            "id": "t5i8caj1i",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "new min",
                    "value": 0
                },
                {
                    "name": "new max",
                    "value": 1
                },
                {
                    "name": "Easing index",
                    "value": 0
                },
                {
                    "name": "Easing",
                    "value": "Linear"
                },
                {
                    "name": "Clamp",
                    "value": 1
                }
            ],
            "portsOut": [
                {
                    "name": "result",
                    "links": [
                        {
                            "portIn": "Value",
                            "portOut": "result",
                            "objIn": "xoznr4wei",
                            "objOut": "t5i8caj1i"
                        },
                        {
                            "portIn": "Numbers_1",
                            "portOut": "result",
                            "objIn": "96isg5d51",
                            "objOut": "t5i8caj1i"
                        }
                    ]
                }
            ],
            "objName": "Ops.Math.MapRange"
        },
        {
            "id": "fsx8oa4k0",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Number",
                    "value": 0
                }
            ],
            "portsOut": [
                {
                    "name": "Result",
                    "links": [
                        {
                            "portIn": "old min",
                            "portOut": "Result",
                            "objIn": "t5i8caj1i",
                            "objOut": "fsx8oa4k0"
                        }
                    ]
                }
            ],
            "objName": "Ops.Ui.VizNumber"
        },
        {
            "id": "pbj0ey3el",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Number",
                    "value": 1
                }
            ],
            "portsOut": [
                {
                    "name": "Result",
                    "links": [
                        {
                            "portIn": "old max",
                            "portOut": "Result",
                            "objIn": "t5i8caj1i",
                            "objOut": "pbj0ey3el"
                        }
                    ]
                }
            ],
            "objName": "Ops.Ui.VizNumber"
        },
        {
            "id": "oivdezoq7",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Min",
                    "value": 0
                },
                {
                    "name": "Max",
                    "value": 1
                },
                {
                    "name": "Easing index",
                    "value": 11
                },
                {
                    "name": "Easing",
                    "value": "Sin Out"
                }
            ],
            "portsOut": [
                {
                    "name": "Result",
                    "links": [
                        {
                            "portIn": "Number 3",
                            "portOut": "Result",
                            "objIn": "xgx6xm8im",
                            "objOut": "oivdezoq7"
                        },
                        {
                            "portIn": "Numbers_2",
                            "portOut": "Result",
                            "objIn": "qgyatuot6",
                            "objOut": "oivdezoq7"
                        }
                    ]
                }
            ],
            "objName": "Ops.Math.Ease"
        },
        {
            "id": "c7dgkdaf2",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "new min",
                    "value": 0
                },
                {
                    "name": "new max",
                    "value": 1
                },
                {
                    "name": "Easing index",
                    "value": 0
                },
                {
                    "name": "Easing",
                    "value": "Linear"
                },
                {
                    "name": "Clamp",
                    "value": 1
                }
            ],
            "portsOut": [
                {
                    "name": "result",
                    "links": [
                        {
                            "portIn": "Value",
                            "portOut": "result",
                            "objIn": "oivdezoq7",
                            "objOut": "c7dgkdaf2"
                        },
                        {
                            "portIn": "Numbers_2",
                            "portOut": "result",
                            "objIn": "96isg5d51",
                            "objOut": "c7dgkdaf2"
                        }
                    ]
                }
            ],
            "objName": "Ops.Math.MapRange"
        },
        {
            "id": "7285d95ks",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Number",
                    "value": 0
                }
            ],
            "portsOut": [
                {
                    "name": "Result",
                    "links": [
                        {
                            "portIn": "old min",
                            "portOut": "Result",
                            "objIn": "c7dgkdaf2",
                            "objOut": "7285d95ks"
                        }
                    ]
                }
            ],
            "objName": "Ops.Ui.VizNumber"
        },
        {
            "id": "5vu1pdo55",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Number",
                    "value": 1
                }
            ],
            "portsOut": [
                {
                    "name": "Result",
                    "links": [
                        {
                            "portIn": "old max",
                            "portOut": "Result",
                            "objIn": "c7dgkdaf2",
                            "objOut": "5vu1pdo55"
                        }
                    ]
                }
            ],
            "objName": "Ops.Ui.VizNumber"
        },
        {
            "id": "nnly25kkn",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Min",
                    "value": 0
                },
                {
                    "name": "Max",
                    "value": 1
                },
                {
                    "name": "Easing index",
                    "value": 11
                },
                {
                    "name": "Easing",
                    "value": "Sin Out"
                }
            ],
            "portsOut": [
                {
                    "name": "Result",
                    "links": [
                        {
                            "portIn": "Number 4",
                            "portOut": "Result",
                            "objIn": "xgx6xm8im",
                            "objOut": "nnly25kkn"
                        },
                        {
                            "portIn": "Numbers_3",
                            "portOut": "Result",
                            "objIn": "qgyatuot6",
                            "objOut": "nnly25kkn"
                        }
                    ]
                }
            ],
            "objName": "Ops.Math.Ease"
        },
        {
            "id": "n9plnzsfh",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "new min",
                    "value": 0
                },
                {
                    "name": "new max",
                    "value": 1
                },
                {
                    "name": "Easing index",
                    "value": 0
                },
                {
                    "name": "Easing",
                    "value": "Linear"
                },
                {
                    "name": "Clamp",
                    "value": 1
                }
            ],
            "portsOut": [
                {
                    "name": "result",
                    "links": [
                        {
                            "portIn": "Value",
                            "portOut": "result",
                            "objIn": "nnly25kkn",
                            "objOut": "n9plnzsfh"
                        },
                        {
                            "portIn": "Numbers_3",
                            "portOut": "result",
                            "objIn": "96isg5d51",
                            "objOut": "n9plnzsfh"
                        }
                    ]
                }
            ],
            "objName": "Ops.Math.MapRange"
        },
        {
            "id": "9vpaed3ps",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Number",
                    "value": 0
                }
            ],
            "portsOut": [
                {
                    "name": "Result",
                    "links": [
                        {
                            "portIn": "old min",
                            "portOut": "Result",
                            "objIn": "n9plnzsfh",
                            "objOut": "9vpaed3ps"
                        }
                    ]
                }
            ],
            "objName": "Ops.Ui.VizNumber"
        },
        {
            "id": "qastfmljx",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Number",
                    "value": 1
                }
            ],
            "portsOut": [
                {
                    "name": "Result",
                    "links": [
                        {
                            "portIn": "old max",
                            "portOut": "Result",
                            "objIn": "n9plnzsfh",
                            "objOut": "qastfmljx"
                        }
                    ]
                }
            ],
            "objName": "Ops.Ui.VizNumber"
        },
        {
            "id": "q94cdkcem",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Title",
                    "value": "Timeline"
                }
            ],
            "objName": "Ops.Ui.Area"
        },
        {
            "id": "mm7fi4gro",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Named Trigger",
                    "value": "ShowDebug"
                }
            ],
            "objName": "Ops.Trigger.TriggerSend"
        },
        {
            "id": "1hh96zykp",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Named Trigger",
                    "value": "ShowDebug"
                }
            ],
            "portsOut": [
                {
                    "name": "Triggered",
                    "links": [
                        {
                            "portIn": "Execute",
                            "portOut": "Triggered",
                            "objIn": "677ny8yzo",
                            "objOut": "1hh96zykp"
                        }
                    ]
                }
            ],
            "objName": "Ops.Trigger.TriggerReceive"
        },
        {
            "id": "nljeedhbb",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "posZ",
                    "value": 0
                },
                {
                    "name": "scale",
                    "value": 0.1
                },
                {
                    "name": "rotX",
                    "value": 0
                },
                {
                    "name": "rotY",
                    "value": 0
                },
                {
                    "name": "rotZ",
                    "value": 0
                }
            ],
            "portsOut": [
                {
                    "name": "trigger",
                    "links": [
                        {
                            "portIn": "render",
                            "portOut": "trigger",
                            "objIn": "ota0tuges",
                            "objOut": "nljeedhbb"
                        }
                    ]
                }
            ],
            "objName": "Ops.Graphics.Transform"
        },
        {
            "id": "eebxt06vk",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "old min",
                    "value": 0
                },
                {
                    "name": "old max",
                    "value": 1
                },
                {
                    "name": "new min",
                    "value": -1
                },
                {
                    "name": "new max",
                    "value": 1
                },
                {
                    "name": "Easing index",
                    "value": 0
                },
                {
                    "name": "Easing",
                    "value": "Linear"
                }
            ],
            "portsOut": [
                {
                    "name": "result",
                    "links": [
                        {
                            "portIn": "Array2x",
                            "portOut": "result",
                            "objIn": "vtwu526ht",
                            "objOut": "eebxt06vk"
                        }
                    ]
                }
            ],
            "objName": "Ops.Array.MapRangeArray"
        },
        {
            "id": "eyn0yb0eg",
            "uiAttribs": {},
            "portsOut": [
                {
                    "name": "Array out",
                    "links": [
                        {
                            "portIn": "array",
                            "portOut": "Array out",
                            "objIn": "eebxt06vk",
                            "objOut": "eyn0yb0eg"
                        }
                    ]
                },
                {
                    "name": "Num Points",
                    "value": 4
                },
                {
                    "name": "Array length",
                    "value": 8
                }
            ],
            "objName": "Ops.Array.ArrayPack2Simple"
        },
        {
            "id": "677ny8yzo",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Step",
                    "value": 0
                }
            ],
            "portsOut": [
                {
                    "name": "Trigger",
                    "links": [
                        {
                            "portIn": "render",
                            "portOut": "Trigger",
                            "objIn": "nljeedhbb",
                            "objOut": "677ny8yzo"
                        }
                    ]
                },
                {
                    "name": "Index",
                    "value": 3
                },
                {
                    "name": "Value 1",
                    "links": [
                        {
                            "portIn": "posX",
                            "portOut": "Value 1",
                            "objIn": "nljeedhbb",
                            "objOut": "677ny8yzo"
                        }
                    ]
                },
                {
                    "name": "Value 2",
                    "links": [
                        {
                            "portIn": "posY",
                            "portOut": "Value 2",
                            "objIn": "nljeedhbb",
                            "objOut": "677ny8yzo"
                        }
                    ]
                },
                {
                    "name": "Value 3",
                    "value": 0
                }
            ],
            "objName": "Ops.Array.Array3Iterator"
        },
        {
            "id": "vtwu526ht",
            "uiAttribs": {},
            "portsOut": [
                {
                    "name": "Array3x",
                    "links": [
                        {
                            "portIn": "Array",
                            "portOut": "Array3x",
                            "objIn": "677ny8yzo",
                            "objOut": "vtwu526ht"
                        }
                    ]
                },
                {
                    "name": "Total points",
                    "value": 4
                },
                {
                    "name": "Array length",
                    "value": 12
                }
            ],
            "objName": "Ops.Array.Array2To3"
        },
        {
            "id": "ota0tuges",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "r",
                    "value": 0.5467848600007359
                },
                {
                    "name": "g",
                    "value": 0.7117675010801583
                },
                {
                    "name": "b",
                    "value": 0.4659036745017242
                },
                {
                    "name": "a",
                    "value": 1
                },
                {
                    "name": "colorizeTexture",
                    "value": 0
                },
                {
                    "name": "Vertex Colors",
                    "value": 0
                },
                {
                    "name": "Alpha Mask Source index",
                    "value": 0
                },
                {
                    "name": "Alpha Mask Source",
                    "value": "Luminance"
                },
                {
                    "name": "Opacity TexCoords Transform",
                    "value": 0
                },
                {
                    "name": "Discard Transparent Pixels",
                    "value": 0
                },
                {
                    "name": "diffuseRepeatX",
                    "value": 1
                },
                {
                    "name": "diffuseRepeatY",
                    "value": 1
                },
                {
                    "name": "Tex Offset X",
                    "value": 0
                },
                {
                    "name": "Tex Offset Y",
                    "value": 0
                },
                {
                    "name": "Crop TexCoords",
                    "value": 0
                },
                {
                    "name": "billboard",
                    "value": 0
                }
            ],
            "portsOut": [
                {
                    "name": "trigger",
                    "links": [
                        {
                            "portIn": "render",
                            "portOut": "trigger",
                            "objIn": "vhqz99soe",
                            "objOut": "ota0tuges"
                        }
                    ]
                }
            ],
            "objName": "Ops.Gl.Shader.BasicMaterial_v3"
        },
        {
            "id": "vhqz99soe",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "radius",
                    "value": 0.5
                },
                {
                    "name": "innerRadius",
                    "value": 0
                },
                {
                    "name": "segments",
                    "value": 40
                },
                {
                    "name": "percent",
                    "value": 1
                },
                {
                    "name": "steps",
                    "value": 0
                },
                {
                    "name": "invertSteps",
                    "value": 0
                },
                {
                    "name": "mapping index",
                    "value": 0
                },
                {
                    "name": "mapping",
                    "value": "flat"
                },
                {
                    "name": "Spline",
                    "value": 0
                },
                {
                    "name": "Draw",
                    "title": "Render mesh"
                }
            ],
            "objName": "Ops.Graphics.Meshes.Circle_v3"
        },
        {
            "id": "xgx6xm8im",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Number 5",
                    "value": 0
                },
                {
                    "name": "Number 6",
                    "value": 0
                },
                {
                    "name": "Number 7",
                    "value": 0
                },
                {
                    "name": "Number 8",
                    "value": 0
                },
                {
                    "name": "Fill Graph",
                    "value": 1
                }
            ],
            "objName": "Ops.Ui.VizGraph"
        },
        {
            "id": "qgd2vnbvp",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Text",
                    "value": "Play Animation"
                },
                {
                    "name": "Grey Out",
                    "value": 0
                },
                {
                    "name": "Visible",
                    "value": 1
                }
            ],
            "portsOut": [
                {
                    "name": "childs",
                    "links": [
                        {
                            "portIn": "link",
                            "portOut": "childs",
                            "objIn": "z8zee7ph8",
                            "objOut": "qgd2vnbvp"
                        }
                    ]
                },
                {
                    "name": "Pressed Trigger",
                    "links": [
                        {
                            "portIn": "Bang",
                            "portOut": "Pressed Trigger",
                            "objIn": "8x60pbu7u",
                            "objOut": "qgd2vnbvp"
                        }
                    ]
                }
            ],
            "objName": "Ops.Sidebar.Button_v2"
        },
        {
            "id": "8x60pbu7u",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Invert",
                    "value": 0
                }
            ],
            "portsOut": [
                {
                    "name": "Value",
                    "links": [
                        {
                            "portIn": "Value",
                            "portOut": "Value",
                            "objIn": "mn8h0awz8",
                            "objOut": "8x60pbu7u"
                        }
                    ]
                }
            ],
            "objName": "Ops.Anim.Bang"
        },
        {
            "id": "vp7gvop3r",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Named Trigger",
                    "value": "Initialization"
                }
            ],
            "objName": "Ops.Trigger.TriggerSend"
        },
        {
            "id": "z2ojbelv8",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Named Trigger",
                    "value": "Initialization"
                }
            ],
            "portsOut": [
                {
                    "name": "Triggered",
                    "links": [
                        {
                            "portIn": "update",
                            "portOut": "Triggered",
                            "objIn": "8x60pbu7u",
                            "objOut": "z2ojbelv8"
                        }
                    ]
                }
            ],
            "objName": "Ops.Trigger.TriggerReceive"
        },
        {
            "id": "mn8h0awz8",
            "uiAttribs": {},
            "portsOut": [
                {
                    "name": "Result",
                    "links": [
                        {
                            "portIn": "Value",
                            "portOut": "Result",
                            "objIn": "euusn5dlp",
                            "objOut": "mn8h0awz8"
                        }
                    ]
                }
            ],
            "objName": "Ops.Math.OneMinus"
        },
        {
            "id": "8b5i8iwyp",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Variable",
                    "value": "TimelineArray"
                }
            ],
            "objName": "Ops.Vars.VarSetArray_v2"
        },
        {
            "id": "96isg5d51",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Numbers",
                    "multiPortNum": 4
                },
                {
                    "name": "Numbers_4",
                    "value": 0,
                    "title": "add port"
                }
            ],
            "portsOut": [
                {
                    "name": "Result",
                    "links": [
                        {
                            "portIn": "Array 1",
                            "portOut": "Result",
                            "objIn": "eyn0yb0eg",
                            "objOut": "96isg5d51"
                        }
                    ]
                },
                {
                    "name": "Num Values",
                    "value": 4
                }
            ],
            "objName": "Ops.Array.NumbersToArrayMultiPort"
        },
        {
            "id": "qgyatuot6",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Numbers",
                    "multiPortNum": 4
                },
                {
                    "name": "Numbers_4",
                    "value": 0,
                    "title": "add port"
                }
            ],
            "portsOut": [
                {
                    "name": "Result",
                    "links": [
                        {
                            "portIn": "Value",
                            "portOut": "Result",
                            "objIn": "8b5i8iwyp",
                            "objOut": "qgyatuot6"
                        },
                        {
                            "portIn": "Array 2",
                            "portOut": "Result",
                            "objIn": "eyn0yb0eg",
                            "objOut": "qgyatuot6"
                        }
                    ]
                },
                {
                    "name": "Num Values",
                    "value": 4
                }
            ],
            "objName": "Ops.Array.NumbersToArrayMultiPort"
        },
        {
            "id": "v5j9kt6fq",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Number",
                    "value": 3
                }
            ],
            "portsOut": [
                {
                    "name": "Result",
                    "links": [
                        {
                            "portIn": "Value",
                            "portOut": "Result",
                            "objIn": "t2nmc9d60",
                            "objOut": "v5j9kt6fq"
                        }
                    ]
                }
            ],
            "objName": "Ops.Ui.VizNumber"
        },
        {
            "id": "t2nmc9d60",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Variable",
                    "value": "LayerCount"
                }
            ],
            "objName": "Ops.Vars.VarSetNumber_v2"
        },
        {
            "id": "xp481g2x6",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Named Trigger",
                    "value": "ShowDebug"
                }
            ],
            "portsOut": [
                {
                    "name": "Triggered",
                    "links": [
                        {
                            "portIn": "exe",
                            "portOut": "Triggered",
                            "objIn": "sd2qxmw71",
                            "objOut": "xp481g2x6"
                        }
                    ]
                }
            ],
            "objName": "Ops.Trigger.TriggerReceive"
        },
        {
            "id": "0qai90wl1",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Variable",
                    "value": "LayerCount"
                }
            ],
            "portsOut": [
                {
                    "name": "Value",
                    "links": [
                        {
                            "portIn": "number2",
                            "portOut": "Value",
                            "objIn": "8q764mh8f",
                            "objOut": "0qai90wl1"
                        },
                        {
                            "portIn": "Repeats",
                            "portOut": "Value",
                            "objIn": "xm4ppijzz",
                            "objOut": "0qai90wl1"
                        },
                        {
                            "portIn": "Line Count",
                            "portOut": "Value",
                            "objIn": "six7lj3jb",
                            "objOut": "0qai90wl1"
                        }
                    ]
                }
            ],
            "objName": "Ops.Vars.VarGetNumber_v2"
        },
        {
            "id": "epmdrmmnc",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Min",
                    "value": 0
                },
                {
                    "name": "Max",
                    "value": 1
                }
            ],
            "portsOut": [
                {
                    "name": "X",
                    "links": [
                        {
                            "portIn": "r",
                            "portOut": "X",
                            "objIn": "7hny7d6b3",
                            "objOut": "epmdrmmnc"
                        }
                    ]
                },
                {
                    "name": "Y",
                    "links": [
                        {
                            "portIn": "g",
                            "portOut": "Y",
                            "objIn": "7hny7d6b3",
                            "objOut": "epmdrmmnc"
                        }
                    ]
                },
                {
                    "name": "Z",
                    "links": [
                        {
                            "portIn": "b",
                            "portOut": "Z",
                            "objIn": "7hny7d6b3",
                            "objOut": "epmdrmmnc"
                        }
                    ]
                },
                {
                    "name": "W",
                    "value": 0.15904582962087152
                }
            ],
            "objName": "Ops.Math.RandomNumbers_v3"
        },
        {
            "id": "hv71bbsp5",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Value Invalid Index",
                    "value": 0
                }
            ],
            "portsOut": [
                {
                    "name": "value",
                    "links": [
                        {
                            "portIn": "Seed",
                            "portOut": "value",
                            "objIn": "epmdrmmnc",
                            "objOut": "hv71bbsp5"
                        },
                        {
                            "portIn": "mqmfkaq8t",
                            "portOut": "value",
                            "objIn": "fmxh87zov",
                            "objOut": "hv71bbsp5"
                        }
                    ]
                },
                {
                    "name": "Valid Index",
                    "value": 1
                }
            ],
            "objName": "Ops.Array.ArrayGetNumber"
        },
        {
            "id": "7hny7d6b3",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "a",
                    "value": 1
                },
                {
                    "name": "colorizeTexture",
                    "value": 0
                },
                {
                    "name": "Vertex Colors",
                    "value": 0
                },
                {
                    "name": "Alpha Mask Source index",
                    "value": 0
                },
                {
                    "name": "Alpha Mask Source",
                    "value": "Luminance"
                },
                {
                    "name": "Opacity TexCoords Transform",
                    "value": 0
                },
                {
                    "name": "Discard Transparent Pixels",
                    "value": 0
                },
                {
                    "name": "diffuseRepeatX",
                    "value": 1
                },
                {
                    "name": "diffuseRepeatY",
                    "value": 1
                },
                {
                    "name": "Tex Offset X",
                    "value": 0
                },
                {
                    "name": "Tex Offset Y",
                    "value": 0
                },
                {
                    "name": "Crop TexCoords",
                    "value": 0
                },
                {
                    "name": "billboard",
                    "value": 0
                }
            ],
            "portsOut": [
                {
                    "name": "trigger",
                    "links": [
                        {
                            "portIn": "render",
                            "portOut": "trigger",
                            "objIn": "k4ywtp7gk",
                            "objOut": "7hny7d6b3"
                        }
                    ]
                }
            ],
            "objName": "Ops.Gl.Shader.BasicMaterial_v3"
        },
        {
            "id": "j6xwu99hi",
            "uiAttribs": {},
            "portsOut": [
                {
                    "name": "Result",
                    "links": [
                        {
                            "portIn": "Array of Arrays",
                            "portOut": "Result",
                            "objIn": "fajmzxle7",
                            "objOut": "j6xwu99hi"
                        },
                        {
                            "portIn": "Array of Arrays",
                            "portOut": "Result",
                            "objIn": "yfriw7kr1",
                            "objOut": "j6xwu99hi"
                        },
                        {
                            "portIn": "Array of Arrays",
                            "portOut": "Result",
                            "objIn": "gw3l6ntmh",
                            "objOut": "j6xwu99hi"
                        }
                    ]
                }
            ],
            "objName": "Ops.Array.ArrayToArrays"
        },
        {
            "id": "fajmzxle7",
            "uiAttribs": {},
            "portsOut": [
                {
                    "name": "Result Array",
                    "links": [
                        {
                            "portIn": "1pmfn9q3x",
                            "portOut": "Result Array",
                            "objIn": "i1mlyurg1",
                            "objOut": "fajmzxle7"
                        }
                    ]
                }
            ],
            "objName": "Ops.Array.ArrayGetArray"
        },
        {
            "id": "7utqeenoy",
            "uiAttribs": {},
            "portsOut": [
                {
                    "name": "length",
                    "links": [
                        {
                            "portIn": "number1",
                            "portOut": "length",
                            "objIn": "8q764mh8f",
                            "objOut": "7utqeenoy"
                        }
                    ]
                }
            ],
            "objName": "Ops.Array.ArrayLength_v2"
        },
        {
            "id": "8q764mh8f",
            "uiAttribs": {},
            "portsOut": [
                {
                    "name": "result",
                    "links": [
                        {
                            "portIn": "Stride",
                            "portOut": "result",
                            "objIn": "j6xwu99hi",
                            "objOut": "8q764mh8f"
                        }
                    ]
                }
            ],
            "objName": "Ops.Math.Divide"
        },
        {
            "id": "pldfwb6m0",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Array 3",
                    "value": 0
                },
                {
                    "name": "Array 4",
                    "value": 0
                },
                {
                    "name": "Array 5",
                    "value": 0
                },
                {
                    "name": "Array 6",
                    "value": 0
                },
                {
                    "name": "Array 7",
                    "value": 0
                }
            ],
            "portsOut": [
                {
                    "name": "Result",
                    "links": [
                        {
                            "portIn": "Array in xyz",
                            "portOut": "Result",
                            "objIn": "jbtizveis",
                            "objOut": "pldfwb6m0"
                        }
                    ]
                },
                {
                    "name": "Array length",
                    "value": 468
                }
            ],
            "objName": "Ops.Array.ArrayMerge_v3"
        },
        {
            "id": "yfriw7kr1",
            "uiAttribs": {},
            "portsOut": [
                {
                    "name": "Result Array",
                    "links": [
                        {
                            "portIn": "1pmfn9q3x",
                            "portOut": "Result Array",
                            "objIn": "td75a2hl1",
                            "objOut": "yfriw7kr1"
                        }
                    ]
                }
            ],
            "objName": "Ops.Array.ArrayGetArray"
        },
        {
            "id": "gw3l6ntmh",
            "uiAttribs": {},
            "portsOut": [
                {
                    "name": "Result Array",
                    "links": [
                        {
                            "portIn": "1pmfn9q3x",
                            "portOut": "Result Array",
                            "objIn": "n9wrhsyb1",
                            "objOut": "gw3l6ntmh"
                        }
                    ]
                }
            ],
            "objName": "Ops.Array.ArrayGetArray"
        },
        {
            "id": "kc8sbfm68",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Number",
                    "value": 0
                }
            ],
            "portsOut": [
                {
                    "name": "Result",
                    "links": [
                        {
                            "portIn": "Index",
                            "portOut": "Result",
                            "objIn": "fajmzxle7",
                            "objOut": "kc8sbfm68"
                        }
                    ]
                }
            ],
            "objName": "Ops.Ui.VizNumber"
        },
        {
            "id": "ygobf347j",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Number",
                    "value": 1
                }
            ],
            "portsOut": [
                {
                    "name": "Result",
                    "links": [
                        {
                            "portIn": "Index",
                            "portOut": "Result",
                            "objIn": "yfriw7kr1",
                            "objOut": "ygobf347j"
                        }
                    ]
                }
            ],
            "objName": "Ops.Ui.VizNumber"
        },
        {
            "id": "yfz87tm80",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Number",
                    "value": 2
                }
            ],
            "portsOut": [
                {
                    "name": "Result",
                    "links": [
                        {
                            "portIn": "Index",
                            "portOut": "Result",
                            "objIn": "gw3l6ntmh",
                            "objOut": "yfz87tm80"
                        }
                    ]
                }
            ],
            "objName": "Ops.Ui.VizNumber"
        },
        {
            "id": "ol35gamf9",
            "uiAttribs": {},
            "portsOut": [
                {
                    "name": "Result",
                    "links": [
                        {
                            "portIn": "Value",
                            "portOut": "Result",
                            "objIn": "e8n5vctyx",
                            "objOut": "ol35gamf9"
                        },
                        {
                            "portIn": "Array",
                            "portOut": "Result",
                            "objIn": "pee34val8",
                            "objOut": "ol35gamf9"
                        }
                    ]
                }
            ],
            "objName": "Ops.Array.ArrayToArrays"
        },
        {
            "id": "08hurvojj",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Variable",
                    "value": "PointCount"
                }
            ],
            "portsOut": [
                {
                    "name": "Value",
                    "links": [
                        {
                            "portIn": "Stride",
                            "portOut": "Value",
                            "objIn": "ol35gamf9",
                            "objOut": "08hurvojj"
                        }
                    ]
                }
            ],
            "objName": "Ops.Vars.VarGetNumber_v2"
        },
        {
            "id": "73go6ulrl",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Number",
                    "value": 0
                }
            ],
            "portsOut": [
                {
                    "name": "Result",
                    "links": [
                        {
                            "portIn": "8kld546qj",
                            "portOut": "Result",
                            "objIn": "7kfqpc5qm",
                            "objOut": "73go6ulrl"
                        }
                    ]
                }
            ],
            "objName": "Ops.Ui.VizNumber"
        },
        {
            "id": "g0427zjz7",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Number",
                    "value": 1
                }
            ],
            "portsOut": [
                {
                    "name": "Result",
                    "links": [
                        {
                            "portIn": "8kld546qj",
                            "portOut": "Result",
                            "objIn": "tpwdgfvie",
                            "objOut": "g0427zjz7"
                        }
                    ]
                }
            ],
            "objName": "Ops.Ui.VizNumber"
        },
        {
            "id": "e9dm8j2qu",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Number",
                    "value": 2
                }
            ],
            "portsOut": [
                {
                    "name": "Result",
                    "links": [
                        {
                            "portIn": "8kld546qj",
                            "portOut": "Result",
                            "objIn": "u5j2xjuwv",
                            "objOut": "e9dm8j2qu"
                        }
                    ]
                }
            ],
            "objName": "Ops.Ui.VizNumber"
        },
        {
            "id": "alz68d7az",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Title",
                    "value": "Draw Bg"
                }
            ],
            "objName": "Ops.Ui.Area"
        },
        {
            "id": "d9nq2rlh9",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Variable",
                    "value": "IntervalList"
                }
            ],
            "objName": "Ops.Vars.VarSetArray_v2"
        },
        {
            "id": "stkczpbr4",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Variable",
                    "value": "Debug_BuildingLayerIndex"
                }
            ],
            "objName": "Ops.Vars.VarSetNumber_v2"
        },
        {
            "id": "evj2ah90j",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Variable",
                    "value": "Debug_ShowSpecific"
                }
            ],
            "objName": "Ops.Vars.VarSetNumber_v2"
        },
        {
            "id": "6ytucfqvs",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Variable",
                    "value": "Debug_Image_Index"
                }
            ],
            "objName": "Ops.Vars.VarSetNumber_v2"
        },
        {
            "id": "p0izr64wz",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Number",
                    "value": 0
                },
                {
                    "name": "storedJson",
                    "value": "[-0.95,0,0.1,2,-0.85,0,0.1,2,-0.75,0,0.1,2,-0.6499999999999999,0,0.1,2,-0.55,0,0.1,2,-0.44999999999999996,0,0.1,2,-0.35,0,0.1,2,-0.25,0,0.1,2,-0.1499999999999999,0,0.1,2,-0.04999999999999993,0,0.1,2,0.050000000000000044,0,0.1,2,0.15000000000000013,0,0.1,2,0.25,0,0.1,2,0.3500000000000001,0,0.1,2,0.4500000000000002,0,0.1,2,0.55,0,0.1,2,0.6500000000000001,0,0.1,2,0.75,0,0.1,2,0.8500000000000001,0,0.1,2,0.9500000000000002,0,0.1,2]"
                }
            ],
            "objName": "Ops.Array.FreezeArray"
        },
        {
            "id": "xm4ppijzz",
            "uiAttribs": {},
            "portsOut": [
                {
                    "name": "Result",
                    "links": [
                        {
                            "portIn": "Array 1",
                            "portOut": "Result",
                            "objIn": "bv0mcibyb",
                            "objOut": "xm4ppijzz"
                        }
                    ]
                }
            ],
            "objName": "Ops.Array.ArrayChunkDuplicate"
        },
        {
            "id": "six7lj3jb",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Mouse Dragging",
                    "value": 0
                }
            ],
            "portsOut": [
                {
                    "name": "Point Out",
                    "links": [
                        {
                            "portIn": "Array",
                            "portOut": "Point Out",
                            "objIn": "kptkkohg1",
                            "objOut": "six7lj3jb"
                        },
                        {
                            "portIn": "Array",
                            "portOut": "Point Out",
                            "objIn": "j6xwu99hi",
                            "objOut": "six7lj3jb"
                        },
                        {
                            "portIn": "array",
                            "portOut": "Point Out",
                            "objIn": "7utqeenoy",
                            "objOut": "six7lj3jb"
                        },
                        {
                            "portIn": "Number",
                            "portOut": "Point Out",
                            "objIn": "auomhi2va",
                            "objOut": "six7lj3jb"
                        }
                    ]
                },
                {
                    "name": "Line Index Out",
                    "links": [
                        {
                            "portIn": "array",
                            "portOut": "Line Index Out",
                            "objIn": "hv71bbsp5",
                            "objOut": "six7lj3jb"
                        }
                    ]
                }
            ],
            "objName": "Ops.Patch.PLH3vXR.ControlPointManager"
        },
        {
            "id": "nhswn2lwb",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Text",
                    "value": "Buildings"
                },
                {
                    "name": "Default",
                    "value": "",
                    "title": "Input"
                },
                {
                    "name": "Grey Out",
                    "value": 0
                },
                {
                    "name": "Visible",
                    "value": 1
                },
                {
                    "name": "Lines",
                    "value": 1
                }
            ],
            "portsOut": [
                {
                    "name": "Children",
                    "links": [
                        {
                            "portIn": "link",
                            "portOut": "Children",
                            "objIn": "ipu3o3y9s",
                            "objOut": "nhswn2lwb"
                        }
                    ]
                },
                {
                    "name": "Result",
                    "value": ""
                },
                {
                    "name": "Index",
                    "links": [
                        {
                            "portIn": "Value",
                            "portOut": "Index",
                            "objIn": "stkczpbr4",
                            "objOut": "nhswn2lwb"
                        },
                        {
                            "portIn": "Index",
                            "portOut": "Index",
                            "objIn": "sy5iin1oq",
                            "objOut": "nhswn2lwb"
                        },
                        {
                            "portIn": "Index",
                            "portOut": "Index",
                            "objIn": "441874qxd",
                            "objOut": "nhswn2lwb"
                        }
                    ]
                }
            ],
            "objName": "Ops.Sidebar.DropDown_v2"
        },
        {
            "id": "ctg34aj36",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "text",
                    "value": "All\nBackground\nForeground"
                },
                {
                    "name": "separator",
                    "value": ""
                },
                {
                    "name": "Numbers",
                    "value": 0
                },
                {
                    "name": "Trim",
                    "value": 1
                },
                {
                    "name": "Split Lines",
                    "value": 1
                }
            ],
            "portsOut": [
                {
                    "name": "array",
                    "links": [
                        {
                            "portIn": "Values",
                            "portOut": "array",
                            "objIn": "nhswn2lwb",
                            "objOut": "ctg34aj36"
                        }
                    ]
                },
                {
                    "name": "length",
                    "value": 3
                }
            ],
            "objName": "Ops.Array.StringToArray_v2"
        },
        {
            "id": "leuzuoble",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Variable",
                    "value": "Debug_ShowHighestPoints"
                }
            ],
            "objName": "Ops.Vars.VarSetNumber_v2"
        },
        {
            "id": "8d05js0nc",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Variable",
                    "value": "Debug_ShowImageBounds"
                }
            ],
            "objName": "Ops.Vars.VarSetNumber_v2"
        },
        {
            "id": "g7nhl4y28",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Named Trigger",
                    "value": "ShowDebug"
                }
            ],
            "portsOut": [
                {
                    "name": "Triggered",
                    "links": [
                        {
                            "portIn": "render",
                            "portOut": "Triggered",
                            "objIn": "e9b1uhjgp",
                            "objOut": "g7nhl4y28"
                        }
                    ]
                }
            ],
            "objName": "Ops.Trigger.TriggerReceive"
        },
        {
            "id": "sy5iin1oq",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Value 0",
                    "value": 0
                },
                {
                    "name": "Value 1",
                    "value": 0
                },
                {
                    "name": "Value 3",
                    "value": 0
                },
                {
                    "name": "Value 4",
                    "value": 0
                },
                {
                    "name": "Value 5",
                    "value": 0
                },
                {
                    "name": "Value 6",
                    "value": 0
                },
                {
                    "name": "Value 7",
                    "value": 0
                },
                {
                    "name": "Value 8",
                    "value": 0
                },
                {
                    "name": "Value 9",
                    "value": 0
                },
                {
                    "name": "Value 10",
                    "value": 0
                },
                {
                    "name": "Value 11",
                    "value": 0
                },
                {
                    "name": "Value 12",
                    "value": 0
                },
                {
                    "name": "Value 13",
                    "value": 0
                },
                {
                    "name": "Value 14",
                    "value": 0
                },
                {
                    "name": "Value 15",
                    "value": 0
                }
            ],
            "portsOut": [
                {
                    "name": "Result",
                    "links": [
                        {
                            "portIn": "min",
                            "portOut": "Result",
                            "objIn": "fi0aiesu6",
                            "objOut": "sy5iin1oq"
                        }
                    ]
                }
            ],
            "objName": "Ops.Number.SwitchNumber"
        },
        {
            "id": "y3fn1agqr",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Variable",
                    "value": "BarCount"
                }
            ],
            "portsOut": [
                {
                    "name": "Value",
                    "links": [
                        {
                            "portIn": "number1",
                            "portOut": "Value",
                            "objIn": "68g3ansv2",
                            "objOut": "y3fn1agqr"
                        },
                        {
                            "portIn": "number1",
                            "portOut": "Value",
                            "objIn": "v5qivl45d",
                            "objOut": "y3fn1agqr"
                        },
                        {
                            "portIn": "Value 2",
                            "portOut": "Value",
                            "objIn": "sy5iin1oq",
                            "objOut": "y3fn1agqr"
                        },
                        {
                            "portIn": "Value 1",
                            "portOut": "Value",
                            "objIn": "441874qxd",
                            "objOut": "y3fn1agqr"
                        }
                    ]
                }
            ],
            "objName": "Ops.Vars.VarGetNumber_v2"
        },
        {
            "id": "68g3ansv2",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "number2",
                    "value": 1
                }
            ],
            "portsOut": [
                {
                    "name": "result",
                    "links": [
                        {
                            "portIn": "number2",
                            "portOut": "result",
                            "objIn": "v5qivl45d",
                            "objOut": "68g3ansv2"
                        }
                    ]
                }
            ],
            "objName": "Ops.Math.Subtract"
        },
        {
            "id": "v5qivl45d",
            "uiAttribs": {},
            "portsOut": [
                {
                    "name": "result",
                    "links": [
                        {
                            "portIn": "Value 0",
                            "portOut": "result",
                            "objIn": "441874qxd",
                            "objOut": "v5qivl45d"
                        },
                        {
                            "portIn": "Value 2",
                            "portOut": "result",
                            "objIn": "441874qxd",
                            "objOut": "v5qivl45d"
                        }
                    ]
                }
            ],
            "objName": "Ops.Math.Sum"
        },
        {
            "id": "441874qxd",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Value 3",
                    "value": 0
                },
                {
                    "name": "Value 4",
                    "value": 0
                },
                {
                    "name": "Value 5",
                    "value": 0
                },
                {
                    "name": "Value 6",
                    "value": 0
                },
                {
                    "name": "Value 7",
                    "value": 0
                },
                {
                    "name": "Value 8",
                    "value": 0
                },
                {
                    "name": "Value 9",
                    "value": 0
                },
                {
                    "name": "Value 10",
                    "value": 0
                },
                {
                    "name": "Value 11",
                    "value": 0
                },
                {
                    "name": "Value 12",
                    "value": 0
                },
                {
                    "name": "Value 13",
                    "value": 0
                },
                {
                    "name": "Value 14",
                    "value": 0
                },
                {
                    "name": "Value 15",
                    "value": 0
                }
            ],
            "portsOut": [
                {
                    "name": "Result",
                    "links": [
                        {
                            "portIn": "max",
                            "portOut": "Result",
                            "objIn": "fi0aiesu6",
                            "objOut": "441874qxd"
                        }
                    ]
                }
            ],
            "objName": "Ops.Number.SwitchNumber"
        },
        {
            "id": "zl7hzbiwy",
            "uiAttribs": {},
            "portsOut": [
                {
                    "name": "Trigger out",
                    "links": [
                        {
                            "portIn": "render",
                            "portOut": "Trigger out",
                            "objIn": "znqta5g14",
                            "objOut": "zl7hzbiwy"
                        }
                    ]
                }
            ],
            "objName": "Ops.Trigger.GateTrigger"
        },
        {
            "id": "jpcpnty47",
            "uiAttribs": {},
            "portsOut": [
                {
                    "name": "result",
                    "links": [
                        {
                            "portIn": "Pass Through",
                            "portOut": "result",
                            "objIn": "zl7hzbiwy",
                            "objOut": "jpcpnty47"
                        }
                    ]
                }
            ],
            "objName": "Ops.Boolean.And"
        },
        {
            "id": "i9iwvbp5i",
            "uiAttribs": {},
            "storage": {
                "blueprintVer": 2,
                "subPatchVer": 2
            },
            "portsIn": [
                {
                    "name": "x4u8fkg49",
                    "title": "ImageIndex"
                },
                {
                    "name": "patchId",
                    "value": "bp2sub_i9iwvbp5i"
                }
            ],
            "portsOut": [
                {
                    "name": "5i5pamobs",
                    "title": "Visible",
                    "links": [
                        {
                            "portIn": "bool 2",
                            "portOut": "5i5pamobs",
                            "objIn": "jpcpnty47",
                            "objOut": "i9iwvbp5i"
                        }
                    ]
                }
            ],
            "objName": "Ops.Patch.PLH3vXR.IsImageVisible"
        },
        {
            "id": "jd5zw3t0s",
            "uiAttribs": {},
            "portsOut": [
                {
                    "name": "result",
                    "links": [
                        {
                            "portIn": "Draw",
                            "portOut": "result",
                            "objIn": "k4ywtp7gk",
                            "objOut": "jd5zw3t0s"
                        }
                    ]
                }
            ],
            "objName": "Ops.Boolean.And"
        },
        {
            "id": "i1mlyurg1",
            "uiAttribs": {},
            "storage": {
                "blueprintVer": 2,
                "subPatchVer": 2
            },
            "portsIn": [
                {
                    "name": "1pmfn9q3x",
                    "title": "Points"
                },
                {
                    "name": "patchId",
                    "value": "bp2sub_i1mlyurg1"
                }
            ],
            "portsOut": [
                {
                    "name": "oorqf21z8",
                    "title": "Result",
                    "links": [
                        {
                            "portIn": "Array 0",
                            "portOut": "oorqf21z8",
                            "objIn": "pldfwb6m0",
                            "objOut": "i1mlyurg1"
                        }
                    ]
                }
            ],
            "objName": "Ops.Patch.PLH3vXR.RedistributeSingleLine"
        },
        {
            "id": "td75a2hl1",
            "uiAttribs": {},
            "storage": {
                "blueprintVer": 2,
                "subPatchVer": 2
            },
            "portsIn": [
                {
                    "name": "1pmfn9q3x",
                    "title": "Points"
                },
                {
                    "name": "patchId",
                    "value": "bp2sub_td75a2hl1"
                }
            ],
            "portsOut": [
                {
                    "name": "oorqf21z8",
                    "title": "Result",
                    "links": [
                        {
                            "portIn": "Array 1",
                            "portOut": "oorqf21z8",
                            "objIn": "pldfwb6m0",
                            "objOut": "td75a2hl1"
                        }
                    ]
                }
            ],
            "objName": "Ops.Patch.PLH3vXR.RedistributeSingleLine"
        },
        {
            "id": "n9wrhsyb1",
            "uiAttribs": {},
            "storage": {
                "blueprintVer": 2,
                "subPatchVer": 2
            },
            "portsIn": [
                {
                    "name": "1pmfn9q3x",
                    "title": "Points"
                },
                {
                    "name": "patchId",
                    "value": "bp2sub_n9wrhsyb1"
                }
            ],
            "portsOut": [
                {
                    "name": "oorqf21z8",
                    "title": "Result",
                    "links": [
                        {
                            "portIn": "Array 2",
                            "portOut": "oorqf21z8",
                            "objIn": "pldfwb6m0",
                            "objOut": "n9wrhsyb1"
                        }
                    ]
                }
            ],
            "objName": "Ops.Patch.PLH3vXR.RedistributeSingleLine"
        },
        {
            "id": "9fzkomtgw",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Text",
                    "value": "Image"
                },
                {
                    "name": "Show Title",
                    "value": 1
                },
                {
                    "name": "Default Minimized",
                    "value": 0
                },
                {
                    "name": "Visible",
                    "value": 1
                }
            ],
            "portsOut": [
                {
                    "name": "childs",
                    "links": [
                        {
                            "portIn": "link",
                            "portOut": "childs",
                            "objIn": "h5exbxlf5",
                            "objOut": "9fzkomtgw"
                        }
                    ]
                }
            ],
            "objName": "Ops.Sidebar.Group"
        },
        {
            "id": "h5exbxlf5",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Text",
                    "value": "Value"
                },
                {
                    "name": "Id",
                    "value": ""
                }
            ],
            "objName": "Ops.Sidebar.SidebarText_v2"
        },
        {
            "id": "bce0xxlth",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Variable",
                    "value": "ImageSetBaseURL"
                }
            ],
            "objName": "Ops.Vars.VarSetString_v2"
        },
        {
            "id": "auomhi2va",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "storedJson",
                    "value": "[-0.95,0.2996742671009771,0,-0.85,0.716612377850163,0,-0.75,0.322875816993464,0,-0.65,0.6339869281045751,0,-0.55,0.8326797385620914,0,-0.44999999999999996,0.9529411764705882,0,-0.35,0.6504854368932038,0,-0.25,0.3475728155339808,0,-0.15000000000000002,0.5067961165048545,0,-0.050000000000000044,0.7394136807817591,0,0.050000000000000044,0.5146579804560261,0,0.1499999999999999,0.6188925081433225,0,0.25,0.719869706840391,0,0.3500000000000001,0.280130293159609,0,0.44999999999999996,0.719869706840391,0,0.55,0.0684039087947883,0,0.6499999999999999,-0.009771986970684043,0,0.75,0.4951456310679614,0,0.8500000000000001,0.19218241042345285,0,0.95,-0.2280130293159609,0,-0.95,0.21172638436482094,0,-0.85,0.032573289902280145,0,-0.75,-0.40065146579804556,0,-0.65,0.31270358306188917,0,-0.55,0.5111111111111111,0,-0.44999999999999996,0.33333333333333326,0,-0.35,-0.25732899022801303,0,-0.25,0.6349514563106797,0,-0.15000000000000002,0.6123778501628665,0,-0.050000000000000044,0.8501628664495113,0,0.050000000000000044,0.990228013029316,0,0.1499999999999999,0.8371335504885993,0,0.25,0.6123778501628665,0,0.3500000000000001,0.6582524271844663,0,0.44999999999999996,0.5495145631067961,0,0.55,0.18446601941747587,0,0.6499999999999999,0.2349514563106796,0,0.75,0.7320388349514564,0,0.8500000000000001,0.9413680781758957,0,0.95,0.8859934853420195,0,-0.95,-0.5732899022801303,0,-0.85,0.3452768729641693,0,-0.75,0.10097719869706845,0,-0.65,-0.37459283387622155,0,-0.55,-0.4446952595936795,0,-0.44999999999999996,-0.501628664495114,0,-0.35,-0.1843137254901961,0,-0.25,-0.1140065146579805,0,-0.15000000000000002,-0.745928338762215,0,-0.050000000000000044,-0.5928338762214984,0,0.050000000000000044,-0.6872964169381108,0,0.1499999999999999,-0.4364820846905537,0,0.25,0.019543973941368087,0,0.3500000000000001,-0.09706546275395034,0,0.44999999999999996,-0.20541760722347635,0,0.55,-0.020316027088036148,0,0.6499999999999999,-0.3408577878103838,0,0.75,0.30618892508143314,0,0.8500000000000001,0.5472312703583062,0,0.95,0.6568848758465011,0]"
                }
            ],
            "portsOut": [
                {
                    "name": "Frozen Array",
                    "links": [
                        {
                            "portIn": "Array 2",
                            "portOut": "Frozen Array",
                            "objIn": "bv0mcibyb",
                            "objOut": "auomhi2va"
                        }
                    ]
                }
            ],
            "objName": "Ops.Array.FreezeArray"
        },
        {
            "id": "7s7m5p6xv",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Area index",
                    "value": 0
                },
                {
                    "name": "Area",
                    "value": "Canvas"
                },
                {
                    "name": "Active",
                    "value": 1
                }
            ],
            "portsOut": [
                {
                    "name": "Double Click",
                    "links": [
                        {
                            "portIn": "Bang",
                            "portOut": "Double Click",
                            "objIn": "8x60pbu7u",
                            "objOut": "7s7m5p6xv"
                        }
                    ]
                },
                {
                    "name": "Button pressed Left",
                    "value": 0
                },
                {
                    "name": "Button pressed Middle",
                    "value": 0
                },
                {
                    "name": "Button pressed Right",
                    "value": 0
                }
            ],
            "objName": "Ops.Devices.Mouse.MouseButtons"
        },
        {
            "id": "lg0wdx582",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "value",
                    "value": 0
                }
            ],
            "portsOut": [
                {
                    "name": "result",
                    "links": [
                        {
                            "portIn": "Draw",
                            "portOut": "result",
                            "objIn": "vhqz99soe",
                            "objOut": "lg0wdx582"
                        }
                    ]
                }
            ],
            "objName": "Ops.Boolean.Boolean"
        },
        {
            "id": "7dcne33po",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Title",
                    "value": "Draw Layers - Main Part"
                }
            ],
            "objName": "Ops.Ui.Area"
        },
        {
            "id": "sm2jebpdz",
            "uiAttribs": {},
            "portsOut": [
                {
                    "name": "Result",
                    "links": [
                        {
                            "portIn": "Array length",
                            "portOut": "Result",
                            "objIn": "w12wf89h6",
                            "objOut": "sm2jebpdz"
                        },
                        {
                            "portIn": "Array length",
                            "portOut": "Result",
                            "objIn": "069r0x96d",
                            "objOut": "sm2jebpdz"
                        },
                        {
                            "portIn": "Array length",
                            "portOut": "Result",
                            "objIn": "h5znjm807",
                            "objOut": "sm2jebpdz"
                        },
                        {
                            "portIn": "number2",
                            "portOut": "Result",
                            "objIn": "dc4sqykuq",
                            "objOut": "sm2jebpdz"
                        },
                        {
                            "portIn": "Array length",
                            "portOut": "Result",
                            "objIn": "2xyegcf2c",
                            "objOut": "sm2jebpdz"
                        },
                        {
                            "portIn": "old max",
                            "portOut": "Result",
                            "objIn": "xtxnbs5sb",
                            "objOut": "sm2jebpdz"
                        }
                    ]
                }
            ],
            "objName": "Ops.Ui.VizNumber"
        },
        {
            "id": "w12wf89h6",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Mode select index",
                    "value": 1
                },
                {
                    "name": "Mode select",
                    "value": "1,2,3,4"
                },
                {
                    "name": "Default Value",
                    "value": 0
                },
                {
                    "name": "Reverse",
                    "value": 0
                }
            ],
            "portsOut": [
                {
                    "name": "Array",
                    "links": [
                        {
                            "portIn": "In",
                            "portOut": "Array",
                            "objIn": "p6onbdc3h",
                            "objOut": "w12wf89h6"
                        }
                    ]
                },
                {
                    "name": "Array length out",
                    "value": 13
                }
            ],
            "objName": "Ops.Array.Array_v3"
        },
        {
            "id": "p6onbdc3h",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Value",
                    "value": 0.5
                }
            ],
            "portsOut": [
                {
                    "name": "Result",
                    "links": [
                        {
                            "portIn": "array",
                            "portOut": "Result",
                            "objIn": "xtxnbs5sb",
                            "objOut": "p6onbdc3h"
                        }
                    ]
                }
            ],
            "objName": "Ops.Array.ArraySum"
        },
        {
            "id": "069r0x96d",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Mode select index",
                    "value": 0
                },
                {
                    "name": "Mode select",
                    "value": "Number"
                },
                {
                    "name": "Default Value",
                    "value": 0
                },
                {
                    "name": "Reverse",
                    "value": 0
                }
            ],
            "portsOut": [
                {
                    "name": "Array",
                    "links": [
                        {
                            "portIn": "Array 2",
                            "portOut": "Array",
                            "objIn": "75fv8fffe",
                            "objOut": "069r0x96d"
                        }
                    ]
                },
                {
                    "name": "Array length out",
                    "value": 13
                }
            ],
            "objName": "Ops.Array.Array_v3"
        },
        {
            "id": "h5znjm807",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Mode select index",
                    "value": 0
                },
                {
                    "name": "Mode select",
                    "value": "Number"
                },
                {
                    "name": "Reverse",
                    "value": 0
                }
            ],
            "portsOut": [
                {
                    "name": "Array",
                    "links": [
                        {
                            "portIn": "Array 3",
                            "portOut": "Array",
                            "objIn": "75fv8fffe",
                            "objOut": "h5znjm807"
                        }
                    ]
                },
                {
                    "name": "Array length out",
                    "value": 13
                }
            ],
            "objName": "Ops.Array.Array_v3"
        },
        {
            "id": "dc4sqykuq",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "number1",
                    "value": 2
                }
            ],
            "portsOut": [
                {
                    "name": "result",
                    "links": [
                        {
                            "portIn": "Default Value",
                            "portOut": "result",
                            "objIn": "h5znjm807",
                            "objOut": "dc4sqykuq"
                        }
                    ]
                }
            ],
            "objName": "Ops.Math.Divide"
        },
        {
            "id": "2xyegcf2c",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Mode select index",
                    "value": 0
                },
                {
                    "name": "Mode select",
                    "value": "Number"
                },
                {
                    "name": "Default Value",
                    "value": 2
                },
                {
                    "name": "Reverse",
                    "value": 0
                }
            ],
            "portsOut": [
                {
                    "name": "Array",
                    "links": [
                        {
                            "portIn": "Array 4",
                            "portOut": "Array",
                            "objIn": "75fv8fffe",
                            "objOut": "2xyegcf2c"
                        }
                    ]
                },
                {
                    "name": "Array length out",
                    "value": 13
                }
            ],
            "objName": "Ops.Array.Array_v3"
        },
        {
            "id": "75fv8fffe",
            "uiAttribs": {},
            "portsOut": [
                {
                    "name": "Array out",
                    "links": [
                        {
                            "portIn": "Array in xyzw",
                            "portOut": "Array out",
                            "objIn": "gfhvjg9lr",
                            "objOut": "75fv8fffe"
                        }
                    ]
                },
                {
                    "name": "Num Points",
                    "value": 13
                },
                {
                    "name": "Array length",
                    "value": 52
                }
            ],
            "objName": "Ops.Array.ArrayPack4Simple"
        },
        {
            "id": "xtxnbs5sb",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "old min",
                    "value": 0
                },
                {
                    "name": "new min",
                    "value": -1
                },
                {
                    "name": "new max",
                    "value": 1
                },
                {
                    "name": "Easing index",
                    "value": 0
                },
                {
                    "name": "Easing",
                    "value": "Linear"
                }
            ],
            "portsOut": [
                {
                    "name": "result",
                    "links": [
                        {
                            "portIn": "Array 1",
                            "portOut": "result",
                            "objIn": "75fv8fffe",
                            "objOut": "xtxnbs5sb"
                        }
                    ]
                }
            ],
            "objName": "Ops.Array.MapRangeArray"
        },
        {
            "id": "cnx4nr1qm",
            "uiAttribs": {},
            "portsOut": [
                {
                    "name": "Result",
                    "links": [
                        {
                            "portIn": "number2",
                            "portOut": "Result",
                            "objIn": "q2qhrfixp",
                            "objOut": "cnx4nr1qm"
                        }
                    ]
                }
            ],
            "objName": "Ops.Ui.VizNumber"
        },
        {
            "id": "p2otlkbr1",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Number",
                    "value": 750
                }
            ],
            "portsOut": [
                {
                    "name": "Result",
                    "links": [
                        {
                            "portIn": "number1",
                            "portOut": "Result",
                            "objIn": "s3suru7q4",
                            "objOut": "p2otlkbr1"
                        }
                    ]
                }
            ],
            "objName": "Ops.Ui.VizNumber"
        },
        {
            "id": "ogfsvytds",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Number",
                    "value": 500
                }
            ],
            "portsOut": [
                {
                    "name": "Result",
                    "links": [
                        {
                            "portIn": "number2",
                            "portOut": "Result",
                            "objIn": "s3suru7q4",
                            "objOut": "ogfsvytds"
                        }
                    ]
                }
            ],
            "objName": "Ops.Ui.VizNumber"
        },
        {
            "id": "s3suru7q4",
            "uiAttribs": {},
            "portsOut": [
                {
                    "name": "result",
                    "links": [
                        {
                            "portIn": "Number",
                            "portOut": "result",
                            "objIn": "cnx4nr1qm",
                            "objOut": "s3suru7q4"
                        }
                    ]
                }
            ],
            "objName": "Ops.Math.Divide"
        },
        {
            "id": "q2qhrfixp",
            "uiAttribs": {},
            "portsOut": [
                {
                    "name": "result",
                    "links": [
                        {
                            "portIn": "number1",
                            "portOut": "result",
                            "objIn": "xc9mql1oo",
                            "objOut": "q2qhrfixp"
                        }
                    ]
                }
            ],
            "objName": "Ops.Math.Divide"
        },
        {
            "id": "xc9mql1oo",
            "uiAttribs": {},
            "portsOut": [
                {
                    "name": "result",
                    "links": [
                        {
                            "portIn": "Value",
                            "portOut": "result",
                            "objIn": "7cnsgrxc3",
                            "objOut": "xc9mql1oo"
                        }
                    ]
                }
            ],
            "objName": "Ops.Math.Divide"
        },
        {
            "id": "7cnsgrxc3",
            "uiAttribs": {},
            "portsOut": [
                {
                    "name": "Result",
                    "links": [
                        {
                            "portIn": "Number",
                            "portOut": "Result",
                            "objIn": "6z2a02pf7",
                            "objOut": "7cnsgrxc3"
                        },
                        {
                            "portIn": "Input",
                            "portOut": "Result",
                            "objIn": "76oghcr63",
                            "objOut": "7cnsgrxc3"
                        }
                    ]
                }
            ],
            "objName": "Ops.Math.OneMinus"
        },
        {
            "id": "4f9c7h99d",
            "uiAttribs": {},
            "portsOut": [
                {
                    "name": "result",
                    "links": [
                        {
                            "portIn": "number1",
                            "portOut": "result",
                            "objIn": "q2qhrfixp",
                            "objOut": "4f9c7h99d"
                        }
                    ]
                }
            ],
            "objName": "Ops.Math.Multiply"
        },
        {
            "id": "gx0qmw1xj",
            "uiAttribs": {},
            "portsOut": [
                {
                    "name": "Result",
                    "links": [
                        {
                            "portIn": "number1",
                            "portOut": "Result",
                            "objIn": "4f9c7h99d",
                            "objOut": "gx0qmw1xj"
                        }
                    ]
                }
            ],
            "objName": "Ops.Math.OneMinus"
        },
        {
            "id": "rlupg22va",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Variable",
                    "value": "RegionStr"
                }
            ],
            "objName": "Ops.Vars.VarSetString_v2"
        },
        {
            "id": "wcpz6o8ej",
            "uiAttribs": {},
            "portsOut": [
                {
                    "name": "String",
                    "links": [
                        {
                            "portIn": "Value",
                            "portOut": "String",
                            "objIn": "rlupg22va",
                            "objOut": "wcpz6o8ej"
                        }
                    ]
                }
            ],
            "objName": "Ops.String.String_v2"
        },
        {
            "id": "ktnom1cns",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "ZoomText",
                    "value": 0
                },
                {
                    "name": "Line Numbers",
                    "value": 1
                },
                {
                    "name": "Whitespace",
                    "value": 0
                },
                {
                    "name": "Wrap lines",
                    "value": 1
                },
                {
                    "name": "Syntax index",
                    "value": 0
                },
                {
                    "name": "Syntax",
                    "value": "text"
                },
                {
                    "name": "Font Size",
                    "value": 10
                },
                {
                    "name": "Scroll",
                    "value": 0
                }
            ],
            "portsOut": [
                {
                    "name": "Passthrough String",
                    "value": "china\nasia\nus"
                }
            ],
            "objName": "Ops.Ui.VizString"
        },
        {
            "id": "t9nxp1bjw",
            "uiAttribs": {},
            "portsOut": [
                {
                    "name": "Result",
                    "links": [
                        {
                            "portIn": "index",
                            "portOut": "Result",
                            "objIn": "i3vzufwf3",
                            "objOut": "t9nxp1bjw"
                        }
                    ]
                }
            ],
            "objName": "Ops.Ui.VizNumber"
        },
        {
            "id": "kztqs1zdk",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "value",
                    "value": "china\nasia\nus"
                },
                {
                    "name": "Syntax index",
                    "value": 0
                },
                {
                    "name": "Syntax",
                    "value": "text"
                }
            ],
            "portsOut": [
                {
                    "name": "Result",
                    "links": [
                        {
                            "portIn": "String",
                            "portOut": "Result",
                            "objIn": "ktnom1cns",
                            "objOut": "kztqs1zdk"
                        },
                        {
                            "portIn": "text",
                            "portOut": "Result",
                            "objIn": "bu6dju217",
                            "objOut": "kztqs1zdk"
                        }
                    ]
                }
            ],
            "objName": "Ops.String.StringEditor"
        },
        {
            "id": "bu6dju217",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "separator",
                    "value": ""
                },
                {
                    "name": "Numbers",
                    "value": 0
                },
                {
                    "name": "Trim",
                    "value": 1
                },
                {
                    "name": "Split Lines",
                    "value": 1
                }
            ],
            "portsOut": [
                {
                    "name": "array",
                    "links": [
                        {
                            "portIn": "array",
                            "portOut": "array",
                            "objIn": "i3vzufwf3",
                            "objOut": "bu6dju217"
                        }
                    ]
                },
                {
                    "name": "length",
                    "value": 3
                }
            ],
            "objName": "Ops.Array.StringToArray_v2"
        },
        {
            "id": "i3vzufwf3",
            "uiAttribs": {},
            "portsOut": [
                {
                    "name": "result",
                    "links": [
                        {
                            "portIn": "value",
                            "portOut": "result",
                            "objIn": "wcpz6o8ej",
                            "objOut": "i3vzufwf3"
                        },
                        {
                            "portIn": "Key",
                            "portOut": "result",
                            "objIn": "l5bew6qid",
                            "objOut": "i3vzufwf3"
                        }
                    ]
                }
            ],
            "objName": "Ops.Array.ArrayGetString"
        },
        {
            "id": "dtsox5yb7",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Variable",
                    "value": "RegionIndex"
                }
            ],
            "portsOut": [
                {
                    "name": "Value",
                    "links": [
                        {
                            "portIn": "Number",
                            "portOut": "Value",
                            "objIn": "t9nxp1bjw",
                            "objOut": "dtsox5yb7"
                        }
                    ]
                }
            ],
            "objName": "Ops.Vars.VarGetNumber_v2"
        },
        {
            "id": "dx6tbw7x0",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Text",
                    "value": "Shuffle Image"
                },
                {
                    "name": "Grey Out",
                    "value": 0
                },
                {
                    "name": "Visible",
                    "value": 1
                }
            ],
            "portsOut": [
                {
                    "name": "childs",
                    "links": [
                        {
                            "portIn": "link",
                            "portOut": "childs",
                            "objIn": "9fzkomtgw",
                            "objOut": "dx6tbw7x0"
                        }
                    ]
                },
                {
                    "name": "Pressed Trigger",
                    "links": [
                        {
                            "portIn": "Shuffle Imageset",
                            "portOut": "Pressed Trigger",
                            "objIn": "rplcv7si2",
                            "objOut": "dx6tbw7x0"
                        }
                    ]
                }
            ],
            "objName": "Ops.Sidebar.Button_v2"
        },
        {
            "id": "nhrpk86dk",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Variable",
                    "value": "BarCount"
                }
            ],
            "portsOut": [
                {
                    "name": "Value",
                    "links": [
                        {
                            "portIn": "Number",
                            "portOut": "Value",
                            "objIn": "sm2jebpdz",
                            "objOut": "nhrpk86dk"
                        }
                    ]
                }
            ],
            "objName": "Ops.Vars.VarGetNumber_v2"
        },
        {
            "id": "em4nemcy9",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Gradient",
                    "value": "{\"keys\":[{\"pos\":0,\"posy\":0.51,\"r\":0.9294117647058824,\"g\":0.5137254901960784,\"b\":0.43137254901960786},{\"pos\":0.0234375,\"posy\":0.51,\"r\":0.9294117647058824,\"g\":0.5137254901960784,\"b\":0.43137254901960786},{\"pos\":0.2265625,\"posy\":0.56,\"r\":0.21490885416666672,\"g\":0.12095060730189613,\"b\":0.06614162996411325},{\"pos\":0.435546875,\"posy\":0.57,\"r\":0.6627450980392157,\"g\":0.36627450980392157,\"b\":0.3333333333333333},{\"pos\":0.6328125,\"posy\":0.6,\"r\":0.9163411458333334,\"g\":0.602397546172142,\"b\":0.5239116462568442},{\"pos\":0.767578125,\"posy\":0.51,\"r\":0.9379231770833333,\"g\":0.7690338502859786,\"b\":0.7014781195670367},{\"pos\":0.875,\"posy\":0.66,\"r\":1,\"g\":1,\"b\":1},{\"pos\":1,\"posy\":0.66,\"r\":1,\"g\":1,\"b\":1}]}"
                },
                {
                    "name": "Direction index",
                    "value": 0
                },
                {
                    "name": "Direction",
                    "value": "X"
                },
                {
                    "name": "Smoothstep",
                    "value": 1
                },
                {
                    "name": "Step",
                    "value": 0
                },
                {
                    "name": "Flip",
                    "value": 0
                },
                {
                    "name": "sRGB",
                    "value": 0
                },
                {
                    "name": "Oklab",
                    "value": 0
                },
                {
                    "name": "Size",
                    "value": 256
                },
                {
                    "name": "filter index",
                    "value": 1
                },
                {
                    "name": "filter",
                    "value": "linear"
                },
                {
                    "name": "wrap index",
                    "value": 0
                },
                {
                    "name": "wrap",
                    "value": "clamp to edge"
                },
                {
                    "name": "Dither",
                    "value": 0
                },
                {
                    "name": "Gradient Array",
                    "value": 0
                }
            ],
            "portsOut": [
                {
                    "name": "Texture",
                    "links": [
                        {
                            "portIn": "object port 0",
                            "portOut": "Texture",
                            "objIn": "w15soy3mm",
                            "objOut": "em4nemcy9"
                        }
                    ]
                }
            ],
            "objName": "Ops.Gl.GradientTexture"
        },
        {
            "id": "zxh1ihr4d",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Gradient",
                    "value": "{\"keys\":[{\"pos\":0,\"posy\":0.51,\"r\":0.61650390625,\"g\":0.61650390625,\"b\":0.61650390625},{\"pos\":0.0234375,\"posy\":0.51,\"r\":0.61650390625,\"g\":0.61650390625,\"b\":0.61650390625},{\"pos\":0.126953125,\"posy\":0.34,\"r\":0.83427734375,\"g\":0.83427734375,\"b\":0.83427734375},{\"pos\":0.271484375,\"posy\":0.64,\"r\":0.3940104166666667,\"g\":0.3940104166666667,\"b\":0.3940104166666667},{\"pos\":0.494140625,\"posy\":0.63,\"r\":0.63330078125,\"g\":0.63330078125,\"b\":0.63330078125},{\"pos\":0.640625,\"posy\":0.1,\"r\":0.8588541666666667,\"g\":0.8588541666666667,\"b\":0.8588541666666667},{\"pos\":0.912109375,\"posy\":0.52,\"r\":1,\"g\":1,\"b\":1},{\"pos\":1,\"posy\":0.52,\"r\":1,\"g\":1,\"b\":1}]}"
                },
                {
                    "name": "Direction index",
                    "value": 0
                },
                {
                    "name": "Direction",
                    "value": "X"
                },
                {
                    "name": "Smoothstep",
                    "value": 1
                },
                {
                    "name": "Step",
                    "value": 0
                },
                {
                    "name": "Flip",
                    "value": 0
                },
                {
                    "name": "sRGB",
                    "value": 0
                },
                {
                    "name": "Oklab",
                    "value": 0
                },
                {
                    "name": "Size",
                    "value": 256
                },
                {
                    "name": "filter index",
                    "value": 1
                },
                {
                    "name": "filter",
                    "value": "linear"
                },
                {
                    "name": "wrap index",
                    "value": 0
                },
                {
                    "name": "wrap",
                    "value": "clamp to edge"
                },
                {
                    "name": "Dither",
                    "value": 0
                },
                {
                    "name": "Gradient Array",
                    "value": 0
                }
            ],
            "portsOut": [
                {
                    "name": "Texture",
                    "links": [
                        {
                            "portIn": "object port 1",
                            "portOut": "Texture",
                            "objIn": "w15soy3mm",
                            "objOut": "zxh1ihr4d"
                        }
                    ]
                }
            ],
            "objName": "Ops.Gl.GradientTexture"
        },
        {
            "id": "w15soy3mm",
            "uiAttribs": {},
            "portsOut": [
                {
                    "name": "object out",
                    "links": [
                        {
                            "portIn": "earjb46wu",
                            "portOut": "object out",
                            "objIn": "7kfqpc5qm",
                            "objOut": "w15soy3mm"
                        },
                        {
                            "portIn": "earjb46wu",
                            "portOut": "object out",
                            "objIn": "tpwdgfvie",
                            "objOut": "w15soy3mm"
                        },
                        {
                            "portIn": "earjb46wu",
                            "portOut": "object out",
                            "objIn": "u5j2xjuwv",
                            "objOut": "w15soy3mm"
                        },
                        {
                            "portIn": "earjb46wu",
                            "portOut": "object out",
                            "objIn": "ulcz6fiks",
                            "objOut": "w15soy3mm"
                        }
                    ]
                }
            ],
            "objName": "Ops.Json.SwitchObject"
        },
        {
            "id": "7w59v0cu1",
            "uiAttribs": {},
            "portsOut": [
                {
                    "name": "Result",
                    "links": [
                        {
                            "portIn": "Object Index",
                            "portOut": "Result",
                            "objIn": "w15soy3mm",
                            "objOut": "7w59v0cu1"
                        }
                    ]
                }
            ],
            "objName": "Ops.Ui.VizNumber"
        },
        {
            "id": "dyhawpz8f",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Gradient",
                    "value": "{\"keys\":[{\"pos\":0,\"posy\":0.47,\"r\":0.49785156249999996,\"g\":0.3838319142790217,\"b\":0.016435270011425016},{\"pos\":0.025390625,\"posy\":0.47,\"r\":0.49785156249999996,\"g\":0.3838319142790217,\"b\":0.016435270011425016},{\"pos\":0.220703125,\"posy\":0.7,\"r\":0.25611979166666665,\"g\":0.21120218365800145,\"b\":0.07990456024805705},{\"pos\":0.474609375,\"posy\":0.76,\"r\":0.5665690104166667,\"g\":0.3949108444030572,\"b\":0.04373152678211531},{\"pos\":0.619140625,\"posy\":0.27,\"r\":0.9229166666666666,\"g\":0.8126879861212183,\"b\":0.2295427083969116},{\"pos\":0.73828125,\"posy\":0.6,\"r\":0.9372549019607843,\"g\":0.9235654105392156,\"b\":0.6980392156862745},{\"pos\":0.9296875,\"posy\":0.38,\"r\":0.989453125,\"g\":0.9540763370037894,\"b\":0.6700013533234597},{\"pos\":1,\"posy\":0.38,\"r\":0.989453125,\"g\":0.9540763370037894,\"b\":0.6700013533234597}]}"
                },
                {
                    "name": "Direction index",
                    "value": 0
                },
                {
                    "name": "Direction",
                    "value": "X"
                },
                {
                    "name": "Smoothstep",
                    "value": 1
                },
                {
                    "name": "Step",
                    "value": 0
                },
                {
                    "name": "Flip",
                    "value": 0
                },
                {
                    "name": "sRGB",
                    "value": 0
                },
                {
                    "name": "Oklab",
                    "value": 0
                },
                {
                    "name": "Size",
                    "value": 256
                },
                {
                    "name": "filter index",
                    "value": 1
                },
                {
                    "name": "filter",
                    "value": "linear"
                },
                {
                    "name": "wrap index",
                    "value": 0
                },
                {
                    "name": "wrap",
                    "value": "clamp to edge"
                },
                {
                    "name": "Dither",
                    "value": 0
                },
                {
                    "name": "Gradient Array",
                    "value": 0
                }
            ],
            "portsOut": [
                {
                    "name": "Texture",
                    "links": [
                        {
                            "portIn": "object port 2",
                            "portOut": "Texture",
                            "objIn": "w15soy3mm",
                            "objOut": "dyhawpz8f"
                        }
                    ]
                }
            ],
            "objName": "Ops.Gl.GradientTexture"
        },
        {
            "id": "wludx0qz0",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Variable",
                    "value": "LayerIndex"
                }
            ],
            "objName": "Ops.Vars.VarSetNumber_v2"
        },
        {
            "id": "gonsnbpbs",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "text",
                    "value": "all\nlayer1\nlayer2\nlayer3\nlayer4"
                },
                {
                    "name": "separator",
                    "value": ""
                },
                {
                    "name": "Numbers",
                    "value": 0
                },
                {
                    "name": "Trim",
                    "value": 1
                },
                {
                    "name": "Split Lines",
                    "value": 1
                }
            ],
            "portsOut": [
                {
                    "name": "array",
                    "links": [
                        {
                            "portIn": "Values",
                            "portOut": "array",
                            "objIn": "pu2ujx53p",
                            "objOut": "gonsnbpbs"
                        }
                    ]
                },
                {
                    "name": "length",
                    "value": 5
                }
            ],
            "objName": "Ops.Array.StringToArray_v2"
        },
        {
            "id": "pu2ujx53p",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Text",
                    "value": "Layers"
                },
                {
                    "name": "Default",
                    "value": "",
                    "title": "Input"
                },
                {
                    "name": "Grey Out",
                    "value": 0
                },
                {
                    "name": "Visible",
                    "value": 1
                },
                {
                    "name": "Lines",
                    "value": 1
                }
            ],
            "portsOut": [
                {
                    "name": "Children",
                    "links": [
                        {
                            "portIn": "link",
                            "portOut": "Children",
                            "objIn": "vd9tmhfbh",
                            "objOut": "pu2ujx53p"
                        }
                    ]
                },
                {
                    "name": "Result",
                    "value": "layer4"
                },
                {
                    "name": "Index",
                    "links": [
                        {
                            "portIn": "Value",
                            "portOut": "Index",
                            "objIn": "wludx0qz0",
                            "objOut": "pu2ujx53p"
                        }
                    ]
                }
            ],
            "objName": "Ops.Sidebar.DropDown_v2"
        },
        {
            "id": "c7wnjk7fg",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "text",
                    "value": "china\nasia\nus"
                },
                {
                    "name": "separator",
                    "value": ""
                },
                {
                    "name": "Numbers",
                    "value": 0
                },
                {
                    "name": "Trim",
                    "value": 1
                },
                {
                    "name": "Split Lines",
                    "value": 1
                }
            ],
            "portsOut": [
                {
                    "name": "array",
                    "links": [
                        {
                            "portIn": "Values",
                            "portOut": "array",
                            "objIn": "0vsk950rh",
                            "objOut": "c7wnjk7fg"
                        }
                    ]
                },
                {
                    "name": "length",
                    "value": 3
                }
            ],
            "objName": "Ops.Array.StringToArray_v2"
        },
        {
            "id": "0vsk950rh",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Text",
                    "value": "Region"
                },
                {
                    "name": "Default",
                    "value": "us",
                    "title": "Input"
                },
                {
                    "name": "Grey Out",
                    "value": 0
                },
                {
                    "name": "Visible",
                    "value": 1
                },
                {
                    "name": "Lines",
                    "value": 1
                }
            ],
            "portsOut": [
                {
                    "name": "Result",
                    "value": "us"
                },
                {
                    "name": "Index",
                    "links": [
                        {
                            "portIn": "Value",
                            "portOut": "Index",
                            "objIn": "ekezspqbh",
                            "objOut": "0vsk950rh"
                        }
                    ]
                }
            ],
            "objName": "Ops.Sidebar.DropDown_v2"
        },
        {
            "id": "ekezspqbh",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Variable",
                    "value": "RegionIndex"
                }
            ],
            "objName": "Ops.Vars.VarSetNumber_v2"
        },
        {
            "id": "f8zl4itqi",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Text",
                    "value": "Class"
                },
                {
                    "name": "Default",
                    "value": "us",
                    "title": "Input"
                },
                {
                    "name": "Grey Out",
                    "value": 0
                },
                {
                    "name": "Visible",
                    "value": 1
                },
                {
                    "name": "Lines",
                    "value": 1
                }
            ],
            "portsOut": [
                {
                    "name": "Children",
                    "links": [
                        {
                            "portIn": "Link",
                            "portOut": "Children",
                            "objIn": "pu2ujx53p",
                            "objOut": "f8zl4itqi"
                        }
                    ]
                },
                {
                    "name": "Result",
                    "value": "copper"
                },
                {
                    "name": "Index",
                    "links": [
                        {
                            "portIn": "Value",
                            "portOut": "Index",
                            "objIn": "4pf1f79oa",
                            "objOut": "f8zl4itqi"
                        }
                    ]
                }
            ],
            "objName": "Ops.Sidebar.DropDown_v2"
        },
        {
            "id": "c9zb0kql8",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "text",
                    "value": "copper\nsilver\ngold"
                },
                {
                    "name": "separator",
                    "value": ""
                },
                {
                    "name": "Numbers",
                    "value": 0
                },
                {
                    "name": "Trim",
                    "value": 1
                },
                {
                    "name": "Split Lines",
                    "value": 1
                }
            ],
            "portsOut": [
                {
                    "name": "array",
                    "links": [
                        {
                            "portIn": "Values",
                            "portOut": "array",
                            "objIn": "f8zl4itqi",
                            "objOut": "c9zb0kql8"
                        }
                    ]
                },
                {
                    "name": "length",
                    "value": 3
                }
            ],
            "objName": "Ops.Array.StringToArray_v2"
        },
        {
            "id": "4pf1f79oa",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Variable",
                    "value": "ClassIndex"
                }
            ],
            "objName": "Ops.Vars.VarSetNumber_v2"
        },
        {
            "id": "grved4i23",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Variable",
                    "value": "ClassIndex"
                }
            ],
            "portsOut": [
                {
                    "name": "Value",
                    "links": [
                        {
                            "portIn": "Number",
                            "portOut": "Value",
                            "objIn": "7w59v0cu1",
                            "objOut": "grved4i23"
                        }
                    ]
                }
            ],
            "objName": "Ops.Vars.VarGetNumber_v2"
        },
        {
            "id": "p7bxj3yqo",
            "uiAttribs": {},
            "storage": {
                "subPatchVer": 2,
                "blueprintVer": 2
            },
            "portsIn": [
                {
                    "name": "7zxlhqqf8",
                    "title": "Texture"
                },
                {
                    "name": "c6sm5ztz4",
                    "value": "PNG",
                    "title": "Format"
                },
                {
                    "name": "6ozewyh0e",
                    "value": 1,
                    "title": "Quality"
                },
                {
                    "name": "ainvr3s9o",
                    "value": "screenshot",
                    "title": "Filename"
                },
                {
                    "name": "uxwx45pbg",
                    "title": "Download"
                },
                {
                    "name": "patchId",
                    "value": "bp2sub_p7bxj3yqo"
                }
            ],
            "objName": "Ops.Gl.DownloadTexture_v3"
        },
        {
            "id": "mjsfpuud5",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Size index",
                    "value": 0
                },
                {
                    "name": "Size",
                    "value": "Auto"
                },
                {
                    "name": "Width",
                    "value": 640
                },
                {
                    "name": "Height",
                    "value": 480
                },
                {
                    "name": "Filter index",
                    "value": 1
                },
                {
                    "name": "Filter",
                    "value": "linear"
                },
                {
                    "name": "Wrap index",
                    "value": 1
                },
                {
                    "name": "Wrap",
                    "value": "repeat"
                },
                {
                    "name": "Anisotropic index",
                    "value": 0
                },
                {
                    "name": "Anisotropic",
                    "value": "0"
                },
                {
                    "name": "Pixel Format index",
                    "value": 4
                },
                {
                    "name": "Pixel Format",
                    "value": "RGBA 8bit ubyte"
                },
                {
                    "name": "Clear",
                    "value": 1
                },
                {
                    "name": "R",
                    "value": 0
                },
                {
                    "name": "G",
                    "value": 0
                },
                {
                    "name": "B",
                    "value": 0
                },
                {
                    "name": "A",
                    "value": 0
                }
            ],
            "portsOut": [
                {
                    "name": "Next",
                    "links": [
                        {
                            "portIn": "render",
                            "portOut": "Next",
                            "objIn": "dwb6w9856",
                            "objOut": "mjsfpuud5"
                        }
                    ]
                },
                {
                    "name": "texture_out",
                    "links": [
                        {
                            "portIn": "7zxlhqqf8",
                            "portOut": "texture_out",
                            "objIn": "p7bxj3yqo",
                            "objOut": "mjsfpuud5"
                        }
                    ]
                },
                {
                    "name": "Aspect Ratio",
                    "value": 1.0338849487785657
                },
                {
                    "name": "Texture Width",
                    "value": 1312
                },
                {
                    "name": "Texture Height",
                    "value": 1269
                }
            ],
            "objName": "Ops.Gl.ImageCompose.ImageCompose_v4"
        },
        {
            "id": "gj8g56bq3",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "blendMode index",
                    "value": 0
                },
                {
                    "name": "blendMode",
                    "value": "normal"
                },
                {
                    "name": "amount",
                    "value": 1
                },
                {
                    "name": "Premultiplied",
                    "value": 0
                },
                {
                    "name": "Alpha Mask",
                    "value": 0
                },
                {
                    "name": "removeAlphaSrc",
                    "value": 0
                },
                {
                    "name": "Mask Src index",
                    "value": 1
                },
                {
                    "name": "Mask Src",
                    "value": "luminance"
                },
                {
                    "name": "Invert alpha channel",
                    "value": 0
                },
                {
                    "name": "Aspect Ratio",
                    "value": 0
                },
                {
                    "name": "Stretch Axis index",
                    "value": 0
                },
                {
                    "name": "Stretch Axis",
                    "value": "X"
                },
                {
                    "name": "Position",
                    "value": 0
                },
                {
                    "name": "Crop",
                    "value": 0
                },
                {
                    "name": "flip x",
                    "value": 0
                },
                {
                    "name": "flip y",
                    "value": 0
                },
                {
                    "name": "Transform",
                    "value": 0
                },
                {
                    "name": "Scale X",
                    "value": 1
                },
                {
                    "name": "Scale Y",
                    "value": 1
                },
                {
                    "name": "Position X",
                    "value": 0
                },
                {
                    "name": "Position Y",
                    "value": 0
                },
                {
                    "name": "Rotation",
                    "value": 0
                },
                {
                    "name": "Clip Repeat",
                    "value": 0
                }
            ],
            "portsOut": [
                {
                    "name": "trigger",
                    "links": [
                        {
                            "portIn": "render",
                            "portOut": "trigger",
                            "objIn": "1zlx0178z",
                            "objOut": "gj8g56bq3"
                        }
                    ]
                }
            ],
            "objName": "Ops.Gl.ImageCompose.DrawImage_v3"
        },
        {
            "id": "f23kpy36i",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "blendMode index",
                    "value": 0
                },
                {
                    "name": "blendMode",
                    "value": "normal"
                },
                {
                    "name": "amount",
                    "value": 1
                },
                {
                    "name": "Premultiplied",
                    "value": 0
                },
                {
                    "name": "Alpha Mask",
                    "value": 0
                },
                {
                    "name": "removeAlphaSrc",
                    "value": 0
                },
                {
                    "name": "Mask Src index",
                    "value": 1
                },
                {
                    "name": "Mask Src",
                    "value": "luminance"
                },
                {
                    "name": "Invert alpha channel",
                    "value": 0
                },
                {
                    "name": "Aspect Ratio",
                    "value": 0
                },
                {
                    "name": "Stretch Axis index",
                    "value": 0
                },
                {
                    "name": "Stretch Axis",
                    "value": "X"
                },
                {
                    "name": "Position",
                    "value": 0
                },
                {
                    "name": "Crop",
                    "value": 0
                },
                {
                    "name": "flip x",
                    "value": 0
                },
                {
                    "name": "flip y",
                    "value": 0
                },
                {
                    "name": "Transform",
                    "value": 0
                },
                {
                    "name": "Scale X",
                    "value": 1
                },
                {
                    "name": "Scale Y",
                    "value": 1
                },
                {
                    "name": "Position X",
                    "value": 0
                },
                {
                    "name": "Position Y",
                    "value": 0
                },
                {
                    "name": "Rotation",
                    "value": 0
                },
                {
                    "name": "Clip Repeat",
                    "value": 0
                }
            ],
            "portsOut": [
                {
                    "name": "trigger",
                    "links": [
                        {
                            "portIn": "render",
                            "portOut": "trigger",
                            "objIn": "ljpagbd2h",
                            "objOut": "f23kpy36i"
                        }
                    ]
                }
            ],
            "objName": "Ops.Gl.ImageCompose.DrawImage_v3"
        },
        {
            "id": "f3krgexcm",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "blendMode index",
                    "value": 0
                },
                {
                    "name": "blendMode",
                    "value": "normal"
                },
                {
                    "name": "amount",
                    "value": 1
                },
                {
                    "name": "Premultiplied",
                    "value": 0
                },
                {
                    "name": "Alpha Mask",
                    "value": 0
                },
                {
                    "name": "removeAlphaSrc",
                    "value": 0
                },
                {
                    "name": "Mask Src index",
                    "value": 1
                },
                {
                    "name": "Mask Src",
                    "value": "luminance"
                },
                {
                    "name": "Invert alpha channel",
                    "value": 0
                },
                {
                    "name": "Aspect Ratio",
                    "value": 0
                },
                {
                    "name": "Stretch Axis index",
                    "value": 0
                },
                {
                    "name": "Stretch Axis",
                    "value": "X"
                },
                {
                    "name": "Position",
                    "value": 0
                },
                {
                    "name": "Crop",
                    "value": 0
                },
                {
                    "name": "flip x",
                    "value": 0
                },
                {
                    "name": "flip y",
                    "value": 0
                },
                {
                    "name": "Transform",
                    "value": 0
                },
                {
                    "name": "Scale X",
                    "value": 1
                },
                {
                    "name": "Scale Y",
                    "value": 1
                },
                {
                    "name": "Position X",
                    "value": 0
                },
                {
                    "name": "Position Y",
                    "value": 0
                },
                {
                    "name": "Rotation",
                    "value": 0
                },
                {
                    "name": "Clip Repeat",
                    "value": 0
                }
            ],
            "portsOut": [
                {
                    "name": "trigger",
                    "links": [
                        {
                            "portIn": "render",
                            "portOut": "trigger",
                            "objIn": "12ya0ntt9",
                            "objOut": "f3krgexcm"
                        }
                    ]
                }
            ],
            "objName": "Ops.Gl.ImageCompose.DrawImage_v3"
        },
        {
            "id": "vd9tmhfbh",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Text",
                    "value": "Download Image"
                },
                {
                    "name": "Grey Out",
                    "value": 0
                },
                {
                    "name": "Visible",
                    "value": 1
                }
            ],
            "portsOut": [
                {
                    "name": "childs",
                    "links": [
                        {
                            "portIn": "link",
                            "portOut": "childs",
                            "objIn": "qgd2vnbvp",
                            "objOut": "vd9tmhfbh"
                        }
                    ]
                },
                {
                    "name": "Pressed Trigger",
                    "links": [
                        {
                            "portIn": "uxwx45pbg",
                            "portOut": "Pressed Trigger",
                            "objIn": "p7bxj3yqo",
                            "objOut": "vd9tmhfbh"
                        }
                    ]
                }
            ],
            "objName": "Ops.Sidebar.Button_v2"
        },
        {
            "id": "fmxh87zov",
            "uiAttribs": {},
            "storage": {
                "blueprintVer": 2,
                "subPatchVer": 2
            },
            "portsIn": [
                {
                    "name": "mqmfkaq8t",
                    "title": "LayerIndex"
                },
                {
                    "name": "patchId",
                    "value": "bp2sub_fmxh87zov"
                }
            ],
            "portsOut": [
                {
                    "name": "vfunjpwkx",
                    "title": "Visible",
                    "links": [
                        {
                            "portIn": "bool 1",
                            "portOut": "vfunjpwkx",
                            "objIn": "jd5zw3t0s",
                            "objOut": "fmxh87zov"
                        }
                    ]
                }
            ],
            "objName": "Ops.Patch.PLH3vXR.IsLayerVisible"
        },
        {
            "id": "1zlx0178z",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "blendMode index",
                    "value": 0
                },
                {
                    "name": "blendMode",
                    "value": "normal"
                },
                {
                    "name": "amount",
                    "value": 1
                },
                {
                    "name": "Premultiplied",
                    "value": 0
                },
                {
                    "name": "Alpha Mask",
                    "value": 0
                },
                {
                    "name": "removeAlphaSrc",
                    "value": 0
                },
                {
                    "name": "Mask Src index",
                    "value": 1
                },
                {
                    "name": "Mask Src",
                    "value": "luminance"
                },
                {
                    "name": "Invert alpha channel",
                    "value": 0
                },
                {
                    "name": "Aspect Ratio",
                    "value": 0
                },
                {
                    "name": "Stretch Axis index",
                    "value": 0
                },
                {
                    "name": "Stretch Axis",
                    "value": "X"
                },
                {
                    "name": "Position",
                    "value": 0
                },
                {
                    "name": "Crop",
                    "value": 0
                },
                {
                    "name": "flip x",
                    "value": 0
                },
                {
                    "name": "flip y",
                    "value": 0
                },
                {
                    "name": "Transform",
                    "value": 0
                },
                {
                    "name": "Scale X",
                    "value": 1
                },
                {
                    "name": "Scale Y",
                    "value": 1
                },
                {
                    "name": "Position X",
                    "value": 0
                },
                {
                    "name": "Position Y",
                    "value": 0
                },
                {
                    "name": "Rotation",
                    "value": 0
                },
                {
                    "name": "Clip Repeat",
                    "value": 0
                }
            ],
            "objName": "Ops.Gl.ImageCompose.DrawImage_v3"
        },
        {
            "id": "ljpagbd2h",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "blendMode index",
                    "value": 0
                },
                {
                    "name": "blendMode",
                    "value": "normal"
                },
                {
                    "name": "amount",
                    "value": 1
                },
                {
                    "name": "Premultiplied",
                    "value": 0
                },
                {
                    "name": "Alpha Mask",
                    "value": 0
                },
                {
                    "name": "removeAlphaSrc",
                    "value": 0
                },
                {
                    "name": "Mask Src index",
                    "value": 1
                },
                {
                    "name": "Mask Src",
                    "value": "luminance"
                },
                {
                    "name": "Invert alpha channel",
                    "value": 0
                },
                {
                    "name": "Aspect Ratio",
                    "value": 0
                },
                {
                    "name": "Stretch Axis index",
                    "value": 0
                },
                {
                    "name": "Stretch Axis",
                    "value": "X"
                },
                {
                    "name": "Position",
                    "value": 0
                },
                {
                    "name": "Crop",
                    "value": 0
                },
                {
                    "name": "flip x",
                    "value": 0
                },
                {
                    "name": "flip y",
                    "value": 0
                },
                {
                    "name": "Transform",
                    "value": 0
                },
                {
                    "name": "Scale X",
                    "value": 1
                },
                {
                    "name": "Scale Y",
                    "value": 1
                },
                {
                    "name": "Position X",
                    "value": 0
                },
                {
                    "name": "Position Y",
                    "value": 0
                },
                {
                    "name": "Rotation",
                    "value": 0
                },
                {
                    "name": "Clip Repeat",
                    "value": 0
                }
            ],
            "portsOut": [
                {
                    "name": "trigger",
                    "links": [
                        {
                            "portIn": "render",
                            "portOut": "trigger",
                            "objIn": "gj8g56bq3",
                            "objOut": "ljpagbd2h"
                        }
                    ]
                }
            ],
            "objName": "Ops.Gl.ImageCompose.DrawImage_v3"
        },
        {
            "id": "12ya0ntt9",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "blendMode index",
                    "value": 0
                },
                {
                    "name": "blendMode",
                    "value": "normal"
                },
                {
                    "name": "amount",
                    "value": 1
                },
                {
                    "name": "Premultiplied",
                    "value": 0
                },
                {
                    "name": "Alpha Mask",
                    "value": 0
                },
                {
                    "name": "removeAlphaSrc",
                    "value": 0
                },
                {
                    "name": "Mask Src index",
                    "value": 1
                },
                {
                    "name": "Mask Src",
                    "value": "luminance"
                },
                {
                    "name": "Invert alpha channel",
                    "value": 0
                },
                {
                    "name": "Aspect Ratio",
                    "value": 0
                },
                {
                    "name": "Stretch Axis index",
                    "value": 0
                },
                {
                    "name": "Stretch Axis",
                    "value": "X"
                },
                {
                    "name": "Position",
                    "value": 0
                },
                {
                    "name": "Crop",
                    "value": 0
                },
                {
                    "name": "flip x",
                    "value": 0
                },
                {
                    "name": "flip y",
                    "value": 0
                },
                {
                    "name": "Transform",
                    "value": 0
                },
                {
                    "name": "Scale X",
                    "value": 1
                },
                {
                    "name": "Scale Y",
                    "value": 1
                },
                {
                    "name": "Position X",
                    "value": 0
                },
                {
                    "name": "Position Y",
                    "value": 0
                },
                {
                    "name": "Rotation",
                    "value": 0
                },
                {
                    "name": "Clip Repeat",
                    "value": 0
                }
            ],
            "objName": "Ops.Gl.ImageCompose.DrawImage_v3"
        },
        {
            "id": "x0ump1ymj",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Variable",
                    "value": "CameraParameter"
                }
            ],
            "objName": "Ops.Vars.VarSetArray_v2"
        },
        {
            "id": "77khg8wx3",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Num Triplets",
                    "value": 1
                }
            ],
            "portsOut": [
                {
                    "name": "Array",
                    "links": [
                        {
                            "portIn": "Array 1",
                            "portOut": "Array",
                            "objIn": "bwe0c0gvt",
                            "objOut": "77khg8wx3"
                        }
                    ]
                },
                {
                    "name": "Total points",
                    "value": 1
                },
                {
                    "name": "Array length",
                    "value": 3
                }
            ],
            "objName": "Ops.Array.Array3"
        },
        {
            "id": "qbp2tpc51",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Num Triplets",
                    "value": 1
                },
                {
                    "name": "X",
                    "value": 90
                },
                {
                    "name": "Y",
                    "value": 0
                },
                {
                    "name": "Z",
                    "value": 1
                }
            ],
            "portsOut": [
                {
                    "name": "Array",
                    "links": [
                        {
                            "portIn": "Array 0",
                            "portOut": "Array",
                            "objIn": "bwe0c0gvt",
                            "objOut": "qbp2tpc51"
                        }
                    ]
                },
                {
                    "name": "Total points",
                    "value": 1
                },
                {
                    "name": "Array length",
                    "value": 3
                }
            ],
            "objName": "Ops.Array.Array3"
        },
        {
            "id": "bwe0c0gvt",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Array 5",
                    "value": 0
                },
                {
                    "name": "Array 6",
                    "value": 0
                },
                {
                    "name": "Array 7",
                    "value": 0
                }
            ],
            "portsOut": [
                {
                    "name": "Result",
                    "links": [
                        {
                            "portIn": "Value",
                            "portOut": "Result",
                            "objIn": "x0ump1ymj",
                            "objOut": "bwe0c0gvt"
                        }
                    ]
                },
                {
                    "name": "Array length",
                    "value": 15
                }
            ],
            "objName": "Ops.Array.ArrayMerge_v3"
        },
        {
            "id": "wyvzk7olm",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Text",
                    "value": "LayerInterval"
                },
                {
                    "name": "Min",
                    "value": 0
                },
                {
                    "name": "Max",
                    "value": 0.2
                },
                {
                    "name": "Step",
                    "value": 0.001
                },
                {
                    "name": "Suffix",
                    "value": ""
                },
                {
                    "name": "Grey Out",
                    "value": 1
                },
                {
                    "name": "Visible",
                    "value": 1
                },
                {
                    "name": "Input",
                    "value": 0.001
                },
                {
                    "name": "Default",
                    "value": 0.001
                }
            ],
            "portsOut": [
                {
                    "name": "childs",
                    "links": [
                        {
                            "portIn": "link",
                            "portOut": "childs",
                            "objIn": "d4a0fqbdw",
                            "objOut": "wyvzk7olm"
                        }
                    ]
                },
                {
                    "name": "Result",
                    "value": 0.001
                }
            ],
            "objName": "Ops.Sidebar.Slider_v3"
        },
        {
            "id": "d4a0fqbdw",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Text",
                    "value": "ImageIntervalX"
                },
                {
                    "name": "Min",
                    "value": 0
                },
                {
                    "name": "Max",
                    "value": 0.2
                },
                {
                    "name": "Step",
                    "value": 0.001
                },
                {
                    "name": "Suffix",
                    "value": ""
                },
                {
                    "name": "Grey Out",
                    "value": 0
                },
                {
                    "name": "Visible",
                    "value": 1
                },
                {
                    "name": "Input",
                    "value": 0.005
                },
                {
                    "name": "Default",
                    "value": 0.005
                }
            ],
            "portsOut": [
                {
                    "name": "childs",
                    "links": [
                        {
                            "portIn": "link",
                            "portOut": "childs",
                            "objIn": "zjs755gma",
                            "objOut": "d4a0fqbdw"
                        }
                    ]
                },
                {
                    "name": "Result",
                    "links": [
                        {
                            "portIn": "Number",
                            "portOut": "Result",
                            "objIn": "pzvxk2yv4",
                            "objOut": "d4a0fqbdw"
                        }
                    ]
                }
            ],
            "objName": "Ops.Sidebar.Slider_v3"
        },
        {
            "id": "zjs755gma",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Text",
                    "value": "ImageIntervalZ"
                },
                {
                    "name": "Min",
                    "value": 0
                },
                {
                    "name": "Max",
                    "value": 0.01
                },
                {
                    "name": "Step",
                    "value": 0.0001
                },
                {
                    "name": "Suffix",
                    "value": ""
                },
                {
                    "name": "Grey Out",
                    "value": 0
                },
                {
                    "name": "Visible",
                    "value": 1
                },
                {
                    "name": "Input",
                    "value": 0
                },
                {
                    "name": "Default",
                    "value": 0
                }
            ],
            "portsOut": [
                {
                    "name": "childs",
                    "links": [
                        {
                            "portIn": "link",
                            "portOut": "childs",
                            "objIn": "lk86313o6",
                            "objOut": "zjs755gma"
                        }
                    ]
                },
                {
                    "name": "Result",
                    "links": [
                        {
                            "portIn": "Number",
                            "portOut": "Result",
                            "objIn": "8jr3xd95w",
                            "objOut": "zjs755gma"
                        }
                    ]
                }
            ],
            "objName": "Ops.Sidebar.Slider_v3"
        },
        {
            "id": "t8yw0x6hm",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Variable",
                    "value": "LayerInterval"
                }
            ],
            "objName": "Ops.Vars.VarSetNumber_v2"
        },
        {
            "id": "5e3m8ibhh",
            "uiAttribs": {},
            "portsOut": [
                {
                    "name": "Result",
                    "links": [
                        {
                            "portIn": "Value",
                            "portOut": "Result",
                            "objIn": "t8yw0x6hm",
                            "objOut": "5e3m8ibhh"
                        }
                    ]
                }
            ],
            "objName": "Ops.Ui.VizNumber"
        },
        {
            "id": "pzvxk2yv4",
            "uiAttribs": {},
            "portsOut": [
                {
                    "name": "Result",
                    "links": [
                        {
                            "portIn": "Value",
                            "portOut": "Result",
                            "objIn": "z0m37sdix",
                            "objOut": "pzvxk2yv4"
                        }
                    ]
                }
            ],
            "objName": "Ops.Ui.VizNumber"
        },
        {
            "id": "8jr3xd95w",
            "uiAttribs": {},
            "portsOut": [
                {
                    "name": "Result",
                    "links": [
                        {
                            "portIn": "Value",
                            "portOut": "Result",
                            "objIn": "wufcltzix",
                            "objOut": "8jr3xd95w"
                        }
                    ]
                }
            ],
            "objName": "Ops.Ui.VizNumber"
        },
        {
            "id": "z0m37sdix",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Variable",
                    "value": "ImageIntervalX"
                }
            ],
            "objName": "Ops.Vars.VarSetNumber_v2"
        },
        {
            "id": "wufcltzix",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Variable",
                    "value": "ImageIntervalZ"
                }
            ],
            "objName": "Ops.Vars.VarSetNumber_v2"
        },
        {
            "id": "vkv1i5j7q",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Gradient",
                    "value": "{\"keys\":[{\"pos\":0,\"posy\":0.82,\"r\":1,\"g\":0.9795150756835938,\"b\":0.9795150756835938},{\"pos\":0.216796875,\"posy\":0.82,\"r\":1,\"g\":0.9795150756835938,\"b\":0.9795150756835938},{\"pos\":0.373046875,\"posy\":0.52,\"r\":0.4146809895833333,\"g\":0.4146809895833333,\"b\":0.4146809895833333},{\"pos\":0.490234375,\"posy\":0.49,\"r\":0.14537034742534163,\"g\":0.15413411458333337,\"b\":0.1531382319517434},{\"pos\":0.587890625,\"posy\":0.71,\"r\":0,\"g\":0,\"b\":0},{\"pos\":1,\"posy\":0.71,\"r\":0,\"g\":0,\"b\":0}]}"
                },
                {
                    "name": "Direction index",
                    "value": 2
                },
                {
                    "name": "Direction",
                    "value": "Y"
                },
                {
                    "name": "Smoothstep",
                    "value": 0
                },
                {
                    "name": "Step",
                    "value": 0
                },
                {
                    "name": "Flip",
                    "value": 0
                },
                {
                    "name": "sRGB",
                    "value": 0
                },
                {
                    "name": "Oklab",
                    "value": 0
                },
                {
                    "name": "Size",
                    "value": 256
                },
                {
                    "name": "filter index",
                    "value": 1
                },
                {
                    "name": "filter",
                    "value": "linear"
                },
                {
                    "name": "wrap index",
                    "value": 0
                },
                {
                    "name": "wrap",
                    "value": "clamp to edge"
                },
                {
                    "name": "Dither",
                    "value": 0
                },
                {
                    "name": "Gradient Array",
                    "value": 0
                }
            ],
            "portsOut": [
                {
                    "name": "Texture",
                    "links": [
                        {
                            "portIn": "1er6wsd99",
                            "portOut": "Texture",
                            "objIn": "ulcz6fiks",
                            "objOut": "vkv1i5j7q"
                        }
                    ]
                }
            ],
            "objName": "Ops.Gl.GradientTexture"
        },
        {
            "id": "umz46jcb8",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Gradient",
                    "value": "{\"keys\":[{\"pos\":0,\"posy\":0.65,\"r\":0.772265625,\"g\":0.7694375038146972,\"b\":0.7694375038146972},{\"pos\":0.4453125,\"posy\":0.65,\"r\":0.772265625,\"g\":0.7694375038146972,\"b\":0.7694375038146972},{\"pos\":0.599609375,\"posy\":0.6,\"r\":0.3150716145833333,\"g\":0.2978303185353676,\"b\":0.3044742789069763},{\"pos\":0.72265625,\"posy\":0.43,\"r\":0.001822916666666674,\"g\":0.001822916666666674,\"b\":0.001822916666666674},{\"pos\":1,\"posy\":0.43,\"r\":0.001822916666666674,\"g\":0.001822916666666674,\"b\":0.001822916666666674}]}"
                },
                {
                    "name": "Direction index",
                    "value": 2
                },
                {
                    "name": "Direction",
                    "value": "Y"
                },
                {
                    "name": "Smoothstep",
                    "value": 0
                },
                {
                    "name": "Step",
                    "value": 0
                },
                {
                    "name": "Flip",
                    "value": 0
                },
                {
                    "name": "sRGB",
                    "value": 0
                },
                {
                    "name": "Oklab",
                    "value": 0
                },
                {
                    "name": "Size",
                    "value": 256
                },
                {
                    "name": "filter index",
                    "value": 1
                },
                {
                    "name": "filter",
                    "value": "linear"
                },
                {
                    "name": "wrap index",
                    "value": 0
                },
                {
                    "name": "wrap",
                    "value": "clamp to edge"
                },
                {
                    "name": "Dither",
                    "value": 0
                },
                {
                    "name": "Gradient Array",
                    "value": 0
                }
            ],
            "portsOut": [
                {
                    "name": "Texture",
                    "links": [
                        {
                            "portIn": "1er6wsd99",
                            "portOut": "Texture",
                            "objIn": "tpwdgfvie",
                            "objOut": "umz46jcb8"
                        }
                    ]
                }
            ],
            "objName": "Ops.Gl.GradientTexture"
        },
        {
            "id": "mop8ua86p",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Num Triplets",
                    "value": 1
                },
                {
                    "name": "Z",
                    "value": 0
                }
            ],
            "portsOut": [
                {
                    "name": "Array",
                    "links": [
                        {
                            "portIn": "Array 2",
                            "portOut": "Array",
                            "objIn": "bwe0c0gvt",
                            "objOut": "mop8ua86p"
                        }
                    ]
                },
                {
                    "name": "Total points",
                    "value": 1
                },
                {
                    "name": "Array length",
                    "value": 3
                }
            ],
            "objName": "Ops.Array.Array3"
        },
        {
            "id": "8l7yqurh2",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Num Triplets",
                    "value": 1
                },
                {
                    "name": "X",
                    "value": 0
                },
                {
                    "name": "Y",
                    "value": 0
                },
                {
                    "name": "Z",
                    "value": 0
                }
            ],
            "portsOut": [
                {
                    "name": "Array",
                    "links": [
                        {
                            "portIn": "Array 3",
                            "portOut": "Array",
                            "objIn": "bwe0c0gvt",
                            "objOut": "8l7yqurh2"
                        }
                    ]
                },
                {
                    "name": "Total points",
                    "value": 1
                },
                {
                    "name": "Array length",
                    "value": 3
                }
            ],
            "objName": "Ops.Array.Array3"
        },
        {
            "id": "rgkl3u4p1",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Num Triplets",
                    "value": 1
                },
                {
                    "name": "X",
                    "value": 0
                },
                {
                    "name": "Y",
                    "value": 0
                },
                {
                    "name": "Z",
                    "value": 0
                }
            ],
            "portsOut": [
                {
                    "name": "Array",
                    "links": [
                        {
                            "portIn": "Array 4",
                            "portOut": "Array",
                            "objIn": "bwe0c0gvt",
                            "objOut": "rgkl3u4p1"
                        }
                    ]
                },
                {
                    "name": "Total points",
                    "value": 1
                },
                {
                    "name": "Array length",
                    "value": 3
                }
            ],
            "objName": "Ops.Array.Array3"
        },
        {
            "id": "qnd88wix5",
            "uiAttribs": {},
            "portsOut": [
                {
                    "name": "Next",
                    "links": [
                        {
                            "portIn": "Trigger",
                            "portOut": "Next",
                            "objIn": "vzy144kac",
                            "objOut": "qnd88wix5"
                        }
                    ]
                },
                {
                    "name": "Was Triggered",
                    "value": 0
                }
            ],
            "objName": "Ops.Trigger.TriggerOnce"
        },
        {
            "id": "isyibn62s",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Variable",
                    "value": "IsInDebugMode"
                }
            ],
            "objName": "Ops.Vars.VarSetNumber_v2"
        },
        {
            "id": "sa1md22kb",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Variable",
                    "value": "IsInDebugMode"
                }
            ],
            "portsOut": [
                {
                    "name": "Value",
                    "links": [
                        {
                            "portIn": "Boolean",
                            "portOut": "Value",
                            "objIn": "c6g9rrcm1",
                            "objOut": "sa1md22kb"
                        }
                    ]
                }
            ],
            "objName": "Ops.Vars.VarGetNumber_v2"
        },
        {
            "id": "w58slypkb",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Variable",
                    "value": "IsInDebugMode"
                }
            ],
            "portsOut": [
                {
                    "name": "Value",
                    "links": [
                        {
                            "portIn": "bool 1",
                            "portOut": "Value",
                            "objIn": "z27ar9eht",
                            "objOut": "w58slypkb"
                        }
                    ]
                }
            ],
            "objName": "Ops.Vars.VarGetNumber_v2"
        },
        {
            "id": "dw95cjnda",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Array 2",
                    "value": 0
                },
                {
                    "name": "Array 3",
                    "value": 0
                },
                {
                    "name": "Array 4",
                    "value": 0
                },
                {
                    "name": "Array 5",
                    "value": 0
                },
                {
                    "name": "Array 6",
                    "value": 0
                },
                {
                    "name": "Array 7",
                    "value": 0
                },
                {
                    "name": "Array 8",
                    "value": 0
                },
                {
                    "name": "Array 9",
                    "value": 0
                }
            ],
            "objName": "Ops.Array.SwitchArray"
        },
        {
            "id": "9chbeaohk",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Variable",
                    "value": "APIData_In"
                }
            ],
            "portsOut": [
                {
                    "name": "Value",
                    "links": [
                        {
                            "portIn": "Array 0",
                            "portOut": "Value",
                            "objIn": "dw95cjnda",
                            "objOut": "9chbeaohk"
                        },
                        {
                            "portIn": "array",
                            "portOut": "Value",
                            "objIn": "qitmpipz3",
                            "objOut": "9chbeaohk"
                        }
                    ]
                }
            ],
            "objName": "Ops.Vars.VarGetArray_v2"
        },
        {
            "id": "q98mehqp7",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Variable",
                    "value": "APIData_In"
                }
            ],
            "objName": "Ops.Vars.VarSetArray_v2"
        },
        {
            "id": "zijtbt5ea",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Title",
                    "value": "Set API Data"
                }
            ],
            "objName": "Ops.Ui.Area"
        },
        {
            "id": "pee34val8",
            "uiAttribs": {},
            "portsOut": [
                {
                    "name": "Changed",
                    "links": [
                        {
                            "portIn": "Trigger",
                            "portOut": "Changed",
                            "objIn": "ikcwihejy",
                            "objOut": "pee34val8"
                        }
                    ]
                }
            ],
            "objName": "Ops.Trigger.TriggerOnChangeArray"
        },
        {
            "id": "ikcwihejy",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Named Trigger",
                    "value": "OnDataChange"
                }
            ],
            "objName": "Ops.Trigger.TriggerSend"
        },
        {
            "id": "cvzahihkb",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Mode select index",
                    "value": 0
                },
                {
                    "name": "Mode select",
                    "value": "Number"
                },
                {
                    "name": "Default Value",
                    "value": 0
                },
                {
                    "name": "Reverse",
                    "value": 0
                }
            ],
            "portsOut": [
                {
                    "name": "Array length out",
                    "value": 156
                }
            ],
            "objName": "Ops.Array.Array_v3"
        },
        {
            "id": "fvqi5pt53",
            "uiAttribs": {},
            "portsOut": [
                {
                    "name": "UI",
                    "links": [
                        {
                            "portIn": "Value",
                            "portOut": "UI",
                            "objIn": "isyibn62s",
                            "objOut": "fvqi5pt53"
                        }
                    ]
                },
                {
                    "name": "Overlay Mode",
                    "value": 0
                },
                {
                    "name": "Remote Viewer",
                    "value": 0
                },
                {
                    "name": "Is Standalone",
                    "value": 0
                },
                {
                    "name": "Canvas Mode",
                    "value": 0
                },
                {
                    "name": "Patch Field Visible",
                    "value": 0
                }
            ],
            "objName": "Ops.Cables.UIMode"
        },
        {
            "id": "0fdc9rxf7",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Variable",
                    "value": "AnimationDuration"
                }
            ],
            "objName": "Ops.Vars.VarSetNumber_v2"
        },
        {
            "id": "c0f9bdzbd",
            "uiAttribs": {},
            "portsOut": [
                {
                    "name": "Result",
                    "links": [
                        {
                            "portIn": "Value",
                            "portOut": "Result",
                            "objIn": "0fdc9rxf7",
                            "objOut": "c0f9bdzbd"
                        },
                        {
                            "portIn": "Duration",
                            "portOut": "Result",
                            "objIn": "8x60pbu7u",
                            "objOut": "c0f9bdzbd"
                        }
                    ]
                }
            ],
            "objName": "Ops.Ui.VizNumber"
        },
        {
            "id": "z8zee7ph8",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Text",
                    "value": "Duration"
                },
                {
                    "name": "Min",
                    "value": 0
                },
                {
                    "name": "Max",
                    "value": 10
                },
                {
                    "name": "Step",
                    "value": 0.5
                },
                {
                    "name": "Suffix",
                    "value": ""
                },
                {
                    "name": "Grey Out",
                    "value": 0
                },
                {
                    "name": "Visible",
                    "value": 1
                },
                {
                    "name": "Input",
                    "value": 4
                },
                {
                    "name": "Default",
                    "value": 4
                }
            ],
            "portsOut": [
                {
                    "name": "childs",
                    "links": [
                        {
                            "portIn": "link",
                            "portOut": "childs",
                            "objIn": "y0uj4w0yk",
                            "objOut": "z8zee7ph8"
                        }
                    ]
                },
                {
                    "name": "Result",
                    "links": [
                        {
                            "portIn": "Number",
                            "portOut": "Result",
                            "objIn": "c0f9bdzbd",
                            "objOut": "z8zee7ph8"
                        }
                    ]
                }
            ],
            "objName": "Ops.Sidebar.Slider_v3"
        },
        {
            "id": "zzrl1muoq",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Named Trigger",
                    "value": "Initialization"
                }
            ],
            "portsOut": [
                {
                    "name": "Triggered",
                    "links": [
                        {
                            "portIn": "Exec",
                            "portOut": "Triggered",
                            "objIn": "iso21stoi",
                            "objOut": "zzrl1muoq"
                        }
                    ]
                }
            ],
            "objName": "Ops.Trigger.TriggerReceive"
        },
        {
            "id": "c6g9rrcm1",
            "uiAttribs": {},
            "portsOut": [
                {
                    "name": "Bool",
                    "value": 1
                }
            ],
            "objName": "Ops.Ui.VizBool"
        },
        {
            "id": "5f3c5zunk",
            "uiAttribs": {},
            "portsOut": [
                {
                    "name": "Next",
                    "links": [
                        {
                            "portIn": "Trigger",
                            "portOut": "Next",
                            "objIn": "ikcwihejy",
                            "objOut": "5f3c5zunk"
                        }
                    ]
                }
            ],
            "objName": "Ops.Trigger.TriggerButton"
        },
        {
            "id": "g9114cgug",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Area index",
                    "value": 0
                },
                {
                    "name": "Area",
                    "value": "Canvas"
                },
                {
                    "name": "Active",
                    "value": 1
                }
            ],
            "portsOut": [
                {
                    "name": "Click Right",
                    "links": [
                        {
                            "portIn": "Trigger",
                            "portOut": "Click Right",
                            "objIn": "5f3c5zunk",
                            "objOut": "g9114cgug"
                        }
                    ]
                },
                {
                    "name": "Button pressed Left",
                    "value": 0
                },
                {
                    "name": "Button pressed Middle",
                    "value": 0
                },
                {
                    "name": "Button pressed Right",
                    "value": 0
                }
            ],
            "objName": "Ops.Devices.Mouse.MouseButtons"
        },
        {
            "id": "ioep6m2t1",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Gradient",
                    "value": "{\"keys\":[{\"pos\":0,\"posy\":0.65,\"r\":1,\"g\":1,\"b\":1},{\"pos\":0.4453125,\"posy\":0.65,\"r\":1,\"g\":1,\"b\":1},{\"pos\":1,\"posy\":0.65,\"r\":1,\"g\":1,\"b\":1}]}"
                },
                {
                    "name": "Direction index",
                    "value": 2
                },
                {
                    "name": "Direction",
                    "value": "Y"
                },
                {
                    "name": "Smoothstep",
                    "value": 0
                },
                {
                    "name": "Step",
                    "value": 0
                },
                {
                    "name": "Flip",
                    "value": 0
                },
                {
                    "name": "sRGB",
                    "value": 0
                },
                {
                    "name": "Oklab",
                    "value": 0
                },
                {
                    "name": "Size",
                    "value": 256
                },
                {
                    "name": "filter index",
                    "value": 1
                },
                {
                    "name": "filter",
                    "value": "linear"
                },
                {
                    "name": "wrap index",
                    "value": 0
                },
                {
                    "name": "wrap",
                    "value": "clamp to edge"
                },
                {
                    "name": "Dither",
                    "value": 0
                },
                {
                    "name": "Gradient Array",
                    "value": 0
                }
            ],
            "portsOut": [
                {
                    "name": "Texture",
                    "links": [
                        {
                            "portIn": "1er6wsd99",
                            "portOut": "Texture",
                            "objIn": "7kfqpc5qm",
                            "objOut": "ioep6m2t1"
                        }
                    ]
                }
            ],
            "objName": "Ops.Gl.GradientTexture"
        },
        {
            "id": "iso21stoi",
            "uiAttribs": {},
            "portsOut": [
                {
                    "name": "Next",
                    "links": [
                        {
                            "portIn": "Trigger",
                            "portOut": "Next",
                            "objIn": "5iqp3hc5r",
                            "objOut": "iso21stoi"
                        }
                    ]
                },
                {
                    "name": "Was Triggered",
                    "value": 1
                }
            ],
            "objName": "Ops.Trigger.TriggerOnce"
        },
        {
            "id": "ldvs1lghl",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Variable",
                    "value": "Animation"
                }
            ],
            "portsOut": [
                {
                    "name": "Value",
                    "links": [
                        {
                            "portIn": "Number",
                            "portOut": "Value",
                            "objIn": "yilsnfhdz",
                            "objOut": "ldvs1lghl"
                        }
                    ]
                }
            ],
            "objName": "Ops.Vars.VarGetNumber_v2"
        },
        {
            "id": "dzp3pbx66",
            "uiAttribs": {},
            "storage": {
                "blueprintVer": 2,
                "subPatchVer": 2
            },
            "portsIn": [
                {
                    "name": "patchId",
                    "value": "bp2sub_dzp3pbx66"
                }
            ],
            "objName": "Ops.Patch.PLH3vXR.CameraAnimated"
        },
        {
            "id": "pq2y2fz0y",
            "uiAttribs": {},
            "portsOut": [
                {
                    "name": "Average X",
                    "value": 1
                },
                {
                    "name": "Average Y",
                    "links": [
                        {
                            "portIn": "7ry50s9p2",
                            "portOut": "Average Y",
                            "objIn": "kfckegrh0",
                            "objOut": "pq2y2fz0y"
                        },
                        {
                            "portIn": "dw634vl53",
                            "portOut": "Average Y",
                            "objIn": "kfckegrh0",
                            "objOut": "pq2y2fz0y"
                        }
                    ]
                },
                {
                    "name": "Average Z",
                    "value": -0.001
                }
            ],
            "objName": "Ops.Array.Array3GetAverage"
        },
        {
            "id": "p5pdm7pgt",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Array 3",
                    "value": 0
                },
                {
                    "name": "Array 4",
                    "value": 0
                },
                {
                    "name": "Array 5",
                    "value": 0
                },
                {
                    "name": "Array 6",
                    "value": 0
                },
                {
                    "name": "Array 7",
                    "value": 0
                }
            ],
            "portsOut": [
                {
                    "name": "Result",
                    "links": [
                        {
                            "portIn": "Array In",
                            "portOut": "Result",
                            "objIn": "7wf3mhm2n",
                            "objOut": "p5pdm7pgt"
                        }
                    ]
                },
                {
                    "name": "Array length",
                    "value": 9
                }
            ],
            "objName": "Ops.Array.ArrayMerge_v3"
        },
        {
            "id": "7wf3mhm2n",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Separate inc/dec",
                    "value": 1
                },
                {
                    "name": "Inc factor",
                    "value": 10,
                    "title": "Inc factor"
                },
                {
                    "name": "Dec factor",
                    "value": 20
                }
            ],
            "portsOut": [
                {
                    "name": "Next",
                    "links": [
                        {
                            "portIn": "Update",
                            "portOut": "Next",
                            "objIn": "wkoq4a75k",
                            "objOut": "7wf3mhm2n"
                        }
                    ]
                },
                {
                    "name": "Array Out",
                    "links": [
                        {
                            "portIn": "Array",
                            "portOut": "Array Out",
                            "objIn": "pq2y2fz0y",
                            "objOut": "7wf3mhm2n"
                        },
                        {
                            "portIn": "Array in xyz",
                            "portOut": "Array Out",
                            "objIn": "ktmrkv5gx",
                            "objOut": "7wf3mhm2n"
                        }
                    ]
                }
            ],
            "objName": "Ops.Array.SmoothArray"
        },
        {
            "id": "ceerw8mm0",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "old min",
                    "value": 0
                },
                {
                    "name": "old max",
                    "value": 1
                },
                {
                    "name": "new min",
                    "value": 0.16
                },
                {
                    "name": "new max",
                    "value": 0.65
                },
                {
                    "name": "Easing index",
                    "value": 0
                },
                {
                    "name": "Easing",
                    "value": "Linear"
                },
                {
                    "name": "Clamp",
                    "value": 1
                }
            ],
            "portsOut": [
                {
                    "name": "result",
                    "links": [
                        {
                            "portIn": "Value",
                            "portOut": "result",
                            "objIn": "wkoq4a75k",
                            "objOut": "ceerw8mm0"
                        }
                    ]
                }
            ],
            "objName": "Ops.Math.MapRange"
        },
        {
            "id": "u52u16k6y",
            "uiAttribs": {},
            "portsOut": [
                {
                    "name": "Max",
                    "links": [
                        {
                            "portIn": "number1",
                            "portOut": "Max",
                            "objIn": "0ygh0rfpa",
                            "objOut": "u52u16k6y"
                        }
                    ]
                },
                {
                    "name": "Index Max",
                    "value": 1
                },
                {
                    "name": "Min",
                    "links": [
                        {
                            "portIn": "number2",
                            "portOut": "Min",
                            "objIn": "0ygh0rfpa",
                            "objOut": "u52u16k6y"
                        }
                    ]
                },
                {
                    "name": "Index Min",
                    "value": 2
                }
            ],
            "objName": "Ops.Array.ArrayIndexMinMax"
        },
        {
            "id": "ktmrkv5gx",
            "uiAttribs": {},
            "portsOut": [
                {
                    "name": "Array 2 out",
                    "links": [
                        {
                            "portIn": "Array",
                            "portOut": "Array 2 out",
                            "objIn": "u52u16k6y",
                            "objOut": "ktmrkv5gx"
                        }
                    ]
                },
                {
                    "name": "Array lengths",
                    "value": 3
                }
            ],
            "objName": "Ops.Array.ArrayUnpack3"
        },
        {
            "id": "0ygh0rfpa",
            "uiAttribs": {},
            "portsOut": [
                {
                    "name": "result",
                    "links": [
                        {
                            "portIn": "value",
                            "portOut": "result",
                            "objIn": "ceerw8mm0",
                            "objOut": "0ygh0rfpa"
                        }
                    ]
                }
            ],
            "objName": "Ops.Math.Subtract"
        },
        {
            "id": "bmhtsiqh7",
            "uiAttribs": {},
            "portsOut": [
                {
                    "name": "result",
                    "links": [
                        {
                            "portIn": "X",
                            "portOut": "result",
                            "objIn": "77khg8wx3",
                            "objOut": "bmhtsiqh7"
                        }
                    ]
                }
            ],
            "objName": "Ops.Math.Sum"
        },
        {
            "id": "05979cqb8",
            "uiAttribs": {},
            "portsOut": [
                {
                    "name": "result",
                    "links": [
                        {
                            "portIn": "Y",
                            "portOut": "result",
                            "objIn": "77khg8wx3",
                            "objOut": "05979cqb8"
                        }
                    ]
                }
            ],
            "objName": "Ops.Math.Sum"
        },
        {
            "id": "i71ekouwg",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Number",
                    "value": 0.6
                }
            ],
            "portsOut": [
                {
                    "name": "Result",
                    "links": [
                        {
                            "portIn": "4wxi8etyc",
                            "portOut": "Result",
                            "objIn": "xjo7cfb3u",
                            "objOut": "i71ekouwg"
                        },
                        {
                            "portIn": "4wxi8etyc",
                            "portOut": "Result",
                            "objIn": "gbotcom6n",
                            "objOut": "i71ekouwg"
                        },
                        {
                            "portIn": "4wxi8etyc",
                            "portOut": "Result",
                            "objIn": "49nrp55cf",
                            "objOut": "i71ekouwg"
                        },
                        {
                            "portIn": "4wxi8etyc",
                            "portOut": "Result",
                            "objIn": "kfckegrh0",
                            "objOut": "i71ekouwg"
                        },
                        {
                            "portIn": "4wxi8etyc",
                            "portOut": "Result",
                            "objIn": "1kohtb298",
                            "objOut": "i71ekouwg"
                        },
                        {
                            "portIn": "Value",
                            "portOut": "Result",
                            "objIn": "1vp8odv70",
                            "objOut": "i71ekouwg"
                        }
                    ]
                }
            ],
            "objName": "Ops.Ui.VizNumber"
        },
        {
            "id": "yilsnfhdz",
            "uiAttribs": {},
            "portsOut": [
                {
                    "name": "Result",
                    "links": [
                        {
                            "portIn": "ul3e7qngs",
                            "portOut": "Result",
                            "objIn": "xjo7cfb3u",
                            "objOut": "yilsnfhdz"
                        },
                        {
                            "portIn": "ul3e7qngs",
                            "portOut": "Result",
                            "objIn": "gbotcom6n",
                            "objOut": "yilsnfhdz"
                        },
                        {
                            "portIn": "ul3e7qngs",
                            "portOut": "Result",
                            "objIn": "49nrp55cf",
                            "objOut": "yilsnfhdz"
                        },
                        {
                            "portIn": "ul3e7qngs",
                            "portOut": "Result",
                            "objIn": "kfckegrh0",
                            "objOut": "yilsnfhdz"
                        },
                        {
                            "portIn": "ul3e7qngs",
                            "portOut": "Result",
                            "objIn": "1kohtb298",
                            "objOut": "yilsnfhdz"
                        }
                    ]
                }
            ],
            "objName": "Ops.Ui.VizNumber"
        },
        {
            "id": "wq2nzlxwu",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Variable",
                    "value": "Animation"
                }
            ],
            "portsOut": [
                {
                    "name": "Value",
                    "links": [
                        {
                            "portIn": "ul3e7qngs",
                            "portOut": "Value",
                            "objIn": "y4vbd9fg3",
                            "objOut": "wq2nzlxwu"
                        }
                    ]
                }
            ],
            "objName": "Ops.Vars.VarGetNumber_v2"
        },
        {
            "id": "gmsk1c9oy",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Number",
                    "value": 0.6
                }
            ],
            "portsOut": [
                {
                    "name": "Result",
                    "links": [
                        {
                            "portIn": "4wxi8etyc",
                            "portOut": "Result",
                            "objIn": "y4vbd9fg3",
                            "objOut": "gmsk1c9oy"
                        }
                    ]
                }
            ],
            "objName": "Ops.Ui.VizNumber"
        },
        {
            "id": "wkoq4a75k",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Separate inc/dec",
                    "value": 0
                },
                {
                    "name": "Inc factor",
                    "value": 10,
                    "title": "Inc/Dec factor"
                },
                {
                    "name": "Dec factor",
                    "value": 4
                }
            ],
            "portsOut": [
                {
                    "name": "Result",
                    "links": [
                        {
                            "portIn": "7ry50s9p2",
                            "portOut": "Result",
                            "objIn": "xjo7cfb3u",
                            "objOut": "wkoq4a75k"
                        },
                        {
                            "portIn": "dw634vl53",
                            "portOut": "Result",
                            "objIn": "xjo7cfb3u",
                            "objOut": "wkoq4a75k"
                        }
                    ]
                }
            ],
            "objName": "Ops.Anim.Smooth"
        },
        {
            "id": "xjo7cfb3u",
            "uiAttribs": {},
            "storage": {
                "blueprintVer": 2,
                "subPatchVer": 2
            },
            "portsIn": [
                {
                    "name": "ul3e7qngs",
                    "title": "Animation"
                },
                {
                    "name": "4wxi8etyc",
                    "title": "Turning Point"
                },
                {
                    "name": "7ry50s9p2",
                    "title": "Value Start"
                },
                {
                    "name": "dw634vl53",
                    "title": "Value Turning"
                },
                {
                    "name": "xafw2raho",
                    "value": 1,
                    "title": "Value End"
                },
                {
                    "name": "patchId",
                    "value": "bp2sub_xjo7cfb3u"
                }
            ],
            "portsOut": [
                {
                    "name": "oud37e362",
                    "title": "Value",
                    "links": [
                        {
                            "portIn": "Z",
                            "portOut": "oud37e362",
                            "objIn": "77khg8wx3",
                            "objOut": "xjo7cfb3u"
                        }
                    ]
                }
            ],
            "objName": "Ops.Patch.PLH3vXR.TwoStepAniamation"
        },
        {
            "id": "gbotcom6n",
            "uiAttribs": {},
            "storage": {
                "blueprintVer": 2,
                "subPatchVer": 2
            },
            "portsIn": [
                {
                    "name": "ul3e7qngs",
                    "title": "Animation"
                },
                {
                    "name": "4wxi8etyc",
                    "title": "Turning Point"
                },
                {
                    "name": "7ry50s9p2",
                    "value": -0.5,
                    "title": "Value Start"
                },
                {
                    "name": "dw634vl53",
                    "value": 0.7,
                    "title": "Value Turning"
                },
                {
                    "name": "xafw2raho",
                    "value": 0,
                    "title": "Value End"
                },
                {
                    "name": "patchId",
                    "value": "bp2sub_gbotcom6n"
                }
            ],
            "portsOut": [
                {
                    "name": "oud37e362",
                    "title": "Value",
                    "links": [
                        {
                            "portIn": "X",
                            "portOut": "oud37e362",
                            "objIn": "mop8ua86p",
                            "objOut": "gbotcom6n"
                        },
                        {
                            "portIn": "number2",
                            "portOut": "oud37e362",
                            "objIn": "bmhtsiqh7",
                            "objOut": "gbotcom6n"
                        }
                    ]
                }
            ],
            "objName": "Ops.Patch.PLH3vXR.TwoStepAniamation"
        },
        {
            "id": "49nrp55cf",
            "uiAttribs": {},
            "storage": {
                "blueprintVer": 2,
                "subPatchVer": 2
            },
            "portsIn": [
                {
                    "name": "ul3e7qngs",
                    "title": "Animation"
                },
                {
                    "name": "4wxi8etyc",
                    "title": "Turning Point"
                },
                {
                    "name": "7ry50s9p2",
                    "value": -0.4,
                    "title": "Value Start"
                },
                {
                    "name": "dw634vl53",
                    "value": -0.4,
                    "title": "Value Turning"
                },
                {
                    "name": "xafw2raho",
                    "value": 0,
                    "title": "Value End"
                },
                {
                    "name": "patchId",
                    "value": "bp2sub_49nrp55cf"
                }
            ],
            "portsOut": [
                {
                    "name": "oud37e362",
                    "title": "Value",
                    "links": [
                        {
                            "portIn": "number1",
                            "portOut": "oud37e362",
                            "objIn": "bmhtsiqh7",
                            "objOut": "49nrp55cf"
                        }
                    ]
                }
            ],
            "objName": "Ops.Patch.PLH3vXR.TwoStepAniamation"
        },
        {
            "id": "kfckegrh0",
            "uiAttribs": {},
            "storage": {
                "blueprintVer": 2,
                "subPatchVer": 2
            },
            "portsIn": [
                {
                    "name": "ul3e7qngs",
                    "title": "Animation"
                },
                {
                    "name": "4wxi8etyc",
                    "title": "Turning Point"
                },
                {
                    "name": "7ry50s9p2",
                    "title": "Value Start"
                },
                {
                    "name": "dw634vl53",
                    "title": "Value Turning"
                },
                {
                    "name": "xafw2raho",
                    "value": 0,
                    "title": "Value End"
                },
                {
                    "name": "patchId",
                    "value": "bp2sub_kfckegrh0"
                }
            ],
            "portsOut": [
                {
                    "name": "oud37e362",
                    "title": "Value",
                    "links": [
                        {
                            "portIn": "Y",
                            "portOut": "oud37e362",
                            "objIn": "mop8ua86p",
                            "objOut": "kfckegrh0"
                        },
                        {
                            "portIn": "number2",
                            "portOut": "oud37e362",
                            "objIn": "05979cqb8",
                            "objOut": "kfckegrh0"
                        }
                    ]
                }
            ],
            "objName": "Ops.Patch.PLH3vXR.TwoStepAniamation"
        },
        {
            "id": "1kohtb298",
            "uiAttribs": {},
            "storage": {
                "blueprintVer": 2,
                "subPatchVer": 2
            },
            "portsIn": [
                {
                    "name": "ul3e7qngs",
                    "title": "Animation"
                },
                {
                    "name": "4wxi8etyc",
                    "title": "Turning Point"
                },
                {
                    "name": "7ry50s9p2",
                    "value": 0.2,
                    "title": "Value Start"
                },
                {
                    "name": "dw634vl53",
                    "value": 0.2,
                    "title": "Value Turning"
                },
                {
                    "name": "xafw2raho",
                    "value": 0,
                    "title": "Value End"
                },
                {
                    "name": "patchId",
                    "value": "bp2sub_1kohtb298"
                }
            ],
            "portsOut": [
                {
                    "name": "oud37e362",
                    "title": "Value",
                    "links": [
                        {
                            "portIn": "number1",
                            "portOut": "oud37e362",
                            "objIn": "05979cqb8",
                            "objOut": "1kohtb298"
                        }
                    ]
                }
            ],
            "objName": "Ops.Patch.PLH3vXR.TwoStepAniamation"
        },
        {
            "id": "y4vbd9fg3",
            "uiAttribs": {},
            "storage": {
                "blueprintVer": 2,
                "subPatchVer": 2
            },
            "portsIn": [
                {
                    "name": "ul3e7qngs",
                    "title": "Animation"
                },
                {
                    "name": "4wxi8etyc",
                    "title": "Turning Point"
                },
                {
                    "name": "7ry50s9p2",
                    "value": 0.2,
                    "title": "Value Start"
                },
                {
                    "name": "dw634vl53",
                    "value": 0.2,
                    "title": "Value Turning"
                },
                {
                    "name": "xafw2raho",
                    "value": 0.001,
                    "title": "Value End"
                },
                {
                    "name": "patchId",
                    "value": "bp2sub_y4vbd9fg3"
                }
            ],
            "portsOut": [
                {
                    "name": "oud37e362",
                    "title": "Value",
                    "links": [
                        {
                            "portIn": "Number",
                            "portOut": "oud37e362",
                            "objIn": "5e3m8ibhh",
                            "objOut": "y4vbd9fg3"
                        }
                    ]
                }
            ],
            "objName": "Ops.Patch.PLH3vXR.TwoStepAniamation"
        },
        {
            "id": "a6nsmmuum",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Title",
                    "value": "Camera"
                }
            ],
            "objName": "Ops.Ui.Area"
        },
        {
            "id": "1vp8odv70",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Variable",
                    "value": "AnimationTurningPoint"
                }
            ],
            "objName": "Ops.Vars.VarSetNumber_v2"
        },
        {
            "id": "nx4j31ykm",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Function Name",
                    "value": "StartPlayingAnimation"
                },
                {
                    "name": "Default Parameter 1",
                    "value": ""
                },
                {
                    "name": "Default Parameter 2",
                    "value": ""
                },
                {
                    "name": "Default Parameter 3",
                    "value": ""
                }
            ],
            "portsOut": [
                {
                    "name": "Next",
                    "links": [
                        {
                            "portIn": "Bang",
                            "portOut": "Next",
                            "objIn": "8x60pbu7u",
                            "objOut": "nx4j31ykm"
                        }
                    ]
                },
                {
                    "name": "Parameter 1",
                    "value": ""
                },
                {
                    "name": "Parameter 2",
                    "value": ""
                },
                {
                    "name": "Parameter 3",
                    "value": ""
                }
            ],
            "objName": "Ops.Cables.Function_v2"
        },
        {
            "id": "qitmpipz3",
            "uiAttribs": {},
            "portsOut": [
                {
                    "name": "length",
                    "links": [
                        {
                            "portIn": "number1",
                            "portOut": "length",
                            "objIn": "v1w8rmfu6",
                            "objOut": "qitmpipz3"
                        }
                    ]
                }
            ],
            "objName": "Ops.Array.ArrayLength_v2"
        },
        {
            "id": "v1w8rmfu6",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "number2",
                    "value": 0
                }
            ],
            "portsOut": [
                {
                    "name": "result",
                    "links": [
                        {
                            "portIn": "bool 2",
                            "portOut": "result",
                            "objIn": "z27ar9eht",
                            "objOut": "v1w8rmfu6"
                        }
                    ]
                }
            ],
            "objName": "Ops.Math.Compare.Equals"
        },
        {
            "id": "z27ar9eht",
            "uiAttribs": {},
            "portsOut": [
                {
                    "name": "result",
                    "links": [
                        {
                            "portIn": "Index",
                            "portOut": "result",
                            "objIn": "dw95cjnda",
                            "objOut": "z27ar9eht"
                        }
                    ]
                }
            ],
            "objName": "Ops.Boolean.And"
        },
        {
            "id": "ja9l5mf5h",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "bounds",
                    "value": 1
                },
                {
                    "name": "Axis index",
                    "value": 2
                },
                {
                    "name": "Axis",
                    "value": "None"
                },
                {
                    "name": "frustum near",
                    "value": -100
                },
                {
                    "name": "frustum far",
                    "value": 100
                }
            ],
            "portsOut": [
                {
                    "name": "trigger",
                    "links": [
                        {
                            "portIn": "Execute",
                            "portOut": "trigger",
                            "objIn": "kptkkohg1",
                            "objOut": "ja9l5mf5h"
                        }
                    ]
                },
                {
                    "name": "Ratio",
                    "value": 1
                },
                {
                    "name": "Width",
                    "value": 2
                },
                {
                    "name": "Height",
                    "value": 2
                }
            ],
            "objName": "Ops.Gl.Orthogonal_v2"
        },
        {
            "id": "5nlu993g6",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Named Trigger",
                    "value": "Initialization"
                }
            ],
            "portsOut": [
                {
                    "name": "Triggered",
                    "links": [
                        {
                            "portIn": "Rebuild Image DataSet Trigger",
                            "portOut": "Triggered",
                            "objIn": "rplcv7si2",
                            "objOut": "5nlu993g6"
                        }
                    ]
                }
            ],
            "objName": "Ops.Trigger.TriggerReceive"
        },
        {
            "id": "rplcv7si2",
            "uiAttribs": {},
            "portsOut": [
                {
                    "name": "Iconic Image Index Array",
                    "links": [
                        {
                            "portIn": "Value",
                            "portOut": "Iconic Image Index Array",
                            "objIn": "uzaf2yqk2",
                            "objOut": "rplcv7si2"
                        }
                    ]
                },
                {
                    "name": "Generic Image Index Array",
                    "links": [
                        {
                            "portIn": "Value",
                            "portOut": "Generic Image Index Array",
                            "objIn": "u0btbys2l",
                            "objOut": "rplcv7si2"
                        }
                    ]
                }
            ],
            "objName": "Ops.Patch.PLH3vXR.CreatePathIndexArray"
        },
        {
            "id": "38lyqth9g",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Variable",
                    "value": "ImageSetBaseURL"
                }
            ],
            "portsOut": [
                {
                    "name": "Value",
                    "links": [
                        {
                            "portIn": "string1",
                            "portOut": "Value",
                            "objIn": "umqsozawu",
                            "objOut": "38lyqth9g"
                        }
                    ]
                }
            ],
            "objName": "Ops.Vars.VarGetString"
        },
        {
            "id": "dkx6p5jbr",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "value",
                    "value": "generic"
                }
            ],
            "portsOut": [
                {
                    "name": "String",
                    "links": [
                        {
                            "portIn": "Key",
                            "portOut": "String",
                            "objIn": "vznmjt2fw",
                            "objOut": "dkx6p5jbr"
                        }
                    ]
                }
            ],
            "objName": "Ops.String.String_v2"
        },
        {
            "id": "ux736lvty",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "separator",
                    "value": ","
                },
                {
                    "name": "Numbers",
                    "value": 1
                },
                {
                    "name": "Trim",
                    "value": 0
                },
                {
                    "name": "Split Lines",
                    "value": 0
                }
            ],
            "portsOut": [
                {
                    "name": "array",
                    "links": [
                        {
                            "portIn": "Generic Image Count List",
                            "portOut": "array",
                            "objIn": "rplcv7si2",
                            "objOut": "ux736lvty"
                        }
                    ]
                },
                {
                    "name": "length",
                    "value": 0
                }
            ],
            "objName": "Ops.Array.StringToArray_v2"
        },
        {
            "id": "vznmjt2fw",
            "uiAttribs": {},
            "portsOut": [
                {
                    "name": "Result",
                    "links": [
                        {
                            "portIn": "text",
                            "portOut": "Result",
                            "objIn": "ux736lvty",
                            "objOut": "vznmjt2fw"
                        }
                    ]
                }
            ],
            "objName": "Ops.Json.ObjectGetString"
        },
        {
            "id": "qyl7o26pc",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "separator",
                    "value": ","
                },
                {
                    "name": "Numbers",
                    "value": 1
                },
                {
                    "name": "Trim",
                    "value": 0
                },
                {
                    "name": "Split Lines",
                    "value": 0
                }
            ],
            "portsOut": [
                {
                    "name": "array",
                    "links": [
                        {
                            "portIn": "Iconic Image Count List",
                            "portOut": "array",
                            "objIn": "rplcv7si2",
                            "objOut": "qyl7o26pc"
                        }
                    ]
                },
                {
                    "name": "length",
                    "value": 0
                }
            ],
            "objName": "Ops.Array.StringToArray_v2"
        },
        {
            "id": "l5bew6qid",
            "uiAttribs": {},
            "portsOut": [
                {
                    "name": "Result",
                    "links": [
                        {
                            "portIn": "text",
                            "portOut": "Result",
                            "objIn": "qyl7o26pc",
                            "objOut": "l5bew6qid"
                        }
                    ]
                }
            ],
            "objName": "Ops.Json.ObjectGetString"
        },
        {
            "id": "umqsozawu",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "string2",
                    "value": "/__imagecount__.json"
                },
                {
                    "name": "New Line",
                    "value": 0
                },
                {
                    "name": "Active",
                    "value": 1
                }
            ],
            "portsOut": [
                {
                    "name": "result",
                    "links": [
                        {
                            "portIn": "file",
                            "portOut": "result",
                            "objIn": "62wzwk01m",
                            "objOut": "umqsozawu"
                        }
                    ]
                }
            ],
            "objName": "Ops.String.Concat_v2"
        },
        {
            "id": "62wzwk01m",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "file",
                    "display": "file",
                    "title": "URL"
                },
                {
                    "name": "body",
                    "value": ""
                },
                {
                    "name": "HTTP Method index",
                    "value": 0
                },
                {
                    "name": "HTTP Method",
                    "value": "GET"
                },
                {
                    "name": "Content-Type",
                    "value": "application/json"
                },
                {
                    "name": "Content index",
                    "value": 0
                },
                {
                    "name": "Content",
                    "value": "JSON",
                    "title": "Response Content"
                },
                {
                    "name": "Auto request",
                    "value": 1
                },
                {
                    "name": "Send Credentials",
                    "value": 0
                }
            ],
            "portsOut": [
                {
                    "name": "Response Json Object",
                    "links": [
                        {
                            "portIn": "data",
                            "portOut": "Response Json Object",
                            "objIn": "vznmjt2fw",
                            "objOut": "62wzwk01m"
                        },
                        {
                            "portIn": "data",
                            "portOut": "Response Json Object",
                            "objIn": "l5bew6qid",
                            "objOut": "62wzwk01m"
                        }
                    ]
                },
                {
                    "name": "Response Data Url",
                    "value": ""
                },
                {
                    "name": "Duration MS",
                    "value": 63
                },
                {
                    "name": "Status Code",
                    "value": 404
                },
                {
                    "name": "Is Loading",
                    "value": 0
                }
            ],
            "objName": "Ops.Json.HttpRequest_v3"
        },
        {
            "id": "u0btbys2l",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Variable",
                    "value": "IndexArray_Generic"
                }
            ],
            "objName": "Ops.Vars.VarSetArray_v2"
        },
        {
            "id": "uzaf2yqk2",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Variable",
                    "value": "IndexArray_Iconic"
                }
            ],
            "objName": "Ops.Vars.VarSetArray_v2"
        },
        {
            "id": "d0x1a6mws",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Variable",
                    "value": "APIData_In"
                }
            ],
            "portsOut": [
                {
                    "name": "Value",
                    "links": [
                        {
                            "portIn": "Array",
                            "portOut": "Value",
                            "objIn": "ol35gamf9",
                            "objOut": "d0x1a6mws"
                        }
                    ]
                }
            ],
            "objName": "Ops.Vars.VarGetArray_v2"
        },
        {
            "id": "vj6ccb3nw",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "value",
                    "value": "0.16, 0.2, 0.33, 0.42, 0.64, 0.51, 0.45, 0.38, 0.31, 0.36, 0.45, 0.53, 0.61, 0.68, 0.74, 0.82, 0.89, 0.83, 0.77, 0.7, 0.62, 0.57, 0.52, 0.47, 0.41, 0.41, 0.43, 0.45, 0.47, 0.46, 0.45, 0.44, 0.44, 0.38, 0.3, 0.22, 0.16, 0.27, 0.37, 0.48, 0.59, 0.58, 0.58, 0.58, 0.58, 0.64, 0.7, 0.77, 0.84, 0.73, 0.64, 0.54\n0.85, 0.8, 0.67, 0.61, 0.48, 0.45, 0.43, 0.46, 0.47, 0.55, 0.7, 0.76, 0.87, 0.81, 0.71, 0.72, 0.59, 0.57, 0.58, 0.5, 0.47, 0.5, 0.59, 0.66, 0.74, 0.78, 0.75, 0.72, 0.78, 0.73, 0.7, 0.67, 0.68, 0.67, 0.68, 0.71, 0.75, 0.73, 0.75, 0.66, 0.55, 0.42, 0.3, 0.33, 0.36, 0.38, 0.41, 0.41, 0.44, 0.54, 0.55, 0.61\n0.34, 0.4, 0.51, 0.63, 0.69, 0.58, 0.53, 0.45, 0.41, 0.44, 0.43, 0.45, 0.42, 0.41, 0.51, 0.5, 0.55, 0.54, 0.56, 0.58, 0.63, 0.69, 0.65, 0.59, 0.44, 0.42, 0.48, 0.54, 0.6, 0.71, 0.76, 0.7, 0.72, 0.74, 0.72, 0.76, 0.76, 0.68, 0.7, 0.61, 0.53, 0.44, 0.41, 0.44, 0.43, 0.48, 0.53, 0.49, 0.47, 0.49, 0.53, 0.47\n0.93, 0.79, 0.56, 0.44, 0.25, 0.3, 0.33, 0.36, 0.39, 0.45, 0.43, 0.44, 0.5, 0.53, 0.56, 0.52, 0.59, 0.61, 0.62, 0.56, 0.61, 0.58, 0.59, 0.47, 0.45, 0.43, 0.51, 0.54, 0.51, 0.57, 0.56, 0.48, 0.43, 0.36, 0.34, 0.44, 0.5, 0.53, 0.57, 0.6, 0.68, 0.74, 0.75, 0.74, 0.68, 0.59, 0.59, 0.62, 0.58, 0.51, 0.51, 0.54\n"
                },
                {
                    "name": "Syntax index",
                    "value": 0
                },
                {
                    "name": "Syntax",
                    "value": "text"
                }
            ],
            "portsOut": [
                {
                    "name": "Result",
                    "links": [
                        {
                            "portIn": "text",
                            "portOut": "Result",
                            "objIn": "ninb2x6bs",
                            "objOut": "vj6ccb3nw"
                        }
                    ]
                }
            ],
            "objName": "Ops.String.StringEditor"
        },
        {
            "id": "ninb2x6bs",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "separator",
                    "value": ","
                },
                {
                    "name": "Numbers",
                    "value": 0
                },
                {
                    "name": "Trim",
                    "value": 1
                },
                {
                    "name": "Split Lines",
                    "value": 1
                }
            ],
            "portsOut": [
                {
                    "name": "array",
                    "links": [
                        {
                            "portIn": "Array",
                            "portOut": "array",
                            "objIn": "awtsqo661",
                            "objOut": "ninb2x6bs"
                        }
                    ]
                },
                {
                    "name": "length",
                    "value": 4
                }
            ],
            "objName": "Ops.Array.StringToArray_v2"
        },
        {
            "id": "bah0h8s9g",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Active",
                    "value": 1
                },
                {
                    "name": "Clear",
                    "value": 1
                }
            ],
            "portsOut": [
                {
                    "name": "Next",
                    "links": [
                        {
                            "portIn": "Exe",
                            "portOut": "Next",
                            "objIn": "awtsqo661",
                            "objOut": "bah0h8s9g"
                        }
                    ]
                },
                {
                    "name": "Result",
                    "links": [
                        {
                            "portIn": "Value",
                            "portOut": "Result",
                            "objIn": "q98mehqp7",
                            "objOut": "bah0h8s9g"
                        }
                    ]
                }
            ],
            "objName": "Ops.Data.Compose.Array.CompArray"
        },
        {
            "id": "bqy2by67m",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Named Trigger",
                    "value": "Initialization"
                }
            ],
            "portsOut": [
                {
                    "name": "Triggered",
                    "links": [
                        {
                            "portIn": "Exec",
                            "portOut": "Triggered",
                            "objIn": "bg3otc8tp",
                            "objOut": "bqy2by67m"
                        }
                    ]
                }
            ],
            "objName": "Ops.Trigger.TriggerReceive"
        },
        {
            "id": "tygxxglmi",
            "uiAttribs": {},
            "objName": "Ops.Data.Compose.Array.CompArrayPushNumber"
        },
        {
            "id": "awtsqo661",
            "uiAttribs": {},
            "portsOut": [
                {
                    "name": "Trigger",
                    "links": [
                        {
                            "portIn": "exe",
                            "portOut": "Trigger",
                            "objIn": "wm9rp5q92",
                            "objOut": "awtsqo661"
                        }
                    ]
                },
                {
                    "name": "Index",
                    "value": 3
                },
                {
                    "name": "Value",
                    "links": [
                        {
                            "portIn": "text",
                            "portOut": "Value",
                            "objIn": "siptoaj6b",
                            "objOut": "awtsqo661"
                        }
                    ]
                }
            ],
            "objName": "Ops.Array.ArrayIteratorStrings"
        },
        {
            "id": "siptoaj6b",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "separator",
                    "value": ","
                },
                {
                    "name": "Numbers",
                    "value": 1
                },
                {
                    "name": "Trim",
                    "value": 1
                },
                {
                    "name": "Split Lines",
                    "value": 0
                }
            ],
            "portsOut": [
                {
                    "name": "array",
                    "links": [
                        {
                            "portIn": "array",
                            "portOut": "array",
                            "objIn": "wm9rp5q92",
                            "objOut": "siptoaj6b"
                        }
                    ]
                },
                {
                    "name": "length",
                    "value": 52
                }
            ],
            "objName": "Ops.Array.StringToArray_v2"
        },
        {
            "id": "wm9rp5q92",
            "uiAttribs": {},
            "portsOut": [
                {
                    "name": "trigger",
                    "links": [
                        {
                            "portIn": "Update",
                            "portOut": "trigger",
                            "objIn": "tygxxglmi",
                            "objOut": "wm9rp5q92"
                        }
                    ]
                },
                {
                    "name": "index",
                    "value": 51
                },
                {
                    "name": "value",
                    "links": [
                        {
                            "portIn": "Number",
                            "portOut": "value",
                            "objIn": "tygxxglmi",
                            "objOut": "wm9rp5q92"
                        }
                    ]
                }
            ],
            "objName": "Ops.Array.ArrayIteratorNumbers"
        },
        {
            "id": "z3pjzv0r1",
            "uiAttribs": {},
            "portsOut": [
                {
                    "name": "Next",
                    "links": [
                        {
                            "portIn": "Update",
                            "portOut": "Next",
                            "objIn": "bah0h8s9g",
                            "objOut": "z3pjzv0r1"
                        }
                    ]
                }
            ],
            "objName": "Ops.Trigger.TriggerButton"
        },
        {
            "id": "e9b1uhjgp",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "bounds",
                    "value": 1
                },
                {
                    "name": "Axis index",
                    "value": 0
                },
                {
                    "name": "Axis",
                    "value": "X"
                },
                {
                    "name": "frustum near",
                    "value": -100
                },
                {
                    "name": "frustum far",
                    "value": 100
                }
            ],
            "portsOut": [
                {
                    "name": "trigger",
                    "links": [
                        {
                            "portIn": "Execute",
                            "portOut": "trigger",
                            "objIn": "i6n8udet1",
                            "objOut": "e9b1uhjgp"
                        }
                    ]
                },
                {
                    "name": "Ratio",
                    "value": 0.9664889565879665
                },
                {
                    "name": "Width",
                    "value": 2
                },
                {
                    "name": "Height",
                    "value": 1.932977913175933
                }
            ],
            "objName": "Ops.Gl.Orthogonal_v2"
        },
        {
            "id": "libkjv80h",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Number",
                    "value": 3
                }
            ],
            "portsOut": [
                {
                    "name": "Result",
                    "links": [
                        {
                            "portIn": "8kld546qj",
                            "portOut": "Result",
                            "objIn": "ulcz6fiks",
                            "objOut": "libkjv80h"
                        }
                    ]
                }
            ],
            "objName": "Ops.Ui.VizNumber"
        },
        {
            "id": "r41761ry1",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Gradient",
                    "value": "{\"keys\":[{\"pos\":0,\"posy\":0.65,\"r\":0.772265625,\"g\":0.7694375038146972,\"b\":0.7694375038146972},{\"pos\":0.310546875,\"posy\":0.65,\"r\":0.772265625,\"g\":0.7694375038146972,\"b\":0.7694375038146972},{\"pos\":0.466796875,\"posy\":0.56,\"r\":0.3150716145833333,\"g\":0.2978303185353676,\"b\":0.3044742789069763},{\"pos\":0.6171875,\"posy\":0.4,\"r\":0.001822916666666674,\"g\":0.001822916666666674,\"b\":0.001822916666666674},{\"pos\":1,\"posy\":0.4,\"r\":0.001822916666666674,\"g\":0.001822916666666674,\"b\":0.001822916666666674}]}"
                },
                {
                    "name": "Direction index",
                    "value": 2
                },
                {
                    "name": "Direction",
                    "value": "Y"
                },
                {
                    "name": "Smoothstep",
                    "value": 0
                },
                {
                    "name": "Step",
                    "value": 0
                },
                {
                    "name": "Flip",
                    "value": 0
                },
                {
                    "name": "sRGB",
                    "value": 0
                },
                {
                    "name": "Oklab",
                    "value": 0
                },
                {
                    "name": "Size",
                    "value": 256
                },
                {
                    "name": "filter index",
                    "value": 1
                },
                {
                    "name": "filter",
                    "value": "linear"
                },
                {
                    "name": "wrap index",
                    "value": 0
                },
                {
                    "name": "wrap",
                    "value": "clamp to edge"
                },
                {
                    "name": "Dither",
                    "value": 0
                },
                {
                    "name": "Gradient Array",
                    "value": 0
                }
            ],
            "portsOut": [
                {
                    "name": "Texture",
                    "links": [
                        {
                            "portIn": "1er6wsd99",
                            "portOut": "Texture",
                            "objIn": "u5j2xjuwv",
                            "objOut": "r41761ry1"
                        }
                    ]
                }
            ],
            "objName": "Ops.Gl.GradientTexture"
        },
        {
            "id": "dwb6w9856",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "blendMode index",
                    "value": 0
                },
                {
                    "name": "blendMode",
                    "value": "normal"
                },
                {
                    "name": "amount",
                    "value": 1
                },
                {
                    "name": "Premultiplied",
                    "value": 0
                },
                {
                    "name": "Alpha Mask",
                    "value": 0
                },
                {
                    "name": "removeAlphaSrc",
                    "value": 0
                },
                {
                    "name": "Mask Src index",
                    "value": 1
                },
                {
                    "name": "Mask Src",
                    "value": "luminance"
                },
                {
                    "name": "Invert alpha channel",
                    "value": 0
                },
                {
                    "name": "Aspect Ratio",
                    "value": 0
                },
                {
                    "name": "Stretch Axis index",
                    "value": 0
                },
                {
                    "name": "Stretch Axis",
                    "value": "X"
                },
                {
                    "name": "Position",
                    "value": 0
                },
                {
                    "name": "Crop",
                    "value": 0
                },
                {
                    "name": "flip x",
                    "value": 0
                },
                {
                    "name": "flip y",
                    "value": 0
                },
                {
                    "name": "Transform",
                    "value": 0
                },
                {
                    "name": "Scale X",
                    "value": 1
                },
                {
                    "name": "Scale Y",
                    "value": 1
                },
                {
                    "name": "Position X",
                    "value": 0
                },
                {
                    "name": "Position Y",
                    "value": 0
                },
                {
                    "name": "Rotation",
                    "value": 0
                },
                {
                    "name": "Clip Repeat",
                    "value": 0
                }
            ],
            "portsOut": [
                {
                    "name": "trigger",
                    "links": [
                        {
                            "portIn": "render",
                            "portOut": "trigger",
                            "objIn": "l8x56lds1",
                            "objOut": "dwb6w9856"
                        }
                    ]
                }
            ],
            "objName": "Ops.Gl.ImageCompose.DrawImage_v3"
        },
        {
            "id": "l8x56lds1",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "blendMode index",
                    "value": 0
                },
                {
                    "name": "blendMode",
                    "value": "normal"
                },
                {
                    "name": "amount",
                    "value": 1
                },
                {
                    "name": "Premultiplied",
                    "value": 0
                },
                {
                    "name": "Alpha Mask",
                    "value": 0
                },
                {
                    "name": "removeAlphaSrc",
                    "value": 0
                },
                {
                    "name": "Mask Src index",
                    "value": 1
                },
                {
                    "name": "Mask Src",
                    "value": "luminance"
                },
                {
                    "name": "Invert alpha channel",
                    "value": 0
                },
                {
                    "name": "Aspect Ratio",
                    "value": 0
                },
                {
                    "name": "Stretch Axis index",
                    "value": 0
                },
                {
                    "name": "Stretch Axis",
                    "value": "X"
                },
                {
                    "name": "Position",
                    "value": 0
                },
                {
                    "name": "Crop",
                    "value": 0
                },
                {
                    "name": "flip x",
                    "value": 0
                },
                {
                    "name": "flip y",
                    "value": 0
                },
                {
                    "name": "Transform",
                    "value": 0
                },
                {
                    "name": "Scale X",
                    "value": 1
                },
                {
                    "name": "Scale Y",
                    "value": 1
                },
                {
                    "name": "Position X",
                    "value": 0
                },
                {
                    "name": "Position Y",
                    "value": 0
                },
                {
                    "name": "Rotation",
                    "value": 0
                },
                {
                    "name": "Clip Repeat",
                    "value": 0
                }
            ],
            "portsOut": [
                {
                    "name": "trigger",
                    "links": [
                        {
                            "portIn": "render",
                            "portOut": "trigger",
                            "objIn": "f3krgexcm",
                            "objOut": "l8x56lds1"
                        }
                    ]
                }
            ],
            "objName": "Ops.Gl.ImageCompose.DrawImage_v3"
        },
        {
            "id": "19h690pso",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Text",
                    "value": "LayerOffset"
                },
                {
                    "name": "Min",
                    "value": 0
                },
                {
                    "name": "Max",
                    "value": 1
                },
                {
                    "name": "Step",
                    "value": 0.01
                },
                {
                    "name": "Suffix",
                    "value": ""
                },
                {
                    "name": "Grey Out",
                    "value": 0
                },
                {
                    "name": "Visible",
                    "value": 1
                },
                {
                    "name": "Input",
                    "value": 1
                },
                {
                    "name": "Default",
                    "value": 0
                }
            ],
            "portsOut": [
                {
                    "name": "Result",
                    "links": [
                        {
                            "portIn": "Value",
                            "portOut": "Result",
                            "objIn": "dzfq60x7a",
                            "objOut": "19h690pso"
                        }
                    ]
                }
            ],
            "objName": "Ops.Sidebar.Slider_v3"
        },
        {
            "id": "dzfq60x7a",
            "uiAttribs": {},
            "portsIn": [
                {
                    "name": "Variable",
                    "value": "LayerOffset"
                }
            ],
            "objName": "Ops.Vars.VarSetNumber_v2"
        },
        {
            "id": "7kfqpc5qm",
            "uiAttribs": {},
            "storage": {
                "blueprintVer": 2,
                "subPatchVer": 2
            },
            "portsIn": [
                {
                    "name": "8kld546qj",
                    "title": "Layer Index"
                },
                {
                    "name": "d288224z4",
                    "value": 0,
                    "title": "API Data"
                },
                {
                    "name": "lfi6e6fmy",
                    "value": 0,
                    "title": "ImagePathList"
                },
                {
                    "name": "hho85lkjc",
                    "value": 0,
                    "title": "ImagePathList_SecondLayer"
                },
                {
                    "name": "xoahcr8lh",
                    "value": 0,
                    "title": "ShowDebug"
                },
                {
                    "name": "xkk55pzq0",
                    "value": 0,
                    "title": "LayerInterval"
                },
                {
                    "name": "00mtr84dk",
                    "value": 0,
                    "title": "ImageIntervalX"
                },
                {
                    "name": "rxdonrolr",
                    "value": 0,
                    "title": "ImageIntervalZ"
                },
                {
                    "name": "k39iw7qf1",
                    "value": 0,
                    "title": "IndicatorArray_Iconic"
                },
                {
                    "name": "v17tbxwpy",
                    "value": 0,
                    "title": "IndicatorArray_Generic"
                },
                {
                    "name": "dobslg7sf",
                    "title": "Trigger"
                },
                {
                    "name": "earjb46wu",
                    "title": "GradientMap_ForBuilding"
                },
                {
                    "name": "1er6wsd99",
                    "title": "GradientMap_ForMask"
                },
                {
                    "name": "ga4abt9us",
                    "title": "BoundsMask"
                },
                {
                    "name": "patchId",
                    "value": "bp2sub_7kfqpc5qm"
                }
            ],
            "portsOut": [
                {
                    "name": "740vm05xs",
                    "title": "IndicatorArray_Iconic"
                },
                {
                    "name": "vh2f15cw8",
                    "title": "IndicatorArray_Generic"
                },
                {
                    "name": "3cpnu6igj",
                    "title": "ImageList"
                },
                {
                    "name": "jycvtf89b",
                    "title": "BuildingTexture",
                    "links": [
                        {
                            "portIn": "Image",
                            "portOut": "jycvtf89b",
                            "objIn": "gj8g56bq3",
                            "objOut": "7kfqpc5qm"
                        }
                    ]
                },
                {
                    "name": "el1t5zxr9",
                    "title": "LineTexture",
                    "links": [
                        {
                            "portIn": "Image",
                            "portOut": "el1t5zxr9",
                            "objIn": "1zlx0178z",
                            "objOut": "7kfqpc5qm"
                        }
                    ]
                },
                {
                    "name": "7lfhdhs5x",
                    "value": 0,
                    "title": "IsLoading"
                },
                {
                    "name": "gr5rfgt62",
                    "title": "CurrentAnimationPoint",
                    "links": [
                        {
                            "portIn": "Array 0",
                            "portOut": "gr5rfgt62",
                            "objIn": "p5pdm7pgt",
                            "objOut": "7kfqpc5qm"
                        }
                    ]
                }
            ],
            "objName": "Ops.Patch.PLH3vXR.ProcessSingleLayer"
        },
        {
            "id": "tpwdgfvie",
            "uiAttribs": {},
            "storage": {
                "blueprintVer": 2,
                "subPatchVer": 2
            },
            "portsIn": [
                {
                    "name": "8kld546qj",
                    "title": "Layer Index"
                },
                {
                    "name": "d288224z4",
                    "value": 0,
                    "title": "API Data"
                },
                {
                    "name": "lfi6e6fmy",
                    "value": 0,
                    "title": "ImagePathList"
                },
                {
                    "name": "hho85lkjc",
                    "value": 0,
                    "title": "ImagePathList_SecondLayer"
                },
                {
                    "name": "xoahcr8lh",
                    "value": 0,
                    "title": "ShowDebug"
                },
                {
                    "name": "xkk55pzq0",
                    "value": 0,
                    "title": "LayerInterval"
                },
                {
                    "name": "00mtr84dk",
                    "value": 0,
                    "title": "ImageIntervalX"
                },
                {
                    "name": "rxdonrolr",
                    "value": 0,
                    "title": "ImageIntervalZ"
                },
                {
                    "name": "k39iw7qf1",
                    "value": 0,
                    "title": "IndicatorArray_Iconic"
                },
                {
                    "name": "v17tbxwpy",
                    "value": 0,
                    "title": "IndicatorArray_Generic"
                },
                {
                    "name": "dobslg7sf",
                    "title": "Trigger"
                },
                {
                    "name": "earjb46wu",
                    "title": "GradientMap_ForBuilding"
                },
                {
                    "name": "1er6wsd99",
                    "title": "GradientMap_ForMask"
                },
                {
                    "name": "ga4abt9us",
                    "title": "BoundsMask"
                },
                {
                    "name": "patchId",
                    "value": "bp2sub_tpwdgfvie"
                }
            ],
            "portsOut": [
                {
                    "name": "740vm05xs",
                    "title": "IndicatorArray_Iconic"
                },
                {
                    "name": "vh2f15cw8",
                    "title": "IndicatorArray_Generic"
                },
                {
                    "name": "3cpnu6igj",
                    "title": "ImageList"
                },
                {
                    "name": "jycvtf89b",
                    "title": "BuildingTexture",
                    "links": [
                        {
                            "portIn": "Image",
                            "portOut": "jycvtf89b",
                            "objIn": "f23kpy36i",
                            "objOut": "tpwdgfvie"
                        }
                    ]
                },
                {
                    "name": "el1t5zxr9",
                    "title": "LineTexture",
                    "links": [
                        {
                            "portIn": "Image",
                            "portOut": "el1t5zxr9",
                            "objIn": "ljpagbd2h",
                            "objOut": "tpwdgfvie"
                        }
                    ]
                },
                {
                    "name": "7lfhdhs5x",
                    "value": 0,
                    "title": "IsLoading"
                },
                {
                    "name": "gr5rfgt62",
                    "title": "CurrentAnimationPoint",
                    "links": [
                        {
                            "portIn": "Array 1",
                            "portOut": "gr5rfgt62",
                            "objIn": "p5pdm7pgt",
                            "objOut": "tpwdgfvie"
                        }
                    ]
                }
            ],
            "objName": "Ops.Patch.PLH3vXR.ProcessSingleLayer"
        },
        {
            "id": "u5j2xjuwv",
            "uiAttribs": {},
            "storage": {
                "blueprintVer": 2,
                "subPatchVer": 2
            },
            "portsIn": [
                {
                    "name": "8kld546qj",
                    "title": "Layer Index"
                },
                {
                    "name": "d288224z4",
                    "value": 0,
                    "title": "API Data"
                },
                {
                    "name": "lfi6e6fmy",
                    "value": 0,
                    "title": "ImagePathList"
                },
                {
                    "name": "hho85lkjc",
                    "value": 0,
                    "title": "ImagePathList_SecondLayer"
                },
                {
                    "name": "xoahcr8lh",
                    "value": 0,
                    "title": "ShowDebug"
                },
                {
                    "name": "xkk55pzq0",
                    "value": 0,
                    "title": "LayerInterval"
                },
                {
                    "name": "00mtr84dk",
                    "value": 0,
                    "title": "ImageIntervalX"
                },
                {
                    "name": "rxdonrolr",
                    "value": 0,
                    "title": "ImageIntervalZ"
                },
                {
                    "name": "k39iw7qf1",
                    "value": 0,
                    "title": "IndicatorArray_Iconic"
                },
                {
                    "name": "v17tbxwpy",
                    "value": 0,
                    "title": "IndicatorArray_Generic"
                },
                {
                    "name": "dobslg7sf",
                    "title": "Trigger"
                },
                {
                    "name": "earjb46wu",
                    "title": "GradientMap_ForBuilding"
                },
                {
                    "name": "1er6wsd99",
                    "title": "GradientMap_ForMask"
                },
                {
                    "name": "ga4abt9us",
                    "title": "BoundsMask"
                },
                {
                    "name": "patchId",
                    "value": "bp2sub_u5j2xjuwv"
                }
            ],
            "portsOut": [
                {
                    "name": "740vm05xs",
                    "title": "IndicatorArray_Iconic"
                },
                {
                    "name": "vh2f15cw8",
                    "title": "IndicatorArray_Generic"
                },
                {
                    "name": "3cpnu6igj",
                    "title": "ImageList"
                },
                {
                    "name": "jycvtf89b",
                    "title": "BuildingTexture",
                    "links": [
                        {
                            "portIn": "Image",
                            "portOut": "jycvtf89b",
                            "objIn": "f3krgexcm",
                            "objOut": "u5j2xjuwv"
                        }
                    ]
                },
                {
                    "name": "el1t5zxr9",
                    "title": "LineTexture",
                    "links": [
                        {
                            "portIn": "Image",
                            "portOut": "el1t5zxr9",
                            "objIn": "12ya0ntt9",
                            "objOut": "u5j2xjuwv"
                        }
                    ]
                },
                {
                    "name": "7lfhdhs5x",
                    "value": 0,
                    "title": "IsLoading"
                },
                {
                    "name": "gr5rfgt62",
                    "title": "CurrentAnimationPoint",
                    "links": [
                        {
                            "portIn": "Array 2",
                            "portOut": "gr5rfgt62",
                            "objIn": "p5pdm7pgt",
                            "objOut": "u5j2xjuwv"
                        }
                    ]
                }
            ],
            "objName": "Ops.Patch.PLH3vXR.ProcessSingleLayer"
        },
        {
            "id": "ulcz6fiks",
            "uiAttribs": {},
            "storage": {
                "blueprintVer": 2,
                "subPatchVer": 2
            },
            "portsIn": [
                {
                    "name": "8kld546qj",
                    "title": "Layer Index"
                },
                {
                    "name": "d288224z4",
                    "value": 0,
                    "title": "API Data"
                },
                {
                    "name": "lfi6e6fmy",
                    "value": 0,
                    "title": "ImagePathList"
                },
                {
                    "name": "hho85lkjc",
                    "value": 0,
                    "title": "ImagePathList_SecondLayer"
                },
                {
                    "name": "xoahcr8lh",
                    "value": 0,
                    "title": "ShowDebug"
                },
                {
                    "name": "xkk55pzq0",
                    "value": 0,
                    "title": "LayerInterval"
                },
                {
                    "name": "00mtr84dk",
                    "value": 0,
                    "title": "ImageIntervalX"
                },
                {
                    "name": "rxdonrolr",
                    "value": 0,
                    "title": "ImageIntervalZ"
                },
                {
                    "name": "k39iw7qf1",
                    "value": 0,
                    "title": "IndicatorArray_Iconic"
                },
                {
                    "name": "v17tbxwpy",
                    "value": 0,
                    "title": "IndicatorArray_Generic"
                },
                {
                    "name": "dobslg7sf",
                    "title": "Trigger"
                },
                {
                    "name": "earjb46wu",
                    "title": "GradientMap_ForBuilding"
                },
                {
                    "name": "1er6wsd99",
                    "title": "GradientMap_ForMask"
                },
                {
                    "name": "ga4abt9us",
                    "title": "BoundsMask"
                },
                {
                    "name": "patchId",
                    "value": "bp2sub_ulcz6fiks"
                }
            ],
            "portsOut": [
                {
                    "name": "740vm05xs",
                    "title": "IndicatorArray_Iconic"
                },
                {
                    "name": "vh2f15cw8",
                    "title": "IndicatorArray_Generic"
                },
                {
                    "name": "3cpnu6igj",
                    "title": "ImageList"
                },
                {
                    "name": "jycvtf89b",
                    "title": "BuildingTexture",
                    "links": [
                        {
                            "portIn": "Image",
                            "portOut": "jycvtf89b",
                            "objIn": "dwb6w9856",
                            "objOut": "ulcz6fiks"
                        }
                    ]
                },
                {
                    "name": "el1t5zxr9",
                    "title": "LineTexture",
                    "links": [
                        {
                            "portIn": "Image",
                            "portOut": "el1t5zxr9",
                            "objIn": "l8x56lds1",
                            "objOut": "ulcz6fiks"
                        }
                    ]
                },
                {
                    "name": "7lfhdhs5x",
                    "value": 0,
                    "title": "IsLoading"
                },
                {
                    "name": "gr5rfgt62",
                    "title": "CurrentAnimationPoint"
                }
            ],
            "objName": "Ops.Patch.PLH3vXR.ProcessSingleLayer"
        },
        {
            "id": "bg3otc8tp",
            "uiAttribs": {},
            "portsOut": [
                {
                    "name": "Next",
                    "links": [
                        {
                            "portIn": "Update",
                            "portOut": "Next",
                            "objIn": "bah0h8s9g",
                            "objOut": "bg3otc8tp"
                        }
                    ]
                },
                {
                    "name": "Was Triggered",
                    "value": 1
                }
            ],
            "objName": "Ops.Trigger.TriggerOnce"
        }
    ],
    "export": {
        "time": "2025-07-25 19:06",
        "service": "html",
        "exportNumber": 5
    }
};
if(!CABLES.exportedPatch){CABLES.exportedPatch=CABLES.exportedPatches['LH3vXR']}
"use strict";

var CABLES=CABLES||{};
CABLES.OPS=CABLES.OPS||{};

var Ops=Ops || {};
Ops.Gl=Ops.Gl || {};
Ops.Ui=Ops.Ui || {};
Ops.Anim=Ops.Anim || {};
Ops.Data=Ops.Data || {};
Ops.Json=Ops.Json || {};
Ops.Math=Ops.Math || {};
Ops.Vars=Ops.Vars || {};
Ops.Array=Ops.Array || {};
Ops.Color=Ops.Color || {};
Ops.Patch=Ops.Patch || {};
Ops.Cables=Ops.Cables || {};
Ops.Number=Ops.Number || {};
Ops.String=Ops.String || {};
Ops.Boolean=Ops.Boolean || {};
Ops.Devices=Ops.Devices || {};
Ops.Sidebar=Ops.Sidebar || {};
Ops.Trigger=Ops.Trigger || {};
Ops.Graphics=Ops.Graphics || {};
Ops.Gl.Matrix=Ops.Gl.Matrix || {};
Ops.Gl.Meshes=Ops.Gl.Meshes || {};
Ops.Gl.Shader=Ops.Gl.Shader || {};
Ops.Gl.Textures=Ops.Gl.Textures || {};
Ops.Data.Compose=Ops.Data.Compose || {};
Ops.Math.Compare=Ops.Math.Compare || {};
Ops.Devices.Mouse=Ops.Devices.Mouse || {};
Ops.Patch.PLH3vXR=Ops.Patch.PLH3vXR || {};
Ops.String.Base64=Ops.String.Base64 || {};
Ops.Devices.Mobile=Ops.Devices.Mobile || {};
Ops.Gl.ImageCompose=Ops.Gl.ImageCompose || {};
Ops.Graphics.Meshes=Ops.Graphics.Meshes || {};
Ops.Array.PointArray=Ops.Array.PointArray || {};
Ops.Data.Compose.Array=Ops.Data.Compose.Array || {};



// **************************************************************
// 
// Ops.Patch.PLH3vXR.IsImageVisible
// 
// **************************************************************

Ops.Patch.PLH3vXR.IsImageVisible= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={"inc_gen_ports_js":"const port_x4u8fkg49=op.inFloat(\"x4u8fkg49\",0);\nport_x4u8fkg49.setUiAttribs({title:\"ImageIndex\",increment:\"integer\",});\nport_x4u8fkg49.setUiAttribs({\"values\":[\"\"]});\n\nconst port_5i5pamobs=op.outNumber(\"5i5pamobs\");\nport_5i5pamobs.setUiAttribs({title:\"Visible\",display:\"bool\",});\nport_5i5pamobs.setUiAttribs({\"values\":[\"\"]});\n\nop.initInnerPorts=function(addedOps)\n{\n  for(let i=0;i<addedOps.length;i++)\n  {\n    if(addedOps[i].innerInput)\n    {\nconst innerOut_x4u8fkg49 = addedOps[i].outNumber(\"innerOut_x4u8fkg49\");\ninnerOut_x4u8fkg49.set(port_x4u8fkg49.get() );\ninnerOut_x4u8fkg49.setUiAttribs({title:\"ImageIndex\"});\nport_x4u8fkg49.on(\"change\", (a,v) => { innerOut_x4u8fkg49.set(a); });\n\n    }\nif(addedOps[i].innerOutput)\n{\nconst innerIn_5i5pamobs = addedOps[i].inFloat(\"innerIn_5i5pamobs\");\ninnerIn_5i5pamobs.setUiAttribs({title:\"Visible\"});\ninnerIn_5i5pamobs.on(\"change\", (a,v) => { port_5i5pamobs.set(a); });\n\n}\n}\n};\n","subpatch_json":"{\"ops\":[{\"id\":\"sp0-0\",\"uiAttribs\":{\"subPatch\":\"6ep585zgi\"},\"storage\":{\"blueprintVer\":2},\"portsOut\":[{\"name\":\"result\",\"links\":[{\"portIn\":\"number2\",\"portOut\":\"result\",\"objIn\":\"sp0-12\",\"objOut\":\"sp0-0\"}]}],\"objName\":\"Ops.Number.Number\"},{\"id\":\"sp0-1\",\"uiAttribs\":{\"subPatch\":\"6ep585zgi\"},\"storage\":{\"blueprintVer\":2},\"portsOut\":[{\"name\":\"result\",\"links\":[{\"portIn\":\"Boolean\",\"portOut\":\"result\",\"objIn\":\"sp0-2\",\"objOut\":\"sp0-1\"}]}],\"objName\":\"Ops.Number.Number\"},{\"id\":\"sp0-2\",\"uiAttribs\":{\"subPatch\":\"6ep585zgi\"},\"storage\":{\"blueprintVer\":2},\"portsOut\":[{\"name\":\"Result\",\"links\":[{\"portIn\":\"bool 1\",\"portOut\":\"Result\",\"objIn\":\"sp0-13\",\"objOut\":\"sp0-2\"}]}],\"objName\":\"Ops.Boolean.Not\"},{\"id\":\"sp0-3\",\"uiAttribs\":{\"subPatch\":\"6ep585zgi\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"Variable\",\"value\":\"Debug_BuildingLayerIndex\"}],\"portsOut\":[{\"name\":\"Value\",\"links\":[{\"portIn\":\"Index\",\"portOut\":\"Value\",\"objIn\":\"sp0-9\",\"objOut\":\"sp0-3\"}]}],\"objName\":\"Ops.Vars.VarGetNumber_v2\"},{\"id\":\"sp0-4\",\"uiAttribs\":{\"subPatch\":\"6ep585zgi\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"Variable\",\"value\":\"Debug_ShowSpecific\"}],\"portsOut\":[{\"name\":\"Value\",\"links\":[{\"portIn\":\"value\",\"portOut\":\"Value\",\"objIn\":\"sp0-1\",\"objOut\":\"sp0-4\"}]}],\"objName\":\"Ops.Vars.VarGetNumber_v2\"},{\"id\":\"sp0-5\",\"uiAttribs\":{\"subPatch\":\"6ep585zgi\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"Variable\",\"value\":\"Debug_Image_Index\"}],\"portsOut\":[{\"name\":\"Value\",\"links\":[{\"portIn\":\"value\",\"portOut\":\"Value\",\"objIn\":\"sp0-0\",\"objOut\":\"sp0-5\"}]}],\"objName\":\"Ops.Vars.VarGetNumber_v2\"},{\"id\":\"sp0-6\",\"uiAttribs\":{\"subPatch\":\"6ep585zgi\"},\"storage\":{\"blueprintVer\":2},\"portsOut\":[{\"name\":\"innerOut_x4u8fkg49\",\"title\":\"ImageIndex\",\"links\":[{\"portIn\":\"number1\",\"portOut\":\"innerOut_x4u8fkg49\",\"objIn\":\"sp0-10\",\"objOut\":\"sp0-6\"},{\"portIn\":\"number1\",\"portOut\":\"innerOut_x4u8fkg49\",\"objIn\":\"sp0-12\",\"objOut\":\"sp0-6\"}]}],\"objName\":\"Ops.Ui.SubPatchInput\"},{\"id\":\"sp0-7\",\"uiAttribs\":{\"subPatch\":\"6ep585zgi\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"innerIn_5i5pamobs\",\"title\":\"Visible\"}],\"objName\":\"Ops.Ui.SubPatchOutput\"},{\"id\":\"sp0-8\",\"uiAttribs\":{\"subPatch\":\"6ep585zgi\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"Variable\",\"value\":\"BarCount\"}],\"portsOut\":[{\"name\":\"Value\",\"links\":[{\"portIn\":\"number2\",\"portOut\":\"Value\",\"objIn\":\"sp0-10\",\"objOut\":\"sp0-8\"}]}],\"objName\":\"Ops.Vars.VarGetNumber_v2\"},{\"id\":\"sp0-9\",\"uiAttribs\":{\"subPatch\":\"6ep585zgi\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"Value 0\",\"value\":1},{\"name\":\"Value 3\",\"value\":0},{\"name\":\"Value 4\",\"value\":0},{\"name\":\"Value 5\",\"value\":0},{\"name\":\"Value 6\",\"value\":0},{\"name\":\"Value 7\",\"value\":0},{\"name\":\"Value 8\",\"value\":0},{\"name\":\"Value 9\",\"value\":0},{\"name\":\"Value 10\",\"value\":0},{\"name\":\"Value 11\",\"value\":0},{\"name\":\"Value 12\",\"value\":0},{\"name\":\"Value 13\",\"value\":0},{\"name\":\"Value 14\",\"value\":0},{\"name\":\"Value 15\",\"value\":0}],\"portsOut\":[{\"name\":\"Result\",\"links\":[{\"portIn\":\"bool 1\",\"portOut\":\"Result\",\"objIn\":\"sp0-14\",\"objOut\":\"sp0-9\"}]}],\"objName\":\"Ops.Number.SwitchNumber\"},{\"id\":\"sp0-10\",\"uiAttribs\":{\"subPatch\":\"6ep585zgi\"},\"storage\":{\"blueprintVer\":2},\"portsOut\":[{\"name\":\"result\",\"links\":[{\"portIn\":\"Value 1\",\"portOut\":\"result\",\"objIn\":\"sp0-9\",\"objOut\":\"sp0-10\"},{\"portIn\":\"Boolean\",\"portOut\":\"result\",\"objIn\":\"sp0-11\",\"objOut\":\"sp0-10\"}]}],\"objName\":\"Ops.Math.Compare.LessThan\"},{\"id\":\"sp0-11\",\"uiAttribs\":{\"subPatch\":\"6ep585zgi\"},\"storage\":{\"blueprintVer\":2},\"portsOut\":[{\"name\":\"Result\",\"links\":[{\"portIn\":\"Value 2\",\"portOut\":\"Result\",\"objIn\":\"sp0-9\",\"objOut\":\"sp0-11\"}]}],\"objName\":\"Ops.Boolean.Not\"},{\"id\":\"sp0-12\",\"uiAttribs\":{\"subPatch\":\"6ep585zgi\"},\"storage\":{\"blueprintVer\":2},\"portsOut\":[{\"name\":\"result\",\"links\":[{\"portIn\":\"bool 2\",\"portOut\":\"result\",\"objIn\":\"sp0-13\",\"objOut\":\"sp0-12\"}]}],\"objName\":\"Ops.Math.Compare.Equals\"},{\"id\":\"sp0-13\",\"uiAttribs\":{\"subPatch\":\"6ep585zgi\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"bool 3\",\"value\":0},{\"name\":\"bool 4\",\"value\":0},{\"name\":\"bool 5\",\"value\":0},{\"name\":\"bool 6\",\"value\":0},{\"name\":\"bool 7\",\"value\":0},{\"name\":\"bool 8\",\"value\":0},{\"name\":\"bool 9\",\"value\":0},{\"name\":\"bool 10\",\"value\":0}],\"portsOut\":[{\"name\":\"result\",\"links\":[{\"portIn\":\"bool 2\",\"portOut\":\"result\",\"objIn\":\"sp0-14\",\"objOut\":\"sp0-13\"}]}],\"objName\":\"Ops.Boolean.Or\"},{\"id\":\"sp0-14\",\"uiAttribs\":{\"subPatch\":\"6ep585zgi\"},\"storage\":{\"blueprintVer\":2},\"portsOut\":[{\"name\":\"result\",\"links\":[{\"portIn\":\"innerIn_5i5pamobs\",\"portOut\":\"result\",\"objIn\":\"sp0-7\",\"objOut\":\"sp0-14\"}]}],\"objName\":\"Ops.Boolean.And\"}]}",};
const port_x4u8fkg49=op.inFloat("x4u8fkg49",0);
port_x4u8fkg49.setUiAttribs({title:"ImageIndex",increment:"integer",});
port_x4u8fkg49.setUiAttribs({"values":[""]});

const port_5i5pamobs=op.outNumber("5i5pamobs");
port_5i5pamobs.setUiAttribs({title:"Visible",display:"bool",});
port_5i5pamobs.setUiAttribs({"values":[""]});

op.initInnerPorts=function(addedOps)
{
  for(let i=0;i<addedOps.length;i++)
  {
    if(addedOps[i].innerInput)
    {
const innerOut_x4u8fkg49 = addedOps[i].outNumber("innerOut_x4u8fkg49");
innerOut_x4u8fkg49.set(port_x4u8fkg49.get() );
innerOut_x4u8fkg49.setUiAttribs({title:"ImageIndex"});
port_x4u8fkg49.on("change", (a,v) => { innerOut_x4u8fkg49.set(a); });

    }
if(addedOps[i].innerOutput)
{
const innerIn_5i5pamobs = addedOps[i].inFloat("innerIn_5i5pamobs");
innerIn_5i5pamobs.setUiAttribs({title:"Visible"});
innerIn_5i5pamobs.on("change", (a,v) => { port_5i5pamobs.set(a); });

}
}
};

const patchId = "bp2sub_" + op.id;

new CABLES.SubPatchOp(op, { "subId": patchId });

initializeSubpatch();

function initializeSubpatch()
{
    const p = JSON.parse(attachments.subpatch_json);

    CABLES.Patch.replaceOpIds(p,
        {
            "parentSubPatchId": patchId,
            "prefixHash": patchId,
            "oldIdAsRef": true,
            "doNotUnlinkLostLinks": true
        });

    for (let i = 0; i < p.ops.length; i++)
    {
        p.ops[i].uiAttribs.blueprintSubpatch2 = true;
    }

    op.loadDependencies(p, () =>
    {
        op.patch.deSerialize(p, { "opsCreated": op.initInnerPorts });
        if (CABLES.UI)gui.savedState.setSaved("blueprintloaded", patchId);
        op.patch.emitEvent("subpatchExpose", patchId);
        op.setStorage({ "blueprintVer": 2 });
        op.patch.emitEvent("subpatchExpose", patchId);
    });
}

}
};

CABLES.OPS["73031d96-98d4-4e0a-9a3c-569d280c14eb"]={f:Ops.Patch.PLH3vXR.IsImageVisible,objName:"Ops.Patch.PLH3vXR.IsImageVisible"};




// **************************************************************
// 
// Ops.Patch.PLH3vXR.RedistributeSingleLine
// 
// **************************************************************

Ops.Patch.PLH3vXR.RedistributeSingleLine= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={"inc_gen_ports_js":"const port_1pmfn9q3x=op.inArray(\"1pmfn9q3x\");\nport_1pmfn9q3x.setUiAttribs({title:\"Points\",});\n\nconst port_oorqf21z8=op.outArray(\"oorqf21z8\");\nport_oorqf21z8.setUiAttribs({title:\"Result\",});\n\nop.initInnerPorts=function(addedOps)\n{\n  for(let i=0;i<addedOps.length;i++)\n  {\n    if(addedOps[i].innerInput)\n    {\nconst innerOut_1pmfn9q3x = addedOps[i].outArray(\"innerOut_1pmfn9q3x\");\ninnerOut_1pmfn9q3x.setUiAttribs({title:\"Points\"});\nport_1pmfn9q3x.on(\"change\", (a,v) => { innerOut_1pmfn9q3x.setRef(a); });\n\n    }\nif(addedOps[i].innerOutput)\n{\nconst innerIn_oorqf21z8 = addedOps[i].inArray(\"innerIn_oorqf21z8\");\ninnerIn_oorqf21z8.setUiAttribs({title:\"Result\"});\ninnerIn_oorqf21z8.on(\"change\", (a,v) => { port_oorqf21z8.setRef(a); });\n\n}\n}\n};\n","subpatch_json":"{\"ops\":[{\"id\":\"sp1-0\",\"uiAttribs\":{\"subPatch\":\"0sb7m34bo\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"Normalized\",\"value\":0}],\"portsOut\":[{\"name\":\"Result\",\"links\":[{\"portIn\":\"innerIn_oorqf21z8\",\"portOut\":\"Result\",\"objIn\":\"sp1-6\",\"objOut\":\"sp1-0\"}]},{\"name\":\"Spline Length\",\"value\":3.376323421610921}],\"objName\":\"Ops.Array.PointArray.RedistributeSplinePoints\"},{\"id\":\"sp1-1\",\"uiAttribs\":{\"subPatch\":\"0sb7m34bo\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"Variable\",\"value\":\"PointCount\"}],\"portsOut\":[{\"name\":\"Value\",\"links\":[{\"portIn\":\"Num Points\",\"portOut\":\"Value\",\"objIn\":\"sp1-0\",\"objOut\":\"sp1-1\"},{\"portIn\":\"Value\",\"portOut\":\"Value\",\"objIn\":\"sp1-4\",\"objOut\":\"sp1-1\"}]}],\"objName\":\"Ops.Vars.VarGetNumber_v2\"},{\"id\":\"sp1-2\",\"uiAttribs\":{\"subPatch\":\"0sb7m34bo\"},\"storage\":{\"blueprintVer\":2},\"portsOut\":[{\"name\":\"Changed\",\"links\":[{\"portIn\":\"Calculate\",\"portOut\":\"Changed\",\"objIn\":\"sp1-0\",\"objOut\":\"sp1-2\"}]}],\"objName\":\"Ops.Trigger.TriggerOnChangeArray\"},{\"id\":\"sp1-3\",\"uiAttribs\":{\"subPatch\":\"0sb7m34bo\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"Smooth\",\"value\":1},{\"name\":\"Loop\",\"value\":0},{\"name\":\"Bezier Start/End Points\",\"value\":1}],\"portsOut\":[{\"name\":\"Result\",\"links\":[{\"portIn\":\"Array3x\",\"portOut\":\"Result\",\"objIn\":\"sp1-0\",\"objOut\":\"sp1-3\"},{\"portIn\":\"Array\",\"portOut\":\"Result\",\"objIn\":\"sp1-2\",\"objOut\":\"sp1-3\"}]}],\"objName\":\"Ops.Array.PointArray.SubdivideArray3_v2\"},{\"id\":\"sp1-4\",\"uiAttribs\":{\"subPatch\":\"0sb7m34bo\"},\"storage\":{\"blueprintVer\":2},\"portsOut\":[{\"name\":\"Next\",\"links\":[{\"portIn\":\"Calculate\",\"portOut\":\"Next\",\"objIn\":\"sp1-0\",\"objOut\":\"sp1-4\"}]},{\"name\":\"Number\",\"value\":50}],\"objName\":\"Ops.Number.TriggerOnChangeNumber\"},{\"id\":\"sp1-5\",\"uiAttribs\":{\"subPatch\":\"0sb7m34bo\"},\"storage\":{\"blueprintVer\":2},\"portsOut\":[{\"name\":\"innerOut_1pmfn9q3x\",\"title\":\"Points\",\"links\":[{\"portIn\":\"Points\",\"portOut\":\"innerOut_1pmfn9q3x\",\"objIn\":\"sp1-3\",\"objOut\":\"sp1-5\"}]}],\"objName\":\"Ops.Ui.SubPatchInput\"},{\"id\":\"sp1-6\",\"uiAttribs\":{\"subPatch\":\"0sb7m34bo\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"innerIn_oorqf21z8\",\"title\":\"Result\"}],\"objName\":\"Ops.Ui.SubPatchOutput\"},{\"id\":\"sp1-7\",\"uiAttribs\":{\"subPatch\":\"0sb7m34bo\"},\"portsIn\":[{\"name\":\"value\",\"value\":2}],\"portsOut\":[{\"name\":\"result\",\"links\":[{\"portIn\":\"Num Subdivs\",\"portOut\":\"result\",\"objIn\":\"sp1-3\",\"objOut\":\"sp1-7\"}]}],\"storage\":{\"ref\":\"sp1-7\",\"blueprintVer\":2},\"objName\":\"Ops.Number.Number\"}]}",};
const port_1pmfn9q3x=op.inArray("1pmfn9q3x");
port_1pmfn9q3x.setUiAttribs({title:"Points",});

const port_oorqf21z8=op.outArray("oorqf21z8");
port_oorqf21z8.setUiAttribs({title:"Result",});

op.initInnerPorts=function(addedOps)
{
  for(let i=0;i<addedOps.length;i++)
  {
    if(addedOps[i].innerInput)
    {
const innerOut_1pmfn9q3x = addedOps[i].outArray("innerOut_1pmfn9q3x");
innerOut_1pmfn9q3x.setUiAttribs({title:"Points"});
port_1pmfn9q3x.on("change", (a,v) => { innerOut_1pmfn9q3x.setRef(a); });

    }
if(addedOps[i].innerOutput)
{
const innerIn_oorqf21z8 = addedOps[i].inArray("innerIn_oorqf21z8");
innerIn_oorqf21z8.setUiAttribs({title:"Result"});
innerIn_oorqf21z8.on("change", (a,v) => { port_oorqf21z8.setRef(a); });

}
}
};

const patchId = "bp2sub_" + op.id;

new CABLES.SubPatchOp(op, { "subId": patchId });

initializeSubpatch();

function initializeSubpatch()
{
    const p = JSON.parse(attachments.subpatch_json);

    CABLES.Patch.replaceOpIds(p,
        {
            "parentSubPatchId": patchId,
            "prefixHash": patchId,
            "oldIdAsRef": true,
            "doNotUnlinkLostLinks": true
        });

    for (let i = 0; i < p.ops.length; i++)
    {
        p.ops[i].uiAttribs.blueprintSubpatch2 = true;
    }

    op.loadDependencies(p, () =>
    {
        op.patch.deSerialize(p, { "opsCreated": op.initInnerPorts });
        if (CABLES.UI)gui.savedState.setSaved("blueprintloaded", patchId);
        op.patch.emitEvent("subpatchExpose", patchId);
        op.setStorage({ "blueprintVer": 2 });
        op.patch.emitEvent("subpatchExpose", patchId);
    });
}

}
};

CABLES.OPS["f92f13e2-bdfd-46f0-8ed4-ff575ff046fb"]={f:Ops.Patch.PLH3vXR.RedistributeSingleLine,objName:"Ops.Patch.PLH3vXR.RedistributeSingleLine"};




// **************************************************************
// 
// Ops.Gl.DownloadTexture_v3
// 
// **************************************************************

Ops.Gl.DownloadTexture_v3= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={"inc_gen_ports_js":"const port_7zxlhqqf8 = op.inObject(\"7zxlhqqf8\");\nport_7zxlhqqf8.setUiAttribs({ \"title\": \"Texture\", \"display\": \"texture\", \"objType\": \"texture\", \"objType\": \"texture\" });\nport_7zxlhqqf8.setUiAttribs({ \"values\": [\"\"] });\n\nconst port_c6sm5ztz4 = op.inString(\"c6sm5ztz4\", \"PNG\");\nport_c6sm5ztz4.setUiAttribs({ \"title\": \"Format\", \"display\": \"dropdown\", });\nport_c6sm5ztz4.setUiAttribs({ \"values\": [\"PNG\", \"JPG\", \"WEBP\"] });\n\nconst port_6ozewyh0e = op.inFloat(\"6ozewyh0e\", 0.9);\nport_6ozewyh0e.setUiAttribs({ \"title\": \"Quality\", \"display\": \"range\", });\nport_6ozewyh0e.setUiAttribs({ \"values\": [\"\"] });\n\nconst port_ainvr3s9o = op.inString(\"ainvr3s9o\", \"screenshot\");\nport_ainvr3s9o.setUiAttribs({ \"title\": \"Filename\", });\nport_ainvr3s9o.setUiAttribs({ \"values\": [\"\"] });\n\nconst port_uxwx45pbg = op.inTrigger(\"uxwx45pbg\");\nport_uxwx45pbg.setUiAttribs({ \"title\": \"Download\", \"display\": \"button\", });\nport_uxwx45pbg.setUiAttribs({ \"values\": [\"\"] });\n\nconst port_jcrmz8mnz = op.outTrigger(\"jcrmz8mnz\");\nport_jcrmz8mnz.setUiAttribs({ \"title\": \"Next\", });\n\nop.initInnerPorts = function (addedOps)\n{\n    for (let i = 0; i < addedOps.length; i++)\n    {\n        if (addedOps[i].innerInput)\n        {\n            const innerOut_7zxlhqqf8 = addedOps[i].outTexture(\"innerOut_7zxlhqqf8\");\n            innerOut_7zxlhqqf8.setUiAttribs({ \"title\": \"Texture\" });\n            port_7zxlhqqf8.on(\"change\", (a, v) => { innerOut_7zxlhqqf8.setRef(a); });\n\n            const innerOut_c6sm5ztz4 = addedOps[i].outString(\"innerOut_c6sm5ztz4\");\n            innerOut_c6sm5ztz4.set(port_c6sm5ztz4.get());\n            innerOut_c6sm5ztz4.setUiAttribs({ \"title\": \"Format\" });\n            port_c6sm5ztz4.on(\"change\", (a, v) => { innerOut_c6sm5ztz4.set(a); });\n\n            const innerOut_6ozewyh0e = addedOps[i].outNumber(\"innerOut_6ozewyh0e\");\n            innerOut_6ozewyh0e.set(port_6ozewyh0e.get());\n            innerOut_6ozewyh0e.setUiAttribs({ \"title\": \"Quality\" });\n            port_6ozewyh0e.on(\"change\", (a, v) => { innerOut_6ozewyh0e.set(a); });\n\n            const innerOut_ainvr3s9o = addedOps[i].outString(\"innerOut_ainvr3s9o\");\n            innerOut_ainvr3s9o.set(port_ainvr3s9o.get());\n            innerOut_ainvr3s9o.setUiAttribs({ \"title\": \"Filename\" });\n            port_ainvr3s9o.on(\"change\", (a, v) => { innerOut_ainvr3s9o.set(a); });\n\n            const innerOut_uxwx45pbg = addedOps[i].outTrigger(\"innerOut_uxwx45pbg\");\n            innerOut_uxwx45pbg.setUiAttribs({ \"title\": \"Download\" });\n            port_uxwx45pbg.onTriggered = () => { innerOut_uxwx45pbg.trigger(); };\n        }\n        if (addedOps[i].innerOutput)\n        {\n            const innerIn_jcrmz8mnz = addedOps[i].inTrigger(\"innerIn_jcrmz8mnz\");\n            innerIn_jcrmz8mnz.setUiAttribs({ \"title\": \"Next\" });\n            innerIn_jcrmz8mnz.onTriggered = () => { port_jcrmz8mnz.trigger(); };\n        }\n    }\n};\n","subpatch_json":"{\"ops\":[{\"id\":\"sp2-0\",\"uiAttribs\":{\"subPatch\":\"ses4gl9il\"},\"storage\":{},\"portsOut\":[{\"name\":\"Next\",\"links\":[{\"portIn\":\"innerIn_jcrmz8mnz\",\"portOut\":\"Next\",\"objIn\":\"sp2-2\",\"objOut\":\"sp2-0\"}]}],\"objName\":\"Ops.String.Base64.DownloadBase64File\"},{\"id\":\"sp2-1\",\"uiAttribs\":{\"subPatch\":\"ses4gl9il\"},\"storage\":{},\"portsOut\":[{\"name\":\"innerOut_7zxlhqqf8\",\"title\":\"Texture\",\"links\":[{\"portIn\":\"Texture\",\"portOut\":\"innerOut_7zxlhqqf8\",\"objIn\":\"sp2-8\",\"objOut\":\"sp2-1\"}]},{\"name\":\"innerOut_c6sm5ztz4\",\"title\":\"Format\",\"links\":[{\"portIn\":\"String\",\"portOut\":\"innerOut_c6sm5ztz4\",\"objIn\":\"sp2-5\",\"objOut\":\"sp2-1\"},{\"portIn\":\"SearchValue\",\"portOut\":\"innerOut_c6sm5ztz4\",\"objIn\":\"sp2-7\",\"objOut\":\"sp2-1\"}]},{\"name\":\"innerOut_6ozewyh0e\",\"title\":\"Quality\",\"links\":[{\"portIn\":\"Quality\",\"portOut\":\"innerOut_6ozewyh0e\",\"objIn\":\"sp2-8\",\"objOut\":\"sp2-1\"}]},{\"name\":\"innerOut_ainvr3s9o\",\"title\":\"Filename\",\"links\":[{\"portIn\":\"String 1\",\"portOut\":\"innerOut_ainvr3s9o\",\"objIn\":\"sp2-4\",\"objOut\":\"sp2-1\"}]},{\"name\":\"innerOut_uxwx45pbg\",\"title\":\"Download\",\"links\":[{\"portIn\":\"Trigger\",\"portOut\":\"innerOut_uxwx45pbg\",\"objIn\":\"sp2-8\",\"objOut\":\"sp2-1\"}]}],\"objName\":\"Ops.Ui.SubPatchInput\"},{\"id\":\"sp2-2\",\"uiAttribs\":{\"subPatch\":\"ses4gl9il\"},\"storage\":{},\"portsIn\":[{\"name\":\"innerIn_jcrmz8mnz\",\"title\":\"Next\"}],\"objName\":\"Ops.Ui.SubPatchOutput\"},{\"id\":\"sp2-3\",\"uiAttribs\":{\"subPatch\":\"ses4gl9il\"},\"storage\":{},\"portsIn\":[{\"name\":\"string 1\",\"value\":\".\"},{\"name\":\"string 3\",\"value\":\"\"},{\"name\":\"string 4\",\"value\":\"\"},{\"name\":\"string 5\",\"value\":\"\"},{\"name\":\"string 6\",\"value\":\"\"},{\"name\":\"string 7\",\"value\":\"\"},{\"name\":\"add spaces\",\"value\":0},{\"name\":\"new lines\",\"value\":0}],\"portsOut\":[{\"name\":\"concat string\",\"links\":[{\"portIn\":\"Filename\",\"portOut\":\"concat string\",\"objIn\":\"sp2-0\",\"objOut\":\"sp2-3\"}]}],\"objName\":\"Ops.String.ConcatMulti_v2\"},{\"id\":\"sp2-4\",\"uiAttribs\":{\"subPatch\":\"ses4gl9il\"},\"storage\":{},\"portsIn\":[{\"name\":\"String 2\",\"value\":\"unknown\"},{\"name\":\"String 3\",\"value\":\"\"},{\"name\":\"String 4\",\"value\":\"\"},{\"name\":\"String 5\",\"value\":\"\"},{\"name\":\"String 6\",\"value\":\"\"},{\"name\":\"String 7\",\"value\":\"\"},{\"name\":\"String 8\",\"value\":\"\"}],\"portsOut\":[{\"name\":\"Result\",\"links\":[{\"portIn\":\"string 0\",\"portOut\":\"Result\",\"objIn\":\"sp2-3\",\"objOut\":\"sp2-4\"}]}],\"objName\":\"Ops.String.OrString\"},{\"id\":\"sp2-5\",\"uiAttribs\":{\"subPatch\":\"ses4gl9il\"},\"storage\":{},\"portsOut\":[{\"name\":\"Result\",\"links\":[{\"portIn\":\"string 2\",\"portOut\":\"Result\",\"objIn\":\"sp2-3\",\"objOut\":\"sp2-5\"}]}],\"objName\":\"Ops.String.Lowercase_v2\"},{\"id\":\"sp2-6\",\"uiAttribs\":{\"subPatch\":\"ses4gl9il\"},\"storage\":{},\"portsIn\":[{\"name\":\"text\",\"value\":\"PNG,JPG,WEBP\"},{\"name\":\"separator\",\"value\":\",\"},{\"name\":\"Numbers\",\"value\":0},{\"name\":\"Trim\",\"value\":1},{\"name\":\"Split Lines\",\"value\":0}],\"portsOut\":[{\"name\":\"array\",\"links\":[{\"portIn\":\"Array\",\"portOut\":\"array\",\"objIn\":\"sp2-7\",\"objOut\":\"sp2-6\"}]},{\"name\":\"length\",\"value\":3}],\"objName\":\"Ops.Array.StringToArray_v2\"},{\"id\":\"sp2-7\",\"uiAttribs\":{\"subPatch\":\"ses4gl9il\"},\"storage\":{},\"portsOut\":[{\"name\":\"Found\",\"value\":1},{\"name\":\"Index\",\"links\":[{\"portIn\":\"Format index\",\"portOut\":\"Index\",\"objIn\":\"sp2-8\",\"objOut\":\"sp2-7\"}]}],\"objName\":\"Ops.String.ArrayContainsString\"},{\"id\":\"sp2-8\",\"uiAttribs\":{\"subPatch\":\"ses4gl9il\"},\"storage\":{},\"portsIn\":[{\"name\":\"Format\",\"value\":\"PNG\"},{\"name\":\"Output dataUrl\",\"value\":1}],\"portsOut\":[{\"name\":\"Binary Size\",\"value\":288279},{\"name\":\"Base64 string\",\"links\":[{\"portIn\":\"Data URL\",\"portOut\":\"Base64 string\",\"objIn\":\"sp2-0\",\"objOut\":\"sp2-8\"}]},{\"name\":\"Loading\",\"value\":0},{\"name\":\"Finished\",\"links\":[{\"portIn\":\"Download\",\"portOut\":\"Finished\",\"objIn\":\"sp2-0\",\"objOut\":\"sp2-8\"}]}],\"objName\":\"Ops.Gl.Textures.TextureToBase64_v5\"}]}",};
const port_7zxlhqqf8 = op.inObject("7zxlhqqf8");
port_7zxlhqqf8.setUiAttribs({ "title": "Texture", "display": "texture", "objType": "texture", "objType": "texture" });
port_7zxlhqqf8.setUiAttribs({ "values": [""] });

const port_c6sm5ztz4 = op.inString("c6sm5ztz4", "PNG");
port_c6sm5ztz4.setUiAttribs({ "title": "Format", "display": "dropdown", });
port_c6sm5ztz4.setUiAttribs({ "values": ["PNG", "JPG", "WEBP"] });

const port_6ozewyh0e = op.inFloat("6ozewyh0e", 0.9);
port_6ozewyh0e.setUiAttribs({ "title": "Quality", "display": "range", });
port_6ozewyh0e.setUiAttribs({ "values": [""] });

const port_ainvr3s9o = op.inString("ainvr3s9o", "screenshot");
port_ainvr3s9o.setUiAttribs({ "title": "Filename", });
port_ainvr3s9o.setUiAttribs({ "values": [""] });

const port_uxwx45pbg = op.inTrigger("uxwx45pbg");
port_uxwx45pbg.setUiAttribs({ "title": "Download", "display": "button", });
port_uxwx45pbg.setUiAttribs({ "values": [""] });

const port_jcrmz8mnz = op.outTrigger("jcrmz8mnz");
port_jcrmz8mnz.setUiAttribs({ "title": "Next", });

op.initInnerPorts = function (addedOps)
{
    for (let i = 0; i < addedOps.length; i++)
    {
        if (addedOps[i].innerInput)
        {
            const innerOut_7zxlhqqf8 = addedOps[i].outTexture("innerOut_7zxlhqqf8");
            innerOut_7zxlhqqf8.setUiAttribs({ "title": "Texture" });
            port_7zxlhqqf8.on("change", (a, v) => { innerOut_7zxlhqqf8.setRef(a); });

            const innerOut_c6sm5ztz4 = addedOps[i].outString("innerOut_c6sm5ztz4");
            innerOut_c6sm5ztz4.set(port_c6sm5ztz4.get());
            innerOut_c6sm5ztz4.setUiAttribs({ "title": "Format" });
            port_c6sm5ztz4.on("change", (a, v) => { innerOut_c6sm5ztz4.set(a); });

            const innerOut_6ozewyh0e = addedOps[i].outNumber("innerOut_6ozewyh0e");
            innerOut_6ozewyh0e.set(port_6ozewyh0e.get());
            innerOut_6ozewyh0e.setUiAttribs({ "title": "Quality" });
            port_6ozewyh0e.on("change", (a, v) => { innerOut_6ozewyh0e.set(a); });

            const innerOut_ainvr3s9o = addedOps[i].outString("innerOut_ainvr3s9o");
            innerOut_ainvr3s9o.set(port_ainvr3s9o.get());
            innerOut_ainvr3s9o.setUiAttribs({ "title": "Filename" });
            port_ainvr3s9o.on("change", (a, v) => { innerOut_ainvr3s9o.set(a); });

            const innerOut_uxwx45pbg = addedOps[i].outTrigger("innerOut_uxwx45pbg");
            innerOut_uxwx45pbg.setUiAttribs({ "title": "Download" });
            port_uxwx45pbg.onTriggered = () => { innerOut_uxwx45pbg.trigger(); };
        }
        if (addedOps[i].innerOutput)
        {
            const innerIn_jcrmz8mnz = addedOps[i].inTrigger("innerIn_jcrmz8mnz");
            innerIn_jcrmz8mnz.setUiAttribs({ "title": "Next" });
            innerIn_jcrmz8mnz.onTriggered = () => { port_jcrmz8mnz.trigger(); };
        }
    }
};
const patchId = "bp2sub_" + op.id;

new CABLES.SubPatchOp(op, { "subId": patchId });

initializeSubpatch();

function initializeSubpatch()
{
    const p = JSON.parse(attachments.subpatch_json);

    CABLES.Patch.replaceOpIds(p,
        {
            "parentSubPatchId": patchId,
            "prefixHash": patchId,
            "oldIdAsRef": true,
            "doNotUnlinkLostLinks": true
        });

    for (let i = 0; i < p.ops.length; i++)
    {
        p.ops[i].uiAttribs.blueprintSubpatch2 = true;
    }

    op.loadDependencies(p, () =>
    {
        op.patch.deSerialize(p, { "opsCreated": op.initInnerPorts });
        if (CABLES.UI)gui.savedState.setSaved("blueprintloaded", patchId);
        op.patch.emitEvent("subpatchExpose", patchId);
        op.setStorage({ "blueprintVer": 2 });
        op.patch.emitEvent("subpatchExpose", patchId);
    });
}

}
};

CABLES.OPS["20f83b41-4b28-4252-89b8-a98c7c72e618"]={f:Ops.Gl.DownloadTexture_v3,objName:"Ops.Gl.DownloadTexture_v3"};




// **************************************************************
// 
// Ops.Patch.PLH3vXR.IsLayerVisible
// 
// **************************************************************

Ops.Patch.PLH3vXR.IsLayerVisible= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={"inc_gen_ports_js":"const port_mqmfkaq8t=op.inFloat(\"mqmfkaq8t\",0);\nport_mqmfkaq8t.setUiAttribs({title:\"LayerIndex\",increment:\"integer\",});\nport_mqmfkaq8t.setUiAttribs({\"values\":[\"\"]});\n\nconst port_vfunjpwkx=op.outNumber(\"vfunjpwkx\");\nport_vfunjpwkx.setUiAttribs({title:\"Visible\",increment:\"integer\",});\nport_vfunjpwkx.setUiAttribs({\"values\":[\"\"]});\n\nop.initInnerPorts=function(addedOps)\n{\n  for(let i=0;i<addedOps.length;i++)\n  {\n    if(addedOps[i].innerInput)\n    {\nconst innerOut_mqmfkaq8t = addedOps[i].outNumber(\"innerOut_mqmfkaq8t\");\ninnerOut_mqmfkaq8t.set(port_mqmfkaq8t.get() );\ninnerOut_mqmfkaq8t.setUiAttribs({title:\"LayerIndex\"});\nport_mqmfkaq8t.on(\"change\", (a,v) => { innerOut_mqmfkaq8t.set(a); });\n\n    }\nif(addedOps[i].innerOutput)\n{\nconst innerIn_vfunjpwkx = addedOps[i].inFloat(\"innerIn_vfunjpwkx\");\ninnerIn_vfunjpwkx.setUiAttribs({title:\"Visible\"});\ninnerIn_vfunjpwkx.on(\"change\", (a,v) => { port_vfunjpwkx.set(a); });\n\n}\n}\n};\n","subpatch_json":"{\"ops\":[{\"id\":\"sp3-0\",\"uiAttribs\":{\"subPatch\":\"1gb8io0qj\"},\"storage\":{\"blueprintVer\":2},\"portsOut\":[{\"name\":\"Result\",\"links\":[{\"portIn\":\"innerIn_vfunjpwkx\",\"portOut\":\"Result\",\"objIn\":\"sp3-7\",\"objOut\":\"sp3-0\"}]}],\"objName\":\"Ops.Ui.VizNumber\"},{\"id\":\"sp3-1\",\"uiAttribs\":{\"subPatch\":\"1gb8io0qj\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"Variable\",\"value\":\"LayerIndex\"}],\"portsOut\":[{\"name\":\"Value\",\"links\":[{\"portIn\":\"number1\",\"portOut\":\"Value\",\"objIn\":\"sp3-3\",\"objOut\":\"sp3-1\"},{\"portIn\":\"number1\",\"portOut\":\"Value\",\"objIn\":\"sp3-4\",\"objOut\":\"sp3-1\"}]}],\"objName\":\"Ops.Vars.VarGetNumber_v2\"},{\"id\":\"sp3-2\",\"uiAttribs\":{\"subPatch\":\"1gb8io0qj\"},\"storage\":{\"blueprintVer\":2},\"portsOut\":[{\"name\":\"result\",\"links\":[{\"portIn\":\"bool 2\",\"portOut\":\"result\",\"objIn\":\"sp3-5\",\"objOut\":\"sp3-2\"}]}],\"objName\":\"Ops.Math.Compare.Equals\"},{\"id\":\"sp3-3\",\"uiAttribs\":{\"subPatch\":\"1gb8io0qj\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"number2\",\"value\":1}],\"portsOut\":[{\"name\":\"result\",\"links\":[{\"portIn\":\"number1\",\"portOut\":\"result\",\"objIn\":\"sp3-2\",\"objOut\":\"sp3-3\"}]}],\"objName\":\"Ops.Math.Subtract\"},{\"id\":\"sp3-4\",\"uiAttribs\":{\"subPatch\":\"1gb8io0qj\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"number2\",\"value\":0}],\"portsOut\":[{\"name\":\"result\",\"links\":[{\"portIn\":\"bool 1\",\"portOut\":\"result\",\"objIn\":\"sp3-5\",\"objOut\":\"sp3-4\"}]}],\"objName\":\"Ops.Math.Compare.Equals\"},{\"id\":\"sp3-5\",\"uiAttribs\":{\"subPatch\":\"1gb8io0qj\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"bool 3\",\"value\":0},{\"name\":\"bool 4\",\"value\":0},{\"name\":\"bool 5\",\"value\":0},{\"name\":\"bool 6\",\"value\":0},{\"name\":\"bool 7\",\"value\":0},{\"name\":\"bool 8\",\"value\":0},{\"name\":\"bool 9\",\"value\":0},{\"name\":\"bool 10\",\"value\":0}],\"portsOut\":[{\"name\":\"result\",\"links\":[{\"portIn\":\"Number\",\"portOut\":\"result\",\"objIn\":\"sp3-0\",\"objOut\":\"sp3-5\"}]}],\"objName\":\"Ops.Boolean.Or\"},{\"id\":\"sp3-6\",\"uiAttribs\":{\"subPatch\":\"1gb8io0qj\"},\"storage\":{\"blueprintVer\":2},\"portsOut\":[{\"name\":\"innerOut_mqmfkaq8t\",\"title\":\"LayerIndex\",\"links\":[{\"portIn\":\"number2\",\"portOut\":\"innerOut_mqmfkaq8t\",\"objIn\":\"sp3-2\",\"objOut\":\"sp3-6\"}]}],\"objName\":\"Ops.Ui.SubPatchInput\"},{\"id\":\"sp3-7\",\"uiAttribs\":{\"subPatch\":\"1gb8io0qj\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"innerIn_vfunjpwkx\",\"title\":\"Visible\"}],\"objName\":\"Ops.Ui.SubPatchOutput\"}]}",};
const port_mqmfkaq8t=op.inFloat("mqmfkaq8t",0);
port_mqmfkaq8t.setUiAttribs({title:"LayerIndex",increment:"integer",});
port_mqmfkaq8t.setUiAttribs({"values":[""]});

const port_vfunjpwkx=op.outNumber("vfunjpwkx");
port_vfunjpwkx.setUiAttribs({title:"Visible",increment:"integer",});
port_vfunjpwkx.setUiAttribs({"values":[""]});

op.initInnerPorts=function(addedOps)
{
  for(let i=0;i<addedOps.length;i++)
  {
    if(addedOps[i].innerInput)
    {
const innerOut_mqmfkaq8t = addedOps[i].outNumber("innerOut_mqmfkaq8t");
innerOut_mqmfkaq8t.set(port_mqmfkaq8t.get() );
innerOut_mqmfkaq8t.setUiAttribs({title:"LayerIndex"});
port_mqmfkaq8t.on("change", (a,v) => { innerOut_mqmfkaq8t.set(a); });

    }
if(addedOps[i].innerOutput)
{
const innerIn_vfunjpwkx = addedOps[i].inFloat("innerIn_vfunjpwkx");
innerIn_vfunjpwkx.setUiAttribs({title:"Visible"});
innerIn_vfunjpwkx.on("change", (a,v) => { port_vfunjpwkx.set(a); });

}
}
};

const patchId = "bp2sub_" + op.id;

new CABLES.SubPatchOp(op, { "subId": patchId });

initializeSubpatch();

function initializeSubpatch()
{
    const p = JSON.parse(attachments.subpatch_json);

    CABLES.Patch.replaceOpIds(p,
        {
            "parentSubPatchId": patchId,
            "prefixHash": patchId,
            "oldIdAsRef": true,
            "doNotUnlinkLostLinks": true
        });

    for (let i = 0; i < p.ops.length; i++)
    {
        p.ops[i].uiAttribs.blueprintSubpatch2 = true;
    }

    op.loadDependencies(p, () =>
    {
        op.patch.deSerialize(p, { "opsCreated": op.initInnerPorts });
        if (CABLES.UI)gui.savedState.setSaved("blueprintloaded", patchId);
        op.patch.emitEvent("subpatchExpose", patchId);
        op.setStorage({ "blueprintVer": 2 });
        op.patch.emitEvent("subpatchExpose", patchId);
    });
}

}
};

CABLES.OPS["6e6e7b3a-151e-4fa6-9e4a-93e6418e6197"]={f:Ops.Patch.PLH3vXR.IsLayerVisible,objName:"Ops.Patch.PLH3vXR.IsLayerVisible"};




// **************************************************************
// 
// Ops.Patch.PLH3vXR.CameraAnimated
// 
// **************************************************************

Ops.Patch.PLH3vXR.CameraAnimated= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={"inc_gen_ports_js":"const port_mbmposg49=op.inTrigger(\"mbmposg49\");\nport_mbmposg49.setUiAttribs({title:\"Trigger\",});\nport_mbmposg49.setUiAttribs({\"values\":[\"\"]});\n\nconst port_z5ocj0lq6=op.outTrigger(\"z5ocj0lq6\");\nport_z5ocj0lq6.setUiAttribs({title:\"Trigger\",});\nport_z5ocj0lq6.setUiAttribs({\"values\":[\"\"]});\n\nop.initInnerPorts=function(addedOps)\n{\n  for(let i=0;i<addedOps.length;i++)\n  {\n    if(addedOps[i].innerInput)\n    {\nconst innerOut_mbmposg49 = addedOps[i].outTrigger(\"innerOut_mbmposg49\");\ninnerOut_mbmposg49.setUiAttribs({title:\"Trigger\"});\nport_mbmposg49.onTriggered = () => { innerOut_mbmposg49.trigger(); };\n\n    }\nif(addedOps[i].innerOutput)\n{\nconst innerIn_z5ocj0lq6 = addedOps[i].inTrigger(\"innerIn_z5ocj0lq6\");\ninnerIn_z5ocj0lq6.setUiAttribs({title:\"Trigger\"});\ninnerIn_z5ocj0lq6.onTriggered = () => { port_z5ocj0lq6.trigger(); };\n\n}\n}\n};\n","subpatch_json":"{\"ops\":[{\"id\":\"sp4-0\",\"uiAttribs\":{\"subPatch\":\"tc6ls98nk\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"Identity\",\"value\":1},{\"name\":\"projection mode index\",\"value\":0},{\"name\":\"projection mode\",\"value\":\"prespective\"},{\"name\":\"frustum near\",\"value\":0.01},{\"name\":\"frustum far\",\"value\":5000}],\"portsOut\":[{\"name\":\"trigger\",\"links\":[{\"portIn\":\"innerIn_z5ocj0lq6\",\"portOut\":\"trigger\",\"objIn\":\"sp4-3\",\"objOut\":\"sp4-0\"}]},{\"name\":\"Aspect\",\"value\":1}],\"objName\":\"Ops.Gl.Matrix.Camera_v2\"},{\"id\":\"sp4-1\",\"uiAttribs\":{\"subPatch\":\"tc6ls98nk\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"Variable\",\"value\":\"CameraParameter\"}],\"portsOut\":[{\"name\":\"Value\",\"links\":[{\"portIn\":\"Array\",\"portOut\":\"Value\",\"objIn\":\"sp4-4\",\"objOut\":\"sp4-1\"}]}],\"objName\":\"Ops.Vars.VarGetArray_v2\"},{\"id\":\"sp4-2\",\"uiAttribs\":{\"subPatch\":\"tc6ls98nk\"},\"storage\":{\"blueprintVer\":2},\"portsOut\":[{\"name\":\"innerOut_mbmposg49\",\"title\":\"Trigger\",\"links\":[{\"portIn\":\"render\",\"portOut\":\"innerOut_mbmposg49\",\"objIn\":\"sp4-0\",\"objOut\":\"sp4-2\"},{\"portIn\":\"render\",\"portOut\":\"innerOut_mbmposg49\",\"objIn\":\"sp4-21\",\"objOut\":\"sp4-2\"}]}],\"objName\":\"Ops.Ui.SubPatchInput\"},{\"id\":\"sp4-3\",\"uiAttribs\":{\"subPatch\":\"tc6ls98nk\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"innerIn_z5ocj0lq6\",\"title\":\"Trigger\"}],\"objName\":\"Ops.Ui.SubPatchOutput\"},{\"id\":\"sp4-4\",\"uiAttribs\":{\"subPatch\":\"tc6ls98nk\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"Stride\",\"value\":3}],\"portsOut\":[{\"name\":\"Result\",\"links\":[{\"portIn\":\"Array of Arrays\",\"portOut\":\"Result\",\"objIn\":\"sp4-5\",\"objOut\":\"sp4-4\"},{\"portIn\":\"Array of Arrays\",\"portOut\":\"Result\",\"objIn\":\"sp4-8\",\"objOut\":\"sp4-4\"},{\"portIn\":\"Array of Arrays\",\"portOut\":\"Result\",\"objIn\":\"sp4-11\",\"objOut\":\"sp4-4\"},{\"portIn\":\"Array of Arrays\",\"portOut\":\"Result\",\"objIn\":\"sp4-14\",\"objOut\":\"sp4-4\"},{\"portIn\":\"Array of Arrays\",\"portOut\":\"Result\",\"objIn\":\"sp4-17\",\"objOut\":\"sp4-4\"}]}],\"objName\":\"Ops.Array.ArrayToArrays\"},{\"id\":\"sp4-5\",\"uiAttribs\":{\"subPatch\":\"tc6ls98nk\"},\"storage\":{\"blueprintVer\":2},\"portsOut\":[{\"name\":\"Result Array\",\"links\":[{\"portIn\":\"Array\",\"portOut\":\"Result Array\",\"objIn\":\"sp4-7\",\"objOut\":\"sp4-5\"}]}],\"objName\":\"Ops.Array.ArrayGetArray\"},{\"id\":\"sp4-6\",\"uiAttribs\":{\"subPatch\":\"tc6ls98nk\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"Number\",\"value\":0}],\"portsOut\":[{\"name\":\"Result\",\"links\":[{\"portIn\":\"Index\",\"portOut\":\"Result\",\"objIn\":\"sp4-5\",\"objOut\":\"sp4-6\"}]}],\"objName\":\"Ops.Ui.VizNumber\"},{\"id\":\"sp4-7\",\"uiAttribs\":{\"subPatch\":\"tc6ls98nk\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"Index\",\"value\":0}],\"portsOut\":[{\"name\":\"X\",\"links\":[{\"portIn\":\"fov\",\"portOut\":\"X\",\"objIn\":\"sp4-0\",\"objOut\":\"sp4-7\"}]},{\"name\":\"Y\",\"links\":[{\"portIn\":\"Auto Aspect Ratio\",\"portOut\":\"Y\",\"objIn\":\"sp4-0\",\"objOut\":\"sp4-7\"}]},{\"name\":\"Z\",\"links\":[{\"portIn\":\"Aspect Ratio\",\"portOut\":\"Z\",\"objIn\":\"sp4-0\",\"objOut\":\"sp4-7\"}]}],\"objName\":\"Ops.Array.Array3GetNumbers\"},{\"id\":\"sp4-8\",\"uiAttribs\":{\"subPatch\":\"tc6ls98nk\"},\"storage\":{\"blueprintVer\":2},\"portsOut\":[{\"name\":\"Result Array\",\"links\":[{\"portIn\":\"Array\",\"portOut\":\"Result Array\",\"objIn\":\"sp4-10\",\"objOut\":\"sp4-8\"}]}],\"objName\":\"Ops.Array.ArrayGetArray\"},{\"id\":\"sp4-9\",\"uiAttribs\":{\"subPatch\":\"tc6ls98nk\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"Number\",\"value\":1}],\"portsOut\":[{\"name\":\"Result\",\"links\":[{\"portIn\":\"Index\",\"portOut\":\"Result\",\"objIn\":\"sp4-8\",\"objOut\":\"sp4-9\"}]}],\"objName\":\"Ops.Ui.VizNumber\"},{\"id\":\"sp4-10\",\"uiAttribs\":{\"subPatch\":\"tc6ls98nk\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"Index\",\"value\":0}],\"portsOut\":[{\"name\":\"X\",\"links\":[{\"portIn\":\"eye X\",\"portOut\":\"X\",\"objIn\":\"sp4-0\",\"objOut\":\"sp4-10\"},{\"portIn\":\"eyeX\",\"portOut\":\"X\",\"objIn\":\"sp4-21\",\"objOut\":\"sp4-10\"}]},{\"name\":\"Y\",\"links\":[{\"portIn\":\"eye Y\",\"portOut\":\"Y\",\"objIn\":\"sp4-0\",\"objOut\":\"sp4-10\"},{\"portIn\":\"eyeY\",\"portOut\":\"Y\",\"objIn\":\"sp4-21\",\"objOut\":\"sp4-10\"}]},{\"name\":\"Z\",\"links\":[{\"portIn\":\"eye Z\",\"portOut\":\"Z\",\"objIn\":\"sp4-0\",\"objOut\":\"sp4-10\"},{\"portIn\":\"eyeZ\",\"portOut\":\"Z\",\"objIn\":\"sp4-21\",\"objOut\":\"sp4-10\"}]}],\"objName\":\"Ops.Array.Array3GetNumbers\"},{\"id\":\"sp4-11\",\"uiAttribs\":{\"subPatch\":\"tc6ls98nk\"},\"storage\":{\"blueprintVer\":2},\"portsOut\":[{\"name\":\"Result Array\",\"links\":[{\"portIn\":\"Array\",\"portOut\":\"Result Array\",\"objIn\":\"sp4-13\",\"objOut\":\"sp4-11\"}]}],\"objName\":\"Ops.Array.ArrayGetArray\"},{\"id\":\"sp4-12\",\"uiAttribs\":{\"subPatch\":\"tc6ls98nk\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"Number\",\"value\":2}],\"portsOut\":[{\"name\":\"Result\",\"links\":[{\"portIn\":\"Index\",\"portOut\":\"Result\",\"objIn\":\"sp4-11\",\"objOut\":\"sp4-12\"}]}],\"objName\":\"Ops.Ui.VizNumber\"},{\"id\":\"sp4-13\",\"uiAttribs\":{\"subPatch\":\"tc6ls98nk\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"Index\",\"value\":0}],\"portsOut\":[{\"name\":\"X\",\"links\":[{\"portIn\":\"center X\",\"portOut\":\"X\",\"objIn\":\"sp4-0\",\"objOut\":\"sp4-13\"},{\"portIn\":\"centerX\",\"portOut\":\"X\",\"objIn\":\"sp4-21\",\"objOut\":\"sp4-13\"}]},{\"name\":\"Y\",\"links\":[{\"portIn\":\"center Y\",\"portOut\":\"Y\",\"objIn\":\"sp4-0\",\"objOut\":\"sp4-13\"},{\"portIn\":\"centerY\",\"portOut\":\"Y\",\"objIn\":\"sp4-21\",\"objOut\":\"sp4-13\"}]},{\"name\":\"Z\",\"links\":[{\"portIn\":\"center Z\",\"portOut\":\"Z\",\"objIn\":\"sp4-0\",\"objOut\":\"sp4-13\"},{\"portIn\":\"centerZ\",\"portOut\":\"Z\",\"objIn\":\"sp4-21\",\"objOut\":\"sp4-13\"}]}],\"objName\":\"Ops.Array.Array3GetNumbers\"},{\"id\":\"sp4-14\",\"uiAttribs\":{\"subPatch\":\"tc6ls98nk\"},\"storage\":{\"blueprintVer\":2},\"portsOut\":[{\"name\":\"Result Array\",\"links\":[{\"portIn\":\"Array\",\"portOut\":\"Result Array\",\"objIn\":\"sp4-16\",\"objOut\":\"sp4-14\"}]}],\"objName\":\"Ops.Array.ArrayGetArray\"},{\"id\":\"sp4-15\",\"uiAttribs\":{\"subPatch\":\"tc6ls98nk\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"Number\",\"value\":3}],\"portsOut\":[{\"name\":\"Result\",\"links\":[{\"portIn\":\"Index\",\"portOut\":\"Result\",\"objIn\":\"sp4-14\",\"objOut\":\"sp4-15\"}]}],\"objName\":\"Ops.Ui.VizNumber\"},{\"id\":\"sp4-16\",\"uiAttribs\":{\"subPatch\":\"tc6ls98nk\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"Index\",\"value\":0}],\"portsOut\":[{\"name\":\"X\",\"links\":[{\"portIn\":\"truck\",\"portOut\":\"X\",\"objIn\":\"sp4-0\",\"objOut\":\"sp4-16\"}]},{\"name\":\"Y\",\"links\":[{\"portIn\":\"boom\",\"portOut\":\"Y\",\"objIn\":\"sp4-0\",\"objOut\":\"sp4-16\"}]},{\"name\":\"Z\",\"links\":[{\"portIn\":\"dolly\",\"portOut\":\"Z\",\"objIn\":\"sp4-0\",\"objOut\":\"sp4-16\"}]}],\"objName\":\"Ops.Array.Array3GetNumbers\"},{\"id\":\"sp4-17\",\"uiAttribs\":{\"subPatch\":\"tc6ls98nk\"},\"storage\":{\"blueprintVer\":2},\"portsOut\":[{\"name\":\"Result Array\",\"links\":[{\"portIn\":\"Array\",\"portOut\":\"Result Array\",\"objIn\":\"sp4-19\",\"objOut\":\"sp4-17\"}]}],\"objName\":\"Ops.Array.ArrayGetArray\"},{\"id\":\"sp4-18\",\"uiAttribs\":{\"subPatch\":\"tc6ls98nk\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"Number\",\"value\":4}],\"portsOut\":[{\"name\":\"Result\",\"links\":[{\"portIn\":\"Index\",\"portOut\":\"Result\",\"objIn\":\"sp4-17\",\"objOut\":\"sp4-18\"}]}],\"objName\":\"Ops.Ui.VizNumber\"},{\"id\":\"sp4-19\",\"uiAttribs\":{\"subPatch\":\"tc6ls98nk\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"Index\",\"value\":0}],\"portsOut\":[{\"name\":\"X\",\"links\":[{\"portIn\":\"tilt\",\"portOut\":\"X\",\"objIn\":\"sp4-0\",\"objOut\":\"sp4-19\"}]},{\"name\":\"Y\",\"links\":[{\"portIn\":\"pan\",\"portOut\":\"Y\",\"objIn\":\"sp4-0\",\"objOut\":\"sp4-19\"}]},{\"name\":\"Z\",\"links\":[{\"portIn\":\"roll\",\"portOut\":\"Z\",\"objIn\":\"sp4-0\",\"objOut\":\"sp4-19\"}]}],\"objName\":\"Ops.Array.Array3GetNumbers\"},{\"id\":\"sp4-20\",\"uiAttribs\":{\"subPatch\":\"tc6ls98nk\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"eyeX\",\"value\":5},{\"name\":\"eyeY\",\"value\":5},{\"name\":\"eyeZ\",\"value\":5},{\"name\":\"quatX\",\"value\":0},{\"name\":\"quatY\",\"value\":0},{\"name\":\"quatZ\",\"value\":0},{\"name\":\"quatW\",\"value\":0},{\"name\":\"upX\",\"value\":0},{\"name\":\"upY\",\"value\":1},{\"name\":\"upZ\",\"value\":0}],\"objName\":\"Ops.Gl.Matrix.QuaternionCamera\"},{\"id\":\"sp4-21\",\"uiAttribs\":{\"subPatch\":\"tc6ls98nk\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"upX\",\"value\":0},{\"name\":\"upY\",\"value\":1},{\"name\":\"upZ\",\"value\":0}],\"objName\":\"Ops.Gl.Matrix.LookatCamera\"}]}",};
const port_mbmposg49=op.inTrigger("mbmposg49");
port_mbmposg49.setUiAttribs({title:"Trigger",});
port_mbmposg49.setUiAttribs({"values":[""]});

const port_z5ocj0lq6=op.outTrigger("z5ocj0lq6");
port_z5ocj0lq6.setUiAttribs({title:"Trigger",});
port_z5ocj0lq6.setUiAttribs({"values":[""]});

op.initInnerPorts=function(addedOps)
{
  for(let i=0;i<addedOps.length;i++)
  {
    if(addedOps[i].innerInput)
    {
const innerOut_mbmposg49 = addedOps[i].outTrigger("innerOut_mbmposg49");
innerOut_mbmposg49.setUiAttribs({title:"Trigger"});
port_mbmposg49.onTriggered = () => { innerOut_mbmposg49.trigger(); };

    }
if(addedOps[i].innerOutput)
{
const innerIn_z5ocj0lq6 = addedOps[i].inTrigger("innerIn_z5ocj0lq6");
innerIn_z5ocj0lq6.setUiAttribs({title:"Trigger"});
innerIn_z5ocj0lq6.onTriggered = () => { port_z5ocj0lq6.trigger(); };

}
}
};

const patchId = "bp2sub_" + op.id;

new CABLES.SubPatchOp(op, { "subId": patchId });

initializeSubpatch();

function initializeSubpatch()
{
    const p = JSON.parse(attachments.subpatch_json);

    CABLES.Patch.replaceOpIds(p,
        {
            "parentSubPatchId": patchId,
            "prefixHash": patchId,
            "oldIdAsRef": true,
            "doNotUnlinkLostLinks": true
        });

    for (let i = 0; i < p.ops.length; i++)
    {
        p.ops[i].uiAttribs.blueprintSubpatch2 = true;
    }

    op.loadDependencies(p, () =>
    {
        op.patch.deSerialize(p, { "opsCreated": op.initInnerPorts });
        if (CABLES.UI)gui.savedState.setSaved("blueprintloaded", patchId);
        op.patch.emitEvent("subpatchExpose", patchId);
        op.setStorage({ "blueprintVer": 2 });
        op.patch.emitEvent("subpatchExpose", patchId);
    });
}

}
};

CABLES.OPS["8789183a-4748-4067-bcd2-b0d532a306fd"]={f:Ops.Patch.PLH3vXR.CameraAnimated,objName:"Ops.Patch.PLH3vXR.CameraAnimated"};




// **************************************************************
// 
// Ops.Patch.PLH3vXR.TwoStepAniamation
// 
// **************************************************************

Ops.Patch.PLH3vXR.TwoStepAniamation= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={"inc_gen_ports_js":"const port_ul3e7qngs=op.inFloat(\"ul3e7qngs\",0);\nport_ul3e7qngs.setUiAttribs({title:\"Animation\",});\nport_ul3e7qngs.setUiAttribs({\"values\":[\"\"]});\n\nconst port_4wxi8etyc=op.inFloat(\"4wxi8etyc\",0.5);\nport_4wxi8etyc.setUiAttribs({title:\"Turning Point\",});\nport_4wxi8etyc.setUiAttribs({\"values\":[\"\"]});\n\nconst port_7ry50s9p2=op.inFloat(\"7ry50s9p2\",0);\nport_7ry50s9p2.setUiAttribs({title:\"Value Start\",});\nport_7ry50s9p2.setUiAttribs({\"values\":[\"\"]});\n\nconst port_dw634vl53=op.inFloat(\"dw634vl53\",0.5);\nport_dw634vl53.setUiAttribs({title:\"Value Turning\",});\nport_dw634vl53.setUiAttribs({\"values\":[\"\"]});\n\nconst port_xafw2raho=op.inFloat(\"xafw2raho\",1);\nport_xafw2raho.setUiAttribs({title:\"Value End\",});\nport_xafw2raho.setUiAttribs({\"values\":[\"\"]});\n\nconst port_oud37e362=op.outNumber(\"oud37e362\");\nport_oud37e362.setUiAttribs({title:\"Value\",});\nport_oud37e362.setUiAttribs({\"values\":[\"\"]});\n\nop.initInnerPorts=function(addedOps)\n{\n  for(let i=0;i<addedOps.length;i++)\n  {\n    if(addedOps[i].innerInput)\n    {\nconst innerOut_ul3e7qngs = addedOps[i].outNumber(\"innerOut_ul3e7qngs\");\ninnerOut_ul3e7qngs.set(port_ul3e7qngs.get() );\ninnerOut_ul3e7qngs.setUiAttribs({title:\"Animation\"});\nport_ul3e7qngs.on(\"change\", (a,v) => { innerOut_ul3e7qngs.set(a); });\n\nconst innerOut_4wxi8etyc = addedOps[i].outNumber(\"innerOut_4wxi8etyc\");\ninnerOut_4wxi8etyc.set(port_4wxi8etyc.get() );\ninnerOut_4wxi8etyc.setUiAttribs({title:\"Turning Point\"});\nport_4wxi8etyc.on(\"change\", (a,v) => { innerOut_4wxi8etyc.set(a); });\n\nconst innerOut_7ry50s9p2 = addedOps[i].outNumber(\"innerOut_7ry50s9p2\");\ninnerOut_7ry50s9p2.set(port_7ry50s9p2.get() );\ninnerOut_7ry50s9p2.setUiAttribs({title:\"Value Start\"});\nport_7ry50s9p2.on(\"change\", (a,v) => { innerOut_7ry50s9p2.set(a); });\n\nconst innerOut_dw634vl53 = addedOps[i].outNumber(\"innerOut_dw634vl53\");\ninnerOut_dw634vl53.set(port_dw634vl53.get() );\ninnerOut_dw634vl53.setUiAttribs({title:\"Value Turning\"});\nport_dw634vl53.on(\"change\", (a,v) => { innerOut_dw634vl53.set(a); });\n\nconst innerOut_xafw2raho = addedOps[i].outNumber(\"innerOut_xafw2raho\");\ninnerOut_xafw2raho.set(port_xafw2raho.get() );\ninnerOut_xafw2raho.setUiAttribs({title:\"Value End\"});\nport_xafw2raho.on(\"change\", (a,v) => { innerOut_xafw2raho.set(a); });\n\n    }\nif(addedOps[i].innerOutput)\n{\nconst innerIn_oud37e362 = addedOps[i].inFloat(\"innerIn_oud37e362\");\ninnerIn_oud37e362.setUiAttribs({title:\"Value\"});\ninnerIn_oud37e362.on(\"change\", (a,v) => { port_oud37e362.set(a); });\n\n}\n}\n};\n","subpatch_json":"{\"ops\":[{\"id\":\"sp5-0\",\"uiAttribs\":{\"subPatch\":\"9x4rthzpd\"},\"storage\":{\"blueprintVer\":2},\"portsOut\":[{\"name\":\"result\",\"links\":[{\"portIn\":\"Index\",\"portOut\":\"result\",\"objIn\":\"sp5-2\",\"objOut\":\"sp5-0\"}]}],\"objName\":\"Ops.Math.Compare.GreaterThan\"},{\"id\":\"sp5-1\",\"uiAttribs\":{\"subPatch\":\"9x4rthzpd\"},\"storage\":{\"blueprintVer\":2},\"portsOut\":[{\"name\":\"Result\",\"links\":[{\"portIn\":\"number2\",\"portOut\":\"Result\",\"objIn\":\"sp5-0\",\"objOut\":\"sp5-1\"},{\"portIn\":\"old min\",\"portOut\":\"Result\",\"objIn\":\"sp5-4\",\"objOut\":\"sp5-1\"},{\"portIn\":\"Max\",\"portOut\":\"Result\",\"objIn\":\"sp5-7\",\"objOut\":\"sp5-1\"},{\"portIn\":\"old max\",\"portOut\":\"Result\",\"objIn\":\"sp5-11\",\"objOut\":\"sp5-1\"},{\"portIn\":\"Min\",\"portOut\":\"Result\",\"objIn\":\"sp5-12\",\"objOut\":\"sp5-1\"}]}],\"objName\":\"Ops.Ui.VizNumber\"},{\"id\":\"sp5-2\",\"uiAttribs\":{\"subPatch\":\"9x4rthzpd\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"Value 2\",\"value\":0},{\"name\":\"Value 3\",\"value\":0},{\"name\":\"Value 4\",\"value\":0},{\"name\":\"Value 5\",\"value\":0},{\"name\":\"Value 6\",\"value\":0},{\"name\":\"Value 7\",\"value\":0},{\"name\":\"Value 8\",\"value\":0},{\"name\":\"Value 9\",\"value\":0},{\"name\":\"Value 10\",\"value\":0},{\"name\":\"Value 11\",\"value\":0},{\"name\":\"Value 12\",\"value\":0},{\"name\":\"Value 13\",\"value\":0},{\"name\":\"Value 14\",\"value\":0},{\"name\":\"Value 15\",\"value\":0}],\"portsOut\":[{\"name\":\"Result\",\"links\":[{\"portIn\":\"innerIn_oud37e362\",\"portOut\":\"Result\",\"objIn\":\"sp5-6\",\"objOut\":\"sp5-2\"}]}],\"objName\":\"Ops.Number.SwitchNumber\"},{\"id\":\"sp5-3\",\"uiAttribs\":{\"subPatch\":\"9x4rthzpd\"},\"storage\":{\"blueprintVer\":2},\"portsOut\":[{\"name\":\"Result\",\"links\":[{\"portIn\":\"number1\",\"portOut\":\"Result\",\"objIn\":\"sp5-0\",\"objOut\":\"sp5-3\"},{\"portIn\":\"Value\",\"portOut\":\"Result\",\"objIn\":\"sp5-7\",\"objOut\":\"sp5-3\"},{\"portIn\":\"Value\",\"portOut\":\"Result\",\"objIn\":\"sp5-12\",\"objOut\":\"sp5-3\"}]}],\"objName\":\"Ops.Ui.VizNumber\"},{\"id\":\"sp5-4\",\"uiAttribs\":{\"subPatch\":\"9x4rthzpd\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"old max\",\"value\":1},{\"name\":\"Easing index\",\"value\":0},{\"name\":\"Easing\",\"value\":\"Linear\"},{\"name\":\"Clamp\",\"value\":1}],\"portsOut\":[{\"name\":\"result\",\"links\":[{\"portIn\":\"Value 1\",\"portOut\":\"result\",\"objIn\":\"sp5-2\",\"objOut\":\"sp5-4\"}]}],\"objName\":\"Ops.Math.MapRange\"},{\"id\":\"sp5-5\",\"uiAttribs\":{\"subPatch\":\"9x4rthzpd\"},\"storage\":{\"blueprintVer\":2},\"portsOut\":[{\"name\":\"innerOut_ul3e7qngs\",\"title\":\"Animation\",\"links\":[{\"portIn\":\"Number\",\"portOut\":\"innerOut_ul3e7qngs\",\"objIn\":\"sp5-3\",\"objOut\":\"sp5-5\"}]},{\"name\":\"innerOut_4wxi8etyc\",\"title\":\"Turning Point\",\"links\":[{\"portIn\":\"Number\",\"portOut\":\"innerOut_4wxi8etyc\",\"objIn\":\"sp5-1\",\"objOut\":\"sp5-5\"}]},{\"name\":\"innerOut_7ry50s9p2\",\"title\":\"Value Start\",\"links\":[{\"portIn\":\"Number\",\"portOut\":\"innerOut_7ry50s9p2\",\"objIn\":\"sp5-8\",\"objOut\":\"sp5-5\"}]},{\"name\":\"innerOut_dw634vl53\",\"title\":\"Value Turning\",\"links\":[{\"portIn\":\"Number\",\"portOut\":\"innerOut_dw634vl53\",\"objIn\":\"sp5-9\",\"objOut\":\"sp5-5\"}]},{\"name\":\"innerOut_xafw2raho\",\"title\":\"Value End\",\"links\":[{\"portIn\":\"Number\",\"portOut\":\"innerOut_xafw2raho\",\"objIn\":\"sp5-10\",\"objOut\":\"sp5-5\"}]}],\"objName\":\"Ops.Ui.SubPatchInput\"},{\"id\":\"sp5-6\",\"uiAttribs\":{\"subPatch\":\"9x4rthzpd\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"innerIn_oud37e362\",\"title\":\"Value\"}],\"objName\":\"Ops.Ui.SubPatchOutput\"},{\"id\":\"sp5-7\",\"uiAttribs\":{\"subPatch\":\"9x4rthzpd\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"Min\",\"value\":0},{\"name\":\"Easing index\",\"value\":12},{\"name\":\"Easing\",\"value\":\"Sin In Out\"}],\"portsOut\":[{\"name\":\"Result\",\"links\":[{\"portIn\":\"value\",\"portOut\":\"Result\",\"objIn\":\"sp5-11\",\"objOut\":\"sp5-7\"}]}],\"objName\":\"Ops.Math.Ease\"},{\"id\":\"sp5-8\",\"uiAttribs\":{\"subPatch\":\"9x4rthzpd\"},\"storage\":{\"blueprintVer\":2},\"portsOut\":[{\"name\":\"Result\",\"links\":[{\"portIn\":\"new min\",\"portOut\":\"Result\",\"objIn\":\"sp5-11\",\"objOut\":\"sp5-8\"}]}],\"objName\":\"Ops.Ui.VizNumber\"},{\"id\":\"sp5-9\",\"uiAttribs\":{\"subPatch\":\"9x4rthzpd\"},\"storage\":{\"blueprintVer\":2},\"portsOut\":[{\"name\":\"Result\",\"links\":[{\"portIn\":\"new max\",\"portOut\":\"Result\",\"objIn\":\"sp5-11\",\"objOut\":\"sp5-9\"},{\"portIn\":\"new min\",\"portOut\":\"Result\",\"objIn\":\"sp5-4\",\"objOut\":\"sp5-9\"}]}],\"objName\":\"Ops.Ui.VizNumber\"},{\"id\":\"sp5-10\",\"uiAttribs\":{\"subPatch\":\"9x4rthzpd\"},\"storage\":{\"blueprintVer\":2},\"portsOut\":[{\"name\":\"Result\",\"links\":[{\"portIn\":\"new max\",\"portOut\":\"Result\",\"objIn\":\"sp5-4\",\"objOut\":\"sp5-10\"}]}],\"objName\":\"Ops.Ui.VizNumber\"},{\"id\":\"sp5-11\",\"uiAttribs\":{\"subPatch\":\"9x4rthzpd\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"old min\",\"value\":0},{\"name\":\"Easing index\",\"value\":0},{\"name\":\"Easing\",\"value\":\"Linear\"},{\"name\":\"Clamp\",\"value\":1}],\"portsOut\":[{\"name\":\"result\",\"links\":[{\"portIn\":\"Value 0\",\"portOut\":\"result\",\"objIn\":\"sp5-2\",\"objOut\":\"sp5-11\"}]}],\"objName\":\"Ops.Math.MapRange\"},{\"id\":\"sp5-12\",\"uiAttribs\":{\"subPatch\":\"9x4rthzpd\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"Max\",\"value\":1},{\"name\":\"Easing index\",\"value\":12},{\"name\":\"Easing\",\"value\":\"Sin In Out\"}],\"portsOut\":[{\"name\":\"Result\",\"links\":[{\"portIn\":\"value\",\"portOut\":\"Result\",\"objIn\":\"sp5-4\",\"objOut\":\"sp5-12\"}]}],\"objName\":\"Ops.Math.Ease\"}]}",};
const port_ul3e7qngs=op.inFloat("ul3e7qngs",0);
port_ul3e7qngs.setUiAttribs({title:"Animation",});
port_ul3e7qngs.setUiAttribs({"values":[""]});

const port_4wxi8etyc=op.inFloat("4wxi8etyc",0.5);
port_4wxi8etyc.setUiAttribs({title:"Turning Point",});
port_4wxi8etyc.setUiAttribs({"values":[""]});

const port_7ry50s9p2=op.inFloat("7ry50s9p2",0);
port_7ry50s9p2.setUiAttribs({title:"Value Start",});
port_7ry50s9p2.setUiAttribs({"values":[""]});

const port_dw634vl53=op.inFloat("dw634vl53",0.5);
port_dw634vl53.setUiAttribs({title:"Value Turning",});
port_dw634vl53.setUiAttribs({"values":[""]});

const port_xafw2raho=op.inFloat("xafw2raho",1);
port_xafw2raho.setUiAttribs({title:"Value End",});
port_xafw2raho.setUiAttribs({"values":[""]});

const port_oud37e362=op.outNumber("oud37e362");
port_oud37e362.setUiAttribs({title:"Value",});
port_oud37e362.setUiAttribs({"values":[""]});

op.initInnerPorts=function(addedOps)
{
  for(let i=0;i<addedOps.length;i++)
  {
    if(addedOps[i].innerInput)
    {
const innerOut_ul3e7qngs = addedOps[i].outNumber("innerOut_ul3e7qngs");
innerOut_ul3e7qngs.set(port_ul3e7qngs.get() );
innerOut_ul3e7qngs.setUiAttribs({title:"Animation"});
port_ul3e7qngs.on("change", (a,v) => { innerOut_ul3e7qngs.set(a); });

const innerOut_4wxi8etyc = addedOps[i].outNumber("innerOut_4wxi8etyc");
innerOut_4wxi8etyc.set(port_4wxi8etyc.get() );
innerOut_4wxi8etyc.setUiAttribs({title:"Turning Point"});
port_4wxi8etyc.on("change", (a,v) => { innerOut_4wxi8etyc.set(a); });

const innerOut_7ry50s9p2 = addedOps[i].outNumber("innerOut_7ry50s9p2");
innerOut_7ry50s9p2.set(port_7ry50s9p2.get() );
innerOut_7ry50s9p2.setUiAttribs({title:"Value Start"});
port_7ry50s9p2.on("change", (a,v) => { innerOut_7ry50s9p2.set(a); });

const innerOut_dw634vl53 = addedOps[i].outNumber("innerOut_dw634vl53");
innerOut_dw634vl53.set(port_dw634vl53.get() );
innerOut_dw634vl53.setUiAttribs({title:"Value Turning"});
port_dw634vl53.on("change", (a,v) => { innerOut_dw634vl53.set(a); });

const innerOut_xafw2raho = addedOps[i].outNumber("innerOut_xafw2raho");
innerOut_xafw2raho.set(port_xafw2raho.get() );
innerOut_xafw2raho.setUiAttribs({title:"Value End"});
port_xafw2raho.on("change", (a,v) => { innerOut_xafw2raho.set(a); });

    }
if(addedOps[i].innerOutput)
{
const innerIn_oud37e362 = addedOps[i].inFloat("innerIn_oud37e362");
innerIn_oud37e362.setUiAttribs({title:"Value"});
innerIn_oud37e362.on("change", (a,v) => { port_oud37e362.set(a); });

}
}
};

const patchId = "bp2sub_" + op.id;

new CABLES.SubPatchOp(op, { "subId": patchId });

initializeSubpatch();

function initializeSubpatch()
{
    const p = JSON.parse(attachments.subpatch_json);

    CABLES.Patch.replaceOpIds(p,
        {
            "parentSubPatchId": patchId,
            "prefixHash": patchId,
            "oldIdAsRef": true,
            "doNotUnlinkLostLinks": true
        });

    for (let i = 0; i < p.ops.length; i++)
    {
        p.ops[i].uiAttribs.blueprintSubpatch2 = true;
    }

    op.loadDependencies(p, () =>
    {
        op.patch.deSerialize(p, { "opsCreated": op.initInnerPorts });
        if (CABLES.UI)gui.savedState.setSaved("blueprintloaded", patchId);
        op.patch.emitEvent("subpatchExpose", patchId);
        op.setStorage({ "blueprintVer": 2 });
        op.patch.emitEvent("subpatchExpose", patchId);
    });
}

}
};

CABLES.OPS["96313876-4adc-47ce-9b38-61b1ba74dfa2"]={f:Ops.Patch.PLH3vXR.TwoStepAniamation,objName:"Ops.Patch.PLH3vXR.TwoStepAniamation"};




// **************************************************************
// 
// Ops.Patch.PLH3vXR.ProcessSingleLayer
// 
// **************************************************************

Ops.Patch.PLH3vXR.ProcessSingleLayer= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={"inc_gen_ports_js":"const port_8kld546qj=op.inFloat(\"8kld546qj\",0);\nport_8kld546qj.setUiAttribs({title:\"Layer Index\",});\nport_8kld546qj.setUiAttribs({\"values\":[\"\"]});\n\nconst port_d288224z4=op.inArray(\"d288224z4\");\nport_d288224z4.setUiAttribs({title:\"API Data\",});\n\nconst port_lfi6e6fmy=op.inArray(\"lfi6e6fmy\");\nport_lfi6e6fmy.setUiAttribs({title:\"ImagePathList\",});\nport_lfi6e6fmy.setUiAttribs({\"values\":[\"\"]});\n\nconst port_hho85lkjc=op.inArray(\"hho85lkjc\");\nport_hho85lkjc.setUiAttribs({title:\"ImagePathList_SecondLayer\",});\nport_hho85lkjc.setUiAttribs({\"values\":[\"\"]});\n\nconst port_p8xx9jp8e=op.inTrigger(\"p8xx9jp8e\");\nport_p8xx9jp8e.setUiAttribs({title:\"RenderToWorld\",});\nport_p8xx9jp8e.setUiAttribs({\"values\":[\"\"]});\n\nconst port_x8q9h17ke=op.inTrigger(\"x8q9h17ke\");\nport_x8q9h17ke.setUiAttribs({title:\"RenderToTexture_Building\",});\nport_x8q9h17ke.setUiAttribs({\"values\":[\"\"]});\n\nconst port_traw627xa=op.inTrigger(\"traw627xa\");\nport_traw627xa.setUiAttribs({title:\"RenderToTexture_Line\",});\nport_traw627xa.setUiAttribs({\"values\":[\"\"]});\n\nconst port_xoahcr8lh=op.inFloat(\"xoahcr8lh\",0);\nport_xoahcr8lh.setUiAttribs({title:\"ShowDebug\",display:\"bool\",});\nport_xoahcr8lh.setUiAttribs({\"values\":[\"\"]});\n\nconst port_xkk55pzq0=op.inFloat(\"xkk55pzq0\",0);\nport_xkk55pzq0.setUiAttribs({title:\"LayerInterval\",});\nport_xkk55pzq0.setUiAttribs({\"values\":[\"\"]});\n\nconst port_00mtr84dk=op.inFloat(\"00mtr84dk\",0);\nport_00mtr84dk.setUiAttribs({title:\"ImageIntervalX\",});\nport_00mtr84dk.setUiAttribs({\"values\":[\"\"]});\n\nconst port_rxdonrolr=op.inFloat(\"rxdonrolr\",0);\nport_rxdonrolr.setUiAttribs({title:\"ImageIntervalZ\",});\nport_rxdonrolr.setUiAttribs({\"values\":[\"\"]});\n\nconst port_k39iw7qf1=op.inArray(\"k39iw7qf1\");\nport_k39iw7qf1.setUiAttribs({title:\"IndicatorArray_Iconic\",});\nport_k39iw7qf1.setUiAttribs({\"values\":[\"\"]});\n\nconst port_v17tbxwpy=op.inArray(\"v17tbxwpy\");\nport_v17tbxwpy.setUiAttribs({title:\"IndicatorArray_Generic\",});\nport_v17tbxwpy.setUiAttribs({\"values\":[\"\"]});\n\nconst port_dobslg7sf=op.inTrigger(\"dobslg7sf\");\nport_dobslg7sf.setUiAttribs({title:\"Trigger\",});\nport_dobslg7sf.setUiAttribs({\"values\":[\"\"]});\n\nconst port_earjb46wu=op.inObject(\"earjb46wu\");\nport_earjb46wu.setUiAttribs({title:\"GradientMap_ForBuilding\",display:\"texture\",objType:\"texture\",objType:\"texture\"});\nport_earjb46wu.setUiAttribs({\"values\":[\"\"]});\n\nconst port_1er6wsd99=op.inObject(\"1er6wsd99\");\nport_1er6wsd99.setUiAttribs({title:\"GradientMap_ForMask\",display:\"texture\",objType:\"texture\",objType:\"texture\"});\nport_1er6wsd99.setUiAttribs({\"values\":[\"\"]});\n\nconst port_ga4abt9us=op.inObject(\"ga4abt9us\");\nport_ga4abt9us.setUiAttribs({title:\"BoundsMask\",display:\"texture\",objType:\"texture\",objType:\"texture\"});\nport_ga4abt9us.setUiAttribs({\"values\":[\"\"]});\n\nconst port_ge8is9nye=op.outTrigger(\"ge8is9nye\");\nport_ge8is9nye.setUiAttribs({title:\"RenderToWorld\",});\nport_ge8is9nye.setUiAttribs({\"values\":[\"\"]});\n\nconst port_cc3tea9q0=op.outTrigger(\"cc3tea9q0\");\nport_cc3tea9q0.setUiAttribs({title:\"RenderToTexture_Building\",});\nport_cc3tea9q0.setUiAttribs({\"values\":[\"\"]});\n\nconst port_wc7us54fg=op.outTrigger(\"wc7us54fg\");\nport_wc7us54fg.setUiAttribs({title:\"RenderToTexture_Line\",});\nport_wc7us54fg.setUiAttribs({\"values\":[\"\"]});\n\nconst port_740vm05xs=op.outArray(\"740vm05xs\");\nport_740vm05xs.setUiAttribs({title:\"IndicatorArray_Iconic\",});\nport_740vm05xs.setUiAttribs({\"values\":[\"\"]});\n\nconst port_vh2f15cw8=op.outArray(\"vh2f15cw8\");\nport_vh2f15cw8.setUiAttribs({title:\"IndicatorArray_Generic\",});\nport_vh2f15cw8.setUiAttribs({\"values\":[\"\"]});\n\nconst port_3cpnu6igj=op.outArray(\"3cpnu6igj\");\nport_3cpnu6igj.setUiAttribs({title:\"ImageList\",});\nport_3cpnu6igj.setUiAttribs({\"values\":[\"\"]});\n\nconst port_jycvtf89b=op.outObject(\"jycvtf89b\");\nport_jycvtf89b.setUiAttribs({title:\"BuildingTexture\",display:\"texture\",objType:\"texture\",objType:\"texture\"});\nport_jycvtf89b.setUiAttribs({\"values\":[\"\"]});\n\nconst port_el1t5zxr9=op.outObject(\"el1t5zxr9\");\nport_el1t5zxr9.setUiAttribs({title:\"LineTexture\",display:\"texture\",objType:\"texture\",objType:\"texture\"});\nport_el1t5zxr9.setUiAttribs({\"values\":[\"\"]});\n\nconst port_7lfhdhs5x=op.outNumber(\"7lfhdhs5x\");\nport_7lfhdhs5x.setUiAttribs({title:\"IsLoading\",display:\"bool\",});\nport_7lfhdhs5x.setUiAttribs({\"values\":[\"\"]});\n\nconst port_gr5rfgt62=op.outArray(\"gr5rfgt62\");\nport_gr5rfgt62.setUiAttribs({title:\"CurrentAnimationPoint\",});\nport_gr5rfgt62.setUiAttribs({\"values\":[\"\"]});\n\nop.initInnerPorts=function(addedOps)\n{\n  for(let i=0;i<addedOps.length;i++)\n  {\n    if(addedOps[i].innerInput)\n    {\nconst innerOut_8kld546qj = addedOps[i].outNumber(\"innerOut_8kld546qj\");\ninnerOut_8kld546qj.set(port_8kld546qj.get() );\ninnerOut_8kld546qj.setUiAttribs({title:\"Layer Index\"});\nport_8kld546qj.on(\"change\", (a,v) => { innerOut_8kld546qj.set(a); });\n\nconst innerOut_d288224z4 = addedOps[i].outArray(\"innerOut_d288224z4\");\ninnerOut_d288224z4.setUiAttribs({title:\"API Data\"});\nport_d288224z4.on(\"change\", (a,v) => { innerOut_d288224z4.setRef(a); });\n\nconst innerOut_lfi6e6fmy = addedOps[i].outArray(\"innerOut_lfi6e6fmy\");\ninnerOut_lfi6e6fmy.setUiAttribs({title:\"ImagePathList\"});\nport_lfi6e6fmy.on(\"change\", (a,v) => { innerOut_lfi6e6fmy.setRef(a); });\n\nconst innerOut_hho85lkjc = addedOps[i].outArray(\"innerOut_hho85lkjc\");\ninnerOut_hho85lkjc.setUiAttribs({title:\"ImagePathList_SecondLayer\"});\nport_hho85lkjc.on(\"change\", (a,v) => { innerOut_hho85lkjc.setRef(a); });\n\nconst innerOut_p8xx9jp8e = addedOps[i].outTrigger(\"innerOut_p8xx9jp8e\");\ninnerOut_p8xx9jp8e.setUiAttribs({title:\"RenderToWorld\"});\nport_p8xx9jp8e.onTriggered = () => { innerOut_p8xx9jp8e.trigger(); };\n\nconst innerOut_x8q9h17ke = addedOps[i].outTrigger(\"innerOut_x8q9h17ke\");\ninnerOut_x8q9h17ke.setUiAttribs({title:\"RenderToTexture_Building\"});\nport_x8q9h17ke.onTriggered = () => { innerOut_x8q9h17ke.trigger(); };\n\nconst innerOut_traw627xa = addedOps[i].outTrigger(\"innerOut_traw627xa\");\ninnerOut_traw627xa.setUiAttribs({title:\"RenderToTexture_Line\"});\nport_traw627xa.onTriggered = () => { innerOut_traw627xa.trigger(); };\n\nconst innerOut_xoahcr8lh = addedOps[i].outNumber(\"innerOut_xoahcr8lh\");\ninnerOut_xoahcr8lh.set(port_xoahcr8lh.get() );\ninnerOut_xoahcr8lh.setUiAttribs({title:\"ShowDebug\"});\nport_xoahcr8lh.on(\"change\", (a,v) => { innerOut_xoahcr8lh.set(a); });\n\nconst innerOut_xkk55pzq0 = addedOps[i].outNumber(\"innerOut_xkk55pzq0\");\ninnerOut_xkk55pzq0.set(port_xkk55pzq0.get() );\ninnerOut_xkk55pzq0.setUiAttribs({title:\"LayerInterval\"});\nport_xkk55pzq0.on(\"change\", (a,v) => { innerOut_xkk55pzq0.set(a); });\n\nconst innerOut_00mtr84dk = addedOps[i].outNumber(\"innerOut_00mtr84dk\");\ninnerOut_00mtr84dk.set(port_00mtr84dk.get() );\ninnerOut_00mtr84dk.setUiAttribs({title:\"ImageIntervalX\"});\nport_00mtr84dk.on(\"change\", (a,v) => { innerOut_00mtr84dk.set(a); });\n\nconst innerOut_rxdonrolr = addedOps[i].outNumber(\"innerOut_rxdonrolr\");\ninnerOut_rxdonrolr.set(port_rxdonrolr.get() );\ninnerOut_rxdonrolr.setUiAttribs({title:\"ImageIntervalZ\"});\nport_rxdonrolr.on(\"change\", (a,v) => { innerOut_rxdonrolr.set(a); });\n\nconst innerOut_k39iw7qf1 = addedOps[i].outArray(\"innerOut_k39iw7qf1\");\ninnerOut_k39iw7qf1.setUiAttribs({title:\"IndicatorArray_Iconic\"});\nport_k39iw7qf1.on(\"change\", (a,v) => { innerOut_k39iw7qf1.setRef(a); });\n\nconst innerOut_v17tbxwpy = addedOps[i].outArray(\"innerOut_v17tbxwpy\");\ninnerOut_v17tbxwpy.setUiAttribs({title:\"IndicatorArray_Generic\"});\nport_v17tbxwpy.on(\"change\", (a,v) => { innerOut_v17tbxwpy.setRef(a); });\n\nconst innerOut_dobslg7sf = addedOps[i].outTrigger(\"innerOut_dobslg7sf\");\ninnerOut_dobslg7sf.setUiAttribs({title:\"Trigger\"});\nport_dobslg7sf.onTriggered = () => { innerOut_dobslg7sf.trigger(); };\n\nconst innerOut_earjb46wu = addedOps[i].outTexture(\"innerOut_earjb46wu\");\ninnerOut_earjb46wu.setUiAttribs({title:\"GradientMap_ForBuilding\"});\nport_earjb46wu.on(\"change\", (a,v) => { innerOut_earjb46wu.setRef(a); });\n\nconst innerOut_1er6wsd99 = addedOps[i].outTexture(\"innerOut_1er6wsd99\");\ninnerOut_1er6wsd99.setUiAttribs({title:\"GradientMap_ForMask\"});\nport_1er6wsd99.on(\"change\", (a,v) => { innerOut_1er6wsd99.setRef(a); });\n\nconst innerOut_ga4abt9us = addedOps[i].outTexture(\"innerOut_ga4abt9us\");\ninnerOut_ga4abt9us.setUiAttribs({title:\"BoundsMask\"});\nport_ga4abt9us.on(\"change\", (a,v) => { innerOut_ga4abt9us.setRef(a); });\n\n    }\nif(addedOps[i].innerOutput)\n{\nconst innerIn_ge8is9nye = addedOps[i].inTrigger(\"innerIn_ge8is9nye\");\ninnerIn_ge8is9nye.setUiAttribs({title:\"RenderToWorld\"});\ninnerIn_ge8is9nye.onTriggered = () => { port_ge8is9nye.trigger(); };\n\nconst innerIn_cc3tea9q0 = addedOps[i].inTrigger(\"innerIn_cc3tea9q0\");\ninnerIn_cc3tea9q0.setUiAttribs({title:\"RenderToTexture_Building\"});\ninnerIn_cc3tea9q0.onTriggered = () => { port_cc3tea9q0.trigger(); };\n\nconst innerIn_wc7us54fg = addedOps[i].inTrigger(\"innerIn_wc7us54fg\");\ninnerIn_wc7us54fg.setUiAttribs({title:\"RenderToTexture_Line\"});\ninnerIn_wc7us54fg.onTriggered = () => { port_wc7us54fg.trigger(); };\n\nconst innerIn_740vm05xs = addedOps[i].inArray(\"innerIn_740vm05xs\");\ninnerIn_740vm05xs.setUiAttribs({title:\"IndicatorArray_Iconic\"});\ninnerIn_740vm05xs.on(\"change\", (a,v) => { port_740vm05xs.setRef(a); });\n\nconst innerIn_vh2f15cw8 = addedOps[i].inArray(\"innerIn_vh2f15cw8\");\ninnerIn_vh2f15cw8.setUiAttribs({title:\"IndicatorArray_Generic\"});\ninnerIn_vh2f15cw8.on(\"change\", (a,v) => { port_vh2f15cw8.setRef(a); });\n\nconst innerIn_3cpnu6igj = addedOps[i].inArray(\"innerIn_3cpnu6igj\");\ninnerIn_3cpnu6igj.setUiAttribs({title:\"ImageList\"});\ninnerIn_3cpnu6igj.on(\"change\", (a,v) => { port_3cpnu6igj.setRef(a); });\n\nconst innerIn_jycvtf89b = addedOps[i].inObject(\"innerIn_jycvtf89b\");\ninnerIn_jycvtf89b.setUiAttribs({title:\"BuildingTexture\"});\ninnerIn_jycvtf89b.on(\"change\", (a,v) => { port_jycvtf89b.setRef(a); });\n\nconst innerIn_el1t5zxr9 = addedOps[i].inObject(\"innerIn_el1t5zxr9\");\ninnerIn_el1t5zxr9.setUiAttribs({title:\"LineTexture\"});\ninnerIn_el1t5zxr9.on(\"change\", (a,v) => { port_el1t5zxr9.setRef(a); });\n\nconst innerIn_7lfhdhs5x = addedOps[i].inFloat(\"innerIn_7lfhdhs5x\");\ninnerIn_7lfhdhs5x.setUiAttribs({title:\"IsLoading\"});\ninnerIn_7lfhdhs5x.on(\"change\", (a,v) => { port_7lfhdhs5x.set(a); });\n\nconst innerIn_gr5rfgt62 = addedOps[i].inArray(\"innerIn_gr5rfgt62\");\ninnerIn_gr5rfgt62.setUiAttribs({title:\"CurrentAnimationPoint\"});\ninnerIn_gr5rfgt62.on(\"change\", (a,v) => { port_gr5rfgt62.setRef(a); });\n\n}\n}\n};\n","subpatch_json":"{\"ops\":[{\"id\":\"sp6-0\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsOut\":[{\"name\":\"innerOut_8kld546qj\",\"title\":\"Layer Index\",\"links\":[{\"portIn\":\"Number\",\"portOut\":\"innerOut_8kld546qj\",\"objIn\":\"sp6-120\",\"objOut\":\"sp6-0\"},{\"portIn\":\"index\",\"portOut\":\"innerOut_8kld546qj\",\"objIn\":\"sp6-191\",\"objOut\":\"sp6-0\"},{\"portIn\":\"Number\",\"portOut\":\"innerOut_8kld546qj\",\"objIn\":\"sp6-199\",\"objOut\":\"sp6-0\"}]},{\"name\":\"innerOut_d288224z4\",\"title\":\"API Data\"},{\"name\":\"innerOut_lfi6e6fmy\",\"title\":\"ImagePathList\"},{\"name\":\"innerOut_hho85lkjc\",\"title\":\"ImagePathList_SecondLayer\"},{\"name\":\"innerOut_xoahcr8lh\",\"value\":0,\"title\":\"ShowDebug\"},{\"name\":\"innerOut_xkk55pzq0\",\"value\":0,\"title\":\"LayerInterval\"},{\"name\":\"innerOut_00mtr84dk\",\"value\":0,\"title\":\"ImageIntervalX\"},{\"name\":\"innerOut_rxdonrolr\",\"value\":0,\"title\":\"ImageIntervalZ\"},{\"name\":\"innerOut_k39iw7qf1\",\"title\":\"IndicatorArray_Iconic\"},{\"name\":\"innerOut_v17tbxwpy\",\"title\":\"IndicatorArray_Generic\"},{\"name\":\"innerOut_dobslg7sf\",\"title\":\"Trigger\",\"links\":[{\"portIn\":\"exe\",\"portOut\":\"innerOut_dobslg7sf\",\"objIn\":\"sp6-135\",\"objOut\":\"sp6-0\"}]},{\"name\":\"innerOut_earjb46wu\",\"title\":\"GradientMap_ForBuilding\",\"links\":[{\"portIn\":\"Gradient\",\"portOut\":\"innerOut_earjb46wu\",\"objIn\":\"sp6-93\",\"objOut\":\"sp6-0\"}]},{\"name\":\"innerOut_1er6wsd99\",\"title\":\"GradientMap_ForMask\",\"links\":[{\"portIn\":\"texture\",\"portOut\":\"innerOut_1er6wsd99\",\"objIn\":\"sp6-147\",\"objOut\":\"sp6-0\"}]},{\"name\":\"innerOut_ga4abt9us\",\"title\":\"BoundsMask\"}],\"objName\":\"Ops.Ui.SubPatchInput\"},{\"id\":\"sp6-1\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"innerIn_740vm05xs\",\"value\":0,\"title\":\"IndicatorArray_Iconic\"},{\"name\":\"innerIn_vh2f15cw8\",\"value\":0,\"title\":\"IndicatorArray_Generic\"},{\"name\":\"innerIn_3cpnu6igj\",\"value\":0,\"title\":\"ImageList\"},{\"name\":\"innerIn_jycvtf89b\",\"title\":\"BuildingTexture\"},{\"name\":\"innerIn_el1t5zxr9\",\"title\":\"LineTexture\"},{\"name\":\"innerIn_7lfhdhs5x\",\"title\":\"IsLoading\"},{\"name\":\"innerIn_gr5rfgt62\",\"title\":\"CurrentAnimationPoint\"}],\"objName\":\"Ops.Ui.SubPatchOutput\"},{\"id\":\"sp6-2\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"Variable\",\"value\":\"BarCount\"}],\"portsOut\":[{\"name\":\"Value\",\"links\":[{\"portIn\":\"Bar Count\",\"portOut\":\"Value\",\"objIn\":\"sp6-175\",\"objOut\":\"sp6-2\"}]}],\"objName\":\"Ops.Vars.VarGetNumber_v2\"},{\"id\":\"sp6-3\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"Variable\",\"value\":\"Animation\"}],\"portsOut\":[{\"name\":\"Value\",\"value\":1}],\"objName\":\"Ops.Vars.VarGetNumber_v2\"},{\"id\":\"sp6-4\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"Variable\",\"value\":\"PointCount\"}],\"portsOut\":[{\"name\":\"Value\",\"links\":[{\"portIn\":\"Point Count\",\"portOut\":\"Value\",\"objIn\":\"sp6-175\",\"objOut\":\"sp6-4\"}]}],\"objName\":\"Ops.Vars.VarGetNumber_v2\"},{\"id\":\"sp6-5\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"Variable\",\"value\":\"TimelineArray\"}],\"portsOut\":[{\"name\":\"Value\",\"links\":[{\"portIn\":\"Timeline Array\",\"portOut\":\"Value\",\"objIn\":\"sp6-175\",\"objOut\":\"sp6-5\"}]}],\"objName\":\"Ops.Vars.VarGetArray_v2\"},{\"id\":\"sp6-6\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"Variable\",\"value\":\"LayerCount\"}],\"portsOut\":[{\"name\":\"Value\",\"value\":3}],\"objName\":\"Ops.Vars.VarGetNumber_v2\"},{\"id\":\"sp6-7\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"Tesselate Edges\",\"value\":1}],\"objName\":\"Ops.Gl.Meshes.SplineMesh_v2\"},{\"id\":\"sp6-8\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"Width Perspective\",\"value\":1},{\"name\":\"Mapping index\",\"value\":1},{\"name\":\"Mapping\",\"value\":\"Face\"},{\"name\":\"Colorize Texture\",\"value\":0},{\"name\":\"Offset\",\"value\":0},{\"name\":\"r\",\"value\":1},{\"name\":\"g\",\"value\":1},{\"name\":\"b\",\"value\":1},{\"name\":\"a\",\"value\":1}],\"portsOut\":[{\"name\":\"Trigger\",\"links\":[{\"portIn\":\"Render\",\"portOut\":\"Trigger\",\"objIn\":\"sp6-7\",\"objOut\":\"sp6-8\"}]}],\"objName\":\"Ops.Gl.Meshes.SplineMeshMaterial_v2\"},{\"id\":\"sp6-9\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"scale\",\"value\":1},{\"name\":\"rotX\",\"value\":0},{\"name\":\"rotY\",\"value\":0},{\"name\":\"rotZ\",\"value\":0}],\"portsOut\":[{\"name\":\"trigger\",\"links\":[{\"portIn\":\"Exec\",\"portOut\":\"trigger\",\"objIn\":\"sp6-174\",\"objOut\":\"sp6-9\"}]}],\"objName\":\"Ops.Graphics.Transform\"},{\"id\":\"sp6-10\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"r\",\"value\":0.9986805555224418},{\"name\":\"g\",\"value\":0.9986805555224418},{\"name\":\"b\",\"value\":0.9986805555224418},{\"name\":\"colorizeTexture\",\"value\":1},{\"name\":\"Vertex Colors\",\"value\":0},{\"name\":\"Alpha Mask Source index\",\"value\":4},{\"name\":\"Alpha Mask Source\",\"value\":\"A\"},{\"name\":\"Opacity TexCoords Transform\",\"value\":0},{\"name\":\"Discard Transparent Pixels\",\"value\":1},{\"name\":\"diffuseRepeatX\",\"value\":1},{\"name\":\"diffuseRepeatY\",\"value\":1},{\"name\":\"Tex Offset X\",\"value\":0},{\"name\":\"Tex Offset Y\",\"value\":0},{\"name\":\"Crop TexCoords\",\"value\":0},{\"name\":\"billboard\",\"value\":0}],\"portsOut\":[{\"name\":\"trigger\",\"links\":[{\"portIn\":\"render\",\"portOut\":\"trigger\",\"objIn\":\"sp6-12\",\"objOut\":\"sp6-10\"}]}],\"objName\":\"Ops.Gl.Shader.BasicMaterial_v3\"},{\"id\":\"sp6-11\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"scale\",\"value\":1},{\"name\":\"z\",\"value\":1}],\"portsOut\":[{\"name\":\"trigger\",\"links\":[{\"portIn\":\"render\",\"portOut\":\"trigger\",\"objIn\":\"sp6-31\",\"objOut\":\"sp6-11\"},{\"portIn\":\"render\",\"portOut\":\"trigger\",\"objIn\":\"sp6-10\",\"objOut\":\"sp6-11\"}]}],\"objName\":\"Ops.Gl.Matrix.Scale\"},{\"id\":\"sp6-12\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"render\",\"title\":\"Trigger\"},{\"name\":\"Render Mesh\",\"title\":\"Render\"},{\"name\":\"width\",\"value\":1},{\"name\":\"height\",\"value\":1},{\"name\":\"pivot x index\",\"value\":1},{\"name\":\"pivot x\",\"value\":\"center\"},{\"name\":\"pivot y index\",\"value\":1},{\"name\":\"pivot y\",\"value\":\"center\"},{\"name\":\"axis index\",\"value\":0},{\"name\":\"axis\",\"value\":\"xy\"},{\"name\":\"Flip TexCoord X\",\"value\":0},{\"name\":\"Flip TexCoord Y\",\"value\":1},{\"name\":\"num columns\",\"value\":1},{\"name\":\"num rows\",\"value\":1}],\"objName\":\"Ops.Graphics.Meshes.Rectangle_v4\"},{\"id\":\"sp6-13\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsOut\":[{\"name\":\"X\",\"value\":0.15307692307692308},{\"name\":\"Y\",\"links\":[{\"portIn\":\"y\",\"portOut\":\"Y\",\"objIn\":\"sp6-11\",\"objOut\":\"sp6-13\"},{\"portIn\":\"number1\",\"portOut\":\"Y\",\"objIn\":\"sp6-20\",\"objOut\":\"sp6-13\"}]},{\"name\":\"Z\",\"value\":0}],\"objName\":\"Ops.Array.Array3GetNumbers\"},{\"id\":\"sp6-14\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsOut\":[{\"name\":\"Array3x\",\"links\":[{\"portIn\":\"Array\",\"portOut\":\"Array3x\",\"objIn\":\"sp6-13\",\"objOut\":\"sp6-14\"}]},{\"name\":\"Total points\",\"value\":13},{\"name\":\"Array length\",\"value\":39}],\"objName\":\"Ops.Array.Array2To3\"},{\"id\":\"sp6-15\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsOut\":[{\"name\":\"value\",\"links\":[{\"portIn\":\"texture\",\"portOut\":\"value\",\"objIn\":\"sp6-10\",\"objOut\":\"sp6-15\"},{\"portIn\":\"textureOpacity\",\"portOut\":\"value\",\"objIn\":\"sp6-10\",\"objOut\":\"sp6-15\"}]}],\"objName\":\"Ops.Array.ArrayGetTexture\"},{\"id\":\"sp6-16\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"urls\",\"value\":0},{\"name\":\"filter index\",\"value\":1},{\"name\":\"filter\",\"value\":\"linear\"},{\"name\":\"wrap index\",\"value\":0},{\"name\":\"wrap\",\"value\":\"repeat\"},{\"name\":\"Flip\",\"value\":0},{\"name\":\"unpackPreMultipliedAlpha\",\"value\":0},{\"name\":\"Caching\",\"value\":1},{\"name\":\"Asset in patch\",\"value\":0}],\"portsOut\":[{\"name\":\"width\",\"value\":128},{\"name\":\"height\",\"value\":750},{\"name\":\"loading\",\"value\":0},{\"name\":\"Aspect Ratio\",\"value\":0.17066666666666666}],\"objName\":\"Ops.Gl.TextureArrayLoaderFromArray_v2\"},{\"id\":\"sp6-17\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsOut\":[{\"name\":\"Widths\",\"links\":[{\"portIn\":\"array\",\"portOut\":\"Widths\",\"objIn\":\"sp6-18\",\"objOut\":\"sp6-17\"}]},{\"name\":\"Heights\",\"links\":[{\"portIn\":\"array\",\"portOut\":\"Heights\",\"objIn\":\"sp6-21\",\"objOut\":\"sp6-17\"}]}],\"objName\":\"Ops.Gl.Textures.TextureArrayInfo\"},{\"id\":\"sp6-18\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"Value Invalid Index\",\"value\":0}],\"portsOut\":[{\"name\":\"value\",\"links\":[{\"portIn\":\"number1\",\"portOut\":\"value\",\"objIn\":\"sp6-19\",\"objOut\":\"sp6-18\"}]},{\"name\":\"Valid Index\",\"value\":1}],\"objName\":\"Ops.Array.ArrayGetNumber\"},{\"id\":\"sp6-19\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsOut\":[{\"name\":\"result\",\"links\":[{\"portIn\":\"number1\",\"portOut\":\"result\",\"objIn\":\"sp6-23\",\"objOut\":\"sp6-19\"}]}],\"objName\":\"Ops.Math.Divide\"},{\"id\":\"sp6-20\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsOut\":[{\"name\":\"result\",\"links\":[{\"portIn\":\"x\",\"portOut\":\"result\",\"objIn\":\"sp6-11\",\"objOut\":\"sp6-20\"}]}],\"objName\":\"Ops.Math.Multiply\"},{\"id\":\"sp6-21\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"Value Invalid Index\",\"value\":0}],\"portsOut\":[{\"name\":\"value\",\"links\":[{\"portIn\":\"number2\",\"portOut\":\"value\",\"objIn\":\"sp6-19\",\"objOut\":\"sp6-21\"}]},{\"name\":\"Valid Index\",\"value\":1}],\"objName\":\"Ops.Array.ArrayGetNumber\"},{\"id\":\"sp6-22\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsOut\":[{\"name\":\"CSS Width\",\"value\":875},{\"name\":\"CSS Height\",\"value\":846},{\"name\":\"Pixel Ratio\",\"value\":1.5},{\"name\":\"Pixel Width\",\"value\":1312.5},{\"name\":\"Pixel Height\",\"value\":1269},{\"name\":\"Aspect Ratio\",\"links\":[{\"portIn\":\"number2\",\"portOut\":\"Aspect Ratio\",\"objIn\":\"sp6-23\",\"objOut\":\"sp6-22\"}]},{\"name\":\"Landscape\",\"value\":1}],\"objName\":\"Ops.Gl.CanvasInfo_v3\"},{\"id\":\"sp6-23\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsOut\":[{\"name\":\"result\",\"links\":[{\"portIn\":\"number2\",\"portOut\":\"result\",\"objIn\":\"sp6-20\",\"objOut\":\"sp6-23\"}]}],\"objName\":\"Ops.Math.Divide\"},{\"id\":\"sp6-24\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"Title\",\"value\":\"Draw Line\"}],\"objName\":\"Ops.Ui.Area\"},{\"id\":\"sp6-25\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"Title\",\"value\":\"Draw Buildings\"}],\"objName\":\"Ops.Ui.Area\"},{\"id\":\"sp6-26\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"Direction index\",\"value\":0},{\"name\":\"Direction\",\"value\":\"Forward\"}],\"portsOut\":[{\"name\":\"Next\",\"links\":[{\"portIn\":\"Execute\",\"portOut\":\"Next\",\"objIn\":\"sp6-39\",\"objOut\":\"sp6-26\"}]},{\"name\":\"index\",\"links\":[{\"portIn\":\"value\",\"portOut\":\"index\",\"objIn\":\"sp6-29\",\"objOut\":\"sp6-26\"},{\"portIn\":\"x4u8fkg49\",\"portOut\":\"index\",\"objIn\":\"sp6-59\",\"objOut\":\"sp6-26\"}]}],\"objName\":\"Ops.Trigger.Repeat_v2\"},{\"id\":\"sp6-27\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsOut\":[{\"name\":\"Array 1 out\",\"links\":[{\"portIn\":\"array\",\"portOut\":\"Array 1 out\",\"objIn\":\"sp6-28\",\"objOut\":\"sp6-27\"}]},{\"name\":\"Array 2 out\",\"links\":[{\"portIn\":\"array\",\"portOut\":\"Array 2 out\",\"objIn\":\"sp6-30\",\"objOut\":\"sp6-27\"}]},{\"name\":\"Array 3 out\",\"links\":[{\"portIn\":\"array\",\"portOut\":\"Array 3 out\",\"objIn\":\"sp6-122\",\"objOut\":\"sp6-27\"}]},{\"name\":\"Array lengths\",\"links\":[{\"portIn\":\"Repeats\",\"portOut\":\"Array lengths\",\"objIn\":\"sp6-26\",\"objOut\":\"sp6-27\"}]}],\"objName\":\"Ops.Array.ArrayUnpack3\"},{\"id\":\"sp6-28\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"Value Invalid Index\",\"value\":0}],\"portsOut\":[{\"name\":\"value\",\"links\":[{\"portIn\":\"number1\",\"portOut\":\"value\",\"objIn\":\"sp6-207\",\"objOut\":\"sp6-28\"}]},{\"name\":\"Valid Index\",\"value\":1}],\"objName\":\"Ops.Array.ArrayGetNumber\"},{\"id\":\"sp6-29\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsOut\":[{\"name\":\"result\",\"links\":[{\"portIn\":\"index\",\"portOut\":\"result\",\"objIn\":\"sp6-18\",\"objOut\":\"sp6-29\"},{\"portIn\":\"index\",\"portOut\":\"result\",\"objIn\":\"sp6-21\",\"objOut\":\"sp6-29\"},{\"portIn\":\"index\",\"portOut\":\"result\",\"objIn\":\"sp6-15\",\"objOut\":\"sp6-29\"},{\"portIn\":\"Index\",\"portOut\":\"result\",\"objIn\":\"sp6-13\",\"objOut\":\"sp6-29\"},{\"portIn\":\"index\",\"portOut\":\"result\",\"objIn\":\"sp6-28\",\"objOut\":\"sp6-29\"},{\"portIn\":\"index\",\"portOut\":\"result\",\"objIn\":\"sp6-30\",\"objOut\":\"sp6-29\"},{\"portIn\":\"index\",\"portOut\":\"result\",\"objIn\":\"sp6-115\",\"objOut\":\"sp6-29\"},{\"portIn\":\"index\",\"portOut\":\"result\",\"objIn\":\"sp6-122\",\"objOut\":\"sp6-29\"}]}],\"objName\":\"Ops.Number.Number\"},{\"id\":\"sp6-30\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"Value Invalid Index\",\"value\":0}],\"portsOut\":[{\"name\":\"value\",\"links\":[{\"portIn\":\"posY\",\"portOut\":\"value\",\"objIn\":\"sp6-9\",\"objOut\":\"sp6-30\"}]},{\"name\":\"Valid Index\",\"value\":1}],\"objName\":\"Ops.Array.ArrayGetNumber\"},{\"id\":\"sp6-31\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"enable depth testing\",\"value\":0},{\"name\":\"width\",\"value\":2.55},{\"name\":\"AntiAlias\",\"value\":1},{\"name\":\"diffuse r\",\"value\":0.7320138804117838},{\"name\":\"diffuse g\",\"value\":0.42814228949684185},{\"name\":\"diffuse b\",\"value\":0.010663259046635478},{\"name\":\"diffuse A\",\"value\":1},{\"name\":\"fill\",\"value\":0},{\"name\":\"Fill R\",\"value\":0.9555550130208333},{\"name\":\"Fill G\",\"value\":0.3647874429932563},{\"name\":\"Fill B\",\"value\":0.3647874429932563},{\"name\":\"Fill A\",\"value\":1}],\"portsOut\":[{\"name\":\"trigger\",\"links\":[{\"portIn\":\"render\",\"portOut\":\"trigger\",\"objIn\":\"sp6-32\",\"objOut\":\"sp6-31\"}]}],\"objName\":\"Ops.Gl.Shader.WireframeMaterial_v2\"},{\"id\":\"sp6-32\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"render\",\"title\":\"Trigger\"},{\"name\":\"Render Mesh\",\"title\":\"Render\"},{\"name\":\"width\",\"value\":1},{\"name\":\"height\",\"value\":1},{\"name\":\"pivot x index\",\"value\":1},{\"name\":\"pivot x\",\"value\":\"center\"},{\"name\":\"pivot y index\",\"value\":1},{\"name\":\"pivot y\",\"value\":\"center\"},{\"name\":\"axis index\",\"value\":0},{\"name\":\"axis\",\"value\":\"xy\"},{\"name\":\"Flip TexCoord X\",\"value\":0},{\"name\":\"Flip TexCoord Y\",\"value\":1},{\"name\":\"num columns\",\"value\":1},{\"name\":\"num rows\",\"value\":1}],\"objName\":\"Ops.Graphics.Meshes.Rectangle_v4\"},{\"id\":\"sp6-33\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"Add Vertex Numbers\",\"value\":1}],\"objName\":\"Ops.Gl.RenderGeometry_v2\"},{\"id\":\"sp6-34\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"a\",\"value\":1},{\"name\":\"colorizeTexture\",\"value\":1},{\"name\":\"Vertex Colors\",\"value\":0},{\"name\":\"Alpha Mask Source index\",\"value\":0},{\"name\":\"Alpha Mask Source\",\"value\":\"Luminance\"},{\"name\":\"Opacity TexCoords Transform\",\"value\":0},{\"name\":\"Discard Transparent Pixels\",\"value\":0},{\"name\":\"diffuseRepeatX\",\"value\":1},{\"name\":\"diffuseRepeatY\",\"value\":1},{\"name\":\"Tex Offset X\",\"value\":0},{\"name\":\"Tex Offset Y\",\"value\":0},{\"name\":\"Crop TexCoords\",\"value\":0},{\"name\":\"billboard\",\"value\":0}],\"portsOut\":[{\"name\":\"trigger\",\"links\":[{\"portIn\":\"render\",\"portOut\":\"trigger\",\"objIn\":\"sp6-33\",\"objOut\":\"sp6-34\"}]}],\"objName\":\"Ops.Gl.Shader.BasicMaterial_v3\"},{\"id\":\"sp6-35\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"Gradient\",\"value\":\"{\\\"keys\\\":[{\\\"pos\\\":0,\\\"posy\\\":0.5,\\\"r\\\":0.9176470588235294,\\\"g\\\":0.792156862745098,\\\"b\\\":0.5333333333333332},{\\\"pos\\\":0,\\\"posy\\\":0.5,\\\"r\\\":0.9176470588235294,\\\"g\\\":0.792156862745098,\\\"b\\\":0.5333333333333332},{\\\"pos\\\":1,\\\"posy\\\":0.53,\\\"r\\\":0.9176470588235294,\\\"g\\\":0.792156862745098,\\\"b\\\":0.5294117647058824},{\\\"pos\\\":1,\\\"posy\\\":0.53,\\\"r\\\":0.9176470588235294,\\\"g\\\":0.792156862745098,\\\"b\\\":0.5294117647058824}]}\"},{\"name\":\"Direction index\",\"value\":2},{\"name\":\"Direction\",\"value\":\"Y\"},{\"name\":\"Smoothstep\",\"value\":1},{\"name\":\"Step\",\"value\":0},{\"name\":\"Flip\",\"value\":0},{\"name\":\"sRGB\",\"value\":0},{\"name\":\"Oklab\",\"value\":0},{\"name\":\"Size\",\"value\":256},{\"name\":\"filter index\",\"value\":1},{\"name\":\"filter\",\"value\":\"linear\"},{\"name\":\"wrap index\",\"value\":0},{\"name\":\"wrap\",\"value\":\"clamp to edge\"},{\"name\":\"Dither\",\"value\":0},{\"name\":\"Gradient Array\",\"value\":0}],\"objName\":\"Ops.Gl.GradientTexture\"},{\"id\":\"sp6-36\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsOut\":[{\"name\":\"Result Array\",\"links\":[{\"portIn\":\"API Data\",\"portOut\":\"Result Array\",\"objIn\":\"sp6-175\",\"objOut\":\"sp6-36\"}]}],\"objName\":\"Ops.Array.ArrayGetArray\"},{\"id\":\"sp6-37\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"Array 1\",\"value\":0},{\"name\":\"Array 2\",\"value\":0},{\"name\":\"Array 3\",\"value\":0},{\"name\":\"Array 4\",\"value\":0},{\"name\":\"Array 5\",\"value\":0},{\"name\":\"Array 6\",\"value\":0},{\"name\":\"Array 7\",\"value\":0}],\"portsOut\":[{\"name\":\"Result\",\"links\":[{\"portIn\":\"Array in xyz\",\"portOut\":\"Result\",\"objIn\":\"sp6-27\",\"objOut\":\"sp6-37\"},{\"portIn\":\"Array in xyz\",\"portOut\":\"Result\",\"objIn\":\"sp6-46\",\"objOut\":\"sp6-37\"}]},{\"name\":\"Array length\",\"value\":39}],\"objName\":\"Ops.Array.ArrayMerge_v3\"},{\"id\":\"sp6-38\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"Array 1\",\"value\":0},{\"name\":\"Array 2\",\"value\":0},{\"name\":\"Array 3\",\"value\":0},{\"name\":\"Array 4\",\"value\":0},{\"name\":\"Array 5\",\"value\":0},{\"name\":\"Array 6\",\"value\":0},{\"name\":\"Array 7\",\"value\":0}],\"portsOut\":[{\"name\":\"Result\",\"links\":[{\"portIn\":\"Array2x\",\"portOut\":\"Result\",\"objIn\":\"sp6-14\",\"objOut\":\"sp6-38\"},{\"portIn\":\"Array in xyz\",\"portOut\":\"Result\",\"objIn\":\"sp6-48\",\"objOut\":\"sp6-38\"}]},{\"name\":\"Array length\",\"value\":26}],\"objName\":\"Ops.Array.ArrayMerge_v3\"},{\"id\":\"sp6-39\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsOut\":[{\"name\":\"Trigger out\",\"links\":[{\"portIn\":\"render\",\"portOut\":\"Trigger out\",\"objIn\":\"sp6-9\",\"objOut\":\"sp6-39\"}]}],\"objName\":\"Ops.Trigger.GateTrigger\"},{\"id\":\"sp6-40\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsOut\":[{\"name\":\"Next\",\"links\":[{\"portIn\":\"Execute\",\"portOut\":\"Next\",\"objIn\":\"sp6-26\",\"objOut\":\"sp6-40\"}]}],\"objName\":\"Ops.Trigger.TriggerExtender\"},{\"id\":\"sp6-41\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"Title\",\"value\":\"Draw Mesh and Solid Line in World\"}],\"objName\":\"Ops.Ui.Area\"},{\"id\":\"sp6-42\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"Variable\",\"value\":\"APIDataList\"}],\"portsOut\":[{\"name\":\"Value\",\"links\":[{\"portIn\":\"Array of Arrays\",\"portOut\":\"Value\",\"objIn\":\"sp6-36\",\"objOut\":\"sp6-42\"}]}],\"objName\":\"Ops.Vars.VarGetArray_v2\"},{\"id\":\"sp6-43\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"posZ\",\"value\":0},{\"name\":\"scale\",\"value\":1},{\"name\":\"rotX\",\"value\":0},{\"name\":\"rotY\",\"value\":0},{\"name\":\"rotZ\",\"value\":0}],\"portsOut\":[{\"name\":\"trigger\",\"links\":[{\"portIn\":\"render\",\"portOut\":\"trigger\",\"objIn\":\"sp6-45\",\"objOut\":\"sp6-43\"},{\"portIn\":\"render\",\"portOut\":\"trigger\",\"objIn\":\"sp6-57\",\"objOut\":\"sp6-43\"}]}],\"objName\":\"Ops.Graphics.Transform\"},{\"id\":\"sp6-44\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"radius\",\"value\":0.02},{\"name\":\"innerRadius\",\"value\":0.644},{\"name\":\"segments\",\"value\":40},{\"name\":\"percent\",\"value\":1},{\"name\":\"steps\",\"value\":0},{\"name\":\"invertSteps\",\"value\":0},{\"name\":\"mapping index\",\"value\":0},{\"name\":\"mapping\",\"value\":\"flat\"},{\"name\":\"Spline\",\"value\":0},{\"name\":\"Draw\",\"title\":\"Render mesh\"}],\"objName\":\"Ops.Graphics.Meshes.Circle_v3\"},{\"id\":\"sp6-45\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"r\",\"value\":0.8117647058823529},{\"name\":\"g\",\"value\":0.027450980392156894},{\"name\":\"b\",\"value\":0.027450980392156894},{\"name\":\"a\",\"value\":1},{\"name\":\"colorizeTexture\",\"value\":0},{\"name\":\"Vertex Colors\",\"value\":0},{\"name\":\"Alpha Mask Source index\",\"value\":0},{\"name\":\"Alpha Mask Source\",\"value\":\"Luminance\"},{\"name\":\"Opacity TexCoords Transform\",\"value\":0},{\"name\":\"Discard Transparent Pixels\",\"value\":0},{\"name\":\"diffuseRepeatX\",\"value\":1},{\"name\":\"diffuseRepeatY\",\"value\":1},{\"name\":\"Tex Offset X\",\"value\":0},{\"name\":\"Tex Offset Y\",\"value\":0},{\"name\":\"Crop TexCoords\",\"value\":0},{\"name\":\"billboard\",\"value\":0}],\"portsOut\":[{\"name\":\"trigger\",\"links\":[{\"portIn\":\"Trigger in 0\",\"portOut\":\"trigger\",\"objIn\":\"sp6-56\",\"objOut\":\"sp6-45\"}]}],\"objName\":\"Ops.Gl.Shader.BasicMaterial_v3\"},{\"id\":\"sp6-46\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsOut\":[{\"name\":\"Array 1 out\",\"links\":[{\"portIn\":\"array\",\"portOut\":\"Array 1 out\",\"objIn\":\"sp6-52\",\"objOut\":\"sp6-46\"}]},{\"name\":\"Array 2 out\",\"links\":[{\"portIn\":\"array\",\"portOut\":\"Array 2 out\",\"objIn\":\"sp6-47\",\"objOut\":\"sp6-46\"}]},{\"name\":\"Array lengths\",\"links\":[{\"portIn\":\"Repeats\",\"portOut\":\"Array lengths\",\"objIn\":\"sp6-54\",\"objOut\":\"sp6-46\"}]}],\"objName\":\"Ops.Array.ArrayUnpack3\"},{\"id\":\"sp6-47\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"Value Invalid Index\",\"value\":0}],\"portsOut\":[{\"name\":\"value\",\"links\":[{\"portIn\":\"number1\",\"portOut\":\"value\",\"objIn\":\"sp6-50\",\"objOut\":\"sp6-47\"}]},{\"name\":\"Valid Index\",\"value\":1}],\"objName\":\"Ops.Array.ArrayGetNumber\"},{\"id\":\"sp6-48\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsOut\":[{\"name\":\"Array 2 out\",\"links\":[{\"portIn\":\"array\",\"portOut\":\"Array 2 out\",\"objIn\":\"sp6-49\",\"objOut\":\"sp6-48\"}]},{\"name\":\"Array lengths\",\"value\":13}],\"objName\":\"Ops.Array.ArrayUnpack2\"},{\"id\":\"sp6-49\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"Value Invalid Index\",\"value\":0}],\"portsOut\":[{\"name\":\"value\",\"links\":[{\"portIn\":\"number1\",\"portOut\":\"value\",\"objIn\":\"sp6-51\",\"objOut\":\"sp6-49\"}]},{\"name\":\"Valid Index\",\"value\":1}],\"objName\":\"Ops.Array.ArrayGetNumber\"},{\"id\":\"sp6-50\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsOut\":[{\"name\":\"result\",\"links\":[{\"portIn\":\"posY\",\"portOut\":\"result\",\"objIn\":\"sp6-43\",\"objOut\":\"sp6-50\"}]}],\"objName\":\"Ops.Math.Sum\"},{\"id\":\"sp6-51\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"number2\",\"value\":2}],\"portsOut\":[{\"name\":\"result\",\"links\":[{\"portIn\":\"number2\",\"portOut\":\"result\",\"objIn\":\"sp6-50\",\"objOut\":\"sp6-51\"}]}],\"objName\":\"Ops.Math.Divide\"},{\"id\":\"sp6-52\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"Value Invalid Index\",\"value\":0}],\"portsOut\":[{\"name\":\"value\",\"links\":[{\"portIn\":\"posX\",\"portOut\":\"value\",\"objIn\":\"sp6-43\",\"objOut\":\"sp6-52\"}]},{\"name\":\"Valid Index\",\"value\":1}],\"objName\":\"Ops.Array.ArrayGetNumber\"},{\"id\":\"sp6-53\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"Title\",\"value\":\"Debug\"}],\"objName\":\"Ops.Ui.Area\"},{\"id\":\"sp6-54\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"Direction index\",\"value\":0},{\"name\":\"Direction\",\"value\":\"Forward\"}],\"portsOut\":[{\"name\":\"Next\",\"links\":[{\"portIn\":\"Execute\",\"portOut\":\"Next\",\"objIn\":\"sp6-62\",\"objOut\":\"sp6-54\"}]},{\"name\":\"index\",\"links\":[{\"portIn\":\"index\",\"portOut\":\"index\",\"objIn\":\"sp6-52\",\"objOut\":\"sp6-54\"},{\"portIn\":\"index\",\"portOut\":\"index\",\"objIn\":\"sp6-47\",\"objOut\":\"sp6-54\"},{\"portIn\":\"index\",\"portOut\":\"index\",\"objIn\":\"sp6-49\",\"objOut\":\"sp6-54\"},{\"portIn\":\"number1\",\"portOut\":\"index\",\"objIn\":\"sp6-55\",\"objOut\":\"sp6-54\"},{\"portIn\":\"x4u8fkg49\",\"portOut\":\"index\",\"objIn\":\"sp6-63\",\"objOut\":\"sp6-54\"}]}],\"objName\":\"Ops.Trigger.Repeat_v2\"},{\"id\":\"sp6-55\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsOut\":[{\"name\":\"result\",\"links\":[{\"portIn\":\"Trigger Index\",\"portOut\":\"result\",\"objIn\":\"sp6-56\",\"objOut\":\"sp6-55\"}]}],\"objName\":\"Ops.Math.Compare.GreaterOrEquals\"},{\"id\":\"sp6-56\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsOut\":[{\"name\":\"Trigger out\",\"links\":[{\"portIn\":\"render\",\"portOut\":\"Trigger out\",\"objIn\":\"sp6-44\",\"objOut\":\"sp6-56\"}]}],\"objName\":\"Ops.Trigger.SwitchTrigger\"},{\"id\":\"sp6-57\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"r\",\"value\":0},{\"name\":\"g\",\"value\":0.413828125},{\"name\":\"b\",\"value\":0.0009699096679687868},{\"name\":\"a\",\"value\":1},{\"name\":\"colorizeTexture\",\"value\":0},{\"name\":\"Vertex Colors\",\"value\":0},{\"name\":\"Alpha Mask Source index\",\"value\":0},{\"name\":\"Alpha Mask Source\",\"value\":\"Luminance\"},{\"name\":\"Opacity TexCoords Transform\",\"value\":0},{\"name\":\"Discard Transparent Pixels\",\"value\":0},{\"name\":\"diffuseRepeatX\",\"value\":1},{\"name\":\"diffuseRepeatY\",\"value\":1},{\"name\":\"Tex Offset X\",\"value\":0},{\"name\":\"Tex Offset Y\",\"value\":0},{\"name\":\"Crop TexCoords\",\"value\":0},{\"name\":\"billboard\",\"value\":0}],\"portsOut\":[{\"name\":\"trigger\",\"links\":[{\"portIn\":\"Trigger in 1\",\"portOut\":\"trigger\",\"objIn\":\"sp6-56\",\"objOut\":\"sp6-57\"}]}],\"objName\":\"Ops.Gl.Shader.BasicMaterial_v3\"},{\"id\":\"sp6-58\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsOut\":[{\"name\":\"Next\",\"links\":[{\"portIn\":\"render\",\"portOut\":\"Next\",\"objIn\":\"sp6-193\",\"objOut\":\"sp6-58\"}]}],\"objName\":\"Ops.Trigger.TriggerExtender\"},{\"id\":\"sp6-59\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2,\"subPatchVer\":2},\"portsIn\":[{\"name\":\"x4u8fkg49\",\"title\":\"ImageIndex\"},{\"name\":\"patchId\",\"value\":\"yhihm23rf\"}],\"portsOut\":[{\"name\":\"5i5pamobs\",\"title\":\"Visible\",\"links\":[{\"portIn\":\"bool 1\",\"portOut\":\"5i5pamobs\",\"objIn\":\"sp6-113\",\"objOut\":\"sp6-59\"}]}],\"objName\":\"Ops.Patch.PLH3vXR.IsImageVisible1\"},{\"id\":\"sp6-60\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"Variable\",\"value\":\"BarCount\"}],\"portsOut\":[{\"name\":\"Value\",\"links\":[{\"portIn\":\"number2\",\"portOut\":\"Value\",\"objIn\":\"sp6-55\",\"objOut\":\"sp6-60\"}]}],\"objName\":\"Ops.Vars.VarGetNumber_v2\"},{\"id\":\"sp6-61\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"Named Trigger\",\"value\":\"ShowDebug\"}],\"portsOut\":[{\"name\":\"Triggered\",\"links\":[{\"portIn\":\"Execute\",\"portOut\":\"Triggered\",\"objIn\":\"sp6-58\",\"objOut\":\"sp6-61\"}]}],\"objName\":\"Ops.Trigger.TriggerReceive\"},{\"id\":\"sp6-62\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsOut\":[{\"name\":\"Trigger out\",\"links\":[{\"portIn\":\"render\",\"portOut\":\"Trigger out\",\"objIn\":\"sp6-43\",\"objOut\":\"sp6-62\"}]}],\"objName\":\"Ops.Trigger.GateTrigger\"},{\"id\":\"sp6-63\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2,\"subPatchVer\":2},\"portsIn\":[{\"name\":\"x4u8fkg49\",\"title\":\"ImageIndex\"},{\"name\":\"patchId\",\"value\":\"f86ftyowa\"}],\"portsOut\":[{\"name\":\"5i5pamobs\",\"title\":\"Visible\",\"links\":[{\"portIn\":\"Pass Through\",\"portOut\":\"5i5pamobs\",\"objIn\":\"sp6-62\",\"objOut\":\"sp6-63\"}]}],\"objName\":\"Ops.Patch.PLH3vXR.IsImageVisible1\"},{\"id\":\"sp6-64\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsOut\":[{\"name\":\"result\",\"links\":[{\"portIn\":\"Render Mesh\",\"portOut\":\"result\",\"objIn\":\"sp6-32\",\"objOut\":\"sp6-64\"}]}],\"objName\":\"Ops.Boolean.And\"},{\"id\":\"sp6-65\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"Title\",\"value\":\"Generate Points and Bars\"}],\"objName\":\"Ops.Ui.Area\"},{\"id\":\"sp6-66\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"Title\",\"value\":\"PickImages\"}],\"objName\":\"Ops.Ui.Area\"},{\"id\":\"sp6-67\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsOut\":[{\"name\":\"result\",\"links\":[{\"portIn\":\"Draw\",\"portOut\":\"result\",\"objIn\":\"sp6-44\",\"objOut\":\"sp6-67\"}]}],\"objName\":\"Ops.Boolean.And\"},{\"id\":\"sp6-68\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"Variable\",\"value\":\"Debug_ShowHighestPoints\"}],\"portsOut\":[{\"name\":\"Value\",\"links\":[{\"portIn\":\"bool 2\",\"portOut\":\"Value\",\"objIn\":\"sp6-67\",\"objOut\":\"sp6-68\"}]}],\"objName\":\"Ops.Vars.VarGetNumber_v2\"},{\"id\":\"sp6-69\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"Variable\",\"value\":\"Debug_ShowImageBounds\"}],\"portsOut\":[{\"name\":\"Value\",\"links\":[{\"portIn\":\"bool 2\",\"portOut\":\"Value\",\"objIn\":\"sp6-64\",\"objOut\":\"sp6-69\"}]}],\"objName\":\"Ops.Vars.VarGetNumber_v2\"},{\"id\":\"sp6-70\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"objName\":\"Ops.Json.SwitchObject\"},{\"id\":\"sp6-71\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"Gradient\",\"value\":\"{\\\"keys\\\":[{\\\"pos\\\":0,\\\"posy\\\":0.5,\\\"r\\\":0.8274509803921568,\\\"g\\\":0.5764705882352941,\\\"b\\\":0.21960784313725487},{\\\"pos\\\":0,\\\"posy\\\":0.5,\\\"r\\\":0.8274509803921568,\\\"g\\\":0.5764705882352941,\\\"b\\\":0.21960784313725487},{\\\"pos\\\":1,\\\"posy\\\":0.53,\\\"r\\\":0.6980392156862745,\\\"g\\\":0.26956127450980394,\\\"b\\\":0.25098039215686274},{\\\"pos\\\":1,\\\"posy\\\":0.53,\\\"r\\\":0.6980392156862745,\\\"g\\\":0.26956127450980394,\\\"b\\\":0.25098039215686274}]}\"},{\"name\":\"Direction index\",\"value\":2},{\"name\":\"Direction\",\"value\":\"Y\"},{\"name\":\"Smoothstep\",\"value\":1},{\"name\":\"Step\",\"value\":0},{\"name\":\"Flip\",\"value\":0},{\"name\":\"sRGB\",\"value\":0},{\"name\":\"Oklab\",\"value\":0},{\"name\":\"Size\",\"value\":256},{\"name\":\"filter index\",\"value\":1},{\"name\":\"filter\",\"value\":\"linear\"},{\"name\":\"wrap index\",\"value\":0},{\"name\":\"wrap\",\"value\":\"clamp to edge\"},{\"name\":\"Dither\",\"value\":0},{\"name\":\"Gradient Array\",\"value\":0}],\"objName\":\"Ops.Gl.GradientTexture\"},{\"id\":\"sp6-72\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"Gradient\",\"value\":\"{\\\"keys\\\":[{\\\"pos\\\":0,\\\"posy\\\":0.5,\\\"r\\\":0.8274509803921568,\\\"g\\\":0.5764705882352941,\\\"b\\\":0.21960784313725487},{\\\"pos\\\":0,\\\"posy\\\":0.5,\\\"r\\\":0.8274509803921568,\\\"g\\\":0.5764705882352941,\\\"b\\\":0.21960784313725487},{\\\"pos\\\":1,\\\"posy\\\":0.53,\\\"r\\\":0.6980392156862745,\\\"g\\\":0.26956127450980394,\\\"b\\\":0.25098039215686274},{\\\"pos\\\":1,\\\"posy\\\":0.53,\\\"r\\\":0.6980392156862745,\\\"g\\\":0.26956127450980394,\\\"b\\\":0.25098039215686274}]}\"},{\"name\":\"Direction index\",\"value\":2},{\"name\":\"Direction\",\"value\":\"Y\"},{\"name\":\"Smoothstep\",\"value\":1},{\"name\":\"Step\",\"value\":0},{\"name\":\"Flip\",\"value\":0},{\"name\":\"sRGB\",\"value\":0},{\"name\":\"Oklab\",\"value\":0},{\"name\":\"Size\",\"value\":256},{\"name\":\"filter index\",\"value\":1},{\"name\":\"filter\",\"value\":\"linear\"},{\"name\":\"wrap index\",\"value\":0},{\"name\":\"wrap\",\"value\":\"clamp to edge\"},{\"name\":\"Dither\",\"value\":0},{\"name\":\"Gradient Array\",\"value\":0}],\"objName\":\"Ops.Gl.GradientTexture\"},{\"id\":\"sp6-73\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"File\",\"value\":\"assets/gradient_3.png\",\"display\":\"file\"},{\"name\":\"Filter index\",\"value\":2},{\"name\":\"Filter\",\"value\":\"mipmap\"},{\"name\":\"Wrap index\",\"value\":0},{\"name\":\"Wrap\",\"value\":\"repeat\"},{\"name\":\"Anisotropic index\",\"value\":0},{\"name\":\"Anisotropic\",\"value\":\"0\"},{\"name\":\"Data Format index\",\"value\":3},{\"name\":\"Data Format\",\"value\":\"RGBA\"},{\"name\":\"Flip\",\"value\":1},{\"name\":\"Pre Multiplied Alpha\",\"value\":0},{\"name\":\"Active\",\"value\":1},{\"name\":\"Save Memory\",\"value\":1},{\"name\":\"Add Cachebuster\",\"value\":0}],\"portsOut\":[{\"name\":\"Texture\",\"links\":[{\"portIn\":\"texture\",\"portOut\":\"Texture\",\"objIn\":\"sp6-34\",\"objOut\":\"sp6-73\"}]},{\"name\":\"Width\",\"value\":256},{\"name\":\"Height\",\"value\":256},{\"name\":\"Aspect Ratio\",\"value\":1},{\"name\":\"Loaded\",\"value\":1},{\"name\":\"Loading\",\"value\":0}],\"objName\":\"Ops.Gl.Texture_v2\"},{\"id\":\"sp6-74\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"Tesselate Edges\",\"value\":1}],\"objName\":\"Ops.Gl.Meshes.SplineMesh_v2\"},{\"id\":\"sp6-75\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"Width Perspective\",\"value\":1},{\"name\":\"Mapping index\",\"value\":1},{\"name\":\"Mapping\",\"value\":\"Face\"},{\"name\":\"Colorize Texture\",\"value\":0},{\"name\":\"Offset\",\"value\":0},{\"name\":\"a\",\"value\":1}],\"portsOut\":[{\"name\":\"Trigger\",\"links\":[{\"portIn\":\"Render\",\"portOut\":\"Trigger\",\"objIn\":\"sp6-74\",\"objOut\":\"sp6-75\"}]}],\"objName\":\"Ops.Gl.Meshes.SplineMeshMaterial_v2\"},{\"id\":\"sp6-76\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"r\",\"value\":0.6588235294117647},{\"name\":\"g\",\"value\":0.5647058823529412},{\"name\":\"b\",\"value\":0.43137254901960786},{\"name\":\"a\",\"value\":1}],\"portsOut\":[{\"name\":\"outr\",\"links\":[{\"portIn\":\"Value 3\",\"portOut\":\"outr\",\"objIn\":\"sp6-79\",\"objOut\":\"sp6-76\"}]},{\"name\":\"outg\",\"links\":[{\"portIn\":\"Value 3\",\"portOut\":\"outg\",\"objIn\":\"sp6-80\",\"objOut\":\"sp6-76\"}]},{\"name\":\"outb\",\"links\":[{\"portIn\":\"Value 3\",\"portOut\":\"outb\",\"objIn\":\"sp6-81\",\"objOut\":\"sp6-76\"}]},{\"name\":\"outa\",\"value\":1},{\"name\":\"Hex\",\"value\":\"A8906E\"}],\"objName\":\"Ops.Color.ColorValue\"},{\"id\":\"sp6-77\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"r\",\"value\":0.807843137254902},{\"name\":\"g\",\"value\":0.6078431372549019},{\"name\":\"b\",\"value\":0.32156862745098047},{\"name\":\"a\",\"value\":1}],\"portsOut\":[{\"name\":\"outr\",\"links\":[{\"portIn\":\"Value 2\",\"portOut\":\"outr\",\"objIn\":\"sp6-79\",\"objOut\":\"sp6-77\"}]},{\"name\":\"outg\",\"links\":[{\"portIn\":\"Value 2\",\"portOut\":\"outg\",\"objIn\":\"sp6-80\",\"objOut\":\"sp6-77\"}]},{\"name\":\"outb\",\"links\":[{\"portIn\":\"Value 2\",\"portOut\":\"outb\",\"objIn\":\"sp6-81\",\"objOut\":\"sp6-77\"}]},{\"name\":\"outa\",\"value\":1},{\"name\":\"Hex\",\"value\":\"CE9B52\"}],\"objName\":\"Ops.Color.ColorValue\"},{\"id\":\"sp6-78\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"r\",\"value\":0.807843137254902},{\"name\":\"g\",\"value\":0.4470588235294118},{\"name\":\"b\",\"value\":0.4470588235294118},{\"name\":\"a\",\"value\":1}],\"portsOut\":[{\"name\":\"outr\",\"links\":[{\"portIn\":\"Value 0\",\"portOut\":\"outr\",\"objIn\":\"sp6-79\",\"objOut\":\"sp6-78\"}]},{\"name\":\"outg\",\"links\":[{\"portIn\":\"Value 0\",\"portOut\":\"outg\",\"objIn\":\"sp6-80\",\"objOut\":\"sp6-78\"}]},{\"name\":\"outb\",\"links\":[{\"portIn\":\"Value 0\",\"portOut\":\"outb\",\"objIn\":\"sp6-81\",\"objOut\":\"sp6-78\"}]},{\"name\":\"outa\",\"value\":1},{\"name\":\"Hex\",\"value\":\"CE7272\"}],\"objName\":\"Ops.Color.ColorValue\"},{\"id\":\"sp6-79\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"Value 4\",\"value\":0},{\"name\":\"Value 5\",\"value\":0},{\"name\":\"Value 6\",\"value\":0},{\"name\":\"Value 7\",\"value\":0},{\"name\":\"Value 8\",\"value\":0},{\"name\":\"Value 9\",\"value\":0},{\"name\":\"Value 10\",\"value\":0},{\"name\":\"Value 11\",\"value\":0},{\"name\":\"Value 12\",\"value\":0},{\"name\":\"Value 13\",\"value\":0},{\"name\":\"Value 14\",\"value\":0},{\"name\":\"Value 15\",\"value\":0}],\"portsOut\":[{\"name\":\"Result\",\"links\":[{\"portIn\":\"r\",\"portOut\":\"Result\",\"objIn\":\"sp6-34\",\"objOut\":\"sp6-79\"},{\"portIn\":\"r\",\"portOut\":\"Result\",\"objIn\":\"sp6-75\",\"objOut\":\"sp6-79\"},{\"portIn\":\"r\",\"portOut\":\"Result\",\"objIn\":\"sp6-176\",\"objOut\":\"sp6-79\"}]}],\"objName\":\"Ops.Number.SwitchNumber\"},{\"id\":\"sp6-80\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"Value 4\",\"value\":0},{\"name\":\"Value 5\",\"value\":0},{\"name\":\"Value 6\",\"value\":0},{\"name\":\"Value 7\",\"value\":0},{\"name\":\"Value 8\",\"value\":0},{\"name\":\"Value 9\",\"value\":0},{\"name\":\"Value 10\",\"value\":0},{\"name\":\"Value 11\",\"value\":0},{\"name\":\"Value 12\",\"value\":0},{\"name\":\"Value 13\",\"value\":0},{\"name\":\"Value 14\",\"value\":0},{\"name\":\"Value 15\",\"value\":0}],\"portsOut\":[{\"name\":\"Result\",\"links\":[{\"portIn\":\"g\",\"portOut\":\"Result\",\"objIn\":\"sp6-34\",\"objOut\":\"sp6-80\"},{\"portIn\":\"g\",\"portOut\":\"Result\",\"objIn\":\"sp6-75\",\"objOut\":\"sp6-80\"},{\"portIn\":\"g\",\"portOut\":\"Result\",\"objIn\":\"sp6-176\",\"objOut\":\"sp6-80\"}]}],\"objName\":\"Ops.Number.SwitchNumber\"},{\"id\":\"sp6-81\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"Value 4\",\"value\":0},{\"name\":\"Value 5\",\"value\":0},{\"name\":\"Value 6\",\"value\":0},{\"name\":\"Value 7\",\"value\":0},{\"name\":\"Value 8\",\"value\":0},{\"name\":\"Value 9\",\"value\":0},{\"name\":\"Value 10\",\"value\":0},{\"name\":\"Value 11\",\"value\":0},{\"name\":\"Value 12\",\"value\":0},{\"name\":\"Value 13\",\"value\":0},{\"name\":\"Value 14\",\"value\":0},{\"name\":\"Value 15\",\"value\":0}],\"portsOut\":[{\"name\":\"Result\",\"links\":[{\"portIn\":\"b\",\"portOut\":\"Result\",\"objIn\":\"sp6-34\",\"objOut\":\"sp6-81\"},{\"portIn\":\"b\",\"portOut\":\"Result\",\"objIn\":\"sp6-75\",\"objOut\":\"sp6-81\"},{\"portIn\":\"b\",\"portOut\":\"Result\",\"objIn\":\"sp6-176\",\"objOut\":\"sp6-81\"}]}],\"objName\":\"Ops.Number.SwitchNumber\"},{\"id\":\"sp6-82\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"File\",\"value\":\"assets/chart_texture.jpg\",\"display\":\"file\"},{\"name\":\"Filter index\",\"value\":0},{\"name\":\"Filter\",\"value\":\"nearest\"},{\"name\":\"Wrap index\",\"value\":0},{\"name\":\"Wrap\",\"value\":\"repeat\"},{\"name\":\"Anisotropic index\",\"value\":0},{\"name\":\"Anisotropic\",\"value\":\"0\"},{\"name\":\"Data Format index\",\"value\":3},{\"name\":\"Data Format\",\"value\":\"RGBA\"},{\"name\":\"Flip\",\"value\":0},{\"name\":\"Pre Multiplied Alpha\",\"value\":0},{\"name\":\"Active\",\"value\":1},{\"name\":\"Save Memory\",\"value\":0},{\"name\":\"Add Cachebuster\",\"value\":0}],\"portsOut\":[{\"name\":\"Texture\",\"links\":[{\"portIn\":\"Image\",\"portOut\":\"Texture\",\"objIn\":\"sp6-85\",\"objOut\":\"sp6-82\"}]},{\"name\":\"Width\",\"value\":2000},{\"name\":\"Height\",\"value\":1000},{\"name\":\"Aspect Ratio\",\"value\":2},{\"name\":\"Loaded\",\"value\":1},{\"name\":\"Loading\",\"value\":0}],\"objName\":\"Ops.Gl.Texture_v2\"},{\"id\":\"sp6-83\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsOut\":[{\"name\":\"trigger 0\",\"links\":[{\"portIn\":\"Execute\",\"portOut\":\"trigger 0\",\"objIn\":\"sp6-155\",\"objOut\":\"sp6-83\"}]},{\"name\":\"trigger 2\",\"links\":[{\"portIn\":\"Execute\",\"portOut\":\"trigger 2\",\"objIn\":\"sp6-151\",\"objOut\":\"sp6-83\"}]},{\"name\":\"trigger 3\",\"links\":[{\"portIn\":\"Execute\",\"portOut\":\"trigger 3\",\"objIn\":\"sp6-152\",\"objOut\":\"sp6-83\"}]},{\"name\":\"trigger 8\",\"links\":[{\"portIn\":\"Execute\",\"portOut\":\"trigger 8\",\"objIn\":\"sp6-158\",\"objOut\":\"sp6-83\"}]}],\"objName\":\"Ops.Trigger.Sequence\"},{\"id\":\"sp6-84\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"Size index\",\"value\":0},{\"name\":\"Size\",\"value\":\"Auto\"},{\"name\":\"Width\",\"value\":640},{\"name\":\"Height\",\"value\":480},{\"name\":\"Filter index\",\"value\":1},{\"name\":\"Filter\",\"value\":\"linear\"},{\"name\":\"Wrap index\",\"value\":1},{\"name\":\"Wrap\",\"value\":\"repeat\"},{\"name\":\"Anisotropic index\",\"value\":0},{\"name\":\"Anisotropic\",\"value\":\"0\"},{\"name\":\"Pixel Format index\",\"value\":4},{\"name\":\"Pixel Format\",\"value\":\"RGBA 8bit ubyte\"},{\"name\":\"Clear\",\"value\":1},{\"name\":\"R\",\"value\":1},{\"name\":\"G\",\"value\":1},{\"name\":\"B\",\"value\":1},{\"name\":\"A\",\"value\":0}],\"portsOut\":[{\"name\":\"Next\",\"links\":[{\"portIn\":\"render\",\"portOut\":\"Next\",\"objIn\":\"sp6-85\",\"objOut\":\"sp6-84\"}]},{\"name\":\"texture_out\",\"links\":[{\"portIn\":\"Texture\",\"portOut\":\"texture_out\",\"objIn\":\"sp6-86\",\"objOut\":\"sp6-84\"},{\"portIn\":\"innerIn_el1t5zxr9\",\"portOut\":\"texture_out\",\"objIn\":\"sp6-1\",\"objOut\":\"sp6-84\"}]},{\"name\":\"Aspect Ratio\",\"value\":1.0338849487785657},{\"name\":\"Texture Width\",\"value\":1312},{\"name\":\"Texture Height\",\"value\":1269}],\"objName\":\"Ops.Gl.ImageCompose.ImageCompose_v4\"},{\"id\":\"sp6-85\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"blendMode index\",\"value\":0},{\"name\":\"blendMode\",\"value\":\"normal\"},{\"name\":\"amount\",\"value\":1},{\"name\":\"Premultiplied\",\"value\":0},{\"name\":\"Alpha Mask\",\"value\":0},{\"name\":\"removeAlphaSrc\",\"value\":0},{\"name\":\"Mask Src index\",\"value\":0},{\"name\":\"Mask Src\",\"value\":\"alpha channel\"},{\"name\":\"Invert alpha channel\",\"value\":0},{\"name\":\"Aspect Ratio\",\"value\":0},{\"name\":\"Stretch Axis index\",\"value\":0},{\"name\":\"Stretch Axis\",\"value\":\"X\"},{\"name\":\"Position\",\"value\":0},{\"name\":\"Crop\",\"value\":0},{\"name\":\"flip x\",\"value\":0},{\"name\":\"flip y\",\"value\":0},{\"name\":\"Transform\",\"value\":0},{\"name\":\"Scale X\",\"value\":1},{\"name\":\"Scale Y\",\"value\":1},{\"name\":\"Position X\",\"value\":0},{\"name\":\"Position Y\",\"value\":0},{\"name\":\"Rotation\",\"value\":0},{\"name\":\"Clip Repeat\",\"value\":0}],\"portsOut\":[{\"name\":\"trigger\",\"links\":[{\"portIn\":\"render\",\"portOut\":\"trigger\",\"objIn\":\"sp6-109\",\"objOut\":\"sp6-85\"}]}],\"objName\":\"Ops.Gl.ImageCompose.DrawImage_v3\"},{\"id\":\"sp6-86\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"Scale index\",\"value\":0},{\"name\":\"Scale\",\"value\":\"Stretch\"},{\"name\":\"Flip Y\",\"value\":0},{\"name\":\"Flip X\",\"value\":0}],\"objName\":\"Ops.Gl.Meshes.FullscreenRectangle_v2\"},{\"id\":\"sp6-87\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"amount\",\"value\":-0.04},{\"name\":\"direction index\",\"value\":0},{\"name\":\"direction\",\"value\":\"both\"},{\"name\":\"Fast\",\"value\":1}],\"objName\":\"Ops.Gl.ImageCompose.Blur\"},{\"id\":\"sp6-88\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"contrast\",\"value\":0.354},{\"name\":\"brightness\",\"value\":0.957}],\"objName\":\"Ops.Gl.ImageCompose.BrightnessContrast\"},{\"id\":\"sp6-89\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"Size index\",\"value\":0},{\"name\":\"Size\",\"value\":\"Auto\"},{\"name\":\"Width\",\"value\":640},{\"name\":\"Height\",\"value\":480},{\"name\":\"Filter index\",\"value\":1},{\"name\":\"Filter\",\"value\":\"linear\"},{\"name\":\"Wrap index\",\"value\":1},{\"name\":\"Wrap\",\"value\":\"repeat\"},{\"name\":\"Anisotropic index\",\"value\":0},{\"name\":\"Anisotropic\",\"value\":\"0\"},{\"name\":\"Pixel Format index\",\"value\":4},{\"name\":\"Pixel Format\",\"value\":\"RGBA 8bit ubyte\"},{\"name\":\"Clear\",\"value\":1},{\"name\":\"R\",\"value\":0},{\"name\":\"G\",\"value\":0},{\"name\":\"B\",\"value\":0},{\"name\":\"A\",\"value\":0}],\"portsOut\":[{\"name\":\"Next\",\"links\":[{\"portIn\":\"render\",\"portOut\":\"Next\",\"objIn\":\"sp6-91\",\"objOut\":\"sp6-89\"}]},{\"name\":\"texture_out\",\"links\":[{\"portIn\":\"innerIn_jycvtf89b\",\"portOut\":\"texture_out\",\"objIn\":\"sp6-1\",\"objOut\":\"sp6-89\"},{\"portIn\":\"Base Texture\",\"portOut\":\"texture_out\",\"objIn\":\"sp6-177\",\"objOut\":\"sp6-89\"}]},{\"name\":\"Aspect Ratio\",\"value\":1.0338849487785657},{\"name\":\"Texture Width\",\"value\":1312},{\"name\":\"Texture Height\",\"value\":1269}],\"objName\":\"Ops.Gl.ImageCompose.ImageCompose_v4\"},{\"id\":\"sp6-90\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"Scale index\",\"value\":1},{\"name\":\"Scale\",\"value\":\"Fit\"},{\"name\":\"Flip Y\",\"value\":0},{\"name\":\"Flip X\",\"value\":0}],\"objName\":\"Ops.Gl.Meshes.FullscreenRectangle_v2\"},{\"id\":\"sp6-91\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"amount\",\"value\":1},{\"name\":\"Invert Mask\",\"value\":0}],\"portsOut\":[{\"name\":\"trigger\",\"links\":[{\"portIn\":\"render\",\"portOut\":\"trigger\",\"objIn\":\"sp6-93\",\"objOut\":\"sp6-91\"}]}],\"objName\":\"Ops.Gl.ImageCompose.Desaturate\"},{\"id\":\"sp6-92\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"Index\",\"value\":1},{\"name\":\"Smooth\",\"value\":1}],\"objName\":\"Ops.Color.ColorPalettes\"},{\"id\":\"sp6-93\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"Blend Mode index\",\"value\":0},{\"name\":\"Blend Mode\",\"value\":\"normal\"},{\"name\":\"Amount\",\"value\":1},{\"name\":\"Method index\",\"value\":0},{\"name\":\"Method\",\"value\":\"Luminance\"},{\"name\":\"Min\",\"value\":0},{\"name\":\"Max\",\"value\":1},{\"name\":\"Position\",\"value\":0.5}],\"portsOut\":[{\"name\":\"trigger\",\"links\":[{\"portIn\":\"render\",\"portOut\":\"trigger\",\"objIn\":\"sp6-176\",\"objOut\":\"sp6-93\"}]}],\"objName\":\"Ops.Gl.ImageCompose.ColorMap_v2\"},{\"id\":\"sp6-94\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"Tone index\",\"value\":2},{\"name\":\"Tone\",\"value\":\"Shadows\"},{\"name\":\"r\",\"value\":9.43},{\"name\":\"g\",\"value\":-1.04},{\"name\":\"b\",\"value\":-0.59}],\"portsOut\":[{\"name\":\"trigger\",\"links\":[{\"portIn\":\"render\",\"portOut\":\"trigger\",\"objIn\":\"sp6-107\",\"objOut\":\"sp6-94\"}]}],\"objName\":\"Ops.Gl.ImageCompose.ColorBalance_v2\"},{\"id\":\"sp6-95\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"objName\":\"Ops.Array.PaletteLibrary\"},{\"id\":\"sp6-96\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"Amount\",\"value\":1}],\"objName\":\"Ops.Gl.ImageCompose.LUTMap\"},{\"id\":\"sp6-97\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"Title\",\"value\":\"Colorize Buildings\"}],\"objName\":\"Ops.Ui.Area\"},{\"id\":\"sp6-98\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"Title\",\"value\":\"Colorize Line\"}],\"objName\":\"Ops.Ui.Area\"},{\"id\":\"sp6-99\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"Tone index\",\"value\":0},{\"name\":\"Tone\",\"value\":\"Highlights\"},{\"name\":\"r\",\"value\":-11.14},{\"name\":\"g\",\"value\":15.93},{\"name\":\"b\",\"value\":-8.08}],\"objName\":\"Ops.Gl.ImageCompose.ColorBalance_v2\"},{\"id\":\"sp6-100\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"Size index\",\"value\":0},{\"name\":\"Size\",\"value\":\"Canvas\"},{\"name\":\"texture width\",\"value\":1312},{\"name\":\"texture height\",\"value\":1269},{\"name\":\"Auto Aspect\",\"value\":1},{\"name\":\"filter index\",\"value\":1},{\"name\":\"filter\",\"value\":\"linear\"},{\"name\":\"Wrap index\",\"value\":1},{\"name\":\"Wrap\",\"value\":\"Repeat\"},{\"name\":\"MSAA index\",\"value\":0},{\"name\":\"MSAA\",\"value\":\"none\"},{\"name\":\"Pixel Format index\",\"value\":4},{\"name\":\"Pixel Format\",\"value\":\"RGBA 8bit ubyte\"},{\"name\":\"Clear\",\"value\":1}],\"portsOut\":[{\"name\":\"trigger\",\"links\":[{\"portIn\":\"mbmposg49\",\"portOut\":\"trigger\",\"objIn\":\"sp6-168\",\"objOut\":\"sp6-100\"}]},{\"name\":\"texture\",\"links\":[{\"portIn\":\"Base Texture\",\"portOut\":\"texture\",\"objIn\":\"sp6-89\",\"objOut\":\"sp6-100\"}]}],\"objName\":\"Ops.Gl.RenderToTexture_v3\"},{\"id\":\"sp6-101\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"B\",\"value\":0},{\"name\":\"Multiply\",\"value\":2}],\"portsOut\":[{\"name\":\"ResultR\",\"links\":[{\"portIn\":\"texture width\",\"portOut\":\"ResultR\",\"objIn\":\"sp6-105\",\"objOut\":\"sp6-101\"}]},{\"name\":\"ResultG\",\"links\":[{\"portIn\":\"texture height\",\"portOut\":\"ResultG\",\"objIn\":\"sp6-105\",\"objOut\":\"sp6-101\"}]},{\"name\":\"ResultB\",\"value\":0}],\"objName\":\"Ops.Math.Multiply3Numbers\"},{\"id\":\"sp6-102\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsOut\":[{\"name\":\"CSS Width\",\"links\":[{\"portIn\":\"R\",\"portOut\":\"CSS Width\",\"objIn\":\"sp6-101\",\"objOut\":\"sp6-102\"}]},{\"name\":\"CSS Height\",\"links\":[{\"portIn\":\"G\",\"portOut\":\"CSS Height\",\"objIn\":\"sp6-101\",\"objOut\":\"sp6-102\"}]},{\"name\":\"Pixel Ratio\",\"value\":1.5},{\"name\":\"Pixel Width\",\"value\":1312.5},{\"name\":\"Pixel Height\",\"value\":1269},{\"name\":\"Aspect Ratio\",\"value\":1.0342789598108748},{\"name\":\"Landscape\",\"value\":1}],\"objName\":\"Ops.Gl.CanvasInfo_v3\"},{\"id\":\"sp6-103\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"r\",\"value\":1},{\"name\":\"g\",\"value\":1},{\"name\":\"b\",\"value\":1},{\"name\":\"a\",\"value\":0}],\"portsOut\":[{\"name\":\"trigger\",\"links\":[{\"portIn\":\"mbmposg49\",\"portOut\":\"trigger\",\"objIn\":\"sp6-169\",\"objOut\":\"sp6-103\"}]}],\"objName\":\"Ops.Gl.ClearColor\"},{\"id\":\"sp6-104\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"bounds\",\"value\":1},{\"name\":\"Axis index\",\"value\":2},{\"name\":\"Axis\",\"value\":\"None\"},{\"name\":\"frustum near\",\"value\":-100},{\"name\":\"frustum far\",\"value\":100}],\"portsOut\":[{\"name\":\"Ratio\",\"value\":1},{\"name\":\"Width\",\"value\":2},{\"name\":\"Height\",\"value\":2}],\"objName\":\"Ops.Gl.Orthogonal_v2\"},{\"id\":\"sp6-105\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"Size index\",\"value\":1},{\"name\":\"Size\",\"value\":\"Manual\"},{\"name\":\"Auto Aspect\",\"value\":0},{\"name\":\"filter index\",\"value\":1},{\"name\":\"filter\",\"value\":\"linear\"},{\"name\":\"Wrap index\",\"value\":1},{\"name\":\"Wrap\",\"value\":\"Repeat\"},{\"name\":\"MSAA index\",\"value\":3},{\"name\":\"MSAA\",\"value\":\"8x\"},{\"name\":\"Pixel Format index\",\"value\":4},{\"name\":\"Pixel Format\",\"value\":\"RGBA 8bit ubyte\"},{\"name\":\"Depth\",\"value\":0},{\"name\":\"Clear\",\"value\":1}],\"portsOut\":[{\"name\":\"trigger\",\"links\":[{\"portIn\":\"render\",\"portOut\":\"trigger\",\"objIn\":\"sp6-103\",\"objOut\":\"sp6-105\"}]},{\"name\":\"texture\",\"links\":[{\"portIn\":\"Mask\",\"portOut\":\"texture\",\"objIn\":\"sp6-85\",\"objOut\":\"sp6-105\"}]}],\"objName\":\"Ops.Gl.RenderToTexture_v3\"},{\"id\":\"sp6-106\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsOut\":[{\"name\":\"Next\",\"links\":[{\"portIn\":\"exe\",\"portOut\":\"Next\",\"objIn\":\"sp6-83\",\"objOut\":\"sp6-106\"}]}],\"objName\":\"Ops.Trigger.TriggerExtender\"},{\"id\":\"sp6-107\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"Tone index\",\"value\":2},{\"name\":\"Tone\",\"value\":\"Shadows\"},{\"name\":\"r\",\"value\":3.56},{\"name\":\"g\",\"value\":0.8},{\"name\":\"b\",\"value\":0.5}],\"objName\":\"Ops.Gl.ImageCompose.ColorBalance_v2\"},{\"id\":\"sp6-108\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"Title\",\"value\":\"Line Color / Building Gradient Map\"}],\"objName\":\"Ops.Ui.Area\"},{\"id\":\"sp6-109\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"contrast\",\"value\":0.407},{\"name\":\"brightness\",\"value\":0.657}],\"objName\":\"Ops.Gl.ImageCompose.BrightnessContrast\"},{\"id\":\"sp6-110\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"Invert\",\"value\":0},{\"name\":\"Black White\",\"value\":0},{\"name\":\"Remove Alpha\",\"value\":1},{\"name\":\"Remap\",\"value\":1},{\"name\":\"Threshold low \",\"value\":0.5},{\"name\":\"Threshold high\",\"value\":1}],\"objName\":\"Ops.Gl.ImageCompose.LumaKey_v3\"},{\"id\":\"sp6-111\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"value\",\"value\":0.07}],\"portsOut\":[{\"name\":\"result\",\"links\":[{\"portIn\":\"Width\",\"portOut\":\"result\",\"objIn\":\"sp6-8\",\"objOut\":\"sp6-111\"}]}],\"objName\":\"Ops.Number.Number\"},{\"id\":\"sp6-112\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"value\",\"value\":0.08}],\"portsOut\":[{\"name\":\"result\",\"links\":[{\"portIn\":\"Width\",\"portOut\":\"result\",\"objIn\":\"sp6-75\",\"objOut\":\"sp6-112\"}]}],\"objName\":\"Ops.Number.Number\"},{\"id\":\"sp6-113\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsOut\":[{\"name\":\"result\",\"links\":[{\"portIn\":\"Pass Through\",\"portOut\":\"result\",\"objIn\":\"sp6-39\",\"objOut\":\"sp6-113\"}]}],\"objName\":\"Ops.Boolean.And\"},{\"id\":\"sp6-114\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"Array 1\",\"value\":0},{\"name\":\"Array 2\",\"value\":0},{\"name\":\"Array 3\",\"value\":0},{\"name\":\"Array 4\",\"value\":0},{\"name\":\"Array 5\",\"value\":0},{\"name\":\"Array 6\",\"value\":0},{\"name\":\"Array 7\",\"value\":0}],\"portsOut\":[{\"name\":\"Result\",\"links\":[{\"portIn\":\"array\",\"portOut\":\"Result\",\"objIn\":\"sp6-115\",\"objOut\":\"sp6-114\"}]},{\"name\":\"Array length\",\"value\":13}],\"objName\":\"Ops.Array.ArrayMerge_v3\"},{\"id\":\"sp6-115\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"Value Invalid Index\",\"value\":0}],\"portsOut\":[{\"name\":\"value\",\"links\":[{\"portIn\":\"a\",\"portOut\":\"value\",\"objIn\":\"sp6-10\",\"objOut\":\"sp6-115\"}]},{\"name\":\"Valid Index\",\"value\":1}],\"objName\":\"Ops.Array.ArrayGetNumber\"},{\"id\":\"sp6-116\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"Blend Mode index\",\"value\":0},{\"name\":\"Blend Mode\",\"value\":\"normal\"},{\"name\":\"Amount\",\"value\":1},{\"name\":\"Method index\",\"value\":0},{\"name\":\"Method\",\"value\":\"Luminance\"},{\"name\":\"Min\",\"value\":0},{\"name\":\"Max\",\"value\":1},{\"name\":\"Position\",\"value\":0.5}],\"objName\":\"Ops.Gl.ImageCompose.ColorMap_v2\"},{\"id\":\"sp6-117\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"Gradient\",\"value\":\"{\\\"keys\\\":[{\\\"pos\\\":0,\\\"posy\\\":0.51,\\\"r\\\":0.9294117647058824,\\\"g\\\":0.5137254901960784,\\\"b\\\":0.43137254901960786},{\\\"pos\\\":0.0234375,\\\"posy\\\":0.51,\\\"r\\\":0.9294117647058824,\\\"g\\\":0.5137254901960784,\\\"b\\\":0.43137254901960786},{\\\"pos\\\":0.2265625,\\\"posy\\\":0.56,\\\"r\\\":0.21490885416666672,\\\"g\\\":0.12095060730189613,\\\"b\\\":0.06614162996411325},{\\\"pos\\\":0.435546875,\\\"posy\\\":0.57,\\\"r\\\":0.6627450980392157,\\\"g\\\":0.36627450980392157,\\\"b\\\":0.3333333333333333},{\\\"pos\\\":0.6328125,\\\"posy\\\":0.6,\\\"r\\\":0.9163411458333334,\\\"g\\\":0.602397546172142,\\\"b\\\":0.5239116462568442},{\\\"pos\\\":0.767578125,\\\"posy\\\":0.51,\\\"r\\\":0.9379231770833333,\\\"g\\\":0.7690338502859786,\\\"b\\\":0.7014781195670367},{\\\"pos\\\":0.875,\\\"posy\\\":0.66,\\\"r\\\":1,\\\"g\\\":1,\\\"b\\\":1},{\\\"pos\\\":1,\\\"posy\\\":0.66,\\\"r\\\":1,\\\"g\\\":1,\\\"b\\\":1}]}\"},{\"name\":\"Direction index\",\"value\":0},{\"name\":\"Direction\",\"value\":\"X\"},{\"name\":\"Smoothstep\",\"value\":1},{\"name\":\"Step\",\"value\":0},{\"name\":\"Flip\",\"value\":0},{\"name\":\"sRGB\",\"value\":0},{\"name\":\"Oklab\",\"value\":0},{\"name\":\"Size\",\"value\":256},{\"name\":\"filter index\",\"value\":1},{\"name\":\"filter\",\"value\":\"linear\"},{\"name\":\"wrap index\",\"value\":0},{\"name\":\"wrap\",\"value\":\"clamp to edge\"},{\"name\":\"Dither\",\"value\":0},{\"name\":\"Gradient Array\",\"value\":0}],\"objName\":\"Ops.Gl.GradientTexture\"},{\"id\":\"sp6-118\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"Tone index\",\"value\":0},{\"name\":\"Tone\",\"value\":\"Highlights\"},{\"name\":\"r\",\"value\":-2.81},{\"name\":\"g\",\"value\":-1.19},{\"name\":\"b\",\"value\":-0.31}],\"objName\":\"Ops.Gl.ImageCompose.ColorBalance_v2\"},{\"id\":\"sp6-119\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"Amount\",\"value\":1},{\"name\":\"Method index\",\"value\":1},{\"name\":\"Method\",\"value\":\"Mul\"},{\"name\":\"Invert\",\"value\":0},{\"name\":\"method index\",\"value\":0},{\"name\":\"method\",\"value\":\"luminance\"}],\"objName\":\"Ops.Gl.ImageCompose.AlphaMask_v2\"},{\"id\":\"sp6-120\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsOut\":[{\"name\":\"Result\",\"links\":[{\"portIn\":\"Number\",\"portOut\":\"Result\",\"objIn\":\"sp6-160\",\"objOut\":\"sp6-120\"},{\"portIn\":\"Number\",\"portOut\":\"Result\",\"objIn\":\"sp6-161\",\"objOut\":\"sp6-120\"}]}],\"objName\":\"Ops.Ui.VizNumber\"},{\"id\":\"sp6-121\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2,\"subPatchVer\":2},\"portsIn\":[{\"name\":\"mqmfkaq8t\",\"title\":\"LayerIndex\"},{\"name\":\"patchId\",\"value\":\"3xr9pqxbh\"}],\"portsOut\":[{\"name\":\"vfunjpwkx\",\"title\":\"Visible\",\"links\":[{\"portIn\":\"Render Mesh\",\"portOut\":\"vfunjpwkx\",\"objIn\":\"sp6-7\",\"objOut\":\"sp6-121\"},{\"portIn\":\"Render Mesh\",\"portOut\":\"vfunjpwkx\",\"objIn\":\"sp6-12\",\"objOut\":\"sp6-121\"},{\"portIn\":\"bool 2\",\"portOut\":\"vfunjpwkx\",\"objIn\":\"sp6-113\",\"objOut\":\"sp6-121\"},{\"portIn\":\"Number\",\"portOut\":\"vfunjpwkx\",\"objIn\":\"sp6-156\",\"objOut\":\"sp6-121\"}]}],\"objName\":\"Ops.Patch.PLH3vXR.IsLayerVisible1\"},{\"id\":\"sp6-122\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"Value Invalid Index\",\"value\":0}],\"portsOut\":[{\"name\":\"value\",\"links\":[{\"portIn\":\"posZ\",\"portOut\":\"value\",\"objIn\":\"sp6-9\",\"objOut\":\"sp6-122\"}]},{\"name\":\"Valid Index\",\"value\":1}],\"objName\":\"Ops.Array.ArrayGetNumber\"},{\"id\":\"sp6-123\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"posX\",\"value\":0},{\"name\":\"posY\",\"value\":0},{\"name\":\"scale\",\"value\":1},{\"name\":\"rotX\",\"value\":0},{\"name\":\"rotY\",\"value\":0},{\"name\":\"rotZ\",\"value\":0}],\"portsOut\":[{\"name\":\"trigger\",\"links\":[{\"portIn\":\"render\",\"portOut\":\"trigger\",\"objIn\":\"sp6-90\",\"objOut\":\"sp6-123\"}]}],\"objName\":\"Ops.Graphics.Transform\"},{\"id\":\"sp6-124\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"number2\",\"value\":0.1}],\"portsOut\":[{\"name\":\"result\",\"links\":[{\"portIn\":\"number1\",\"portOut\":\"result\",\"objIn\":\"sp6-125\",\"objOut\":\"sp6-124\"}]}],\"objName\":\"Ops.Math.Multiply\"},{\"id\":\"sp6-125\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"number2\",\"value\":-1}],\"portsOut\":[{\"name\":\"result\",\"links\":[{\"portIn\":\"Number\",\"portOut\":\"result\",\"objIn\":\"sp6-162\",\"objOut\":\"sp6-125\"}]}],\"objName\":\"Ops.Math.Multiply\"},{\"id\":\"sp6-126\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"posX\",\"value\":0},{\"name\":\"posY\",\"value\":0},{\"name\":\"scale\",\"value\":1},{\"name\":\"rotX\",\"value\":0},{\"name\":\"rotY\",\"value\":0},{\"name\":\"rotZ\",\"value\":0}],\"portsOut\":[{\"name\":\"trigger\",\"links\":[{\"portIn\":\"render\",\"portOut\":\"trigger\",\"objIn\":\"sp6-86\",\"objOut\":\"sp6-126\"}]}],\"objName\":\"Ops.Graphics.Transform\"},{\"id\":\"sp6-127\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsOut\":[{\"name\":\"trigger 0\",\"links\":[{\"portIn\":\"render\",\"portOut\":\"trigger 0\",\"objIn\":\"sp6-128\",\"objOut\":\"sp6-127\"}]},{\"name\":\"trigger 5\",\"links\":[{\"portIn\":\"Render\",\"portOut\":\"trigger 5\",\"objIn\":\"sp6-129\",\"objOut\":\"sp6-127\"}]},{\"name\":\"trigger 10\",\"links\":[{\"portIn\":\"render\",\"portOut\":\"trigger 10\",\"objIn\":\"sp6-163\",\"objOut\":\"sp6-127\"}]}],\"objName\":\"Ops.Trigger.Sequence\"},{\"id\":\"sp6-128\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"Size index\",\"value\":0},{\"name\":\"Size\",\"value\":\"Canvas\"},{\"name\":\"texture width\",\"value\":1312},{\"name\":\"texture height\",\"value\":1269},{\"name\":\"Auto Aspect\",\"value\":1},{\"name\":\"filter index\",\"value\":1},{\"name\":\"filter\",\"value\":\"linear\"},{\"name\":\"Wrap index\",\"value\":1},{\"name\":\"Wrap\",\"value\":\"Repeat\"},{\"name\":\"MSAA index\",\"value\":0},{\"name\":\"MSAA\",\"value\":\"none\"},{\"name\":\"Pixel Format index\",\"value\":4},{\"name\":\"Pixel Format\",\"value\":\"RGBA 8bit ubyte\"},{\"name\":\"Depth\",\"value\":1},{\"name\":\"Clear\",\"value\":1}],\"portsOut\":[{\"name\":\"trigger\",\"links\":[{\"portIn\":\"mbmposg49\",\"portOut\":\"trigger\",\"objIn\":\"sp6-170\",\"objOut\":\"sp6-128\"}]},{\"name\":\"texture\",\"links\":[{\"portIn\":\"Base Texture\",\"portOut\":\"texture\",\"objIn\":\"sp6-129\",\"objOut\":\"sp6-128\"}]}],\"objName\":\"Ops.Gl.RenderToTexture_v3\"},{\"id\":\"sp6-129\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"Size index\",\"value\":0},{\"name\":\"Size\",\"value\":\"Auto\"},{\"name\":\"Width\",\"value\":640},{\"name\":\"Height\",\"value\":480},{\"name\":\"Filter index\",\"value\":1},{\"name\":\"Filter\",\"value\":\"linear\"},{\"name\":\"Wrap index\",\"value\":1},{\"name\":\"Wrap\",\"value\":\"repeat\"},{\"name\":\"Anisotropic index\",\"value\":0},{\"name\":\"Anisotropic\",\"value\":\"0\"},{\"name\":\"Pixel Format index\",\"value\":4},{\"name\":\"Pixel Format\",\"value\":\"RGBA 8bit ubyte\"},{\"name\":\"Clear\",\"value\":1},{\"name\":\"R\",\"value\":0},{\"name\":\"G\",\"value\":0},{\"name\":\"B\",\"value\":0},{\"name\":\"A\",\"value\":0}],\"portsOut\":[{\"name\":\"Next\",\"links\":[{\"portIn\":\"render\",\"portOut\":\"Next\",\"objIn\":\"sp6-131\",\"objOut\":\"sp6-129\"}]},{\"name\":\"texture_out\",\"links\":[{\"portIn\":\"Texture\",\"portOut\":\"texture_out\",\"objIn\":\"sp6-130\",\"objOut\":\"sp6-129\"}]},{\"name\":\"Aspect Ratio\",\"value\":1.0338849487785657},{\"name\":\"Texture Width\",\"value\":1312},{\"name\":\"Texture Height\",\"value\":1269}],\"objName\":\"Ops.Gl.ImageCompose.ImageCompose_v4\"},{\"id\":\"sp6-130\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"Scale index\",\"value\":1},{\"name\":\"Scale\",\"value\":\"Fit\"},{\"name\":\"Flip Y\",\"value\":0},{\"name\":\"Flip X\",\"value\":0}],\"objName\":\"Ops.Gl.Meshes.FullscreenRectangle_v2\"},{\"id\":\"sp6-131\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"Method index\",\"value\":1},{\"name\":\"Method\",\"value\":\"Mul\"},{\"name\":\"Invert\",\"value\":0},{\"name\":\"method index\",\"value\":0},{\"name\":\"method\",\"value\":\"luminance\"}],\"objName\":\"Ops.Gl.ImageCompose.AlphaMask_v2\"},{\"id\":\"sp6-132\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"Variable\",\"value\":\"LayerInterval\"}],\"portsOut\":[{\"name\":\"Value\",\"links\":[{\"portIn\":\"Layer Interval\",\"portOut\":\"Value\",\"objIn\":\"sp6-175\",\"objOut\":\"sp6-132\"}]}],\"objName\":\"Ops.Vars.VarGetNumber_v2\"},{\"id\":\"sp6-133\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"Variable\",\"value\":\"ImageIntervalX\"}],\"portsOut\":[{\"name\":\"Value\",\"links\":[{\"portIn\":\"Image Interval X\",\"portOut\":\"Value\",\"objIn\":\"sp6-175\",\"objOut\":\"sp6-133\"}]}],\"objName\":\"Ops.Vars.VarGetNumber_v2\"},{\"id\":\"sp6-134\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"Variable\",\"value\":\"ImageIntervalZ\"}],\"portsOut\":[{\"name\":\"Value\",\"links\":[{\"portIn\":\"Image Interval Z\",\"portOut\":\"Value\",\"objIn\":\"sp6-175\",\"objOut\":\"sp6-134\"}]}],\"objName\":\"Ops.Vars.VarGetNumber_v2\"},{\"id\":\"sp6-135\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsOut\":[{\"name\":\"trigger 0\",\"links\":[{\"portIn\":\"Execute\",\"portOut\":\"trigger 0\",\"objIn\":\"sp6-154\",\"objOut\":\"sp6-135\"}]},{\"name\":\"trigger 7\",\"links\":[{\"portIn\":\"Execute\",\"portOut\":\"trigger 7\",\"objIn\":\"sp6-106\",\"objOut\":\"sp6-135\"}]}],\"objName\":\"Ops.Trigger.Sequence\"},{\"id\":\"sp6-136\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2,\"subPatchVer\":2},\"portsIn\":[{\"name\":\"patchId\",\"value\":\"5vgnrrdfn\"}],\"portsOut\":[{\"name\":\"br9ezjywo\",\"title\":\"xMin\",\"links\":[{\"portIn\":\"Dst RangeX Min\",\"portOut\":\"br9ezjywo\",\"objIn\":\"sp6-175\",\"objOut\":\"sp6-136\"}]},{\"name\":\"ves8t32bh\",\"title\":\"xMax\",\"links\":[{\"portIn\":\"Dst RangeX Max\",\"portOut\":\"ves8t32bh\",\"objIn\":\"sp6-175\",\"objOut\":\"sp6-136\"}]},{\"name\":\"s4x9bwpue\",\"title\":\"yMin\",\"links\":[{\"portIn\":\"Dst RangeY Min\",\"portOut\":\"s4x9bwpue\",\"objIn\":\"sp6-175\",\"objOut\":\"sp6-136\"}]},{\"name\":\"vvze3lkl2\",\"title\":\"yMax\",\"links\":[{\"portIn\":\"Dst RangeY Max\",\"portOut\":\"vvze3lkl2\",\"objIn\":\"sp6-175\",\"objOut\":\"sp6-136\"}]},{\"name\":\"fimwluhh4\",\"value\":0,\"title\":\"Width\"},{\"name\":\"dzq5f4w23\",\"value\":1.3790386130811663,\"title\":\"Height\"},{\"name\":\"l666gc2uq\",\"value\":0,\"title\":\"centerX\"},{\"name\":\"sfmosbvpy\",\"value\":0,\"title\":\"centerY\"}],\"objName\":\"Ops.Patch.PLH3vXR.DisplayBounds\"},{\"id\":\"sp6-137\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"Number\",\"value\":0}],\"portsOut\":[{\"name\":\"Result\",\"value\":0}],\"objName\":\"Ops.Ui.VizNumber\"},{\"id\":\"sp6-138\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsOut\":[{\"name\":\"trigger 0\",\"links\":[{\"portIn\":\"Execute\",\"portOut\":\"trigger 0\",\"objIn\":\"sp6-139\",\"objOut\":\"sp6-138\"}]}],\"objName\":\"Ops.Trigger.Sequence\"},{\"id\":\"sp6-139\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsOut\":[{\"name\":\"Next\",\"links\":[{\"portIn\":\"Trigger In\",\"portOut\":\"Next\",\"objIn\":\"sp6-175\",\"objOut\":\"sp6-139\"}]}],\"objName\":\"Ops.Trigger.TriggerExtender\"},{\"id\":\"sp6-140\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsOut\":[{\"name\":\"Result\",\"links\":[{\"portIn\":\"mqmfkaq8t\",\"portOut\":\"Result\",\"objIn\":\"sp6-121\",\"objOut\":\"sp6-140\"},{\"portIn\":\"Object Index\",\"portOut\":\"Result\",\"objIn\":\"sp6-70\",\"objOut\":\"sp6-140\"}]}],\"objName\":\"Ops.Ui.VizNumber\"},{\"id\":\"sp6-141\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"render\",\"title\":\"Trigger\"},{\"name\":\"Render Mesh\",\"value\":1,\"title\":\"Render\"},{\"name\":\"width\",\"value\":1},{\"name\":\"height\",\"value\":1},{\"name\":\"pivot x index\",\"value\":1},{\"name\":\"pivot x\",\"value\":\"center\"},{\"name\":\"pivot y index\",\"value\":1},{\"name\":\"pivot y\",\"value\":\"center\"},{\"name\":\"axis index\",\"value\":0},{\"name\":\"axis\",\"value\":\"xy\"},{\"name\":\"Flip TexCoord X\",\"value\":0},{\"name\":\"Flip TexCoord Y\",\"value\":1},{\"name\":\"num columns\",\"value\":1},{\"name\":\"num rows\",\"value\":1}],\"objName\":\"Ops.Graphics.Meshes.Rectangle_v4\"},{\"id\":\"sp6-142\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"posZ\",\"value\":0},{\"name\":\"scale\",\"value\":1},{\"name\":\"rotX\",\"value\":0},{\"name\":\"rotY\",\"value\":0},{\"name\":\"rotZ\",\"value\":0}],\"portsOut\":[{\"name\":\"trigger\",\"links\":[{\"portIn\":\"render\",\"portOut\":\"trigger\",\"objIn\":\"sp6-143\",\"objOut\":\"sp6-142\"}]}],\"objName\":\"Ops.Graphics.Transform\"},{\"id\":\"sp6-143\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"scale\",\"value\":1},{\"name\":\"z\",\"value\":1}],\"portsOut\":[{\"name\":\"trigger\",\"links\":[{\"portIn\":\"render\",\"portOut\":\"trigger\",\"objIn\":\"sp6-147\",\"objOut\":\"sp6-143\"}]}],\"objName\":\"Ops.Gl.Matrix.Scale\"},{\"id\":\"sp6-144\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"bounds\",\"value\":1},{\"name\":\"Axis index\",\"value\":2},{\"name\":\"Axis\",\"value\":\"None\"},{\"name\":\"frustum near\",\"value\":-100},{\"name\":\"frustum far\",\"value\":100}],\"portsOut\":[{\"name\":\"trigger\",\"links\":[{\"portIn\":\"render\",\"portOut\":\"trigger\",\"objIn\":\"sp6-142\",\"objOut\":\"sp6-144\"}]},{\"name\":\"Ratio\",\"value\":1},{\"name\":\"Width\",\"value\":2},{\"name\":\"Height\",\"value\":2}],\"objName\":\"Ops.Gl.Orthogonal_v2\"},{\"id\":\"sp6-145\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"Size index\",\"value\":0},{\"name\":\"Size\",\"value\":\"Canvas\"},{\"name\":\"texture width\",\"value\":1312},{\"name\":\"texture height\",\"value\":1269},{\"name\":\"Auto Aspect\",\"value\":1},{\"name\":\"filter index\",\"value\":1},{\"name\":\"filter\",\"value\":\"linear\"},{\"name\":\"Wrap index\",\"value\":1},{\"name\":\"Wrap\",\"value\":\"Repeat\"},{\"name\":\"MSAA index\",\"value\":0},{\"name\":\"MSAA\",\"value\":\"none\"},{\"name\":\"Pixel Format index\",\"value\":4},{\"name\":\"Pixel Format\",\"value\":\"RGBA 8bit ubyte\"},{\"name\":\"Depth\",\"value\":1},{\"name\":\"Clear\",\"value\":1}],\"portsOut\":[{\"name\":\"trigger\",\"links\":[{\"portIn\":\"render\",\"portOut\":\"trigger\",\"objIn\":\"sp6-144\",\"objOut\":\"sp6-145\"}]},{\"name\":\"texture\",\"links\":[{\"portIn\":\"image\",\"portOut\":\"texture\",\"objIn\":\"sp6-119\",\"objOut\":\"sp6-145\"},{\"portIn\":\"image\",\"portOut\":\"texture\",\"objIn\":\"sp6-131\",\"objOut\":\"sp6-145\"}]}],\"objName\":\"Ops.Gl.RenderToTexture_v3\"},{\"id\":\"sp6-146\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"Title\",\"value\":\"Bounds As Mask\"}],\"objName\":\"Ops.Ui.Area\"},{\"id\":\"sp6-147\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"r\",\"value\":1},{\"name\":\"g\",\"value\":1},{\"name\":\"b\",\"value\":1},{\"name\":\"a\",\"value\":1},{\"name\":\"colorizeTexture\",\"value\":0},{\"name\":\"Vertex Colors\",\"value\":0},{\"name\":\"Alpha Mask Source index\",\"value\":0},{\"name\":\"Alpha Mask Source\",\"value\":\"Luminance\"},{\"name\":\"Opacity TexCoords Transform\",\"value\":0},{\"name\":\"Discard Transparent Pixels\",\"value\":0},{\"name\":\"diffuseRepeatX\",\"value\":1},{\"name\":\"diffuseRepeatY\",\"value\":1},{\"name\":\"Tex Offset X\",\"value\":0},{\"name\":\"Tex Offset Y\",\"value\":0},{\"name\":\"Crop TexCoords\",\"value\":0},{\"name\":\"billboard\",\"value\":0}],\"portsOut\":[{\"name\":\"trigger\",\"links\":[{\"portIn\":\"render\",\"portOut\":\"trigger\",\"objIn\":\"sp6-141\",\"objOut\":\"sp6-147\"}]}],\"objName\":\"Ops.Gl.Shader.BasicMaterial_v3\"},{\"id\":\"sp6-148\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2,\"subPatchVer\":2},\"portsIn\":[{\"name\":\"patchId\",\"value\":\"9hpvlbvtt\"}],\"portsOut\":[{\"name\":\"br9ezjywo\",\"value\":-1,\"title\":\"xMin\"},{\"name\":\"ves8t32bh\",\"value\":1,\"title\":\"xMax\"},{\"name\":\"s4x9bwpue\",\"value\":-0.6895193065405831,\"title\":\"yMin\"},{\"name\":\"vvze3lkl2\",\"value\":0.6895193065405831,\"title\":\"yMax\"},{\"name\":\"fimwluhh4\",\"title\":\"Width\",\"links\":[{\"portIn\":\"x\",\"portOut\":\"fimwluhh4\",\"objIn\":\"sp6-143\",\"objOut\":\"sp6-148\"}]},{\"name\":\"dzq5f4w23\",\"title\":\"Height\",\"links\":[{\"portIn\":\"y\",\"portOut\":\"dzq5f4w23\",\"objIn\":\"sp6-143\",\"objOut\":\"sp6-148\"}]},{\"name\":\"l666gc2uq\",\"title\":\"centerX\",\"links\":[{\"portIn\":\"posX\",\"portOut\":\"l666gc2uq\",\"objIn\":\"sp6-142\",\"objOut\":\"sp6-148\"}]},{\"name\":\"sfmosbvpy\",\"title\":\"centerY\",\"links\":[{\"portIn\":\"posY\",\"portOut\":\"sfmosbvpy\",\"objIn\":\"sp6-142\",\"objOut\":\"sp6-148\"}]}],\"objName\":\"Ops.Patch.PLH3vXR.DisplayBounds\"},{\"id\":\"sp6-149\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsOut\":[{\"name\":\"trigger 0\",\"links\":[{\"portIn\":\"render\",\"portOut\":\"trigger 0\",\"objIn\":\"sp6-34\",\"objOut\":\"sp6-149\"}]},{\"name\":\"trigger 11\",\"links\":[{\"portIn\":\"Render\",\"portOut\":\"trigger 11\",\"objIn\":\"sp6-75\",\"objOut\":\"sp6-149\"}]}],\"objName\":\"Ops.Trigger.Sequence\"},{\"id\":\"sp6-150\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2,\"subPatchVer\":2},\"portsIn\":[{\"name\":\"mqmfkaq8t\",\"title\":\"LayerIndex\"},{\"name\":\"patchId\",\"value\":\"s8sn07oys\"}],\"portsOut\":[{\"name\":\"vfunjpwkx\",\"title\":\"Visible\",\"links\":[{\"portIn\":\"Render Mesh\",\"portOut\":\"vfunjpwkx\",\"objIn\":\"sp6-74\",\"objOut\":\"sp6-150\"},{\"portIn\":\"bool 1\",\"portOut\":\"vfunjpwkx\",\"objIn\":\"sp6-166\",\"objOut\":\"sp6-150\"}]}],\"objName\":\"Ops.Patch.PLH3vXR.IsLayerVisible1\"},{\"id\":\"sp6-151\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsOut\":[{\"name\":\"Next\",\"links\":[{\"portIn\":\"exe\",\"portOut\":\"Next\",\"objIn\":\"sp6-127\",\"objOut\":\"sp6-151\"}]}],\"objName\":\"Ops.Trigger.TriggerExtender\"},{\"id\":\"sp6-152\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsOut\":[{\"name\":\"Next\",\"links\":[{\"portIn\":\"exe\",\"portOut\":\"Next\",\"objIn\":\"sp6-157\",\"objOut\":\"sp6-152\"}]}],\"objName\":\"Ops.Trigger.TriggerExtender\"},{\"id\":\"sp6-153\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsOut\":[{\"name\":\"Result\",\"links\":[{\"portIn\":\"Index\",\"portOut\":\"Result\",\"objIn\":\"sp6-79\",\"objOut\":\"sp6-153\"},{\"portIn\":\"Index\",\"portOut\":\"Result\",\"objIn\":\"sp6-80\",\"objOut\":\"sp6-153\"},{\"portIn\":\"Index\",\"portOut\":\"Result\",\"objIn\":\"sp6-81\",\"objOut\":\"sp6-153\"},{\"portIn\":\"mqmfkaq8t\",\"portOut\":\"Result\",\"objIn\":\"sp6-150\",\"objOut\":\"sp6-153\"}]}],\"objName\":\"Ops.Ui.VizNumber\"},{\"id\":\"sp6-154\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsOut\":[{\"name\":\"Next\",\"links\":[{\"portIn\":\"exe\",\"portOut\":\"Next\",\"objIn\":\"sp6-138\",\"objOut\":\"sp6-154\"}]}],\"objName\":\"Ops.Trigger.TriggerExtender\"},{\"id\":\"sp6-155\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsOut\":[{\"name\":\"Next\",\"links\":[{\"portIn\":\"render\",\"portOut\":\"Next\",\"objIn\":\"sp6-145\",\"objOut\":\"sp6-155\"}]}],\"objName\":\"Ops.Trigger.TriggerExtender\"},{\"id\":\"sp6-156\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsOut\":[{\"name\":\"Result\",\"links\":[{\"portIn\":\"bool 1\",\"portOut\":\"Result\",\"objIn\":\"sp6-64\",\"objOut\":\"sp6-156\"}]}],\"objName\":\"Ops.Ui.VizNumber\"},{\"id\":\"sp6-157\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsOut\":[{\"name\":\"trigger 0\",\"links\":[{\"portIn\":\"render\",\"portOut\":\"trigger 0\",\"objIn\":\"sp6-100\",\"objOut\":\"sp6-157\"}]},{\"name\":\"trigger 8\",\"links\":[{\"portIn\":\"Render\",\"portOut\":\"trigger 8\",\"objIn\":\"sp6-89\",\"objOut\":\"sp6-157\"}]},{\"name\":\"trigger 10\",\"links\":[{\"portIn\":\"Render\",\"portOut\":\"trigger 10\",\"objIn\":\"sp6-177\",\"objOut\":\"sp6-157\"}]},{\"name\":\"trigger 13\",\"links\":[{\"portIn\":\"render\",\"portOut\":\"trigger 13\",\"objIn\":\"sp6-123\",\"objOut\":\"sp6-157\"}]}],\"objName\":\"Ops.Trigger.Sequence\"},{\"id\":\"sp6-158\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsOut\":[{\"name\":\"Next\",\"links\":[{\"portIn\":\"exe\",\"portOut\":\"Next\",\"objIn\":\"sp6-159\",\"objOut\":\"sp6-158\"}]}],\"objName\":\"Ops.Trigger.TriggerExtender\"},{\"id\":\"sp6-159\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsOut\":[{\"name\":\"trigger 0\",\"links\":[{\"portIn\":\"render\",\"portOut\":\"trigger 0\",\"objIn\":\"sp6-105\",\"objOut\":\"sp6-159\"}]},{\"name\":\"trigger 8\",\"links\":[{\"portIn\":\"Render\",\"portOut\":\"trigger 8\",\"objIn\":\"sp6-84\",\"objOut\":\"sp6-159\"}]},{\"name\":\"trigger 13\",\"links\":[{\"portIn\":\"render\",\"portOut\":\"trigger 13\",\"objIn\":\"sp6-126\",\"objOut\":\"sp6-159\"}]}],\"objName\":\"Ops.Trigger.Sequence\"},{\"id\":\"sp6-160\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsOut\":[{\"name\":\"Result\",\"links\":[{\"portIn\":\"Number\",\"portOut\":\"Result\",\"objIn\":\"sp6-140\",\"objOut\":\"sp6-160\"},{\"portIn\":\"number1\",\"portOut\":\"Result\",\"objIn\":\"sp6-124\",\"objOut\":\"sp6-160\"},{\"portIn\":\"Number\",\"portOut\":\"Result\",\"objIn\":\"sp6-165\",\"objOut\":\"sp6-160\"},{\"portIn\":\"Number\",\"portOut\":\"Result\",\"objIn\":\"sp6-153\",\"objOut\":\"sp6-160\"}]}],\"objName\":\"Ops.Ui.VizNumber\"},{\"id\":\"sp6-161\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsOut\":[{\"name\":\"Result\",\"links\":[{\"portIn\":\"Index\",\"portOut\":\"Result\",\"objIn\":\"sp6-36\",\"objOut\":\"sp6-161\"},{\"portIn\":\"Layer Index\",\"portOut\":\"Result\",\"objIn\":\"sp6-175\",\"objOut\":\"sp6-161\"}]}],\"objName\":\"Ops.Ui.VizNumber\"},{\"id\":\"sp6-162\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsOut\":[{\"name\":\"Result\",\"links\":[{\"portIn\":\"posZ\",\"portOut\":\"Result\",\"objIn\":\"sp6-126\",\"objOut\":\"sp6-162\"},{\"portIn\":\"posZ\",\"portOut\":\"Result\",\"objIn\":\"sp6-123\",\"objOut\":\"sp6-162\"},{\"portIn\":\"posZ\",\"portOut\":\"Result\",\"objIn\":\"sp6-163\",\"objOut\":\"sp6-162\"}]}],\"objName\":\"Ops.Ui.VizNumber\"},{\"id\":\"sp6-163\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"posX\",\"value\":0},{\"name\":\"posY\",\"value\":0},{\"name\":\"scale\",\"value\":1},{\"name\":\"rotX\",\"value\":0},{\"name\":\"rotY\",\"value\":0},{\"name\":\"rotZ\",\"value\":0}],\"portsOut\":[{\"name\":\"trigger\",\"links\":[{\"portIn\":\"render\",\"portOut\":\"trigger\",\"objIn\":\"sp6-130\",\"objOut\":\"sp6-163\"}]}],\"objName\":\"Ops.Graphics.Transform\"},{\"id\":\"sp6-164\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2,\"subPatchVer\":2},\"portsIn\":[{\"name\":\"mqmfkaq8t\",\"title\":\"LayerIndex\"},{\"name\":\"patchId\",\"value\":\"sch641jbb\"}],\"portsOut\":[{\"name\":\"vfunjpwkx\",\"title\":\"Visible\",\"links\":[{\"portIn\":\"bool 1\",\"portOut\":\"vfunjpwkx\",\"objIn\":\"sp6-67\",\"objOut\":\"sp6-164\"}]}],\"objName\":\"Ops.Patch.PLH3vXR.IsLayerVisible1\"},{\"id\":\"sp6-165\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsOut\":[{\"name\":\"Result\",\"links\":[{\"portIn\":\"mqmfkaq8t\",\"portOut\":\"Result\",\"objIn\":\"sp6-164\",\"objOut\":\"sp6-165\"}]}],\"objName\":\"Ops.Ui.VizNumber\"},{\"id\":\"sp6-166\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsOut\":[{\"name\":\"result\",\"links\":[{\"portIn\":\"Render Mesh\",\"portOut\":\"result\",\"objIn\":\"sp6-33\",\"objOut\":\"sp6-166\"}]}],\"objName\":\"Ops.Boolean.And\"},{\"id\":\"sp6-167\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"Boolean\",\"value\":1}],\"portsOut\":[{\"name\":\"Bool\",\"links\":[{\"portIn\":\"bool 2\",\"portOut\":\"Bool\",\"objIn\":\"sp6-166\",\"objOut\":\"sp6-167\"}]}],\"objName\":\"Ops.Ui.VizBool\"},{\"id\":\"sp6-168\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2,\"subPatchVer\":2},\"portsIn\":[{\"name\":\"mbmposg49\",\"title\":\"Trigger\"},{\"name\":\"patchId\",\"value\":\"2rrm8wjyi\"}],\"portsOut\":[{\"name\":\"z5ocj0lq6\",\"title\":\"Trigger\",\"links\":[{\"portIn\":\"Execute\",\"portOut\":\"z5ocj0lq6\",\"objIn\":\"sp6-40\",\"objOut\":\"sp6-168\"}]}],\"objName\":\"Ops.Patch.PLH3vXR.CameraAnimated\"},{\"id\":\"sp6-169\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2,\"subPatchVer\":2},\"portsIn\":[{\"name\":\"mbmposg49\",\"title\":\"Trigger\"},{\"name\":\"patchId\",\"value\":\"bqqs1lcf5\"}],\"portsOut\":[{\"name\":\"z5ocj0lq6\",\"title\":\"Trigger\",\"links\":[{\"portIn\":\"Render\",\"portOut\":\"z5ocj0lq6\",\"objIn\":\"sp6-8\",\"objOut\":\"sp6-169\"}]}],\"objName\":\"Ops.Patch.PLH3vXR.CameraAnimated\"},{\"id\":\"sp6-170\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2,\"subPatchVer\":2},\"portsIn\":[{\"name\":\"mbmposg49\",\"title\":\"Trigger\"},{\"name\":\"patchId\",\"value\":\"ey0r9uuh8\"}],\"portsOut\":[{\"name\":\"z5ocj0lq6\",\"title\":\"Trigger\",\"links\":[{\"portIn\":\"exe\",\"portOut\":\"z5ocj0lq6\",\"objIn\":\"sp6-149\",\"objOut\":\"sp6-170\"}]}],\"objName\":\"Ops.Patch.PLH3vXR.CameraAnimated\"},{\"id\":\"sp6-171\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"Gradient\",\"value\":\"{\\\"keys\\\":[{\\\"pos\\\":0,\\\"posy\\\":0.51,\\\"r\\\":0.9294117647058824,\\\"g\\\":0.5137254901960784,\\\"b\\\":0.43137254901960786},{\\\"pos\\\":0.0234375,\\\"posy\\\":0.51,\\\"r\\\":0.9294117647058824,\\\"g\\\":0.5137254901960784,\\\"b\\\":0.43137254901960786},{\\\"pos\\\":0.2265625,\\\"posy\\\":0.56,\\\"r\\\":0.21490885416666672,\\\"g\\\":0.12095060730189613,\\\"b\\\":0.06614162996411325},{\\\"pos\\\":0.435546875,\\\"posy\\\":0.57,\\\"r\\\":0.6627450980392157,\\\"g\\\":0.36627450980392157,\\\"b\\\":0.3333333333333333},{\\\"pos\\\":0.6328125,\\\"posy\\\":0.6,\\\"r\\\":0.9163411458333334,\\\"g\\\":0.602397546172142,\\\"b\\\":0.5239116462568442},{\\\"pos\\\":0.767578125,\\\"posy\\\":0.51,\\\"r\\\":0.9379231770833333,\\\"g\\\":0.7690338502859786,\\\"b\\\":0.7014781195670367},{\\\"pos\\\":0.875,\\\"posy\\\":0.66,\\\"r\\\":1,\\\"g\\\":1,\\\"b\\\":1},{\\\"pos\\\":1,\\\"posy\\\":0.66,\\\"r\\\":1,\\\"g\\\":1,\\\"b\\\":1}]}\"},{\"name\":\"Direction index\",\"value\":0},{\"name\":\"Direction\",\"value\":\"X\"},{\"name\":\"Smoothstep\",\"value\":1},{\"name\":\"Step\",\"value\":0},{\"name\":\"Flip\",\"value\":0},{\"name\":\"sRGB\",\"value\":0},{\"name\":\"Oklab\",\"value\":0},{\"name\":\"Size\",\"value\":256},{\"name\":\"filter index\",\"value\":1},{\"name\":\"filter\",\"value\":\"linear\"},{\"name\":\"wrap index\",\"value\":0},{\"name\":\"wrap\",\"value\":\"clamp to edge\"},{\"name\":\"Dither\",\"value\":0},{\"name\":\"Gradient Array\",\"value\":0}],\"portsOut\":[{\"name\":\"Texture\",\"links\":[{\"portIn\":\"object port 0\",\"portOut\":\"Texture\",\"objIn\":\"sp6-70\",\"objOut\":\"sp6-171\"}]}],\"objName\":\"Ops.Gl.GradientTexture\"},{\"id\":\"sp6-172\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"Gradient\",\"value\":\"{\\\"keys\\\":[{\\\"pos\\\":0,\\\"posy\\\":0.51,\\\"r\\\":0.61650390625,\\\"g\\\":0.61650390625,\\\"b\\\":0.61650390625},{\\\"pos\\\":0.0234375,\\\"posy\\\":0.51,\\\"r\\\":0.61650390625,\\\"g\\\":0.61650390625,\\\"b\\\":0.61650390625},{\\\"pos\\\":0.126953125,\\\"posy\\\":0.34,\\\"r\\\":0.83427734375,\\\"g\\\":0.83427734375,\\\"b\\\":0.83427734375},{\\\"pos\\\":0.271484375,\\\"posy\\\":0.64,\\\"r\\\":0.3940104166666667,\\\"g\\\":0.3940104166666667,\\\"b\\\":0.3940104166666667},{\\\"pos\\\":0.494140625,\\\"posy\\\":0.63,\\\"r\\\":0.63330078125,\\\"g\\\":0.63330078125,\\\"b\\\":0.63330078125},{\\\"pos\\\":0.640625,\\\"posy\\\":0.1,\\\"r\\\":0.8588541666666667,\\\"g\\\":0.8588541666666667,\\\"b\\\":0.8588541666666667},{\\\"pos\\\":0.912109375,\\\"posy\\\":0.52,\\\"r\\\":1,\\\"g\\\":1,\\\"b\\\":1},{\\\"pos\\\":1,\\\"posy\\\":0.52,\\\"r\\\":1,\\\"g\\\":1,\\\"b\\\":1}]}\"},{\"name\":\"Direction index\",\"value\":0},{\"name\":\"Direction\",\"value\":\"X\"},{\"name\":\"Smoothstep\",\"value\":1},{\"name\":\"Step\",\"value\":0},{\"name\":\"Flip\",\"value\":0},{\"name\":\"sRGB\",\"value\":0},{\"name\":\"Oklab\",\"value\":0},{\"name\":\"Size\",\"value\":256},{\"name\":\"filter index\",\"value\":1},{\"name\":\"filter\",\"value\":\"linear\"},{\"name\":\"wrap index\",\"value\":0},{\"name\":\"wrap\",\"value\":\"clamp to edge\"},{\"name\":\"Dither\",\"value\":0},{\"name\":\"Gradient Array\",\"value\":0}],\"portsOut\":[{\"name\":\"Texture\",\"links\":[{\"portIn\":\"object port 1\",\"portOut\":\"Texture\",\"objIn\":\"sp6-70\",\"objOut\":\"sp6-172\"}]}],\"objName\":\"Ops.Gl.GradientTexture\"},{\"id\":\"sp6-173\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"Gradient\",\"value\":\"{\\\"keys\\\":[{\\\"pos\\\":0,\\\"posy\\\":0.47,\\\"r\\\":0.49785156249999996,\\\"g\\\":0.3838319142790217,\\\"b\\\":0.016435270011425016},{\\\"pos\\\":0.025390625,\\\"posy\\\":0.47,\\\"r\\\":0.49785156249999996,\\\"g\\\":0.3838319142790217,\\\"b\\\":0.016435270011425016},{\\\"pos\\\":0.220703125,\\\"posy\\\":0.7,\\\"r\\\":0.25611979166666665,\\\"g\\\":0.21120218365800145,\\\"b\\\":0.07990456024805705},{\\\"pos\\\":0.474609375,\\\"posy\\\":0.76,\\\"r\\\":0.5665690104166667,\\\"g\\\":0.3949108444030572,\\\"b\\\":0.04373152678211531},{\\\"pos\\\":0.619140625,\\\"posy\\\":0.27,\\\"r\\\":0.9229166666666666,\\\"g\\\":0.8126879861212183,\\\"b\\\":0.2295427083969116},{\\\"pos\\\":0.73828125,\\\"posy\\\":0.6,\\\"r\\\":0.9372549019607843,\\\"g\\\":0.9235654105392156,\\\"b\\\":0.6980392156862745},{\\\"pos\\\":0.9296875,\\\"posy\\\":0.38,\\\"r\\\":0.989453125,\\\"g\\\":0.9540763370037894,\\\"b\\\":0.6700013533234597},{\\\"pos\\\":1,\\\"posy\\\":0.38,\\\"r\\\":0.989453125,\\\"g\\\":0.9540763370037894,\\\"b\\\":0.6700013533234597}]}\"},{\"name\":\"Direction index\",\"value\":0},{\"name\":\"Direction\",\"value\":\"X\"},{\"name\":\"Smoothstep\",\"value\":1},{\"name\":\"Step\",\"value\":0},{\"name\":\"Flip\",\"value\":0},{\"name\":\"sRGB\",\"value\":0},{\"name\":\"Oklab\",\"value\":0},{\"name\":\"Size\",\"value\":256},{\"name\":\"filter index\",\"value\":1},{\"name\":\"filter\",\"value\":\"linear\"},{\"name\":\"wrap index\",\"value\":0},{\"name\":\"wrap\",\"value\":\"clamp to edge\"},{\"name\":\"Dither\",\"value\":0},{\"name\":\"Gradient Array\",\"value\":0}],\"portsOut\":[{\"name\":\"Texture\",\"links\":[{\"portIn\":\"object port 2\",\"portOut\":\"Texture\",\"objIn\":\"sp6-70\",\"objOut\":\"sp6-173\"}]}],\"objName\":\"Ops.Gl.GradientTexture\"},{\"id\":\"sp6-174\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsOut\":[{\"name\":\"Next\",\"links\":[{\"portIn\":\"render\",\"portOut\":\"Next\",\"objIn\":\"sp6-11\",\"objOut\":\"sp6-174\"}]}],\"objName\":\"Ops.Gl.Matrix.Billboard\"},{\"id\":\"sp6-175\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"Animation\",\"value\":1},{\"name\":\"API Range Min\",\"value\":0},{\"name\":\"API Range Max\",\"value\":1}],\"portsOut\":[{\"name\":\"Point List\",\"links\":[{\"portIn\":\"Points\",\"portOut\":\"Point List\",\"objIn\":\"sp6-74\",\"objOut\":\"sp6-175\"}]},{\"name\":\"Colorful Point List\",\"links\":[{\"portIn\":\"Points\",\"portOut\":\"Colorful Point List\",\"objIn\":\"sp6-7\",\"objOut\":\"sp6-175\"}]},{\"name\":\"Bar List\",\"links\":[{\"portIn\":\"Array 0\",\"portOut\":\"Bar List\",\"objIn\":\"sp6-37\",\"objOut\":\"sp6-175\"}]},{\"name\":\"Bar Size List\",\"links\":[{\"portIn\":\"Array 0\",\"portOut\":\"Bar Size List\",\"objIn\":\"sp6-38\",\"objOut\":\"sp6-175\"}]},{\"name\":\"Bar Anim List\",\"links\":[{\"portIn\":\"Array 0\",\"portOut\":\"Bar Anim List\",\"objIn\":\"sp6-114\",\"objOut\":\"sp6-175\"}]},{\"name\":\"Geometry\",\"links\":[{\"portIn\":\"Geometry\",\"portOut\":\"Geometry\",\"objIn\":\"sp6-33\",\"objOut\":\"sp6-175\"}]},{\"name\":\"Current Animation Point\",\"links\":[{\"portIn\":\"innerIn_gr5rfgt62\",\"portOut\":\"Current Animation Point\",\"objIn\":\"sp6-1\",\"objOut\":\"sp6-175\"}]}],\"objName\":\"Ops.Patch.PLH3vXR.AnimationPointsGenerator_SingleLayer\"},{\"id\":\"sp6-176\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"Blend Mode index\",\"value\":0},{\"name\":\"Blend Mode\",\"value\":\"normal\"},{\"name\":\"Alpha Mask index\",\"value\":1},{\"name\":\"Alpha Mask\",\"value\":\"On\"},{\"name\":\"Mask Invert\",\"value\":0},{\"name\":\"A\",\"value\":1}],\"objName\":\"Ops.Gl.ImageCompose.Color_v2\"},{\"id\":\"sp6-177\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"Size index\",\"value\":0},{\"name\":\"Size\",\"value\":\"Auto\"},{\"name\":\"Width\",\"value\":640},{\"name\":\"Height\",\"value\":480},{\"name\":\"Filter index\",\"value\":1},{\"name\":\"Filter\",\"value\":\"linear\"},{\"name\":\"Wrap index\",\"value\":1},{\"name\":\"Wrap\",\"value\":\"repeat\"},{\"name\":\"Anisotropic index\",\"value\":0},{\"name\":\"Anisotropic\",\"value\":\"0\"},{\"name\":\"Pixel Format index\",\"value\":4},{\"name\":\"Pixel Format\",\"value\":\"RGBA 8bit ubyte\"},{\"name\":\"Clear\",\"value\":1},{\"name\":\"R\",\"value\":0},{\"name\":\"G\",\"value\":0},{\"name\":\"B\",\"value\":0},{\"name\":\"A\",\"value\":0}],\"portsOut\":[{\"name\":\"Next\",\"links\":[{\"portIn\":\"Render\",\"portOut\":\"Next\",\"objIn\":\"sp6-178\",\"objOut\":\"sp6-177\"}]},{\"name\":\"texture_out\",\"links\":[{\"portIn\":\"Texture\",\"portOut\":\"texture_out\",\"objIn\":\"sp6-90\",\"objOut\":\"sp6-177\"}]},{\"name\":\"Aspect Ratio\",\"value\":1.0338849487785657},{\"name\":\"Texture Width\",\"value\":1312},{\"name\":\"Texture Height\",\"value\":1269}],\"objName\":\"Ops.Gl.ImageCompose.ImageCompose_v4\"},{\"id\":\"sp6-178\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"Method index\",\"value\":3},{\"name\":\"Method\",\"value\":\"Mul\"},{\"name\":\"Clamp\",\"value\":1}],\"objName\":\"Ops.Gl.ImageCompose.Alpha\"},{\"id\":\"sp6-179\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"Variable\",\"value\":\"Animation\"}],\"portsOut\":[{\"name\":\"Value\",\"links\":[{\"portIn\":\"ul3e7qngs\",\"portOut\":\"Value\",\"objIn\":\"sp6-181\",\"objOut\":\"sp6-179\"},{\"portIn\":\"ul3e7qngs\",\"portOut\":\"Value\",\"objIn\":\"sp6-182\",\"objOut\":\"sp6-179\"}]}],\"objName\":\"Ops.Vars.VarGetNumber_v2\"},{\"id\":\"sp6-180\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"Variable\",\"value\":\"AnimationTurningPoint\"}],\"portsOut\":[{\"name\":\"Value\",\"links\":[{\"portIn\":\"4wxi8etyc\",\"portOut\":\"Value\",\"objIn\":\"sp6-181\",\"objOut\":\"sp6-180\"},{\"portIn\":\"4wxi8etyc\",\"portOut\":\"Value\",\"objIn\":\"sp6-182\",\"objOut\":\"sp6-180\"}]}],\"objName\":\"Ops.Vars.VarGetNumber_v2\"},{\"id\":\"sp6-181\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2,\"subPatchVer\":2},\"portsIn\":[{\"name\":\"ul3e7qngs\",\"title\":\"Animation\"},{\"name\":\"4wxi8etyc\",\"title\":\"Turning Point\"},{\"name\":\"7ry50s9p2\",\"value\":0.4,\"title\":\"Value Start\"},{\"name\":\"dw634vl53\",\"value\":0.4,\"title\":\"Value Turning\"},{\"name\":\"xafw2raho\",\"value\":1,\"title\":\"Value End\"},{\"name\":\"patchId\",\"value\":\"d0bxgaa1x\"}],\"portsOut\":[{\"name\":\"oud37e362\",\"title\":\"Value\",\"links\":[{\"portIn\":\"Amount\",\"portOut\":\"oud37e362\",\"objIn\":\"sp6-178\",\"objOut\":\"sp6-181\"}]}],\"objName\":\"Ops.Patch.PLH3vXR.TwoStepAniamation\"},{\"id\":\"sp6-182\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2,\"subPatchVer\":2},\"portsIn\":[{\"name\":\"ul3e7qngs\",\"title\":\"Animation\"},{\"name\":\"4wxi8etyc\",\"title\":\"Turning Point\"},{\"name\":\"7ry50s9p2\",\"value\":1,\"title\":\"Value Start\"},{\"name\":\"dw634vl53\",\"value\":1,\"title\":\"Value Turning\"},{\"name\":\"xafw2raho\",\"value\":0,\"title\":\"Value End\"},{\"name\":\"patchId\",\"value\":\"615xghat4\"}],\"portsOut\":[{\"name\":\"oud37e362\",\"title\":\"Value\",\"links\":[{\"portIn\":\"Amount\",\"portOut\":\"oud37e362\",\"objIn\":\"sp6-176\",\"objOut\":\"sp6-182\"}]}],\"objName\":\"Ops.Patch.PLH3vXR.TwoStepAniamation\"},{\"id\":\"sp6-183\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"Variable\",\"value\":\"Animation\"}],\"portsOut\":[{\"name\":\"Value\",\"links\":[{\"portIn\":\"ul3e7qngs\",\"portOut\":\"Value\",\"objIn\":\"sp6-185\",\"objOut\":\"sp6-183\"}]}],\"objName\":\"Ops.Vars.VarGetNumber_v2\"},{\"id\":\"sp6-184\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"Variable\",\"value\":\"AnimationTurningPoint\"}],\"portsOut\":[{\"name\":\"Value\",\"links\":[{\"portIn\":\"4wxi8etyc\",\"portOut\":\"Value\",\"objIn\":\"sp6-185\",\"objOut\":\"sp6-184\"}]}],\"objName\":\"Ops.Vars.VarGetNumber_v2\"},{\"id\":\"sp6-185\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2,\"subPatchVer\":2},\"portsIn\":[{\"name\":\"ul3e7qngs\",\"title\":\"Animation\"},{\"name\":\"4wxi8etyc\",\"title\":\"Turning Point\"},{\"name\":\"7ry50s9p2\",\"value\":0,\"title\":\"Value Start\"},{\"name\":\"dw634vl53\",\"value\":0,\"title\":\"Value Turning\"},{\"name\":\"xafw2raho\",\"value\":1,\"title\":\"Value End\"},{\"name\":\"patchId\",\"value\":\"qy0rnyjvb\"}],\"portsOut\":[{\"name\":\"oud37e362\",\"title\":\"Value\",\"links\":[{\"portIn\":\"Amount\",\"portOut\":\"oud37e362\",\"objIn\":\"sp6-131\",\"objOut\":\"sp6-185\"}]}],\"objName\":\"Ops.Patch.PLH3vXR.TwoStepAniamation\"},{\"id\":\"sp6-186\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"Number\",\"value\":0}],\"portsOut\":[{\"name\":\"Result\",\"links\":[{\"portIn\":\"Depth\",\"portOut\":\"Result\",\"objIn\":\"sp6-100\",\"objOut\":\"sp6-186\"}]}],\"objName\":\"Ops.Ui.VizNumber\"},{\"id\":\"sp6-187\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{},\"portsIn\":[{\"name\":\"Variable\",\"value\":\"BarCount\"}],\"portsOut\":[{\"name\":\"Value\",\"links\":[{\"portIn\":\"Index End\",\"portOut\":\"Value\",\"objIn\":\"sp6-195\",\"objOut\":\"sp6-187\"}]}],\"objName\":\"Ops.Vars.VarGetNumber_v2\"},{\"id\":\"sp6-188\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"Variable\",\"value\":\"ImageSetBaseURL\"}],\"portsOut\":[{\"name\":\"Value\",\"links\":[{\"portIn\":\"string 0\",\"portOut\":\"Value\",\"objIn\":\"sp6-196\",\"objOut\":\"sp6-188\"}]}],\"objName\":\"Ops.Vars.VarGetString\"},{\"id\":\"sp6-189\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{},\"portsIn\":[{\"name\":\"value\",\"value\":\"china\\noverseas\\nglobal\\nothers\"},{\"name\":\"Syntax index\",\"value\":0},{\"name\":\"Syntax\",\"value\":\"text\"}],\"portsOut\":[{\"name\":\"Result\",\"links\":[{\"portIn\":\"text\",\"portOut\":\"Result\",\"objIn\":\"sp6-190\",\"objOut\":\"sp6-189\"},{\"portIn\":\"String\",\"portOut\":\"Result\",\"objIn\":\"sp6-192\",\"objOut\":\"sp6-189\"}]}],\"objName\":\"Ops.String.StringEditor\"},{\"id\":\"sp6-190\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{},\"portsIn\":[{\"name\":\"separator\",\"value\":\"\"},{\"name\":\"Numbers\",\"value\":0},{\"name\":\"Trim\",\"value\":1},{\"name\":\"Split Lines\",\"value\":1}],\"portsOut\":[{\"name\":\"array\",\"links\":[{\"portIn\":\"array\",\"portOut\":\"array\",\"objIn\":\"sp6-191\",\"objOut\":\"sp6-190\"}]},{\"name\":\"length\",\"value\":4}],\"objName\":\"Ops.Array.StringToArray_v2\"},{\"id\":\"sp6-191\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{},\"portsOut\":[{\"name\":\"result\",\"links\":[{\"portIn\":\"string 2\",\"portOut\":\"result\",\"objIn\":\"sp6-196\",\"objOut\":\"sp6-191\"}]}],\"objName\":\"Ops.Array.ArrayGetString\"},{\"id\":\"sp6-192\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{},\"portsIn\":[{\"name\":\"ZoomText\",\"value\":0},{\"name\":\"Line Numbers\",\"value\":1},{\"name\":\"Whitespace\",\"value\":0},{\"name\":\"Wrap lines\",\"value\":1},{\"name\":\"Syntax index\",\"value\":0},{\"name\":\"Syntax\",\"value\":\"text\"},{\"name\":\"Font Size\",\"value\":10},{\"name\":\"Scroll\",\"value\":0}],\"portsOut\":[{\"name\":\"Passthrough String\",\"value\":\"china\\noverseas\\nglobal\\nothers\"}],\"objName\":\"Ops.Ui.VizString\"},{\"id\":\"sp6-193\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"bounds\",\"value\":1},{\"name\":\"Axis index\",\"value\":2},{\"name\":\"Axis\",\"value\":\"None\"},{\"name\":\"frustum near\",\"value\":-100},{\"name\":\"frustum far\",\"value\":100}],\"portsOut\":[{\"name\":\"trigger\",\"links\":[{\"portIn\":\"Execute\",\"portOut\":\"trigger\",\"objIn\":\"sp6-54\",\"objOut\":\"sp6-193\"}]},{\"name\":\"Ratio\",\"value\":1},{\"name\":\"Width\",\"value\":2},{\"name\":\"Height\",\"value\":2}],\"objName\":\"Ops.Gl.Orthogonal_v2\"},{\"id\":\"sp6-194\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"r\",\"value\":0.9882352941176471},{\"name\":\"g\",\"value\":0.7843137254901962},{\"name\":\"b\",\"value\":0.3333333333333333},{\"name\":\"a\",\"value\":1}],\"portsOut\":[{\"name\":\"outr\",\"links\":[{\"portIn\":\"Value 1\",\"portOut\":\"outr\",\"objIn\":\"sp6-79\",\"objOut\":\"sp6-194\"}]},{\"name\":\"outg\",\"links\":[{\"portIn\":\"Value 1\",\"portOut\":\"outg\",\"objIn\":\"sp6-80\",\"objOut\":\"sp6-194\"}]},{\"name\":\"outb\",\"links\":[{\"portIn\":\"Value 1\",\"portOut\":\"outb\",\"objIn\":\"sp6-81\",\"objOut\":\"sp6-194\"}]},{\"name\":\"outa\",\"value\":1},{\"name\":\"Hex\",\"value\":\"FCC855\"}],\"objName\":\"Ops.Color.ColorValue\"},{\"id\":\"sp6-195\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{},\"portsIn\":[{\"name\":\"Left Pad\",\"value\":0},{\"name\":\"Num Digits\",\"value\":3},{\"name\":\"Index Start\",\"value\":1},{\"name\":\"filter index\",\"value\":1},{\"name\":\"filter\",\"value\":\"linear\"},{\"name\":\"wrap index\",\"value\":0},{\"name\":\"wrap\",\"value\":\"repeat\"},{\"name\":\"Flip\",\"value\":0},{\"name\":\"unpackPreMultipliedAlpha\",\"value\":0}],\"portsOut\":[{\"name\":\"TextureArray\",\"links\":[{\"portIn\":\"array\",\"portOut\":\"TextureArray\",\"objIn\":\"sp6-15\",\"objOut\":\"sp6-195\"},{\"portIn\":\"Texture Array\",\"portOut\":\"TextureArray\",\"objIn\":\"sp6-17\",\"objOut\":\"sp6-195\"}]},{\"name\":\"Width\",\"value\":128},{\"name\":\"Height\",\"value\":276},{\"name\":\"Loading\",\"links\":[{\"portIn\":\"innerIn_7lfhdhs5x\",\"portOut\":\"Loading\",\"objIn\":\"sp6-1\",\"objOut\":\"sp6-195\"}]},{\"name\":\"Aspect Ratio\",\"value\":0.463768115942029}],\"objName\":\"Ops.Gl.TextureArrayLoader_v2\"},{\"id\":\"sp6-196\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{},\"portsIn\":[{\"name\":\"string 1\",\"value\":\"/\"},{\"name\":\"string 3\",\"value\":\"/X.png\"},{\"name\":\"string 4\",\"value\":\"\"},{\"name\":\"string 5\",\"value\":\"\"},{\"name\":\"string 6\",\"value\":\"\"},{\"name\":\"string 7\",\"value\":\"\"},{\"name\":\"add spaces\",\"value\":0},{\"name\":\"new lines\",\"value\":0}],\"portsOut\":[{\"name\":\"concat string\",\"links\":[{\"portIn\":\"Url\",\"portOut\":\"concat string\",\"objIn\":\"sp6-195\",\"objOut\":\"sp6-196\"}]}],\"objName\":\"Ops.String.ConcatMulti_v2\"},{\"id\":\"sp6-197\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{},\"portsIn\":[{\"name\":\"Variable\",\"value\":\"LayerOffset\"}],\"portsOut\":[{\"name\":\"Value\",\"links\":[{\"portIn\":\"number2\",\"portOut\":\"Value\",\"objIn\":\"sp6-206\",\"objOut\":\"sp6-197\"}]}],\"objName\":\"Ops.Vars.VarGetNumber_v2\"},{\"id\":\"sp6-198\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{},\"portsIn\":[{\"name\":\"number2\",\"value\":0.5}],\"portsOut\":[{\"name\":\"result\",\"links\":[{\"portIn\":\"number1\",\"portOut\":\"result\",\"objIn\":\"sp6-203\",\"objOut\":\"sp6-198\"}]}],\"objName\":\"Ops.Math.Sum\"},{\"id\":\"sp6-199\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{\"blueprintVer\":2},\"portsOut\":[{\"name\":\"Result\",\"links\":[{\"portIn\":\"number1\",\"portOut\":\"Result\",\"objIn\":\"sp6-198\",\"objOut\":\"sp6-199\"}]}],\"objName\":\"Ops.Ui.VizNumber\"},{\"id\":\"sp6-200\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{},\"portsIn\":[{\"name\":\"Variable\",\"value\":\"BarCount\"}],\"portsOut\":[{\"name\":\"Value\",\"links\":[{\"portIn\":\"number2\",\"portOut\":\"Value\",\"objIn\":\"sp6-201\",\"objOut\":\"sp6-200\"}]}],\"objName\":\"Ops.Vars.VarGetNumber_v2\"},{\"id\":\"sp6-201\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{},\"portsIn\":[{\"name\":\"number1\",\"value\":1}],\"portsOut\":[{\"name\":\"result\",\"links\":[{\"portIn\":\"number1\",\"portOut\":\"result\",\"objIn\":\"sp6-202\",\"objOut\":\"sp6-201\"},{\"portIn\":\"number2\",\"portOut\":\"result\",\"objIn\":\"sp6-204\",\"objOut\":\"sp6-201\"}]}],\"objName\":\"Ops.Math.Divide\"},{\"id\":\"sp6-202\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{},\"portsIn\":[{\"name\":\"number2\",\"value\":5}],\"portsOut\":[{\"name\":\"result\",\"links\":[{\"portIn\":\"number2\",\"portOut\":\"result\",\"objIn\":\"sp6-203\",\"objOut\":\"sp6-202\"}]}],\"objName\":\"Ops.Math.Divide\"},{\"id\":\"sp6-203\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{},\"portsOut\":[{\"name\":\"result\",\"links\":[{\"portIn\":\"number1\",\"portOut\":\"result\",\"objIn\":\"sp6-205\",\"objOut\":\"sp6-203\"}]}],\"objName\":\"Ops.Math.Multiply\"},{\"id\":\"sp6-204\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{},\"portsIn\":[{\"name\":\"number1\",\"value\":0.5}],\"portsOut\":[{\"name\":\"result\",\"links\":[{\"portIn\":\"number2\",\"portOut\":\"result\",\"objIn\":\"sp6-205\",\"objOut\":\"sp6-204\"}]}],\"objName\":\"Ops.Math.Multiply\"},{\"id\":\"sp6-205\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{},\"portsOut\":[{\"name\":\"result\",\"links\":[{\"portIn\":\"number1\",\"portOut\":\"result\",\"objIn\":\"sp6-206\",\"objOut\":\"sp6-205\"}]}],\"objName\":\"Ops.Math.Subtract\"},{\"id\":\"sp6-206\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{},\"portsOut\":[{\"name\":\"result\",\"links\":[{\"portIn\":\"number2\",\"portOut\":\"result\",\"objIn\":\"sp6-207\",\"objOut\":\"sp6-206\"}]}],\"objName\":\"Ops.Math.Multiply\"},{\"id\":\"sp6-207\",\"uiAttribs\":{\"subPatch\":\"ordl9jqj0\"},\"storage\":{},\"portsOut\":[{\"name\":\"result\",\"links\":[{\"portIn\":\"posX\",\"portOut\":\"result\",\"objIn\":\"sp6-9\",\"objOut\":\"sp6-207\"}]}],\"objName\":\"Ops.Math.Sum\"}]}",};
const port_8kld546qj=op.inFloat("8kld546qj",0);
port_8kld546qj.setUiAttribs({title:"Layer Index",});
port_8kld546qj.setUiAttribs({"values":[""]});

const port_d288224z4=op.inArray("d288224z4");
port_d288224z4.setUiAttribs({title:"API Data",});

const port_lfi6e6fmy=op.inArray("lfi6e6fmy");
port_lfi6e6fmy.setUiAttribs({title:"ImagePathList",});
port_lfi6e6fmy.setUiAttribs({"values":[""]});

const port_hho85lkjc=op.inArray("hho85lkjc");
port_hho85lkjc.setUiAttribs({title:"ImagePathList_SecondLayer",});
port_hho85lkjc.setUiAttribs({"values":[""]});

const port_p8xx9jp8e=op.inTrigger("p8xx9jp8e");
port_p8xx9jp8e.setUiAttribs({title:"RenderToWorld",});
port_p8xx9jp8e.setUiAttribs({"values":[""]});

const port_x8q9h17ke=op.inTrigger("x8q9h17ke");
port_x8q9h17ke.setUiAttribs({title:"RenderToTexture_Building",});
port_x8q9h17ke.setUiAttribs({"values":[""]});

const port_traw627xa=op.inTrigger("traw627xa");
port_traw627xa.setUiAttribs({title:"RenderToTexture_Line",});
port_traw627xa.setUiAttribs({"values":[""]});

const port_xoahcr8lh=op.inFloat("xoahcr8lh",0);
port_xoahcr8lh.setUiAttribs({title:"ShowDebug",display:"bool",});
port_xoahcr8lh.setUiAttribs({"values":[""]});

const port_xkk55pzq0=op.inFloat("xkk55pzq0",0);
port_xkk55pzq0.setUiAttribs({title:"LayerInterval",});
port_xkk55pzq0.setUiAttribs({"values":[""]});

const port_00mtr84dk=op.inFloat("00mtr84dk",0);
port_00mtr84dk.setUiAttribs({title:"ImageIntervalX",});
port_00mtr84dk.setUiAttribs({"values":[""]});

const port_rxdonrolr=op.inFloat("rxdonrolr",0);
port_rxdonrolr.setUiAttribs({title:"ImageIntervalZ",});
port_rxdonrolr.setUiAttribs({"values":[""]});

const port_k39iw7qf1=op.inArray("k39iw7qf1");
port_k39iw7qf1.setUiAttribs({title:"IndicatorArray_Iconic",});
port_k39iw7qf1.setUiAttribs({"values":[""]});

const port_v17tbxwpy=op.inArray("v17tbxwpy");
port_v17tbxwpy.setUiAttribs({title:"IndicatorArray_Generic",});
port_v17tbxwpy.setUiAttribs({"values":[""]});

const port_dobslg7sf=op.inTrigger("dobslg7sf");
port_dobslg7sf.setUiAttribs({title:"Trigger",});
port_dobslg7sf.setUiAttribs({"values":[""]});

const port_earjb46wu=op.inObject("earjb46wu");
port_earjb46wu.setUiAttribs({title:"GradientMap_ForBuilding",display:"texture",objType:"texture",objType:"texture"});
port_earjb46wu.setUiAttribs({"values":[""]});

const port_1er6wsd99=op.inObject("1er6wsd99");
port_1er6wsd99.setUiAttribs({title:"GradientMap_ForMask",display:"texture",objType:"texture",objType:"texture"});
port_1er6wsd99.setUiAttribs({"values":[""]});

const port_ga4abt9us=op.inObject("ga4abt9us");
port_ga4abt9us.setUiAttribs({title:"BoundsMask",display:"texture",objType:"texture",objType:"texture"});
port_ga4abt9us.setUiAttribs({"values":[""]});

const port_ge8is9nye=op.outTrigger("ge8is9nye");
port_ge8is9nye.setUiAttribs({title:"RenderToWorld",});
port_ge8is9nye.setUiAttribs({"values":[""]});

const port_cc3tea9q0=op.outTrigger("cc3tea9q0");
port_cc3tea9q0.setUiAttribs({title:"RenderToTexture_Building",});
port_cc3tea9q0.setUiAttribs({"values":[""]});

const port_wc7us54fg=op.outTrigger("wc7us54fg");
port_wc7us54fg.setUiAttribs({title:"RenderToTexture_Line",});
port_wc7us54fg.setUiAttribs({"values":[""]});

const port_740vm05xs=op.outArray("740vm05xs");
port_740vm05xs.setUiAttribs({title:"IndicatorArray_Iconic",});
port_740vm05xs.setUiAttribs({"values":[""]});

const port_vh2f15cw8=op.outArray("vh2f15cw8");
port_vh2f15cw8.setUiAttribs({title:"IndicatorArray_Generic",});
port_vh2f15cw8.setUiAttribs({"values":[""]});

const port_3cpnu6igj=op.outArray("3cpnu6igj");
port_3cpnu6igj.setUiAttribs({title:"ImageList",});
port_3cpnu6igj.setUiAttribs({"values":[""]});

const port_jycvtf89b=op.outObject("jycvtf89b");
port_jycvtf89b.setUiAttribs({title:"BuildingTexture",display:"texture",objType:"texture",objType:"texture"});
port_jycvtf89b.setUiAttribs({"values":[""]});

const port_el1t5zxr9=op.outObject("el1t5zxr9");
port_el1t5zxr9.setUiAttribs({title:"LineTexture",display:"texture",objType:"texture",objType:"texture"});
port_el1t5zxr9.setUiAttribs({"values":[""]});

const port_7lfhdhs5x=op.outNumber("7lfhdhs5x");
port_7lfhdhs5x.setUiAttribs({title:"IsLoading",display:"bool",});
port_7lfhdhs5x.setUiAttribs({"values":[""]});

const port_gr5rfgt62=op.outArray("gr5rfgt62");
port_gr5rfgt62.setUiAttribs({title:"CurrentAnimationPoint",});
port_gr5rfgt62.setUiAttribs({"values":[""]});

op.initInnerPorts=function(addedOps)
{
  for(let i=0;i<addedOps.length;i++)
  {
    if(addedOps[i].innerInput)
    {
const innerOut_8kld546qj = addedOps[i].outNumber("innerOut_8kld546qj");
innerOut_8kld546qj.set(port_8kld546qj.get() );
innerOut_8kld546qj.setUiAttribs({title:"Layer Index"});
port_8kld546qj.on("change", (a,v) => { innerOut_8kld546qj.set(a); });

const innerOut_d288224z4 = addedOps[i].outArray("innerOut_d288224z4");
innerOut_d288224z4.setUiAttribs({title:"API Data"});
port_d288224z4.on("change", (a,v) => { innerOut_d288224z4.setRef(a); });

const innerOut_lfi6e6fmy = addedOps[i].outArray("innerOut_lfi6e6fmy");
innerOut_lfi6e6fmy.setUiAttribs({title:"ImagePathList"});
port_lfi6e6fmy.on("change", (a,v) => { innerOut_lfi6e6fmy.setRef(a); });

const innerOut_hho85lkjc = addedOps[i].outArray("innerOut_hho85lkjc");
innerOut_hho85lkjc.setUiAttribs({title:"ImagePathList_SecondLayer"});
port_hho85lkjc.on("change", (a,v) => { innerOut_hho85lkjc.setRef(a); });

const innerOut_p8xx9jp8e = addedOps[i].outTrigger("innerOut_p8xx9jp8e");
innerOut_p8xx9jp8e.setUiAttribs({title:"RenderToWorld"});
port_p8xx9jp8e.onTriggered = () => { innerOut_p8xx9jp8e.trigger(); };

const innerOut_x8q9h17ke = addedOps[i].outTrigger("innerOut_x8q9h17ke");
innerOut_x8q9h17ke.setUiAttribs({title:"RenderToTexture_Building"});
port_x8q9h17ke.onTriggered = () => { innerOut_x8q9h17ke.trigger(); };

const innerOut_traw627xa = addedOps[i].outTrigger("innerOut_traw627xa");
innerOut_traw627xa.setUiAttribs({title:"RenderToTexture_Line"});
port_traw627xa.onTriggered = () => { innerOut_traw627xa.trigger(); };

const innerOut_xoahcr8lh = addedOps[i].outNumber("innerOut_xoahcr8lh");
innerOut_xoahcr8lh.set(port_xoahcr8lh.get() );
innerOut_xoahcr8lh.setUiAttribs({title:"ShowDebug"});
port_xoahcr8lh.on("change", (a,v) => { innerOut_xoahcr8lh.set(a); });

const innerOut_xkk55pzq0 = addedOps[i].outNumber("innerOut_xkk55pzq0");
innerOut_xkk55pzq0.set(port_xkk55pzq0.get() );
innerOut_xkk55pzq0.setUiAttribs({title:"LayerInterval"});
port_xkk55pzq0.on("change", (a,v) => { innerOut_xkk55pzq0.set(a); });

const innerOut_00mtr84dk = addedOps[i].outNumber("innerOut_00mtr84dk");
innerOut_00mtr84dk.set(port_00mtr84dk.get() );
innerOut_00mtr84dk.setUiAttribs({title:"ImageIntervalX"});
port_00mtr84dk.on("change", (a,v) => { innerOut_00mtr84dk.set(a); });

const innerOut_rxdonrolr = addedOps[i].outNumber("innerOut_rxdonrolr");
innerOut_rxdonrolr.set(port_rxdonrolr.get() );
innerOut_rxdonrolr.setUiAttribs({title:"ImageIntervalZ"});
port_rxdonrolr.on("change", (a,v) => { innerOut_rxdonrolr.set(a); });

const innerOut_k39iw7qf1 = addedOps[i].outArray("innerOut_k39iw7qf1");
innerOut_k39iw7qf1.setUiAttribs({title:"IndicatorArray_Iconic"});
port_k39iw7qf1.on("change", (a,v) => { innerOut_k39iw7qf1.setRef(a); });

const innerOut_v17tbxwpy = addedOps[i].outArray("innerOut_v17tbxwpy");
innerOut_v17tbxwpy.setUiAttribs({title:"IndicatorArray_Generic"});
port_v17tbxwpy.on("change", (a,v) => { innerOut_v17tbxwpy.setRef(a); });

const innerOut_dobslg7sf = addedOps[i].outTrigger("innerOut_dobslg7sf");
innerOut_dobslg7sf.setUiAttribs({title:"Trigger"});
port_dobslg7sf.onTriggered = () => { innerOut_dobslg7sf.trigger(); };

const innerOut_earjb46wu = addedOps[i].outTexture("innerOut_earjb46wu");
innerOut_earjb46wu.setUiAttribs({title:"GradientMap_ForBuilding"});
port_earjb46wu.on("change", (a,v) => { innerOut_earjb46wu.setRef(a); });

const innerOut_1er6wsd99 = addedOps[i].outTexture("innerOut_1er6wsd99");
innerOut_1er6wsd99.setUiAttribs({title:"GradientMap_ForMask"});
port_1er6wsd99.on("change", (a,v) => { innerOut_1er6wsd99.setRef(a); });

const innerOut_ga4abt9us = addedOps[i].outTexture("innerOut_ga4abt9us");
innerOut_ga4abt9us.setUiAttribs({title:"BoundsMask"});
port_ga4abt9us.on("change", (a,v) => { innerOut_ga4abt9us.setRef(a); });

    }
if(addedOps[i].innerOutput)
{
const innerIn_ge8is9nye = addedOps[i].inTrigger("innerIn_ge8is9nye");
innerIn_ge8is9nye.setUiAttribs({title:"RenderToWorld"});
innerIn_ge8is9nye.onTriggered = () => { port_ge8is9nye.trigger(); };

const innerIn_cc3tea9q0 = addedOps[i].inTrigger("innerIn_cc3tea9q0");
innerIn_cc3tea9q0.setUiAttribs({title:"RenderToTexture_Building"});
innerIn_cc3tea9q0.onTriggered = () => { port_cc3tea9q0.trigger(); };

const innerIn_wc7us54fg = addedOps[i].inTrigger("innerIn_wc7us54fg");
innerIn_wc7us54fg.setUiAttribs({title:"RenderToTexture_Line"});
innerIn_wc7us54fg.onTriggered = () => { port_wc7us54fg.trigger(); };

const innerIn_740vm05xs = addedOps[i].inArray("innerIn_740vm05xs");
innerIn_740vm05xs.setUiAttribs({title:"IndicatorArray_Iconic"});
innerIn_740vm05xs.on("change", (a,v) => { port_740vm05xs.setRef(a); });

const innerIn_vh2f15cw8 = addedOps[i].inArray("innerIn_vh2f15cw8");
innerIn_vh2f15cw8.setUiAttribs({title:"IndicatorArray_Generic"});
innerIn_vh2f15cw8.on("change", (a,v) => { port_vh2f15cw8.setRef(a); });

const innerIn_3cpnu6igj = addedOps[i].inArray("innerIn_3cpnu6igj");
innerIn_3cpnu6igj.setUiAttribs({title:"ImageList"});
innerIn_3cpnu6igj.on("change", (a,v) => { port_3cpnu6igj.setRef(a); });

const innerIn_jycvtf89b = addedOps[i].inObject("innerIn_jycvtf89b");
innerIn_jycvtf89b.setUiAttribs({title:"BuildingTexture"});
innerIn_jycvtf89b.on("change", (a,v) => { port_jycvtf89b.setRef(a); });

const innerIn_el1t5zxr9 = addedOps[i].inObject("innerIn_el1t5zxr9");
innerIn_el1t5zxr9.setUiAttribs({title:"LineTexture"});
innerIn_el1t5zxr9.on("change", (a,v) => { port_el1t5zxr9.setRef(a); });

const innerIn_7lfhdhs5x = addedOps[i].inFloat("innerIn_7lfhdhs5x");
innerIn_7lfhdhs5x.setUiAttribs({title:"IsLoading"});
innerIn_7lfhdhs5x.on("change", (a,v) => { port_7lfhdhs5x.set(a); });

const innerIn_gr5rfgt62 = addedOps[i].inArray("innerIn_gr5rfgt62");
innerIn_gr5rfgt62.setUiAttribs({title:"CurrentAnimationPoint"});
innerIn_gr5rfgt62.on("change", (a,v) => { port_gr5rfgt62.setRef(a); });

}
}
};

const patchId = "bp2sub_" + op.id;

new CABLES.SubPatchOp(op, { "subId": patchId });

initializeSubpatch();

function initializeSubpatch()
{
    const p = JSON.parse(attachments.subpatch_json);

    CABLES.Patch.replaceOpIds(p,
        {
            "parentSubPatchId": patchId,
            "prefixHash": patchId,
            "oldIdAsRef": true,
            "doNotUnlinkLostLinks": true
        });

    for (let i = 0; i < p.ops.length; i++)
    {
        p.ops[i].uiAttribs.blueprintSubpatch2 = true;
    }

    op.loadDependencies(p, () =>
    {
        op.patch.deSerialize(p, { "opsCreated": op.initInnerPorts });
        if (CABLES.UI)gui.savedState.setSaved("blueprintloaded", patchId);
        op.patch.emitEvent("subpatchExpose", patchId);
        op.setStorage({ "blueprintVer": 2 });
        op.patch.emitEvent("subpatchExpose", patchId);
    });
}

}
};

CABLES.OPS["a35a8d32-f419-4d33-9766-6143d035ed7d"]={f:Ops.Patch.PLH3vXR.ProcessSingleLayer,objName:"Ops.Patch.PLH3vXR.ProcessSingleLayer"};




// **************************************************************
// 
// Ops.Number.Number
// 
// **************************************************************

Ops.Number.Number= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
const
    v = op.inValueFloat("value"),
    result = op.outNumber("result");

v.onChange = exec;

let isLinked = false;
v.onLinkChanged = () =>
{
    if (!isLinked && v.isLinked())op.setUiAttribs({ "extendTitle": null });
    isLinked = v.isLinked();
};

function exec()
{
    if (CABLES.UI && !isLinked) op.setUiAttribs({ "extendTitle": v.get() });

    result.set(Number(v.get()));
}

}
};

CABLES.OPS["8fb2bb5d-665a-4d0a-8079-12710ae453be"]={f:Ops.Number.Number,objName:"Ops.Number.Number"};




// **************************************************************
// 
// Ops.Boolean.Not
// 
// **************************************************************

Ops.Boolean.Not= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
const
    bool = op.inValueBool("Boolean"),
    outbool = op.outBoolNum("Result");

bool.changeAlways = true;

bool.onChange = function ()
{
    outbool.set((!bool.get()));
};

}
};

CABLES.OPS["6d123c9f-7485-4fd9-a5c2-76e59dcbeb34"]={f:Ops.Boolean.Not,objName:"Ops.Boolean.Not"};




// **************************************************************
// 
// Ops.Vars.VarGetNumber_v2
// 
// **************************************************************

Ops.Vars.VarGetNumber_v2= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
const val = op.outNumber("Value");
op.varName = op.inValueSelect("Variable", [], "", true);

new CABLES.VarGetOpWrapper(op, "number", op.varName, val);

}
};

CABLES.OPS["421f5b52-c0fa-47c4-8b7a-012b9e1c864a"]={f:Ops.Vars.VarGetNumber_v2,objName:"Ops.Vars.VarGetNumber_v2"};




// **************************************************************
// 
// Ops.Ui.SubPatchInput
// 
// **************************************************************

Ops.Ui.SubPatchInput= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
op.innerInput = true;

const goto = op.inTriggerButton("Goto SubPatchOp");
goto.setUiAttribs({ "hidePort": true });
goto.onTriggered = () =>
{
    const parent = op.patch.getSubPatchOuterOp(op.uiAttribs.subPatch);
    gui.patchView.centerSelectOp(parent.id);
};

}
};

CABLES.OPS["c4e4e933-136e-479e-8de8-0b35b75d9217"]={f:Ops.Ui.SubPatchInput,objName:"Ops.Ui.SubPatchInput"};




// **************************************************************
// 
// Ops.Ui.SubPatchOutput
// 
// **************************************************************

Ops.Ui.SubPatchOutput= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
op.innerOutput = true;

}
};

CABLES.OPS["02d45073-7936-4830-81ad-59a162febf1f"]={f:Ops.Ui.SubPatchOutput,objName:"Ops.Ui.SubPatchOutput"};




// **************************************************************
// 
// Ops.Number.SwitchNumber
// 
// **************************************************************

Ops.Number.SwitchNumber= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
const idx = op.inValueInt("Index");
const valuePorts = [];
const result = op.outNumber("Result");

idx.onChange = update;

for (let i = 0; i < 16; i++)
{
    let p = op.inValueFloat("Value " + i);
    valuePorts.push(p);
    p.onChange = update;
}

function update()
{
    const i = idx.get();
    if (i >= 0 && valuePorts[i])
    {
        result.set(valuePorts[i].get());
    }
}

}
};

CABLES.OPS["fbb89f72-f2e3-4d34-ad01-7d884a1bcdc0"]={f:Ops.Number.SwitchNumber,objName:"Ops.Number.SwitchNumber"};




// **************************************************************
// 
// Ops.Math.Compare.LessThan
// 
// **************************************************************

Ops.Math.Compare.LessThan= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
const number1 = op.inValue("number1");
const number2 = op.inValue("number2");
const result = op.outBoolNum("result");

op.setUiAttribs({ "mathTitle": true });

number1.onChange = exec;
number2.onChange = exec;
exec();

function exec()
{
    result.set(number1.get() < number2.get());
}

}
};

CABLES.OPS["04fd113f-ade1-43fb-99fa-f8825f8814c0"]={f:Ops.Math.Compare.LessThan,objName:"Ops.Math.Compare.LessThan"};




// **************************************************************
// 
// Ops.Math.Compare.Equals
// 
// **************************************************************

Ops.Math.Compare.Equals= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
const
    number1 = op.inValue("number1", 1),
    number2 = op.inValue("number2", 1),
    result = op.outBoolNum("result");

number1.onChange =
    number2.onChange = exec;
exec();

function exec()
{
    result.set(number1.get() == number2.get());
}

}
};

CABLES.OPS["4dd3cc55-eebc-4187-9d4e-2e053a956fab"]={f:Ops.Math.Compare.Equals,objName:"Ops.Math.Compare.Equals"};




// **************************************************************
// 
// Ops.Boolean.Or
// 
// **************************************************************

Ops.Boolean.Or= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
const
    bool0 = op.inValueBool("bool 1"),
    bool1 = op.inValueBool("bool 2"),
    bool2 = op.inValueBool("bool 3"),
    bool3 = op.inValueBool("bool 4"),
    bool4 = op.inValueBool("bool 5"),
    bool5 = op.inValueBool("bool 6"),
    bool6 = op.inValueBool("bool 7"),
    bool7 = op.inValueBool("bool 8"),
    bool8 = op.inValueBool("bool 9"),
    bool9 = op.inValueBool("bool 10"),
    result = op.outBoolNum("result");

bool0.onChange =
    bool1.onChange =
    bool2.onChange =
    bool3.onChange =
    bool4.onChange =
    bool5.onChange =
    bool6.onChange =
    bool7.onChange =
    bool8.onChange =
    bool9.onChange = exec;

function exec()
{
    result.set(bool0.get() || bool1.get() || bool2.get() || bool3.get() || bool4.get() || bool5.get() || bool6.get() || bool7.get() || bool8.get() || bool9.get());
}

}
};

CABLES.OPS["b3b36238-4592-4e11-afe3-8361c4fd6be5"]={f:Ops.Boolean.Or,objName:"Ops.Boolean.Or"};




// **************************************************************
// 
// Ops.Boolean.And
// 
// **************************************************************

Ops.Boolean.And= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
const
    bool0 = op.inValueBool("bool 1"),
    bool1 = op.inValueBool("bool 2"),
    result = op.outBoolNum("result");

bool0.onChange =
bool1.onChange = exec;

function exec()
{
    result.set(bool1.get() && bool0.get());
}

}
};

CABLES.OPS["c26e6ce0-8047-44bb-9bc8-5a4f911ed8ad"]={f:Ops.Boolean.And,objName:"Ops.Boolean.And"};




// **************************************************************
// 
// Ops.Array.PointArray.RedistributeSplinePoints
// 
// **************************************************************

Ops.Array.PointArray.RedistributeSplinePoints= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
const
    inArr = op.inArray("Array3x"),
    num = op.inValueInt("Num Points", 100),
    inExec = op.inTriggerButton("Calculate"),
    inNormalized = op.inValueBool("Normalized"),
    result = op.outArray("Result"),
    outSplineLength = op.outNumber("Spline Length");

const
    animX = new CABLES.Anim(),
    animY = new CABLES.Anim(),
    animZ = new CABLES.Anim();

let needsMapping = true;
let newArray = [];
let totalSplineLength = 0;

function dist(x1, y1, z1, x2, y2, z2)
{
    let xd = x1 - x2;
    let yd = y1 - y2;
    let zd = z1 - z2;
    return Math.sqrt(xd * xd + yd * yd + zd * zd);
}

function splineLength(arr)
{
    let l = 0;
    for (let i = 3; i < arr.length; i += 3)
    {
        l += dist(arr[i - 3], arr[i - 2], arr[i - 1], arr[i + 0], arr[i + 1], arr[i + 2]);
    }

    return l;
}

function mapArrays()
{
    animX.clear();
    animY.clear();
    animZ.clear();
    let arr = inArr.get();
    if (!arr)
    {
        result.set([]);
        return;
    }
    totalSplineLength = splineLength(arr);
    outSplineLength.set(totalSplineLength);

    let distPos = 0;

    for (let i = 0; i < arr.length; i += 3)
    {
        let p = i / (arr.length - 3);
        if (i > 0)
        {
            distPos += dist(arr[i - 3], arr[i - 2], arr[i - 1], arr[i + 0], arr[i + 1], arr[i + 2]);
        }

        animX.setValue(distPos, arr[i + 0]);
        animY.setValue(distPos, arr[i + 1]);
        animZ.setValue(distPos, arr[i + 2]);
    }

    needsMapping = false;
}

function buildResultArray()
{
    let n = Math.max(0, num.get());
    if (n === 0)
    {
        result.set([]);
        return;
    }

    newArray.length = n * 3;

    for (let i = 0; i < n; i++)
    {
        newArray[i * 3 + 0] = animX.getValue(i / n * totalSplineLength);
        newArray[i * 3 + 1] = animY.getValue(i / n * totalSplineLength);
        newArray[i * 3 + 2] = animZ.getValue(i / n * totalSplineLength);
    }

    result.set(null);
    result.set(newArray);
}

inArr.onChange = function ()
{
    needsMapping = true;
};

inExec.onTriggered = function ()
{
    if (needsMapping)mapArrays();
    buildResultArray();
};

}
};

CABLES.OPS["f17bae71-6047-49ea-af17-f7690e6e4d36"]={f:Ops.Array.PointArray.RedistributeSplinePoints,objName:"Ops.Array.PointArray.RedistributeSplinePoints"};




// **************************************************************
// 
// Ops.Trigger.TriggerOnChangeArray
// 
// **************************************************************

Ops.Trigger.TriggerOnChangeArray= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
const
    inval = op.inArray("Array"),
    next = op.outTrigger("Changed"),
    outArr = op.outArray("Result");

inval.onChange = function ()
{
    outArr.set(inval.get());
    next.trigger();
};

}
};

CABLES.OPS["e4ddec93-4dee-422b-a402-6a0f6e469ce6"]={f:Ops.Trigger.TriggerOnChangeArray,objName:"Ops.Trigger.TriggerOnChangeArray"};




// **************************************************************
// 
// Ops.Array.PointArray.SubdivideArray3_v2
// 
// **************************************************************

Ops.Array.PointArray.SubdivideArray3_v2= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
const
    inArr = op.inArray("Points"),
    subDivs = op.inInt("Num Subdivs", 5),
    bezier = op.inValueBool("Smooth", true),
    inLoop = op.inValueBool("Loop", false),
    bezierEndPoints = op.inValueBool("Bezier Start/End Points", true),
    result = op.outArray("Result");

op.toWorkPortsNeedToBeLinked(inArr);

let arr = [];

subDivs.onChange =
    inLoop.onChange =
    bezier.onChange =
    inArr.onChange =
    bezierEndPoints.onChange = calc;

inArr.onLinkChanged = () =>
{
    inArr.copyLinkedUiAttrib("stride", result);
};

function ip(x0, x1, x2, t)// Bezier
{
    const r = (x0 * (1 - t) * (1 - t) + 2 * x1 * (1 - t) * t + x2 * t * t);
    return r;
}

function calc()
{
    inLoop.setUiAttribs({ "greyout": !bezier.get() });
    bezierEndPoints.setUiAttribs({ "greyout": !bezier.get() });

    if (!inArr.get())
    {
        result.set(null);
        return;
    }
    const subd = Math.floor(subDivs.get());
    const inPoints = inArr.get();

    if (inPoints.length < 3) return;

    let i = 0;
    let j = 0;
    let k = 0;
    let count = 0;

    if (subd > 0 && !bezier.get())
    {
        const newLen = (inPoints.length - 3) * subd + 3;
        if (newLen != arr.length)
        {
            arr.length = newLen;
        }

        count = 0;
        for (i = 0; i < inPoints.length - 3; i += 3)
        {
            for (j = 0; j < subd; j++)
            {
                for (k = 0; k < 3; k++)
                {
                    arr[count] =
                        inPoints[i + k] + (inPoints[i + k + 3] - inPoints[i + k]) * j / subd;
                    count++;
                }
            }
        }
        arr[newLen - 3] = inPoints[inPoints.length - 3];
        arr[newLen - 2] = inPoints[inPoints.length - 2];
        arr[newLen - 1] = inPoints[inPoints.length - 1];
    }
    else
    if (subd > 0 && bezier.get())
    {
        let newLen = (inPoints.length - 6) * (subd - 1);
        if (bezierEndPoints.get())newLen += 6;

        if (newLen != arr.length) arr.length = Math.floor(Math.abs(newLen));
        count = 0;

        if (bezierEndPoints.get())
        {
            arr[0] = inPoints[0];
            arr[1] = inPoints[1];
            arr[2] = inPoints[2];
            count = 3;
        }

        const doLoop = inLoop.get();

        function idx(i)
        {
            if (doLoop) return i % (inPoints.length - 3);
            else return i;
        }

        let endi = inPoints.length - 3;
        if (doLoop)endi = inPoints.length;

        for (i = 3; i < endi; i += 3)
        {
            for (j = 0; j < subd; j++)
            {
                for (k = 0; k < 3; k++)
                {
                    const p = ip(
                        (inPoints[idx(i + k - 3)] + inPoints[idx(i + k)]) / 2,
                        inPoints[idx(i + k + 0)],
                        (inPoints[idx(i + k + 3)] + inPoints[idx(i + k + 0)]) / 2,
                        j / subd
                    );
                    arr[count] = p;
                    count++;
                }
            }
        }

        if (doLoop)
        {
            arr[count + 0] = arr[0];
            arr[count + 1] = arr[1];
            arr[count + 2] = arr[2];
            count++; count++; count++;
        }

        if (bezierEndPoints.get())
        {
            arr[count - 0] = inPoints[inPoints.length - 3];
            arr[count + 1] = inPoints[inPoints.length - 2];
            arr[count + 2] = inPoints[inPoints.length - 1];
        }
    }
    if (subd == 0)
    {
        arr = Array.from(inPoints);
    }

    // result.set(null);
    result.setRef(arr);
}

}
};

CABLES.OPS["d8bb5727-35e4-4e2a-999b-112ebc659720"]={f:Ops.Array.PointArray.SubdivideArray3_v2,objName:"Ops.Array.PointArray.SubdivideArray3_v2"};




// **************************************************************
// 
// Ops.Number.TriggerOnChangeNumber
// 
// **************************************************************

Ops.Number.TriggerOnChangeNumber= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
const
    inval = op.inFloat("Value"),
    next = op.outTrigger("Next"),
    number = op.outNumber("Number");

inval.onChange = function ()
{
    number.set(inval.get());
    next.trigger();
};

}
};

CABLES.OPS["f5c8c433-ce13-49c4-9a33-74e98f110ed0"]={f:Ops.Number.TriggerOnChangeNumber,objName:"Ops.Number.TriggerOnChangeNumber"};




// **************************************************************
// 
// Ops.String.Base64.DownloadBase64File
// 
// **************************************************************

Ops.String.Base64.DownloadBase64File= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
const
    inStr = op.inString("Data URL", "default"),
    inFilename = op.inString("Filename"),
    exec = op.inTriggerButton("Download"),
    next = op.outTrigger("Next");

exec.onTriggered = () =>
{
    const a = document.createElement("a");
    a.setAttribute("download", "download");
    a.href = inStr.get();

    a.download = inFilename.get();
    a.click();
};

}
};

CABLES.OPS["7f601f11-6d44-4c0a-842a-51b4fa8ccd6b"]={f:Ops.String.Base64.DownloadBase64File,objName:"Ops.String.Base64.DownloadBase64File"};




// **************************************************************
// 
// Ops.String.ConcatMulti_v2
// 
// **************************************************************

Ops.String.ConcatMulti_v2= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
const stringPorts = [];
for (let i = 0; i < 8; i++)
{
    let p = op.inString("string " + i);
    stringPorts.push(p);
    p.onChange = update;
}

const
    addSpacesCheckBox = op.inBool("add spaces", false),
    newLinesCheckBox = op.inBool("new lines", false),
    result = op.outString("concat string");

stringPorts.onChange =
    addSpacesCheckBox.onChange =
    newLinesCheckBox.onChange = update;

addSpacesCheckBox.setUiAttribs({ "hidePort": true });
newLinesCheckBox.setUiAttribs({ "hidePort": true });

function update()
{
    let str = "";
    let nl = "";
    let space = addSpacesCheckBox.get();

    for (let i = 0; i < stringPorts.length; i++)
    {
        const inString = stringPorts[i].get();
        if (!inString) continue;
        if (i > 0 && space) str += " ";
        if (i > 0 && newLinesCheckBox.get()) nl = "\n";
        str += nl;
        str += inString;
    }
    result.set(str);
}

}
};

CABLES.OPS["bc110e48-812d-489d-b1b3-b09c644c6982"]={f:Ops.String.ConcatMulti_v2,objName:"Ops.String.ConcatMulti_v2"};




// **************************************************************
// 
// Ops.String.OrString
// 
// **************************************************************

Ops.String.OrString= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
const
    str0=op.inString("String 1"),
    str1=op.inString("String 2"),
    str2=op.inString("String 3"),
    str3=op.inString("String 4"),
    str4=op.inString("String 5"),
    str5=op.inString("String 6"),
    str6=op.inString("String 7"),
    str7=op.inString("String 8"),
    result=op.outString("Result");

str0.onChange=
    str1.onChange=
    str2.onChange=
    str3.onChange=
    str4.onChange=
    str5.onChange=
    str6.onChange=
    str7.onChange=exec;

function exec()
{
    result.set( str0.get() || str1.get()  || str2.get() || str3.get() || str4.get() || str5.get() || str6.get() || str7.get() );
}


}
};

CABLES.OPS["6b7f9561-6faf-4df7-ac3b-64235dded700"]={f:Ops.String.OrString,objName:"Ops.String.OrString"};




// **************************************************************
// 
// Ops.String.Lowercase_v2
// 
// **************************************************************

Ops.String.Lowercase_v2= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
const
    inStr = op.inString("String"),
    outStr = op.outString("Result", "");

inStr.onChange = function ()
{
    if (inStr.get() == 0)outStr.set("");
    else outStr.set((inStr.get() || "").toLowerCase());
};

}
};

CABLES.OPS["bff9c3d9-e63a-46d2-a59f-932c715aceab"]={f:Ops.String.Lowercase_v2,objName:"Ops.String.Lowercase_v2"};




// **************************************************************
// 
// Ops.Array.StringToArray_v2
// 
// **************************************************************

Ops.Array.StringToArray_v2= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
const text = op.inStringEditor("text", "1,2,3"),
    separator = op.inString("separator", ","),
    toNumber = op.inValueBool("Numbers", true),
    trim = op.inValueBool("Trim", true),
    splitNewLines = op.inBool("Split Lines", false),
    arr = op.outArray("array"),
    parsed = op.outTrigger("Parsed"),
    len = op.outNumber("length");

text.setUiAttribs({ "ignoreBigPort": true });

text.onChange = separator.onChange = toNumber.onChange = trim.onChange = parse;

splitNewLines.onChange = () =>
{
    separator.setUiAttribs({ "greyout": splitNewLines.get() });
    parse();
};

parse();

function parse()
{
    if (!text.get())
    {
        arr.set(null);
        arr.set([]);
        len.set(0);
        return;
    }

    let textInput = text.get();
    if (trim.get() && textInput)
    {
        textInput = textInput.replace(/^\s+|\s+$/g, "");
        textInput = textInput.trim();
    }

    let r;
    let sep = separator.get();
    if (separator.get() === "\\n") sep = "\n";
    if (splitNewLines.get()) r = textInput.split("\n");
    else r = textInput.split(sep);

    if (r[r.length - 1] === "") r.length -= 1;

    len.set(r.length);

    if (trim.get())
    {
        for (let i = 0; i < r.length; i++)
        {
            r[i] = r[i].replace(/^\s+|\s+$/g, "");
            r[i] = r[i].trim();
        }
    }

    op.setUiError("notnum", null);
    if (toNumber.get())
    {
        let hasStrings = false;
        for (let i = 0; i < r.length; i++)
        {
            r[i] = Number(r[i]);
            if (!CABLES.isNumeric(r[i]))
            {
                hasStrings = true;
            }
        }
        if (hasStrings)
        {
            op.setUiError("notnum", "Parse Error / Not all values numerical!", 1);
        }
    }

    arr.setRef(r);
    parsed.trigger();
}

}
};

CABLES.OPS["c974de41-4ce4-4432-b94d-724741109c71"]={f:Ops.Array.StringToArray_v2,objName:"Ops.Array.StringToArray_v2"};




// **************************************************************
// 
// Ops.String.ArrayContainsString
// 
// **************************************************************

Ops.String.ArrayContainsString= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
const
    inArr = op.inArray("Array"),
    inValue = op.inString("SearchValue"),
    outFound = op.outBoolNum("Found", false),
    outIndex = op.outNumber("Index", -1);

inValue.onChange = () =>
{
    if (!inValue.isLinked()) op.setUiAttrib({ "extendTitle": inValue.get() });
    exec();
};

inArr.onChange = exec;

function exec()
{
    let arr = inArr.get();
    if (arr)
    {
        if (!Array.isArray(arr)) arr = Array.from(arr);
        const index = arr.indexOf(inValue.get());

        outIndex.set(index);
        outFound.set(index > -1);
    }
}

}
};

CABLES.OPS["bace9c9b-5e96-4a82-9bcd-02e316afb9de"]={f:Ops.String.ArrayContainsString,objName:"Ops.String.ArrayContainsString"};




// **************************************************************
// 
// Ops.Gl.Textures.TextureToBase64_v5
// 
// **************************************************************

Ops.Gl.Textures.TextureToBase64_v5= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
const
    start = op.inTriggerButton("Trigger"),
    inTex = op.inTexture("Texture"),
    inFormat = op.inSwitch("Format", ["PNG", "JPEG", "WEBP"], "PNG"),
    inQuality = op.inFloatSlider("Quality", 0.9),

    dataUrl = op.inBool("Output dataUrl", true),
    next = op.outTrigger("next"),
    outSize = op.outNumber("Binary Size"),
    outString = op.outString("Base64 string"),
    outLoading = op.outBoolNum("Loading"),
    finished = op.outTrigger("Finished");

const cgl = op.patch.cgl;
const gl = op.patch.cgl.gl;
const canvas = document.createElement("canvas");

let fb = null;
let texChanged = false;
let loadingId = null;
outString.ignoreValueSerialize = true;

let pixelReader = new CGL.PixelReader();

start.onTriggered = () => { texChanged = true; retrySoon(); };

inQuality.onChange =
inFormat.onChange =
inTex.onChange = () =>
{
    texChanged = true;
};

function retrySoon()
{
    if (texChanged)
    {
        if (loadingId)loadingId = cgl.patch.loading.finished(loadingId);
        outLoading.set(true);

        loadingId = cgl.patch.loading.start(op.name, CABLES.uuid(), op);

        op.patch.cgl.addNextFrameOnceCallback(update.bind(this));
    }
    inQuality.setUiAttribs({ "greyout": inFormat.get() == "PNG" });

    next.trigger();
}

function update()
{
    op.uiAttr({ "error": null });
    if (!inTex.get() || !inTex.get().tex) return;

    const width = inTex.get().width;
    const height = inTex.get().height;

    if (!fb)fb = gl.createFramebuffer();

    gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, inTex.get().tex, 0);

    const canRead = (gl.checkFramebufferStatus(gl.FRAMEBUFFER) == gl.FRAMEBUFFER_COMPLETE);

    gl.bindFramebuffer(gl.FRAMEBUFFER, null);

    if (!canRead)
    {
        outLoading.set(false);
        op.uiAttr({ "error": "cannot read texture!" });
        return;
    }

    let retry = !pixelReader.read(cgl, fb, inTex.get().pixelFormat, 0, 0, width, height, (pixel) =>
    {
        canvas.width = width;
        canvas.height = height;
        const context = canvas.getContext("2d");
        // Copy the pixels to a 2D canvas
        const imageData = context.createImageData(width, height);
        imageData.data.set(pixel);

        const data2 = imageData.data;

        // flip image
        Array.from({ "length": height }, (val, i) => { return data2.slice(i * width * 4, (i + 1) * width * 4); })
            .forEach((val, i) => { return data2.set(val, (height - i - 1) * width * 4); });

        context.putImageData(imageData, 0, 0);

        const ext = inFormat.get().toLowerCase();

        let dataString = "";

        dataString = canvas.toDataURL("image/" + ext, inQuality.get());

        if (!dataUrl.get())
        {
            dataString = dataString.split(",", 2)[1];
        }
        outString.set(dataString);

        outSize.set(Math.ceil(dataString.length * 0.75)); // 6 bit to 8 bit

        outLoading.set(false);
        texChanged = false;
        loadingId = cgl.patch.loading.finished(loadingId);
        finished.trigger();
    });

    if (retry) setTimeout(retrySoon.bind(this), 50);
}

//

}
};

CABLES.OPS["ed772bc0-ab12-427e-8378-64ea4f7635ed"]={f:Ops.Gl.Textures.TextureToBase64_v5,objName:"Ops.Gl.Textures.TextureToBase64_v5"};




// **************************************************************
// 
// Ops.Ui.VizNumber
// 
// **************************************************************

Ops.Ui.VizNumber= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
const inNum = op.inFloat("Number", 0);
const outNum = op.outNumber("Result");

op.setUiAttrib({ "widthOnlyGrow": true });

inNum.onChange = update;

update();

function update()
{
    let n = inNum.get();
    // if (op.patch.isEditorMode())
    // {
    //     let str = "";
    //     if (n === null)str = "null";
    //     else if (isNaN(n))str = "NaN";
    //     else if (n === undefined)str = "undefined";
    //     else
    //     {
    //         str = "" + Math.round(n * 10000) / 10000;

    //         if (str[0] != "-")str = " " + str;
    //     }

    //     op.setUiAttribs({ "extendTitle": str });
    // }
    op.setUiAttribs({ "extendTitle": inNum.getValueForDisplay() });

    outNum.set(n);
}

}
};

CABLES.OPS["2b60d12d-2884-4ad0-bda4-0caeb6882f5c"]={f:Ops.Ui.VizNumber,objName:"Ops.Ui.VizNumber"};




// **************************************************************
// 
// Ops.Math.Subtract
// 
// **************************************************************

Ops.Math.Subtract= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
const
    number1 = op.inValue("number1", 1),
    number2 = op.inValue("number2", 1),
    result = op.outNumber("result");

op.setUiAttribs({ "mathTitle": true });

number1.onChange =
    number2.onChange = exec;
exec();

function exec()
{
    let v = number1.get() - number2.get();
    if (!isNaN(v)) result.set(v);
}

}
};

CABLES.OPS["a4ffe852-d200-4b96-9347-68feb01122ca"]={f:Ops.Math.Subtract,objName:"Ops.Math.Subtract"};




// **************************************************************
// 
// Ops.Gl.Matrix.Camera_v2
// 
// **************************************************************

Ops.Gl.Matrix.Camera_v2= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
const render = op.inTrigger("render");
const trigger = op.outTrigger("trigger");
const inIdentity = op.inBool("Identity", true);
/* Inputs */
// projection | prespective & ortogonal
const projectionMode = op.inValueSelect("projection mode", ["prespective", "ortogonal"], "prespective");
const zNear = op.inValue("frustum near", 0.01);
const zFar = op.inValue("frustum far", 5000.0);

const fov = op.inValue("fov", 45);
const autoAspect = op.inValueBool("Auto Aspect Ratio", true);
const aspect = op.inValue("Aspect Ratio", 1);

// look at camera
const eyeX = op.inValue("eye X", 0);
const eyeY = op.inValue("eye Y", 0);
const eyeZ = op.inValue("eye Z", 5);

const centerX = op.inValue("center X", 0);
const centerY = op.inValue("center Y", 0);
const centerZ = op.inValue("center Z", 0);

// camera transform and movements
const posX = op.inValue("truck", 0);
const posY = op.inValue("boom", 0);
const posZ = op.inValue("dolly", 0);

const rotX = op.inValue("tilt", 0);
const rotY = op.inValue("pan", 0);
const rotZ = op.inValue("roll", 0);

/* Outputs */
const outAsp = op.outNumber("Aspect");
const outArr = op.outArray("Look At Array");

/* logic */
const cgl = op.patch.cgl;

let asp = 0;

const vUp = vec3.create();
const vEye = vec3.create();
const vCenter = vec3.create();
const transMatrix = mat4.create();
mat4.identity(transMatrix);

const arr = [];

// Transform and move
const vPos = vec3.create();
const transMatrixMove = mat4.create();
mat4.identity(transMatrixMove);

let updateCameraMovementMatrix = true;

render.onTriggered = function ()
{
    if (cgl.tempData.shadowPass) return trigger.trigger();

    // Aspect ration
    if (!autoAspect.get()) asp = aspect.get();
    else asp = cgl.getViewPort()[2] / cgl.getViewPort()[3];
    outAsp.set(asp);

    // translation (truck, boom, dolly)
    cgl.pushViewMatrix();

    if (inIdentity.get())mat4.identity(cgl.vMatrix);

    if (updateCameraMovementMatrix)
    {
        mat4.identity(transMatrixMove);

        vec3.set(vPos, posX.get(), posY.get(), posZ.get());
        if (posX.get() !== 0.0 || posY.get() !== 0.0 || posZ.get() !== 0.0)
            mat4.translate(transMatrixMove, transMatrixMove, vPos);

        if (rotX.get() !== 0)
            mat4.rotateX(transMatrixMove, transMatrixMove, rotX.get() * CGL.DEG2RAD);
        if (rotY.get() !== 0)
            mat4.rotateY(transMatrixMove, transMatrixMove, rotY.get() * CGL.DEG2RAD);
        if (rotZ.get() !== 0)
            mat4.rotateZ(transMatrixMove, transMatrixMove, rotZ.get() * CGL.DEG2RAD);

        updateCameraMovementMatrix = false;
    }

    mat4.multiply(cgl.vMatrix, cgl.vMatrix, transMatrixMove);

    // projection (prespective / ortogonal)
    cgl.pushPMatrix();

    // look at
    cgl.pushViewMatrix();

    if (projectionMode.get() == "prespective")
    {
        mat4.perspective(
            cgl.pMatrix,
            fov.get() * 0.0174533,
            asp,
            zNear.get(),
            zFar.get()
        );
    }
    else if (projectionMode.get() == "ortogonal")
    {
        mat4.ortho(
            cgl.pMatrix,
            -1 * (fov.get() / 14),
            1 * (fov.get() / 14),
            -1 * (fov.get() / 14) / asp,
            1 * (fov.get() / 14) / asp,
            zNear.get(),
            zFar.get()
        );
    }

    arr[0] = eyeX.get();
    arr[1] = eyeY.get();
    arr[2] = eyeZ.get();

    arr[3] = centerX.get();
    arr[4] = centerY.get();
    arr[5] = centerZ.get();

    arr[6] = 0;
    arr[7] = 1;
    arr[8] = 0;

    outArr.setRef(arr);

    vec3.set(vUp, 0, 1, 0);
    vec3.set(vEye, eyeX.get(), eyeY.get(), eyeZ.get());
    vec3.set(vCenter, centerX.get(), centerY.get(), centerZ.get());

    mat4.lookAt(transMatrix, vEye, vCenter, vUp);

    mat4.multiply(cgl.vMatrix, cgl.vMatrix, transMatrix);

    trigger.trigger();

    cgl.popViewMatrix();
    cgl.popPMatrix();

    cgl.popViewMatrix();

    // GUI for dolly, boom and truck
    if (op.isCurrentUiOp())
        gui.setTransformGizmo({
            "posX": posX,
            "posY": posY,
            "posZ": posZ
        });
};

const updateUI = function ()
{
    if (!autoAspect.get())
    {
        aspect.setUiAttribs({ "greyout": false });
    }
    else
    {
        aspect.setUiAttribs({ "greyout": true });
    }
};

const cameraMovementChanged = function ()
{
    updateCameraMovementMatrix = true;
};

// listeners
posX.onChange = cameraMovementChanged;
posY.onChange = cameraMovementChanged;
posZ.onChange = cameraMovementChanged;

rotX.onChange = cameraMovementChanged;
rotY.onChange = cameraMovementChanged;
rotZ.onChange = cameraMovementChanged;

autoAspect.onChange = updateUI;
updateUI();

}
};

CABLES.OPS["f7673a93-7772-4ade-9d3d-df7174f5258b"]={f:Ops.Gl.Matrix.Camera_v2,objName:"Ops.Gl.Matrix.Camera_v2"};




// **************************************************************
// 
// Ops.Vars.VarGetArray_v2
// 
// **************************************************************

Ops.Vars.VarGetArray_v2= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
const val = op.outArray("Value");
op.varName = op.inValueSelect("Variable", [], "", true);

new CABLES.VarGetOpWrapper(op, "array", op.varName, val);

}
};

CABLES.OPS["afa79294-aa9c-43bc-a49a-cade000a1de5"]={f:Ops.Vars.VarGetArray_v2,objName:"Ops.Vars.VarGetArray_v2"};




// **************************************************************
// 
// Ops.Array.ArrayToArrays
// 
// **************************************************************

Ops.Array.ArrayToArrays= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
const
    inArr = op.inArray("Array"),
    inStride = op.inInt("Stride", 6),
    outArr = op.outArray("Result");

inStride.onChange =
inArr.onChange = () =>
{
    const stride = inStride.get();

    const result = [];
    const arr = inArr.get();
    if (!arr || stride <= 0) return outArr.set(null);

    let count = 0;
    for (let i = 0; i < arr.length; i += stride)
    {
        const newArr = [];
        for (let j = 0; j < stride; j++)
        {
            newArr[j] = arr[i + j] || 0;
        }
        result[count] = newArr;
        count++;
    }

    outArr.setRef(result);
};

}
};

CABLES.OPS["037a9886-c185-4ab2-8c7e-b9f85b1e678c"]={f:Ops.Array.ArrayToArrays,objName:"Ops.Array.ArrayToArrays"};




// **************************************************************
// 
// Ops.Array.ArrayGetArray
// 
// **************************************************************

Ops.Array.ArrayGetArray= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
const
    inArrays = op.inArray("Array of Arrays"),
    index = op.inValueInt("Index"),
    result = op.outArray("Result Array");

inArrays.onChange =
index.onChange = update;
op.toWorkPortsNeedToBeLinked(inArrays);

function update()
{
    let theArray = inArrays.get();
    if (!theArray)
    {
        result.set(null);
        return;
    }

    let ind = Math.floor(index.get());
    if (ind < 0 || ind > theArray.length - 1)
    {
        result.set(null);
        op.log("index wrong");
        return;
    }

    result.set(null);
    result.set(theArray[ind]);
}

}
};

CABLES.OPS["b9d3f42b-3fbf-4522-9df2-a5c769a92d66"]={f:Ops.Array.ArrayGetArray,objName:"Ops.Array.ArrayGetArray"};




// **************************************************************
// 
// Ops.Array.Array3GetNumbers
// 
// **************************************************************

Ops.Array.Array3GetNumbers= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
const
    pArr = op.inArray("Array", 3),
    pIndex = op.inValueInt("Index"),
    outX = op.outNumber("X"),
    outY = op.outNumber("Y"),
    outZ = op.outNumber("Z");
op.toWorkPortsNeedToBeLinked(pArr);
pArr.onChange =
    pIndex.onChange = update;

function update()
{
    let arr = pArr.get();
    if (!arr)
    {
        outX.set(0);
        outY.set(0);
        outZ.set(0);
        return;
    }
    let ind = Math.min(arr.length - 3, pIndex.get() * 3);
    if (arr)
    {
        outX.set(arr[ind + 0]);
        outY.set(arr[ind + 1]);
        outZ.set(arr[ind + 2]);
    }
}

}
};

CABLES.OPS["56882cc4-c40d-4dc0-bf7c-db1b5a7acad0"]={f:Ops.Array.Array3GetNumbers,objName:"Ops.Array.Array3GetNumbers"};




// **************************************************************
// 
// Ops.Gl.Matrix.QuaternionCamera
// 
// **************************************************************

Ops.Gl.Matrix.QuaternionCamera= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
const
    render = op.inTrigger("render"),
    trigger = op.outTrigger("trigger"),

    eyeX = op.inValueFloat("eyeX", 5),
    eyeY = op.inValueFloat("eyeY", 5),
    eyeZ = op.inValueFloat("eyeZ", 5),

    quatX = op.inValueFloat("quatX", 0),
    quatY = op.inValueFloat("quatY", 0),
    quatZ = op.inValueFloat("quatZ", 0),
    quatW = op.inValueFloat("quatW", 0),

    vecUpX = op.inValueFloat("upX", 0),
    vecUpY = op.inValueFloat("upY", 1),
    vecUpZ = op.inValueFloat("upZ", 0);

const cgl = op.patch.cgl;
const vUp = vec3.create();
const vEye = vec3.create();
const vCenter = vec3.create();
const vQuat = quat.create();
const transMatrix = mat4.create();
mat4.identity(transMatrix);


// arr[i*3+0]=n._animTrans[0].getValue(t);

// arrRot[i*4+3]=n._animRot[3].getValue(t);


const arr = [];

render.onTriggered = function ()
{
    if (cgl.tempData.shadowPass) return trigger.trigger();

    if (op.isCurrentUiOp())
        gui.setTransformGizmo(
            {
                "posX": eyeX,
                "posY": eyeY,
                "posZ": eyeZ
            });

    cgl.pushViewMatrix();

    quat.set(vQuat, quatX.get(), quatY.get(), quatZ.get(), quatW.get());

    vec3.set(vUp, vecUpX.get(), vecUpY.get(), vecUpZ.get());
    vec3.set(vEye, eyeX.get(), eyeY.get(), eyeZ.get());

    vec3.set(vCenter, 0, -1, 0);
    vec3.transformQuat(vCenter, vCenter, vQuat);
    vec3.normalize(vCenter, vCenter);
    vec3.add(vCenter, vCenter, vEye);

    mat4.lookAt(transMatrix, vEye, vCenter, vUp);

    mat4.multiply(cgl.vMatrix, cgl.vMatrix, transMatrix);

    trigger.trigger();
    cgl.popViewMatrix();
};

}
};

CABLES.OPS["7141c048-615e-47b5-9d8b-d0ceaad9bd79"]={f:Ops.Gl.Matrix.QuaternionCamera,objName:"Ops.Gl.Matrix.QuaternionCamera"};




// **************************************************************
// 
// Ops.Gl.Matrix.LookatCamera
// 
// **************************************************************

Ops.Gl.Matrix.LookatCamera= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
const render = op.inTrigger("render");
const trigger = op.outTrigger("trigger");

const eyeX = op.inValueFloat("eyeX");
const eyeY = op.inValueFloat("eyeY");
const eyeZ = op.inValueFloat("eyeZ");

const centerX = op.inValueFloat("centerX");
const centerY = op.inValueFloat("centerY");
const centerZ = op.inValueFloat("centerZ");

const vecUpX = op.inValueFloat("upX");
const vecUpY = op.inValueFloat("upY");
const vecUpZ = op.inValueFloat("upZ");

const outArr = op.outArray("Array");

centerX.set(0);
centerY.set(0);
centerZ.set(0);

eyeX.set(5);
eyeY.set(5);
eyeZ.set(5);

vecUpX.set(0);
vecUpY.set(1);
vecUpZ.set(0);

const cgl = op.patch.cgl;
const vUp = vec3.create();
const vEye = vec3.create();
const vCenter = vec3.create();
const transMatrix = mat4.create();
mat4.identity(transMatrix);

const arr = [];


render.onTriggered = function ()
{
    if (cgl.tempData.shadowPass) return trigger.trigger();


    if (op.isCurrentUiOp())
        gui.setTransformGizmo(
            {
                "posX": eyeX,
                "posY": eyeY,
                "posZ": eyeZ
            });


    cgl.pushViewMatrix();

    arr[0] = eyeX.get();
    arr[1] = eyeY.get();
    arr[2] = eyeZ.get();

    arr[3] = centerX.get();
    arr[4] = centerY.get();
    arr[5] = centerZ.get();

    arr[6] = vecUpX.get();
    arr[7] = vecUpY.get();
    arr[8] = vecUpZ.get();

    outArr.setRef(arr);

    vec3.set(vUp, vecUpX.get(), vecUpY.get(), vecUpZ.get());
    vec3.set(vEye, eyeX.get(), eyeY.get(), eyeZ.get());
    vec3.set(vCenter, centerX.get(), centerY.get(), centerZ.get());

    mat4.lookAt(transMatrix, vEye, vCenter, vUp);

    mat4.multiply(cgl.vMatrix, cgl.vMatrix, transMatrix);

    trigger.trigger();
    cgl.popViewMatrix();
};

}
};

CABLES.OPS["e0f1bad6-7dfb-4665-b458-ca50a1bfe7fa"]={f:Ops.Gl.Matrix.LookatCamera,objName:"Ops.Gl.Matrix.LookatCamera"};




// **************************************************************
// 
// Ops.Math.Compare.GreaterThan
// 
// **************************************************************

Ops.Math.Compare.GreaterThan= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
const
    number1 = op.inValueFloat("number1"),
    number2 = op.inValueFloat("number2"),
    result = op.outBoolNum("result");

op.setUiAttribs({ "mathTitle": true });

number1.onChange = number2.onChange = exec;

function exec()
{
    result.set(number1.get() > number2.get());
}

}
};

CABLES.OPS["b250d606-f7f8-44d3-b099-c29efff2608a"]={f:Ops.Math.Compare.GreaterThan,objName:"Ops.Math.Compare.GreaterThan"};




// **************************************************************
// 
// Ops.Math.MapRange
// 
// **************************************************************

Ops.Math.MapRange= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
const
    v = op.inValueFloat("value", 0),
    old_min = op.inValueFloat("old min", 0),
    old_max = op.inValueFloat("old max", 1),
    new_min = op.inValueFloat("new min", 0),
    new_max = op.inValueFloat("new max", 1),
    easing = op.inValueSelect("Easing", ["Linear", "Smoothstep", "Smootherstep"], "Linear"),
    inClamp = op.inBool("Clamp", true),
    result = op.outNumber("result", 0);

op.setPortGroup("Input Range", [old_min, old_max]);
op.setPortGroup("Output Range", [new_min, new_max]);

let doClamp = true;
let ease = 0;
let r = 0;

v.onChange =
    old_min.onChange =
    old_max.onChange =
    new_min.onChange =
    new_max.onChange = exec;

exec();

inClamp.onChange =
() =>
{
    doClamp = inClamp.get();
    exec();
};

easing.onChange = function ()
{
    if (easing.get() == "Smoothstep") ease = 1;
    else if (easing.get() == "Smootherstep") ease = 2;
    else ease = 0;
};

function exec()
{
    const nMin = new_min.get();
    const nMax = new_max.get();
    const oMin = old_min.get();
    const oMax = old_max.get();
    let x = v.get();

    if (doClamp)
    {
        if (x >= Math.max(oMax, oMin))
        {
            result.set(nMax);
            return;
        }
        else
        if (x <= Math.min(oMax, oMin))
        {
            result.set(nMin);
            return;
        }
    }

    let reverseInput = false;
    const oldMin = Math.min(oMin, oMax);
    const oldMax = Math.max(oMin, oMax);
    if (oldMin != oMin) reverseInput = true;

    let reverseOutput = false;
    const newMin = Math.min(nMin, nMax);
    const newMax = Math.max(nMin, nMax);
    if (newMin != nMin) reverseOutput = true;

    let portion = 0;

    if (reverseInput) portion = (oldMax - x) * (newMax - newMin) / (oldMax - oldMin);
    else portion = (x - oldMin) * (newMax - newMin) / (oldMax - oldMin);

    if (reverseOutput) r = newMax - portion;
    else r = portion + newMin;

    if (ease === 0)
    {
        result.set(r);
    }
    else
    if (ease == 1)
    {
        x = Math.max(0, Math.min(1, (r - nMin) / (nMax - nMin)));
        result.set(nMin + x * x * (3 - 2 * x) * (nMax - nMin)); // smoothstep
    }
    else
    if (ease == 2)
    {
        x = Math.max(0, Math.min(1, (r - nMin) / (nMax - nMin)));
        result.set(nMin + x * x * x * (x * (x * 6 - 15) + 10) * (nMax - nMin)); // smootherstep
    }
}

}
};

CABLES.OPS["2617b407-60a0-4ff6-b4a7-18136cfa7817"]={f:Ops.Math.MapRange,objName:"Ops.Math.MapRange"};




// **************************************************************
// 
// Ops.Math.Ease
// 
// **************************************************************

Ops.Math.Ease= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
const
    inVal = op.inValue("Value"),
    inMin = op.inValue("Min", 0),
    inMax = op.inValue("Max", 1),
    result = op.outNumber("Result"),
    anim = new CABLES.Anim();

anim.createPort(op, "Easing", updateAnimEasing);
anim.setValue(0, 0);
anim.setValue(1, 1);

op.onLoaded = inMin.onChange = inMax.onChange = updateMinMax;

function updateMinMax()
{
    anim.keys[0].time = anim.keys[0].value = Math.min(inMin.get(), inMax.get());
    anim.keys[1].time = anim.keys[1].value = Math.max(inMin.get(), inMax.get());
}

function updateAnimEasing()
{
    anim.keys[0].setEasing(anim.defaultEasing);
}

inVal.onChange = function ()
{
    const r = anim.getValue(inVal.get());
    result.set(r);
};

}
};

CABLES.OPS["8f6e4a08-33e6-408f-ac4a-198bd03b417b"]={f:Ops.Math.Ease,objName:"Ops.Math.Ease"};




// **************************************************************
// 
// Ops.Gl.Meshes.SplineMesh_v2
// 
// **************************************************************

Ops.Gl.Meshes.SplineMesh_v2= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
const
    render = op.inTrigger("Render"),
    inPoints = op.inArray("Points"),
    inHardEdges = op.inBool("Tesselate Edges", false),
    inRenderMesh = op.inBool("Render Mesh", true),
    next = op.outTrigger("Next");

const geom = new CGL.Geometry("splinemesh_2");
geom.vertices = [];
geom.clear();

let thePoints = [];
const cgl = op.patch.cgl;
let points = new Float32Array();
let points2 = new Float32Array();
let points3 = new Float32Array();
let doDraw = new Float32Array();
let splineIndex = null;

let pointsProgress = new Float32Array();
const pointsDoDraw = new Float32Array();
const arrEdges = [];

const verts = [0, 0, 0];

let mesh = new CGL.Mesh(cgl, geom);
mesh.addVertexNumbers = true;

let rebuildLater = true;

inHardEdges.onChange =
    inPoints.onChange = () => { rebuildLater = true; };

render.onTriggered = renderMesh;

let shader = null;

function renderMesh()
{
    if (rebuildLater)rebuild();
    if (mesh && inRenderMesh.get())
    {
        if (shader != cgl.getShader())
        {
            shader = cgl.getShader();
            if (!shader) return;
            if (shader.getName() != "splinemesh_material") op.setUiError("nosplinemat", "Splinemesh needs a SplineMeshMaterial!");
            else op.setUiError("nosplinemat");

            shader = cgl.getShader();
        }

        if (verts.length > 0) mesh.render(shader);
    }

    next.trigger();
}

function buildMesh()
{
    verts.length = 0;

    const max = 1;
    const min = -max;

    for (let i = 0; i < thePoints.length / 3; i++)
    {
        verts.push(
            max, min, 0, 0, min, 0, max, max, 0, 0, min, 0, 0, max, 0, max, max, 0
        );
    }
    geom.vertices = verts;

    // if(mesh)mesh.dispose();
    if (!mesh) mesh = new CGL.Mesh(cgl, geom);

    mesh.addVertexNumbers = true;
    mesh.setGeom(geom);
    mesh.addVertexNumbers = true;
}

function rebuild()
{
    const inpoints = inPoints.get();

    if (!inpoints || inpoints.length === 0)
    {
        mesh = null;
        return;
    }

    if (inpoints[0] && inpoints[0].length)
    {
        const arr = [];
        splineIndex = [];
        let count = 0;

        for (let i = 0; i < inpoints.length; i++)
        {
            for (let j = 0; j < inpoints[i].length / 3; j++)
            {
                splineIndex[(count - 3) / 3] = i;// (i) / inpoints.length;

                arr[count++] = inpoints[i][j * 3 + 0];
                arr[count++] = inpoints[i][j * 3 + 1];
                arr[count++] = inpoints[i][j * 3 + 2];
            }
        }
        thePoints = arr;
    }
    else
    {
        splineIndex = null;
        thePoints = inpoints;
    }

    if (inHardEdges.get()) thePoints = tessEdges(thePoints);

    buildMesh();

    const newLength = thePoints.length * 6;
    let count = 0;
    let lastIndex = 0;
    let drawable = 0;

    if (points.length != newLength)
    {
        points = new Float32Array(newLength);
        points2 = new Float32Array(newLength);
        points3 = new Float32Array(newLength);

        doDraw = new Float32Array(newLength / 3);
        pointsProgress = new Float32Array(newLength / 3);

        for (let i = 0; i < newLength / 3; i++) pointsProgress[i] = i / (newLength / 3);
    }

    for (let i = 0; i < thePoints.length / 3; i++)
    {
        if (splineIndex)
        {
            if (i > 1 && lastIndex != splineIndex[i]) drawable = 0.0;
            else drawable = 1.0;
            lastIndex = splineIndex[i];
        }
        else drawable = 1.0;

        for (let j = 0; j < 6; j++)
        {
            doDraw[count / 3] = drawable;

            for (let k = 0; k < 3; k++)
            {
                points[count] = thePoints[(Math.max(0, i - 1)) * 3 + k];
                points2[count] = thePoints[(i + 0) * 3 + k];
                points3[count] = thePoints[(i + 1) * 3 + k];
                count++;
            }
        }
    }

    mesh.setAttribute("spline", points, 3);
    mesh.setAttribute("spline2", points2, 3);
    mesh.setAttribute("spline3", points3, 3);
    mesh.setAttribute("splineDoDraw", doDraw, 1);
    mesh.setAttribute("splineProgress", pointsProgress, 1);

    rebuildLater = false;
}

function ip(a, b, p)
{
    return a + p * (b - a);
}

function tessEdges(oldArr)
{
    let count = 0;
    const step = 0.001;
    const oneMinusStep = 1 - step;
    const l = oldArr.length * 3 - 3;
    arrEdges.length = l;

    const tessSplineIndex = [];

    if (splineIndex) tessSplineIndex[0] = splineIndex[1];

    for (let i = 0; i < oldArr.length - 3; i += 3)
    {
        arrEdges[count++] = oldArr[i + 0];
        arrEdges[count++] = oldArr[i + 1];
        arrEdges[count++] = oldArr[i + 2];
        if (splineIndex) tessSplineIndex[count / 3] = splineIndex[i / 3];

        arrEdges[count++] = ip(oldArr[i + 0], oldArr[i + 3], step);
        arrEdges[count++] = ip(oldArr[i + 1], oldArr[i + 4], step);
        arrEdges[count++] = ip(oldArr[i + 2], oldArr[i + 5], step);
        if (splineIndex) tessSplineIndex[count / 3] = splineIndex[i / 3];

        arrEdges[count++] = ip(oldArr[i + 0], oldArr[i + 3], oneMinusStep);
        arrEdges[count++] = ip(oldArr[i + 1], oldArr[i + 4], oneMinusStep);
        arrEdges[count++] = ip(oldArr[i + 2], oldArr[i + 5], oneMinusStep);
        if (splineIndex) tessSplineIndex[count / 3] = splineIndex[i / 3];
    }

    if (splineIndex) splineIndex = tessSplineIndex;

    return arrEdges;
}

}
};

CABLES.OPS["287abf6c-5501-4bc9-a627-70ec3c3766d2"]={f:Ops.Gl.Meshes.SplineMesh_v2,objName:"Ops.Gl.Meshes.SplineMesh_v2"};




// **************************************************************
// 
// Ops.Gl.Meshes.SplineMeshMaterial_v2
// 
// **************************************************************

Ops.Gl.Meshes.SplineMeshMaterial_v2= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={"splinemat_frag":"IN vec2 texCoord;\nIN float splineDoDrawFrag;\nUNI vec4 color;\nUNI sampler2D tex;\nUNI sampler2D texMask;\n\n{{MODULES_HEAD}}\n\nvoid main()\n{\n    vec4 col=color;\n\n    #ifdef USE_TEXTURE\n        #ifdef TEX_COLORIZE\n            col*=texture(tex,texCoord);\n        #endif\n        #ifndef TEX_COLORIZE\n            col=texture(tex,texCoord);\n        #endif\n    #endif\n\n    col.a=color.a;\n\n    #ifdef USE_TEXMASK\n        col.a*=texture(texMask,texCoord).r;\n        if(col.a==0.0) discard;\n    #endif\n\n    {{MODULE_COLOR}}\n\n    // if(splineDoDrawFrag==0.0) col.rgb=vec3(1.0,0.0,0.0);\n    if(splineDoDrawFrag==0.0) discard;\n\n    outColor = col;\n}","splinemat_vert":"{{MODULES_HEAD}}\n\nIN vec3 vPosition;\nIN float attrVertIndex;\nIN float splineProgress;\nIN vec3 spline,spline2,spline3;\nIN float splineDoDraw;\n\nOUT float splineDoDrawFrag;\nOUT vec2 texCoord;\nOUT vec3 norm;\nUNI mat4 projMatrix;\nUNI mat4 viewMatrix;\nUNI mat4 modelMatrix;\n\nUNI float width;\nUNI float texOffset;\nUNI float aspect;\n\n#define PI 3.1415926538\n\nvec2 rotate(vec2 v, float a)\n{\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn m * v;\n}\n\nvec2 fix( vec4 i )\n{\n    vec2 res = i.xy / i.w;\n    return res;\n}\n\nvoid main()\n{\n    texCoord=vPosition.xy;\n    texCoord.y=texCoord.y*0.5+0.5;\n    #ifdef TEX_MAP_FULL\n        texCoord.x=splineProgress;\n    #endif\n    texCoord.x+=texOffset;\n\n    mat4 mMatrix=modelMatrix;\n    mat4 mvMatrix=viewMatrix * mMatrix;\n\n    splineDoDrawFrag=splineDoDraw;\n\n    // vec4 pos=vec4((spline2+spline3+spline)/3.0*vPosition,1.0);\n    vec4 pos=vec4(spline2,1.0);\n\n    {{MODULE_VERTEX_POSITION}}\n\n    vec4 finalPosition  = projMatrix * mvMatrix * (vec4(spline2,1.0));\n    vec4 finalPosition2 = projMatrix * mvMatrix * (vec4(spline3,1.0));\n\n    vec2 screenPos =fix(projMatrix * mvMatrix * vec4(spline,1.0));\n    vec2 screenPos2=fix(projMatrix * mvMatrix * vec4(spline2,1.0));\n    vec2 screenPos3=fix(projMatrix * mvMatrix * vec4(spline3,1.0));\n\n    float wid=width/10.0;\n\n    #ifndef PERSPWIDTH\n        wid=width*finalPosition.w*0.0025;\n    #endif\n\n    vec2 dir1 = normalize( screenPos2 - screenPos );\n    vec2 dir2 = normalize( screenPos3 - screenPos2 );\n\n\tif( screenPos2 == screenPos ) dir1 = normalize( screenPos3 - screenPos2 );\n\n    vec2 normal = vec2( -dir1.y/aspect, dir1.x ) * 0.5 * wid;\n    vec2 normal2 = vec2( -dir2.y/aspect, dir2.x ) * 0.5 * wid;\n\n    vec4 offset = vec4( mix(normal,normal2,vPosition.x) * vPosition.y, 0.0, 1.0 );\n\n    finalPosition = mix(finalPosition,finalPosition2,vPosition.x);\n\tfinalPosition.xy += offset.xy;\n\n    gl_Position = finalPosition;\n}\n",};
const
    render = op.inTrigger("Render"),
    inWidth = op.inFloat("Width", 0.2),
    inPerspective = op.inBool("Width Perspective", true),
    inTexture = op.inTexture("Texture"),
    inTextureMask = op.inTexture("Texture Mask"),
    inTexMap = op.inSwitch("Mapping", ["Full", "Face"], "Full"),
    inTexColorize = op.inBool("Colorize Texture", false),
    inTexOffset = op.inFloat("Offset", 0),
    r = op.inValueSlider("r", Math.random()),
    g = op.inValueSlider("g", Math.random()),
    b = op.inValueSlider("b", Math.random()),
    a = op.inValueSlider("a", 1),
    trigger = op.outTrigger("Trigger"),
    shaderOut = op.outObject("Shader");

r.setUiAttribs({ "colorPick": true });
shaderOut.ignoreValueSerialize = true;

const cgl = op.patch.cgl;

op.toWorkPortsNeedToBeLinked(render);
op.setPortGroup("Color", [r, g, b, a]);
op.setPortGroup("Texture", [inTexture, inTexMap, inTexColorize]);

const shader = new CGL.Shader(cgl, "splinemesh_material", this);
shader.setModules(["MODULE_VERTEX_POSITION", "MODULE_COLOR", "MODULE_BEGIN_FRAG"]);
shader.setSource(attachments.splinemat_vert, attachments.splinemat_frag);
shaderOut.setRef(shader);

const uniTex = shader.addUniformFrag("t", "tex");
const uniTexMask = shader.addUniformFrag("t", "texMask");

let aspect = 1.7777;

shader.addUniformFrag("4f", "color", r, g, b, a);
shader.addUniformFrag("f", "width", inWidth);
shader.addUniformFrag("f", "texOffset", inTexOffset);
shader.addUniformFrag("f", "aspect", aspect);
shader.toggleDefine("PERSPWIDTH", inPerspective);
shader.toggleDefine("USE_TEXTURE", inTexture);
shader.toggleDefine("TEX_COLORIZE", inTexColorize);
shader.toggleDefine("USE_TEXMASK", inTextureMask);

inTexMap.on("change", updateMapping);

render.onTriggered = doRender;
updateMapping();

function doRender()
{
    if (!shader) return;

    const vp = op.patch.cgl.getViewPort();
    const newAspect = vp[2] / vp[3];
    if (newAspect != aspect)
    {
        aspect = newAspect;
        shader.addUniformFrag("f", "aspect", aspect);
    }

    cgl.pushShader(shader);
    shader.popTextures();

    if (uniTex && inTexture.get()) shader.pushTexture(uniTex, inTexture.get().tex);
    if (uniTexMask && inTextureMask.get()) shader.pushTexture(uniTexMask, inTextureMask.get().tex);

    trigger.trigger();

    cgl.popShader();
}

function updateMapping()
{
    shader.toggleDefine("TEX_MAP_FULL", inTexMap.get() === "Full");
}

}
};

CABLES.OPS["5ff7c643-cbea-44cc-9f34-fb18a44bcfff"]={f:Ops.Gl.Meshes.SplineMeshMaterial_v2,objName:"Ops.Gl.Meshes.SplineMeshMaterial_v2"};




// **************************************************************
// 
// Ops.Graphics.Transform
// 
// **************************************************************

Ops.Graphics.Transform= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
const
    render = op.inTrigger("render"),
    posX = op.inValue("posX", 0),
    posY = op.inValue("posY", 0),
    posZ = op.inValue("posZ", 0),
    scale = op.inValue("scale", 1),
    rotX = op.inValue("rotX", 0),
    rotY = op.inValue("rotY", 0),
    rotZ = op.inValue("rotZ", 0),
    trigger = op.outTrigger("trigger");

op.setPortGroup("Rotation", [rotX, rotY, rotZ]);
op.setPortGroup("Position", [posX, posY, posZ]);
op.setPortGroup("Scale", [scale]);
op.setUiAxisPorts(posX, posY, posZ);

op.toWorkPortsNeedToBeLinked(render, trigger);

const vPos = vec3.create();
const vScale = vec3.create();
const transMatrix = mat4.create();
mat4.identity(transMatrix);

let
    doScale = false,
    doTranslate = false,
    translationChanged = true,
    scaleChanged = true,
    rotChanged = true;

rotX.onChange = rotY.onChange = rotZ.onChange = setRotChanged;
posX.onChange = posY.onChange = posZ.onChange = setTranslateChanged;
scale.onChange = setScaleChanged;

render.onTriggered = function ()
{
    // if(!CGL.TextureEffect.checkOpNotInTextureEffect(op)) return;

    let updateMatrix = false;
    if (translationChanged)
    {
        updateTranslation();
        updateMatrix = true;
    }
    if (scaleChanged)
    {
        updateScale();
        updateMatrix = true;
    }
    if (rotChanged) updateMatrix = true;

    if (updateMatrix) doUpdateMatrix();

    const cg = op.patch.cg || op.patch.cgl;
    cg.pushModelMatrix();
    mat4.multiply(cg.mMatrix, cg.mMatrix, transMatrix);

    trigger.trigger();
    cg.popModelMatrix();

    if (CABLES.UI)
    {
        if (!posX.isLinked() && !posY.isLinked() && !posZ.isLinked())
        {
            gui.setTransform(op.id, posX.get(), posY.get(), posZ.get());

            if (op.isCurrentUiOp())
                gui.setTransformGizmo(
                    {
                        "posX": posX,
                        "posY": posY,
                        "posZ": posZ,
                    });
        }
    }
};

// op.transform3d = function ()
// {
//     return { "pos": [posX, posY, posZ] };
// };

function doUpdateMatrix()
{
    mat4.identity(transMatrix);
    if (doTranslate)mat4.translate(transMatrix, transMatrix, vPos);

    if (rotX.get() !== 0)mat4.rotateX(transMatrix, transMatrix, rotX.get() * CGL.DEG2RAD);
    if (rotY.get() !== 0)mat4.rotateY(transMatrix, transMatrix, rotY.get() * CGL.DEG2RAD);
    if (rotZ.get() !== 0)mat4.rotateZ(transMatrix, transMatrix, rotZ.get() * CGL.DEG2RAD);

    if (doScale)mat4.scale(transMatrix, transMatrix, vScale);
    rotChanged = false;
}

function updateTranslation()
{
    doTranslate = false;
    if (posX.get() !== 0.0 || posY.get() !== 0.0 || posZ.get() !== 0.0) doTranslate = true;
    vec3.set(vPos, posX.get(), posY.get(), posZ.get());
    translationChanged = false;
}

function updateScale()
{
    // doScale=false;
    // if(scale.get()!==0.0)
    doScale = true;
    vec3.set(vScale, scale.get(), scale.get(), scale.get());
    scaleChanged = false;
}

function setTranslateChanged()
{
    translationChanged = true;
}

function setScaleChanged()
{
    scaleChanged = true;
}

function setRotChanged()
{
    rotChanged = true;
}

doUpdateMatrix();

}
};

CABLES.OPS["650baeb1-db2d-4781-9af6-ab4e9d4277be"]={f:Ops.Graphics.Transform,objName:"Ops.Graphics.Transform"};




// **************************************************************
// 
// Ops.Gl.Shader.BasicMaterial_v3
// 
// **************************************************************

Ops.Gl.Shader.BasicMaterial_v3= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={"basicmaterial_frag":"{{MODULES_HEAD}}\n\nIN vec2 texCoord;\n\n#ifdef VERTEX_COLORS\nIN vec4 vertCol;\n#endif\n\n#ifdef HAS_TEXTURES\n    IN vec2 texCoordOrig;\n    #ifdef HAS_TEXTURE_DIFFUSE\n        UNI sampler2D tex;\n    #endif\n    #ifdef HAS_TEXTURE_OPACITY\n        UNI sampler2D texOpacity;\n   #endif\n#endif\n\n\n\nvoid main()\n{\n    {{MODULE_BEGIN_FRAG}}\n    vec4 col=color;\n\n\n    #ifdef HAS_TEXTURES\n        vec2 uv=texCoord;\n\n        #ifdef CROP_TEXCOORDS\n            if(uv.x<0.0 || uv.x>1.0 || uv.y<0.0 || uv.y>1.0) discard;\n        #endif\n\n        #ifdef HAS_TEXTURE_DIFFUSE\n            col=texture(tex,uv);\n\n            #ifdef COLORIZE_TEXTURE\n                col.r*=color.r;\n                col.g*=color.g;\n                col.b*=color.b;\n            #endif\n        #endif\n        col.a*=color.a;\n        #ifdef HAS_TEXTURE_OPACITY\n            #ifdef TRANSFORMALPHATEXCOORDS\n                uv=texCoordOrig;\n            #endif\n            #ifdef ALPHA_MASK_IR\n                col.a*=1.0-texture(texOpacity,uv).r;\n            #endif\n            #ifdef ALPHA_MASK_IALPHA\n                col.a*=1.0-texture(texOpacity,uv).a;\n            #endif\n            #ifdef ALPHA_MASK_ALPHA\n                col.a*=texture(texOpacity,uv).a;\n            #endif\n            #ifdef ALPHA_MASK_LUMI\n                col.a*=dot(vec3(0.2126,0.7152,0.0722), texture(texOpacity,uv).rgb);\n            #endif\n            #ifdef ALPHA_MASK_R\n                col.a*=texture(texOpacity,uv).r;\n            #endif\n            #ifdef ALPHA_MASK_G\n                col.a*=texture(texOpacity,uv).g;\n            #endif\n            #ifdef ALPHA_MASK_B\n                col.a*=texture(texOpacity,uv).b;\n            #endif\n            // #endif\n        #endif\n    #endif\n\n    {{MODULE_COLOR}}\n\n    #ifdef DISCARDTRANS\n        if(col.a<0.2) discard;\n    #endif\n\n    #ifdef VERTEX_COLORS\n        col*=vertCol;\n    #endif\n\n    outColor = col;\n}\n","basicmaterial_vert":"\n{{MODULES_HEAD}}\n\nOUT vec2 texCoord;\nOUT vec2 texCoordOrig;\n\nUNI mat4 projMatrix;\nUNI mat4 modelMatrix;\nUNI mat4 viewMatrix;\n\n#ifdef HAS_TEXTURES\n    UNI float diffuseRepeatX;\n    UNI float diffuseRepeatY;\n    UNI float texOffsetX;\n    UNI float texOffsetY;\n#endif\n\n#ifdef VERTEX_COLORS\n    in vec4 attrVertColor;\n    out vec4 vertCol;\n\n#endif\n\n\nvoid main()\n{\n    mat4 mMatrix=modelMatrix;\n    mat4 modelViewMatrix;\n\n    norm=attrVertNormal;\n    texCoordOrig=attrTexCoord;\n    texCoord=attrTexCoord;\n    #ifdef HAS_TEXTURES\n        texCoord.x=texCoord.x*diffuseRepeatX+texOffsetX;\n        texCoord.y=(1.0-texCoord.y)*diffuseRepeatY+texOffsetY;\n    #endif\n\n    #ifdef VERTEX_COLORS\n        vertCol=attrVertColor;\n    #endif\n\n    vec4 pos = vec4(vPosition, 1.0);\n\n    #ifdef BILLBOARD\n       vec3 position=vPosition;\n       modelViewMatrix=viewMatrix*modelMatrix;\n\n       gl_Position = projMatrix * modelViewMatrix * vec4((\n           position.x * vec3(\n               modelViewMatrix[0][0],\n               modelViewMatrix[1][0],\n               modelViewMatrix[2][0] ) +\n           position.y * vec3(\n               modelViewMatrix[0][1],\n               modelViewMatrix[1][1],\n               modelViewMatrix[2][1]) ), 1.0);\n    #endif\n\n    {{MODULE_VERTEX_POSITION}}\n\n    #ifndef BILLBOARD\n        modelViewMatrix=viewMatrix * mMatrix;\n\n        {{MODULE_VERTEX_MODELVIEW}}\n\n    #endif\n\n    // mat4 modelViewMatrix=viewMatrix*mMatrix;\n\n    #ifndef BILLBOARD\n        // gl_Position = projMatrix * viewMatrix * modelMatrix * pos;\n        gl_Position = projMatrix * modelViewMatrix * pos;\n    #endif\n}\n",};
const render = op.inTrigger("render");
const trigger = op.outTrigger("trigger");
const shaderOut = op.outObject("shader", null, "shader");

shaderOut.ignoreValueSerialize = true;

op.toWorkPortsNeedToBeLinked(render);
op.toWorkShouldNotBeChild("Ops.Gl.TextureEffects.ImageCompose", CABLES.OP_PORT_TYPE_FUNCTION);

const cgl = op.patch.cgl;

const shader = new CGL.Shader(cgl, "basicmaterial", this);
shader.addAttribute({ "type": "vec3", "name": "vPosition" });
shader.addAttribute({ "type": "vec2", "name": "attrTexCoord" });
shader.addAttribute({ "type": "vec3", "name": "attrVertNormal", "nameFrag": "norm" });
shader.addAttribute({ "type": "float", "name": "attrVertIndex" });

shader.setModules(["MODULE_VERTEX_POSITION", "MODULE_COLOR", "MODULE_BEGIN_FRAG", "MODULE_VERTEX_MODELVIEW"]);

shader.setSource(attachments.basicmaterial_vert, attachments.basicmaterial_frag);

shaderOut.setRef(shader);

render.onTriggered = doRender;

// rgba colors
const r = op.inValueSlider("r", Math.random());
const g = op.inValueSlider("g", Math.random());
const b = op.inValueSlider("b", Math.random());
const a = op.inValueSlider("a", 1);
r.setUiAttribs({ "colorPick": true });

// const uniColor=new CGL.Uniform(shader,'4f','color',r,g,b,a);
const colUni = shader.addUniformFrag("4f", "color", r, g, b, a);

shader.uniformColorDiffuse = colUni;

// diffuse outTexture

const diffuseTexture = op.inTexture("texture");
let diffuseTextureUniform = null;
diffuseTexture.onChange = updateDiffuseTexture;

const colorizeTexture = op.inValueBool("colorizeTexture", false);
const vertexColors = op.inValueBool("Vertex Colors", false);

// opacity texture
const textureOpacity = op.inTexture("textureOpacity");
let textureOpacityUniform = null;

const alphaMaskSource = op.inSwitch("Alpha Mask Source", ["Luminance", "R", "G", "B", "A", "1-A", "1-R"], "Luminance");
alphaMaskSource.setUiAttribs({ "greyout": true });
textureOpacity.onChange = updateOpacity;

const texCoordAlpha = op.inValueBool("Opacity TexCoords Transform", false);
const discardTransPxl = op.inValueBool("Discard Transparent Pixels");

// texture coords
const
    diffuseRepeatX = op.inValue("diffuseRepeatX", 1),
    diffuseRepeatY = op.inValue("diffuseRepeatY", 1),
    diffuseOffsetX = op.inValue("Tex Offset X", 0),
    diffuseOffsetY = op.inValue("Tex Offset Y", 0),
    cropRepeat = op.inBool("Crop TexCoords", false);

shader.addUniformFrag("f", "diffuseRepeatX", diffuseRepeatX);
shader.addUniformFrag("f", "diffuseRepeatY", diffuseRepeatY);
shader.addUniformFrag("f", "texOffsetX", diffuseOffsetX);
shader.addUniformFrag("f", "texOffsetY", diffuseOffsetY);

const doBillboard = op.inValueBool("billboard", false);

alphaMaskSource.onChange =
    doBillboard.onChange =
    discardTransPxl.onChange =
    texCoordAlpha.onChange =
    cropRepeat.onChange =
    vertexColors.onChange =
    colorizeTexture.onChange = updateDefines;

op.setPortGroup("Color", [r, g, b, a]);
op.setPortGroup("Color Texture", [diffuseTexture, vertexColors, colorizeTexture]);
op.setPortGroup("Opacity", [textureOpacity, alphaMaskSource, discardTransPxl, texCoordAlpha]);
op.setPortGroup("Texture Transform", [diffuseRepeatX, diffuseRepeatY, diffuseOffsetX, diffuseOffsetY, cropRepeat]);

updateOpacity();
updateDiffuseTexture();

op.preRender = function ()
{
    shader.bind();
    doRender();
    if (!shader) return;
};

function doRender()
{
    op.checkGraphicsApi();
    cgl.pushShader(shader);
    shader.popTextures();

    if (diffuseTextureUniform && diffuseTexture.get()) shader.pushTexture(diffuseTextureUniform, diffuseTexture.get());
    if (textureOpacityUniform && textureOpacity.get()) shader.pushTexture(textureOpacityUniform, textureOpacity.get());

    trigger.trigger();

    cgl.popShader();
}

function updateOpacity()
{
    if (textureOpacity.get())
    {
        if (textureOpacityUniform !== null) return;
        shader.removeUniform("texOpacity");
        shader.define("HAS_TEXTURE_OPACITY");
        if (!textureOpacityUniform)textureOpacityUniform = new CGL.Uniform(shader, "t", "texOpacity");
    }
    else
    {
        shader.removeUniform("texOpacity");
        shader.removeDefine("HAS_TEXTURE_OPACITY");
        textureOpacityUniform = null;
    }

    updateDefines();
}

function updateDiffuseTexture()
{
    if (diffuseTexture.get())
    {
        if (!shader.hasDefine("HAS_TEXTURE_DIFFUSE"))shader.define("HAS_TEXTURE_DIFFUSE");
        if (!diffuseTextureUniform)diffuseTextureUniform = new CGL.Uniform(shader, "t", "texDiffuse");
    }
    else
    {
        shader.removeUniform("texDiffuse");
        shader.removeDefine("HAS_TEXTURE_DIFFUSE");
        diffuseTextureUniform = null;
    }
    updateUi();
}

function updateUi()
{
    const hasTexture = diffuseTexture.isLinked() || textureOpacity.isLinked();
    diffuseRepeatX.setUiAttribs({ "greyout": !hasTexture });
    diffuseRepeatY.setUiAttribs({ "greyout": !hasTexture });
    diffuseOffsetX.setUiAttribs({ "greyout": !hasTexture });
    diffuseOffsetY.setUiAttribs({ "greyout": !hasTexture });
    colorizeTexture.setUiAttribs({ "greyout": !hasTexture });

    alphaMaskSource.setUiAttribs({ "greyout": !textureOpacity.get() });
    texCoordAlpha.setUiAttribs({ "greyout": !textureOpacity.get() });

    let notUsingColor = true;
    notUsingColor = diffuseTexture.get() && !colorizeTexture.get();
    r.setUiAttribs({ "greyout": notUsingColor });
    g.setUiAttribs({ "greyout": notUsingColor });
    b.setUiAttribs({ "greyout": notUsingColor });
}

function updateDefines()
{
    shader.toggleDefine("VERTEX_COLORS", vertexColors.get());
    shader.toggleDefine("CROP_TEXCOORDS", cropRepeat.get());
    shader.toggleDefine("COLORIZE_TEXTURE", colorizeTexture.get());
    shader.toggleDefine("TRANSFORMALPHATEXCOORDS", texCoordAlpha.get());
    shader.toggleDefine("DISCARDTRANS", discardTransPxl.get());
    shader.toggleDefine("BILLBOARD", doBillboard.get());

    shader.toggleDefine("ALPHA_MASK_ALPHA", alphaMaskSource.get() == "A");
    shader.toggleDefine("ALPHA_MASK_IALPHA", alphaMaskSource.get() == "1-A");
    shader.toggleDefine("ALPHA_MASK_IR", alphaMaskSource.get() == "1-R");
    shader.toggleDefine("ALPHA_MASK_LUMI", alphaMaskSource.get() == "Luminance");
    shader.toggleDefine("ALPHA_MASK_R", alphaMaskSource.get() == "R");
    shader.toggleDefine("ALPHA_MASK_G", alphaMaskSource.get() == "G");
    shader.toggleDefine("ALPHA_MASK_B", alphaMaskSource.get() == "B");
    updateUi();
}

}
};

CABLES.OPS["ec55d252-3843-41b1-b731-0482dbd9e72b"]={f:Ops.Gl.Shader.BasicMaterial_v3,objName:"Ops.Gl.Shader.BasicMaterial_v3"};




// **************************************************************
// 
// Ops.Gl.Matrix.Scale
// 
// **************************************************************

Ops.Gl.Matrix.Scale= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
const
    render = op.inTrigger("render"),
    scale = op.inValueFloat("scale", 1.0),
    scaleX = op.inValueFloat("x", 1),
    scaleY = op.inValueFloat("y", 1),
    scaleZ = op.inValueFloat("z", 1),
    trigger = op.outTrigger("trigger");

op.setPortGroup("Axis", [scaleX, scaleY, scaleZ]);

const vScale = vec3.create();

scaleX.onChange =
    scaleY.onChange =
    scaleZ.onChange =
    scale.onChange = scaleChanged;

scaleChanged();

render.onTriggered = function ()
{
    const cgl = op.patch.cg || op.patch.cgl;
    cgl.pushModelMatrix();
    mat4.scale(cgl.mMatrix, cgl.mMatrix, vScale);
    trigger.trigger();
    cgl.popModelMatrix();
};

function scaleChanged()
{
    const s = scale.get();
    vec3.set(vScale, s * scaleX.get(), s * scaleY.get(), s * scaleZ.get());
}

}
};

CABLES.OPS["50e7f565-0cdb-47ca-912b-87c04e2f00e3"]={f:Ops.Gl.Matrix.Scale,objName:"Ops.Gl.Matrix.Scale"};




// **************************************************************
// 
// Ops.Graphics.Meshes.Rectangle_v4
// 
// **************************************************************

Ops.Graphics.Meshes.Rectangle_v4= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
const
    render = op.inTrigger("render"),
    doRender = op.inValueBool("Render Mesh", true),
    width = op.inValue("width", 1),
    height = op.inValue("height", 1),
    pivotX = op.inSwitch("pivot x", ["left", "center", "right"], "center"),
    pivotY = op.inSwitch("pivot y", ["top", "center", "bottom"], "center"),
    axis = op.inSwitch("axis", ["xy", "xz"], "xy"),
    flipTcX = op.inBool("Flip TexCoord X", false),
    flipTcY = op.inBool("Flip TexCoord Y", true),
    nColumns = op.inValueInt("num columns", 1),
    nRows = op.inValueInt("num rows", 1),
    trigger = op.outTrigger("trigger"),
    geomOut = op.outObject("geometry", null, "geometry");

geomOut.ignoreValueSerialize = true;

const geom = new CGL.Geometry("rectangle");

doRender.setUiAttribs({ "title": "Render" });
render.setUiAttribs({ "title": "Trigger" });
trigger.setUiAttribs({ "title": "Next" });
op.setPortGroup("Pivot", [pivotX, pivotY, axis]);
op.setPortGroup("Size", [width, height]);
op.setPortGroup("Structure", [nColumns, nRows]);
op.toWorkPortsNeedToBeLinked(render);
op.toWorkShouldNotBeChild("Ops.Gl.TextureEffects.ImageCompose", CABLES.OP_PORT_TYPE_TRIGGER);

const AXIS_XY = 0;
const AXIS_XZ = 1;

let curAxis = AXIS_XY;
let mesh = null;
let needsRebuild = true;
let doScale = true;

const vScale = vec3.create();
vec3.set(vScale, 1, 1, 1);

axis.onChange =
    pivotX.onChange =
    pivotY.onChange =
    flipTcX.onChange =
    flipTcY.onChange =
    nRows.onChange =
    nColumns.onChange = rebuildLater;
updateScale();

width.onChange =
    height.onChange =
    () =>
    {
        if (doScale) updateScale();
        else needsRebuild = true;
    };

function updateScale()
{
    if (curAxis === AXIS_XY) vec3.set(vScale, width.get(), height.get(), 1);
    if (curAxis === AXIS_XZ) vec3.set(vScale, width.get(), 1, height.get());
}

geomOut.onLinkChanged = () =>
{
    doScale = !geomOut.isLinked();
    updateScale();
    needsRebuild = true;
};

function rebuildLater()
{
    needsRebuild = true;
}

render.onTriggered = () =>
{
    if (needsRebuild) rebuild();
    const cg = op.patch.cg;
    if (cg && mesh && doRender.get())
    {
        if (doScale)
        {
            cg.pushModelMatrix();
            mat4.scale(cg.mMatrix, cg.mMatrix, vScale);
        }

        mesh.render(cg.getShader());

        if (doScale) cg.popModelMatrix();
    }

    trigger.trigger();
};

op.onDelete = function () { if (mesh)mesh.dispose(); };

function rebuild()
{
    if (axis.get() == "xy") curAxis = AXIS_XY;
    if (axis.get() == "xz") curAxis = AXIS_XZ;

    updateScale();
    let w = width.get();
    let h = height.get();

    if (doScale) w = h = 1;

    let x = 0;
    let y = 0;

    if (pivotX.get() == "center") x = 0;
    else if (pivotX.get() == "right") x = -w / 2;
    else if (pivotX.get() == "left") x = +w / 2;

    if (pivotY.get() == "center") y = 0;
    else if (pivotY.get() == "top") y = -h / 2;
    else if (pivotY.get() == "bottom") y = +h / 2;

    const numRows = Math.max(1, Math.round(nRows.get()));
    const numColumns = Math.max(1, Math.round(nColumns.get()));

    const stepColumn = w / numColumns;
    const stepRow = h / numRows;

    const indices = [];
    const tc = new Float32Array((numColumns + 1) * (numRows + 1) * 2);
    const verts = new Float32Array((numColumns + 1) * (numRows + 1) * 3);
    const norms = new Float32Array((numColumns + 1) * (numRows + 1) * 3);
    const tangents = new Float32Array((numColumns + 1) * (numRows + 1) * 3);
    const biTangents = new Float32Array((numColumns + 1) * (numRows + 1) * 3);

    let idxTc = 0;
    let idxVert = 0;
    let idxNorms = 0;
    let idxTangent = 0;
    let idxBiTangent = 0;

    for (let r = 0; r <= numRows; r++)
    {
        for (let c = 0; c <= numColumns; c++)
        {
            verts[idxVert++] = c * stepColumn - w / 2 + x;
            if (curAxis == AXIS_XZ) verts[idxVert++] = 0;
            verts[idxVert++] = r * stepRow - h / 2 + y;

            if (curAxis == AXIS_XY)verts[idxVert++] = 0;

            tc[idxTc++] = c / numColumns;
            tc[idxTc++] = r / numRows;

            if (curAxis == AXIS_XY) // default
            {
                norms[idxNorms++] = 0;
                norms[idxNorms++] = 0;
                norms[idxNorms++] = 1;

                tangents[idxTangent++] = 1;
                tangents[idxTangent++] = 0;
                tangents[idxTangent++] = 0;

                biTangents[idxBiTangent++] = 0;
                biTangents[idxBiTangent++] = 1;
                biTangents[idxBiTangent++] = 0;
            }
            else if (curAxis == AXIS_XZ)
            {
                norms[idxNorms++] = 0;
                norms[idxNorms++] = 1;
                norms[idxNorms++] = 0;

                biTangents[idxBiTangent++] = 0;
                biTangents[idxBiTangent++] = 0;
                biTangents[idxBiTangent++] = 1;
            }
        }
    }

    indices.length = numColumns * numRows * 6;
    let idx = 0;

    for (let c = 0; c < numColumns; c++)
    {
        for (let r = 0; r < numRows; r++)
        {
            const ind = c + (numColumns + 1) * r;
            const v1 = ind;
            const v2 = ind + 1;
            const v3 = ind + numColumns + 1;
            const v4 = ind + 1 + numColumns + 1;

            if (curAxis == AXIS_XY) // default
            {
                indices[idx++] = v1;
                indices[idx++] = v2;
                indices[idx++] = v3;

                indices[idx++] = v3;
                indices[idx++] = v2;
                indices[idx++] = v4;
            }
            else
            if (curAxis == AXIS_XZ)
            {
                indices[idx++] = v1;
                indices[idx++] = v3;
                indices[idx++] = v2;

                indices[idx++] = v2;
                indices[idx++] = v3;
                indices[idx++] = v4;
            }
        }
    }

    if (flipTcY.get()) for (let i = 0; i < tc.length; i += 2)tc[i + 1] = 1.0 - tc[i + 1];
    if (flipTcX.get()) for (let i = 0; i < tc.length; i += 2)tc[i] = 1.0 - tc[i];

    geom.clear();
    geom.vertices = verts;
    geom.texCoords = tc;
    geom.verticesIndices = indices;
    geom.vertexNormals = norms;
    geom.tangents = tangents;
    geom.biTangents = biTangents;

    if (op.patch.cg)
        if (!mesh) mesh = op.patch.cg.createMesh(geom, { "opId": op.id });
        else mesh.setGeom(geom);

    geomOut.setRef(geom);
    needsRebuild = false;
}

}
};

CABLES.OPS["cc8c3ede-7103-410b-849f-a645793cab39"]={f:Ops.Graphics.Meshes.Rectangle_v4,objName:"Ops.Graphics.Meshes.Rectangle_v4"};




// **************************************************************
// 
// Ops.Array.Array2To3
// 
// **************************************************************

Ops.Array.Array2To3= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
const
    inArr = op.inArray("Array2x", 2),
    outArr = op.outArray("Array3x", 3),
    outTotalPoints = op.outNumber("Total points"),
    outArrayLength = op.outNumber("Array length");

let arr = [];
let showingError = false;

inArr.onChange = function ()
{
    let theArray = inArr.get();
    if (!theArray)
    {
        outArr.set(null);
        return;
    }

    if (theArray.length % 2 != 0)
    {
        if (!showingError)
        {
            op.setUiError("warning", "Arrays length not divisible by 2!");
            showingError = true;
        }
        outArr.set(null);
        outTotalPoints.set(0);
        outArrayLength.set(0);
        return;
    }
    if (showingError)
    {
        showingError = false;
        op.setUiError("warning", null);
    }

    if ((theArray.length / 2) * 3 != arr.length)
    {
        arr.length = (theArray.length / 2) * 3;
    }

    for (let i = 0; i < theArray.length / 2; i++)
    {
        arr[i * 3 + 0] = theArray[i * 2 + 0];
        arr[i * 3 + 1] = theArray[i * 2 + 1];
        arr[i * 3 + 2] = 0;
    }

    outArr.setRef(arr);
    outTotalPoints.set(arr.length / 3);
    outArrayLength.set(arr.length);
};

}
};

CABLES.OPS["9854162e-d415-4300-a47b-173772b454e9"]={f:Ops.Array.Array2To3,objName:"Ops.Array.Array2To3"};




// **************************************************************
// 
// Ops.Array.ArrayGetTexture
// 
// **************************************************************

Ops.Array.ArrayGetTexture= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
const
    array = op.inArray("array"),
    index = op.inValueInt("index"),
    value = op.outTexture("value");

let last = null;

array.ignoreValueSerialize = true;
value.ignoreValueSerialize = true;

index.onChange =
    array.onChange = update;

op.toWorkPortsNeedToBeLinked(array, value);

const emptyTex = CGL.Texture.getEmptyTexture(op.patch.cgl);

function update()
{
    const arr = array.get();
    let ind = index.get();
    if (ind < 0 || !arr || ind >= arr.length)
    {
        value.setRef(emptyTex);
        return;
    }

    if (arr[ind])
    {
        value.setRef(arr[ind] || emptyTex);
        last = arr[ind];
    }
    else
        value.setRef(emptyTex);
}

}
};

CABLES.OPS["afea522b-ab72-4574-b721-5d37f5abaf77"]={f:Ops.Array.ArrayGetTexture,objName:"Ops.Array.ArrayGetTexture"};




// **************************************************************
// 
// Ops.Gl.TextureArrayLoaderFromArray_v2
// 
// **************************************************************

Ops.Gl.TextureArrayLoaderFromArray_v2= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
const
    filenames = op.inArray("urls"),
    tfilter = op.inDropDown("filter", ["nearest", "linear", "mipmap"], "linear"),
    wrap = op.inDropDown("wrap", ["repeat", "mirrored repeat", "clamp to edge"], "repeat"),
    flip = op.inBool("Flip", false),
    unpackAlpha = op.inBool("unpackPreMultipliedAlpha", false),
    inCaching = op.inBool("Caching", false),
    inPatchAsset = op.inBool("Asset in patch", false),
    arrOut = op.outArray("TextureArray"),
    width = op.outNumber("width"),
    height = op.outNumber("height"),
    loading = op.outBoolNum("loading"),
    ratio = op.outNumber("Aspect Ratio");

op.toWorkPortsNeedToBeLinked(filenames);

const cgl = op.patch.cgl;
const arr = [];
let cgl_filter = CGL.Texture.FILTER_LINEAR;
let cgl_wrap = CGL.Texture.WRAP_MIRRORED_REPEAT;
let loadingId = null;
let timedLoader = 0;
arrOut.set(arr);

inPatchAsset.onChange =
    flip.onChange =
    unpackAlpha.onChange =
    filenames.onChange = reload;

tfilter.onChange = onFilterChange;
wrap.onChange = onWrapChange;

function reload(nocache)
{
    if (!filenames.isLinked())
    {
        arrOut.setRef(null);
        return;
    }
    clearTimeout(timedLoader);
    timedLoader = setTimeout(function ()
    {
        realReload(nocache);
    }, 30);
}

function loadImage(_i, _url, nocache, cb)
{
    let url = _url;
    const i = _i;
    if (!url) return;

    if (inPatchAsset.get())
    {
        let patchId = null;
        if (op.storage && op.storage.blueprint && op.storage.blueprint.patchId)
        {
            patchId = op.storage.blueprint.patchId;
        }
        url = op.patch.getAssetPath(patchId) + url;
    }

    url = op.patch.getFilePath(url);

    if (!inCaching.get()) if (nocache)url += "?rnd=" + CABLES.generateUUID();

    let tex = CGL.Texture.load(cgl, url,
        function (err)
        {
            if (err)
            {
                const errMsg = "could not load texture \"" + url + "\"";
                op.uiAttr({ "error": errMsg });
                op.warn("[TextureArrayLoader] " + errMsg);
                if (cb)cb();
                return;
            }
            else op.uiAttr({ "error": null });

            width.set(tex.width);
            height.set(tex.height);
            ratio.set(tex.width / tex.height);

            arr[i] = tex;

            arrOut.setRef(arr);
            if (cb)cb();
        }, {
            "wrap": cgl_wrap,
            "flip": flip.get(),
            "unpackAlpha": unpackAlpha.get(),
            "filter": cgl_filter
        });
}

function realReload(nocache)
{
    const files = filenames.get();

    if (!files || files.length == 0) return;

    if (loadingId)cgl.patch.loading.finished(loadingId);

    loadingId = cgl.patch.loading.start("texturearray", CABLES.uuid(), op);
    loading.set(true);

    for (let i = 0; i < files.length; i++)
    {
        arr[i] = CGL.Texture.getEmptyTexture(cgl);
        let cb = null;
        if (i == files.length - 1)
        {
            cb = () =>
            {
                loading.set(false);
                cgl.patch.loading.finished(loadingId);
            };
        }

        if (!files[i]) { if (cb) cb(); }
        else loadImage(i, files[i], nocache, cb);
    }
}

function onFilterChange()
{
    if (tfilter.get() == "nearest") cgl_filter = CGL.Texture.FILTER_NEAREST;
    if (tfilter.get() == "linear") cgl_filter = CGL.Texture.FILTER_LINEAR;
    if (tfilter.get() == "mipmap") cgl_filter = CGL.Texture.FILTER_MIPMAP;

    reload();
}

function onWrapChange()
{
    if (wrap.get() == "repeat") cgl_wrap = CGL.Texture.WRAP_REPEAT;
    if (wrap.get() == "mirrored repeat") cgl_wrap = CGL.Texture.WRAP_MIRRORED_REPEAT;
    if (wrap.get() == "clamp to edge") cgl_wrap = CGL.Texture.WRAP_CLAMP_TO_EDGE;

    reload();
}

op.onFileChanged = function (fn)
{
    // should reload changed files that are used in the array
};

}
};

CABLES.OPS["f994015c-72ab-42f4-9ef7-a6409a9efb9b"]={f:Ops.Gl.TextureArrayLoaderFromArray_v2,objName:"Ops.Gl.TextureArrayLoaderFromArray_v2"};




// **************************************************************
// 
// Ops.Gl.Textures.TextureArrayInfo
// 
// **************************************************************

Ops.Gl.Textures.TextureArrayInfo= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
const
    inArr = op.inArray("Texture Array"),
    outArrNames = op.outArray("names"),
    outArrWidth = op.outArray("Widths"),
    outArrHeight = op.outArray("Heights");

inArr.onChange = () =>
{
    const arr = inArr.get();
    const arrWidths = [];
    const arrHeights = [];
    const arrNames = [];

    if (arr)
        for (let i = 0; i < arr.length; i++)
        {
            if (arr[i] && arr[i].tex)
            {
                arrWidths.push(arr[i].width);
                arrHeights.push(arr[i].height);
                arrNames.push(arr[i].name);
            }
        }

    outArrWidth.setRef(arrWidths);
    outArrHeight.setRef(arrHeights);
    outArrNames.setRef(arrNames);
};

}
};

CABLES.OPS["afaa2e73-4f97-4e4a-bf23-c17e1dd1c0ad"]={f:Ops.Gl.Textures.TextureArrayInfo,objName:"Ops.Gl.Textures.TextureArrayInfo"};




// **************************************************************
// 
// Ops.Array.ArrayGetNumber
// 
// **************************************************************

Ops.Array.ArrayGetNumber= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
const
    array = op.inArray("array"),
    index = op.inValueInt("index"),
    valueInvalid = op.inFloat("Value Invalid Index", 0),
    value = op.outNumber("value"),
    outValidIndex = op.outBoolNum("Valid Index", true);

array.ignoreValueSerialize = true;
op.toWorkPortsNeedToBeLinked(array);
index.onChange = array.onChange = update;

function update()
{
    if (array.get())
    {
        const input = array.get()[index.get()];
        if (isNaN(input))
        {
            value.set(valueInvalid.get());
            outValidIndex.set(false);
        }
        else
        {
            outValidIndex.set(true);
            value.set(parseFloat(input));
        }
    }
}

}
};

CABLES.OPS["d1189078-70cf-437d-9a37-b2ebe89acdaf"]={f:Ops.Array.ArrayGetNumber,objName:"Ops.Array.ArrayGetNumber"};




// **************************************************************
// 
// Ops.Math.Divide
// 
// **************************************************************

Ops.Math.Divide= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
const
    number1 = op.inValueFloat("number1", 1),
    number2 = op.inValueFloat("number2", 2),
    result = op.outNumber("result");

op.setUiAttribs({ "mathTitle": true });

number1.onChange = number2.onChange = exec;
exec();

function exec()
{
    result.set(number1.get() / number2.get());
}

}
};

CABLES.OPS["86fcfd8c-038d-4b91-9820-a08114f6b7eb"]={f:Ops.Math.Divide,objName:"Ops.Math.Divide"};




// **************************************************************
// 
// Ops.Math.Multiply
// 
// **************************************************************

Ops.Math.Multiply= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
const
    number1 = op.inValueFloat("number1", 1),
    number2 = op.inValueFloat("number2", 1),
    result = op.outNumber("result");

op.setUiAttribs({ "mathTitle": true });

number1.onChange = number2.onChange = update;
update();

function update()
{
    const n1 = number1.get();
    const n2 = number2.get();

    result.set(n1 * n2);
}

}
};

CABLES.OPS["1bbdae06-fbb2-489b-9bcc-36c9d65bd441"]={f:Ops.Math.Multiply,objName:"Ops.Math.Multiply"};




// **************************************************************
// 
// Ops.Gl.CanvasInfo_v3
// 
// **************************************************************

Ops.Gl.CanvasInfo_v3= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
const
    width = op.outNumber("CSS Width"),
    height = op.outNumber("CSS Height"),
    pixelRatio = op.outNumber("Pixel Ratio"),
    widthPixel = op.outNumber("Pixel Width"),
    heightPixel = op.outNumber("Pixel Height"),
    aspect = op.outNumber("Aspect Ratio"),
    landscape = op.outBool("Landscape"),
    outCanvasEle = op.outObject("Canvas", "element"),
    outCanvasParentEle = op.outObject("Canvas Parent", "element"),
    outResize = op.outTrigger("Resized");

let cgl = op.patch.cgl;
outCanvasEle.set(op.patch.cgl.canvas);
outCanvasParentEle.set(op.patch.cgl.canvas.parentElement);

cgl.on("resize", () =>
{
    outResize.trigger();
    update();
});

update();

function update()
{
    let div = 1;

    if (cgl.canvasHeight == 0)setTimeout(update, 100);

    height.set(cgl.canvasHeight / op.patch.cgl.pixelDensity);
    width.set(cgl.canvasWidth / op.patch.cgl.pixelDensity);

    widthPixel.set(cgl.canvasWidth);
    heightPixel.set(cgl.canvasHeight);

    pixelRatio.set(op.patch.cgl.pixelDensity); // window.devicePixelRatio

    aspect.set(cgl.canvasWidth / cgl.canvasHeight);
    landscape.set(cgl.canvasWidth > cgl.canvasHeight ? 1 : 0);
}

}
};

CABLES.OPS["be186ff9-427e-409f-b6a4-f8d957bf7bc7"]={f:Ops.Gl.CanvasInfo_v3,objName:"Ops.Gl.CanvasInfo_v3"};




// **************************************************************
// 
// Ops.Ui.Area
// 
// **************************************************************

Ops.Ui.Area= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
const
    inTitle = op.inString("Title", ""),
    inDelete = op.inTriggerButton("Delete");

inTitle.setUiAttribs({ "hidePort": true });

op.setUiAttrib({ "hasArea": true });

op.init =
    inTitle.onChange =
    op.onLoaded = update;

update();

function update()
{
    if (CABLES.UI)
    {
        gui.savedState.setUnSaved("areaOp", op.getSubPatch());
        op.uiAttr(
            {
                "comment_title": inTitle.get() || " "
            });

        op.name = inTitle.get();
    }
}

inDelete.onTriggered = () =>
{
    op.patch.deleteOp(op.id);
};

}
};

CABLES.OPS["38f79614-b0de-4960-8da5-2827e7f43415"]={f:Ops.Ui.Area,objName:"Ops.Ui.Area"};




// **************************************************************
// 
// Ops.Trigger.Repeat_v2
// 
// **************************************************************

Ops.Trigger.Repeat_v2= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
const
    exe = op.inTrigger("Execute"),
    num = op.inValueInt("Repeats", 5),
    dir = op.inSwitch("Direction", ["Forward", "Backward"], "Forward"),
    next = op.outTrigger("Next"),
    idx = op.addOutPort(new CABLES.Port(op, "index"));

dir.onChange = updateDir;
updateDir();

function updateDir()
{
    if (dir.get() == "Forward") exe.onTriggered = forward;
    else exe.onTriggered = backward;
}

function forward()
{
    const max = Math.floor(num.get());

    for (let i = 0; i < max; i++)
    {
        idx.set(i);
        next.trigger();
    }
}

function backward()
{
    const numi = Math.floor(num.get());
    for (let i = numi - 1; i > -1; i--)
    {
        idx.set(i);
        next.trigger();
    }
}

}
};

CABLES.OPS["a4deea80-db97-478f-ad1a-5ee30f2f47cc"]={f:Ops.Trigger.Repeat_v2,objName:"Ops.Trigger.Repeat_v2"};




// **************************************************************
// 
// Ops.Array.ArrayUnpack3
// 
// **************************************************************

Ops.Array.ArrayUnpack3= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
const inArray1 = op.inArray("Array in xyz"),
    outArray1 = op.outArray("Array 1 out"),
    outArray2 = op.outArray("Array 2 out"),
    outArray3 = op.outArray("Array 3 out"),
    outArrayLength = op.outNumber("Array lengths");

let showingError = false;

const arr1 = [];
const arr2 = [];
const arr3 = [];

inArray1.onChange = update;

function update()
{
    let array1 = inArray1.get();

    if (!array1)
    {
        outArray1.set(null);
        return;
    }

    if (array1.length % 3 !== 0)
    {
        if (!showingError)
        {
            op.uiAttr({ "error": "Arrays length not divisible by 3 !" });
            outArrayLength.set(0);
            showingError = true;
        }
        return;
    }

    if (showingError)
    {
        showingError = false;
        op.uiAttr({ "error": null });
    }

    arr1.length = Math.floor(array1.length / 3);
    arr2.length = Math.floor(array1.length / 3);
    arr3.length = Math.floor(array1.length / 3);

    for (let i = 0; i < array1.length / 3; i++)
    {
        arr1[i] = array1[i * 3];
        arr2[i] = array1[i * 3 + 1];
        arr3[i] = array1[i * 3 + 2];
    }

    // outArray1.set(null);
    // outArray2.set(null);
    // outArray3.set(null);
    outArray1.setRef(arr1);
    outArray2.setRef(arr2);
    outArray3.setRef(arr3);
    outArrayLength.set(arr1.length);
}

}
};

CABLES.OPS["fa671f66-6957-41e6-ac35-d615b7c29285"]={f:Ops.Array.ArrayUnpack3,objName:"Ops.Array.ArrayUnpack3"};




// **************************************************************
// 
// Ops.Gl.Shader.WireframeMaterial_v2
// 
// **************************************************************

Ops.Gl.Shader.WireframeMaterial_v2= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={"wireframe_frag":"{{MODULES_HEAD}}\n\nIN vec3 barycentric;\nIN vec3 norm;\nUNI float width;\n\nUNI vec4 colorFill;\nUNI vec4 colorWire;\n\nUNI float aa;\n\nfloat edgeFactor()\n{\n    vec3 d = fwidth(barycentric);\n    vec3 a3 = smoothstep(vec3(0.0), d*width, barycentric);\n    return min(min(a3.x, a3.y), a3.z);\n}\n\nvoid main()\n{\n    vec4 col;\n    {{MODULE_BEGIN_FRAG}}\n\n\n    #ifdef WIREFRAME_FILL\n\n        float v=(1.0-edgeFactor())*(aa*width);\n        col = mix(colorFill,colorWire,v);\n\n    #endif\n\n    #ifndef WIREFRAME_FILL\n\n        float f=(1.0-edgeFactor())*(aa*width);\n        col = colorWire;\n        col.a=f;\n        if(f==0.0)discard;\n    #endif\n\n    {{MODULE_COLOR}}\n\n    outColor=col;\n}","wireframe_vert":"{{MODULES_HEAD}}\n\nIN vec3 vPosition;\nUNI mat4 projMatrix;\nUNI mat4 modelMatrix;\nUNI mat4 viewMatrix;\nOUT vec3 barycentric;\nIN vec2 attrTexCoord;\nOUT vec2 texCoord;\n\nIN vec3 attrBarycentric;\nIN vec3 attrVertNormal;\nOUT vec3 norm;\n\nvoid main()\n{\n    norm=attrVertNormal;\n    texCoord=attrTexCoord;\n    barycentric=attrBarycentric;\n    mat4 mMatrix=modelMatrix;\n    vec4 pos=vec4(vPosition, 1.0);\n\n    {{MODULE_VERTEX_POSITION}}\n\n    gl_Position = projMatrix * viewMatrix * mMatrix * pos;\n}\n",};
const
    render = op.inTrigger("render"),
    trigger = op.outTrigger("trigger"),
    enableDepth = op.inValueBool("enable depth testing", true),
    w = op.inFloat("width", 1),
    aa = op.inValueSlider("AntiAlias", 0.95),
    r = op.inValueSlider("diffuse r", 1),
    g = op.inValueSlider("diffuse g", 1),
    b = op.inValueSlider("diffuse b", 1),
    a = op.inValueSlider("diffuse A", 1),
    fill = op.inValueBool("fill", true),
    fr = op.inValueSlider("Fill R", 0.5),
    fg = op.inValueSlider("Fill G", 0.5),
    fb = op.inValueSlider("Fill B", 0.5),
    fa = op.inValueSlider("Fill A", 1);

op.setPortGroup("Color Wire", [r, g, b, a]);
op.setPortGroup("Color Fill", [fr, fg, fb, fa, fill]);
r.setUiAttribs({ "colorPick": true });
fr.setUiAttribs({ "colorPick": true });
fill.onChange = setDefines;

const cgl = op.patch.cgl;

function setDefines()
{
    if (shader) shader.toggleDefine("WIREFRAME_FILL", fill.get());

    fr.setUiAttribs({ "greyout": !fill.get() });
    fg.setUiAttribs({ "greyout": !fill.get() });
    fb.setUiAttribs({ "greyout": !fill.get() });
    fa.setUiAttribs({ "greyout": !fill.get() });
}



let doRender = function ()
{
    cgl.pushDepthTest(enableDepth.get());

    cgl.pushShader(shader);
    trigger.trigger();
    cgl.popShader();

    cgl.popDepthTest();
};

const shader = new CGL.Shader(cgl, "Wireframe Material");
const uniformWidth = new CGL.Uniform(shader, "f", "width", w);
const uniaa = new CGL.Uniform(shader, "f", "aa", aa);
const uni1 = new CGL.Uniform(shader, "4f", "colorFill", fr, fg, fb, fa);
const uni2 = new CGL.Uniform(shader, "4f", "colorWire", r, g, b, a);

shader.setModules(["MODULE_VERTEX_POSITION", "MODULE_COLOR", "MODULE_BEGIN_FRAG"]);
shader.setSource(attachments.wireframe_vert || "", attachments.wireframe_frag || "");
shader.wireframe = true;
setDefines();

if (cgl.glVersion == 1)
{
    if (!cgl.gl.getExtension("OES_standard_derivatives")) op.setUiError("noderivatives", "no standard derivatives extension available!");
    shader.enableExtension("OES_standard_derivatives");
}

render.onTriggered = doRender;

doRender();

}
};

CABLES.OPS["a8dfa4ef-8d81-4408-91e2-76b997bd7bd9"]={f:Ops.Gl.Shader.WireframeMaterial_v2,objName:"Ops.Gl.Shader.WireframeMaterial_v2"};




// **************************************************************
// 
// Ops.Gl.RenderGeometry_v2
// 
// **************************************************************

Ops.Gl.RenderGeometry_v2= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
const
    render = op.inTrigger("render"),
    geometry = op.inObject("Geometry", null, "geometry"),
    inActive = op.inBool("Render Mesh", true),

    inVertNums = op.inBool("Add Vertex Numbers", true),
    trigger = op.outTrigger("trigger");

op.toWorkPortsNeedToBeLinked(geometry, render);

geometry.ignoreValueSerialize = true;

let mesh = null;
let needsUpdate = true;

geometry.onLinkChanged =
inVertNums.onChange =
    geometry.onChange = () => { needsUpdate = true; };

render.onTriggered = function ()
{
    if (needsUpdate) update();
    if (mesh && inActive.get()) mesh.render(op.patch.cgl.getShader());
    trigger.trigger();
};

function update()
{
    needsUpdate = false;
    const geom = geometry.get();
    if (geom && geom.isGeometry)
    {
        if (mesh)
        {
            mesh.dispose();
            mesh = null;
        }
        if (!mesh)
        {
            mesh = new CGL.Mesh(op.patch.cgl, geom);
            mesh.addVertexNumbers = inVertNums.get();
            mesh.setGeom(geom);
        }
    }
    else
    {
        mesh = null;
    }
}

}
};

CABLES.OPS["0a9bdb39-8250-460e-8d99-50fe6825d956"]={f:Ops.Gl.RenderGeometry_v2,objName:"Ops.Gl.RenderGeometry_v2"};




// **************************************************************
// 
// Ops.Gl.GradientTexture
// 
// **************************************************************

Ops.Gl.GradientTexture= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
// STOP UPDATING THIS OP ... use Ops.Color.GradientColorArray

const inGrad = op.inGradient("Gradient"),
    inDir = op.inValueSelect("Direction", ["X", "XX", "Y", "YY", "XY", "YX", "Radial"], "X"),
    inSmoothstep = op.inValueBool("Smoothstep", false),
    inStep = op.inBool("Step", false),
    inFlip = op.inBool("Flip", false),
    inSRGB = op.inBool("sRGB", false),
    inOklab = op.inBool("Oklab", false),
    inSize = op.inValueInt("Size", 256),
    tfilter = op.inSwitch("filter", ["nearest", "linear", "mipmap"], "linear"),
    twrap = op.inValueSelect("wrap", ["clamp to edge", "repeat", "mirrored repeat"], "clamp to edge"),
    inNoise = op.inFloatSlider("Dither", 0),
    inGradArray = op.inArray("Gradient Array"),
    inRandom = op.inTriggerButton("Randomize Colors"),
    outTex = op.outTexture("Texture"),
    outColors = op.outArray("Colors", null, 3),
    outColorPos = op.outArray("Colors Pos", null, 1);

const cgl = op.patch.cgl;
let timeout = null;
inGrad.setUiAttribs({ "editShortcut": true });

const bluenoise = [221, 125, 40, 94, 163, 50, 214, 174, 69, 229, 135, 79, 25, 92, 217, 129, 103, 155, 16, 237, 168, 75, 212, 126, 203, 157, 104, 223, 50, 96, 115, 189, 0, 104, 199, 16, 185, 242, 83, 26, 123, 95, 191, 175, 247, 159, 32, 170, 0, 88, 203, 133, 106, 46, 227, 14, 35, 246, 66, 20, 240, 205, 36, 159, 74, 252, 148, 231, 132, 117, 6, 145, 254, 39, 222, 5, 111, 46, 67, 197, 228, 116, 181, 66, 25, 245, 98, 139, 172, 89, 190, 149, 127, 177, 64, 138, 210, 169, 58, 28, 70, 100, 206, 188, 164, 107, 60, 150, 203, 126, 235, 142, 56, 249, 38, 222, 148, 178, 195, 56, 115, 230, 45, 108, 7, 84, 234, 21, 44, 90, 110, 216, 178, 37, 226, 53, 14, 77, 212, 31, 86, 180, 100, 23, 82, 14, 162, 93, 122, 6, 81, 156, 24, 209, 75, 255, 163, 218, 196, 121, 237, 187, 9, 152, 247, 136, 158, 91, 128, 232, 169, 137, 251, 10, 216, 154, 188, 131, 211, 71, 200, 34, 236, 216, 129, 13, 179, 136, 32, 54, 99, 146, 33, 131, 202, 49, 84, 18, 64, 197, 245, 114, 21, 193, 52, 74, 118, 44, 243, 105, 173, 50, 252, 110, 63, 166, 41, 102, 199, 62, 117, 184, 15, 77, 250, 162, 69, 120, 231, 107, 213, 2, 177, 43, 67, 102, 159, 238, 171, 206, 64, 29, 233, 10, 151, 135, 185, 87, 247, 147, 223, 91, 241, 152, 225, 175, 3, 102, 220, 25, 191, 170, 36, 143, 81, 152, 209, 224, 133, 35, 93, 2, 145, 87, 124, 193, 97, 22, 228, 1, 120, 51, 171, 8, 26, 210, 108, 48, 205, 59, 179, 92, 147, 253, 124, 99, 237, 186, 11, 120, 19, 181, 229, 112, 198, 160, 220, 76, 42, 210, 160, 71, 202, 31, 78, 190, 130, 67, 86, 138, 115, 156, 243, 14, 46, 74, 57, 219, 28, 51, 90, 250, 59, 81, 140, 47, 255, 17, 58, 181, 243, 114, 56, 178, 239, 139, 228, 156, 251, 40, 167, 232, 28, 38, 82, 136, 206, 161, 9, 196, 106, 139, 167, 204, 150, 195, 218, 70, 172, 35, 132, 103, 146, 27, 89, 128, 16, 107, 96, 57, 119, 201, 15, 187, 239, 126, 194, 225, 112, 182, 234, 131, 174, 240, 72, 39, 109, 29, 8, 100, 122, 207, 231, 4, 166, 224, 198, 153, 217, 44, 183, 212, 4, 93, 143, 72, 99, 172, 64, 0, 97, 34, 85, 66, 20, 208, 3, 125, 243, 164, 186, 235, 156, 82, 191, 67, 248, 49, 80, 10, 253, 68, 23, 162, 244, 179, 49, 215, 24, 151, 246, 51, 214, 153, 251, 118, 45, 157, 98, 224, 53, 88, 134, 62, 42, 23, 116, 94, 140, 33, 121, 188, 169, 141, 113, 76, 33, 131, 227, 110, 11, 202, 78, 122, 168, 18, 141, 194, 221, 80, 187, 142, 177, 210, 18, 249, 144, 221, 180, 12, 201, 215, 106, 60, 91, 226, 200, 236, 150, 85, 61, 164, 185, 133, 42, 229, 187, 73, 55, 101, 27, 235, 59, 12, 35, 75, 113, 199, 101, 163, 237, 57, 152, 174, 234, 134, 1, 37, 53, 123, 193, 6, 208, 253, 34, 91, 145, 104, 8, 240, 211, 175, 129, 164, 109, 253, 123, 230, 171, 6, 50, 79, 27, 127, 73, 43, 19, 246, 161, 211, 103, 17, 172, 96, 46, 117, 70, 241, 219, 27, 162, 115, 88, 38, 4, 148, 204, 92, 189, 154, 63, 130, 217, 188, 111, 254, 208, 101, 86, 191, 144, 75, 180, 249, 65, 137, 233, 157, 18, 171, 192, 49, 66, 201, 137, 246, 218, 51, 71, 15, 43, 214, 29, 95, 239, 38, 139, 165, 7, 225, 124, 30, 59, 112, 221, 154, 28, 197, 217, 106, 58, 85, 209, 128, 232, 151, 15, 79, 182, 120, 238, 168, 134, 81, 248, 146, 173, 16, 88, 195, 65, 150, 183, 205, 242, 11, 41, 89, 126, 80, 8, 183, 121, 141, 3, 98, 180, 31, 108, 58, 196, 97, 24, 222, 107, 198, 2, 116, 70, 207, 52, 230, 22, 109, 47, 80, 165, 132, 199, 235, 170, 52, 148, 247, 165, 23, 242, 74, 45, 254, 170, 226, 155, 36, 142, 179, 60, 158, 48, 182, 223, 154, 124, 98, 178, 250, 140, 5, 231, 96, 68, 19, 116, 204, 32, 227, 43, 200, 113, 161, 213, 122, 87, 0, 130, 248, 77, 13, 241, 92, 229, 30, 102, 13, 244, 77, 160, 33, 209, 119, 55, 176, 143, 190, 255, 103, 71, 93, 186, 62, 223, 145, 12, 189, 68, 202, 47, 211, 114, 192, 41, 127, 203, 141, 65, 189, 40, 135, 198, 61, 89, 222, 158, 24, 216, 45, 1, 157, 213, 130, 239, 83, 104, 26, 55, 134, 238, 29, 159, 95, 63, 167, 149, 7, 78, 255, 119, 166, 212, 1, 233, 19, 105, 186, 37, 244, 110, 86, 135, 56, 173, 11, 151, 36, 176, 196, 230, 94, 149, 109, 184, 226, 20, 236, 215, 105, 175, 22, 219, 52, 87, 111, 174, 128, 248, 149, 78, 125, 63, 184, 227, 242, 118, 22, 220, 138, 252, 119, 76, 168, 39, 250, 10, 136, 84, 123, 54, 69, 194, 37, 95, 147, 241, 73, 153, 48, 68, 7, 194, 17, 207, 161, 31, 76, 201, 90, 166, 69, 4, 48, 215, 21, 204, 57, 73, 176, 200, 30, 249, 155, 133, 233, 163, 9, 197, 32, 183, 220, 205, 137, 232, 167, 94, 144, 9, 105, 181, 44, 111, 207, 99, 132, 155, 182, 85, 127, 219, 147, 42, 97, 184, 5, 83, 208, 108, 61, 125, 228, 21, 100, 39, 90, 114, 53, 218, 41, 252, 129, 61, 234, 143, 30, 192, 245, 12, 112, 236, 101, 2, 244, 113, 165, 225, 118, 47, 20, 176, 251, 142, 84, 117, 160, 254, 177, 26, 238, 121, 72, 193, 213, 153, 13, 55, 173, 79, 224, 65, 140, 34, 195, 158, 54, 17, 206, 62, 144, 240, 190, 72, 40, 214, 54, 192, 5, 146, 60, 82, 185, 3, 138, 169, 25, 83, 245];
const bluenoiseSize = 32;

inNoise.onChange =
twrap.onChange =
    tfilter.onChange =
    inStep.onChange =
    inFlip.onChange =
    inSRGB.onChange =
    inOklab.onChange =
    inSize.onChange =
    inGrad.onChange =
    inSmoothstep.onChange =
    inDir.onChange =
    inGradArray.onChange = update;

inGrad.set("{\"keys\" : [{\"pos\":0,\"r\":0,\"g\":0,\"b\":0},{\"pos\":1,\"r\":1,\"g\":1,\"b\":1}]}");

op.onLoaded = update;

inRandom.onTriggered = () =>
{
    const keys = parseKeys();
    if (keys)
    {
        keys.forEach((key) =>
        {
            key.r = Math.random();
            key.g = Math.random();
            key.b = Math.random();
        });
        const newKeys = JSON.stringify({ "keys": keys });
        inGrad.set(newKeys);
    }
};

function rgbToOklab(r, g, b)
{
    let l = 0.4122214708 * r + 0.5363325363 * g + 0.0514459929 * b;
    let m = 0.2119034982 * r + 0.6806995451 * g + 0.1073969566 * b;
    let s = 0.0883024619 * r + 0.2817188376 * g + 0.6299787005 * b;
    l = Math.cbrt(l); m = Math.cbrt(m); s = Math.cbrt(s);
    return [
        l * +0.2104542553 + m * +0.7936177850 + s * -0.0040720468,
        l * +1.9779984951 + m * -2.4285922050 + s * +0.4505937099,
        l * +0.0259040371 + m * +0.7827717662 + s * -0.8086757660
    ];
}

function oklabToRGB(L, a, b)
{
    let l = L + a * +0.3963377774 + b * +0.2158037573;
    let m = L + a * -0.1055613458 + b * -0.0638541728;
    let s = L + a * -0.0894841775 + b * -1.2914855480;
    l **= 3; m **= 3; s **= 3;
    let rgb_r = l * +4.0767416621 + m * -3.3077115913 + s * +0.2309699292;
    let rgb_g = l * -1.2684380046 + m * +2.6097574011 + s * -0.3413193965;
    let rgb_b = l * -0.0041960863 + m * -0.7034186147 + s * +1.7076147010;
    rgb_r = CABLES.clamp(rgb_r, 0, 1); rgb_g = CABLES.clamp(rgb_g, 0, 1); rgb_b = CABLES.clamp(rgb_b, 0, 1);
    return [rgb_r, rgb_g, rgb_b];
}

function lin2srgb(r, g, b)
{
    r /= 255;
    const thr = 0.0031308;
    let c_loR = 12.92 * r;
    let c_hiR = 1.055 * Math.pow(r, 0.41666) - 0.055;
    return ((r < thr) ? c_loR : c_hiR) * 255;
}

function update()
{
    cgl.addNextFrameOnceCallback(doUpdate);
}

function doUpdate()
{
    const keys = parseKeys();
    if (keys) updateGradient(keys);
}

function parseKeys()
{
    let keys = null;
    op.setUiError("nodata", null);
    op.setUiError("parse", null);

    if (Array.isArray(inGradArray.get()))
    {
        keys = inGradArray.get();
    }
    else
    {
        let grad = null;
        if (!inGrad.get() || inGrad.get() === "")
        {
            // op.setUiError("nodata", "gradient no data");
            return null;
        }

        try
        {
            grad = JSON.parse(inGrad.get());
        }
        catch (e)
        {
            op.setUiError("parse", "could not parse gradient data");
        }

        if (!grad || !grad.keys)
        {
            op.setUiError("nodata", "gradient no data");
            return null;
        }
        keys = grad.keys;
    }
    return keys;
}

function noise(x, y)
{
    x %= bluenoiseSize;
    y %= bluenoiseSize;

    return bluenoise[x + y * bluenoiseSize] / 255 - 0.5;
}

function addNoise(pixels, width, height)
{
    if (inNoise.get() == 0.0) return pixels;

    for (let x = 0; x < width; x++)
        for (let y = 0; y < height; y++)
        {
            const r1 = pixels[(x + (y * width)) * 4 + 0];
            const g1 = pixels[(x + (y * width)) * 4 + 1];
            const b1 = pixels[(x + (y * width)) * 4 + 2];

            let offX = (width / 8) * inNoise.get() * noise(x, y);
            let offY = (height / 8) * inNoise.get() * noise(x + bluenoiseSize / 2, y + bluenoiseSize / 2);

            if (height == 1) offY = 0;
            if (width == 1) offX = 0;

            offX = Math.round(offX);
            offY = Math.round(offY);

            const yOffY = CABLES.clamp(y + offY, 0, height - 1);
            const xOffX = CABLES.clamp(x + offX, 0, width - 1);

            const r2 = pixels[(xOffX + ((yOffY) * width)) * 4 + 0];
            const g2 = pixels[(xOffX + ((yOffY) * width)) * 4 + 1];
            const b2 = pixels[(xOffX + ((yOffY) * width)) * 4 + 2];

            pixels[(x + y * width) * 4 + 0] = r2;
            pixels[(x + y * width) * 4 + 1] = g2;
            pixels[(x + y * width) * 4 + 2] = b2;

            pixels[(xOffX + ((yOffY) * width)) * 4 + 0] = r1;
            pixels[(xOffX + ((yOffY) * width)) * 4 + 1] = g1;
            pixels[(xOffX + ((yOffY) * width)) * 4 + 2] = b1;
        }
    return pixels;
}

function updateGradient(keys)
{
    let width = Math.round(inSize.get());
    if (width < 4) width = 4;

    inGrad.setUiAttribs(
        {
            "editShortcut": true,
            "gradEditSmoothstep": inSmoothstep.get(),
            "gradEditStep": inStep.get(),
            "gradOklab": inOklab.get()
        });

    let selectedWrap = 0;
    let selectedFilter = 0;
    if (twrap.get() == "repeat") selectedWrap = CGL.Texture.WRAP_REPEAT;
    else if (twrap.get() == "mirrored repeat") selectedWrap = CGL.Texture.WRAP_MIRRORED_REPEAT;
    else if (twrap.get() == "clamp to edge") selectedWrap = CGL.Texture.WRAP_CLAMP_TO_EDGE;

    if (tfilter.get() == "nearest") selectedFilter = CGL.Texture.FILTER_NEAREST;
    else if (tfilter.get() == "linear") selectedFilter = CGL.Texture.FILTER_LINEAR;
    else if (tfilter.get() == "mipmap") selectedFilter = CGL.Texture.FILTER_MIPMAP;

    const tex = new CGL.Texture(cgl);

    let pixels = new Uint8Array(width * 4);

    for (let i = 0; i < keys.length - 1; i++)
    {
        const keyA = keys[i];
        const keyB = keys[i + 1];

        for (let x = keyA.pos * width; x < keyB.pos * width; x++)
        {
            let p = CABLES.map(x, keyA.pos * width, keyB.pos * width, 0, 1);
            if (inStep.get())p = Math.round(p);
            if (inSmoothstep.get()) p = CABLES.smoothStep(p);
            x = Math.round(x);

            let xx = x;
            if (inFlip.get())xx = width - x - 1;

            if (inOklab.get())
            {
                const klabA = rgbToOklab(keyA.r, keyA.g, keyA.b);
                const labA_r = klabA[0];
                const labA_g = klabA[1];
                const labA_b = klabA[2];

                const klabB = rgbToOklab(keyB.r, keyB.g, keyB.b);
                const labB_r = klabB[0];
                const labB_g = klabB[1];
                const labB_b = klabB[2];

                const l = ((p * labB_r + (1.0 - p) * labA_r));
                const a = ((p * labB_g + (1.0 - p) * labA_g));
                const b = ((p * labB_b + (1.0 - p) * labA_b));

                const pixCol = oklabToRGB(l, a, b);
                pixels[xx * 4 + 0] = Math.round(pixCol[0] * 255);
                pixels[xx * 4 + 1] = Math.round(pixCol[1] * 255);
                pixels[xx * 4 + 2] = Math.round(pixCol[2] * 255);
            }
            else
            {
                pixels[xx * 4 + 0] = Math.round((p * keyB.r + (1.0 - p) * keyA.r) * 255);
                pixels[xx * 4 + 1] = Math.round((p * keyB.g + (1.0 - p) * keyA.g) * 255);
                pixels[xx * 4 + 2] = Math.round((p * keyB.b + (1.0 - p) * keyA.b) * 255);
            }

            if (typeof keyA.a !== "undefined" && typeof keyB.a !== "undefined")
            {
                const alpha = Math.round((p * keyB.a + (1.0 - p) * keyA.a) * 255);
                pixels[xx * 4 + 3] = alpha;
            }
            else
            {
                pixels[xx * 4 + 3] = Math.round(255);
            }
        }
    }
    if (inSRGB.get())
        for (let i = 0; i < pixels.length; i += 4)
        {
            pixels[i + 0] = lin2srgb(pixels[i + 0]);
            pixels[i + 1] = lin2srgb(pixels[i + 1]);
            pixels[i + 2] = lin2srgb(pixels[i + 2]);
        }

    if (inDir.get() == "X") tex.initFromData(addNoise(pixels, width, 1), width, 1, selectedFilter, selectedWrap);
    if (inDir.get() == "Y") tex.initFromData(addNoise(pixels, 1, width), 1, width, selectedFilter, selectedWrap);

    if (inDir.get() == "Radial")
    {
        const rpixels = new Uint8Array(width * width * 4);

        for (let x = 0; x < width; x++)
        {
            for (let y = 0; y < width; y++)
            {
                const dx = x - (width - 1) / 2;
                const dy = y - (width - 1) / 2;
                let pos = Math.sqrt(dx * dx + dy * dy) / (width) * 2;

                if (inSmoothstep.get()) pos = CABLES.smoothStep(pos);

                let aa = Math.round(pos * width) * 4;
                if (aa >= width * 4)aa = width * 4 - 4;

                rpixels[(x * 4) + (y * 4 * width) + 0] = pixels[aa + 0];
                rpixels[(x * 4) + (y * 4 * width) + 1] = pixels[aa + 1];
                rpixels[(x * 4) + (y * 4 * width) + 2] = pixels[aa + 2];
                rpixels[(x * 4) + (y * 4 * width) + 3] = Math.round(255);
            }
        }

        pixels = rpixels;

        tex.initFromData(addNoise(pixels, width, width), width, width, selectedFilter, selectedWrap);
    }

    if (inDir.get() == "XX")
    {
        const rpixels = new Uint8Array(width * width * 4);
        for (let x = 0; x < width; x++)
            for (let y = 0; y < width; y++)
            {
                const aa = x * 4;
                rpixels[(x * 4) + (y * 4 * width) + 0] = pixels[aa + 0];
                rpixels[(x * 4) + (y * 4 * width) + 1] = pixels[aa + 1];
                rpixels[(x * 4) + (y * 4 * width) + 2] = pixels[aa + 2];
                rpixels[(x * 4) + (y * 4 * width) + 3] = Math.round(255);
            }
        pixels = rpixels;
        tex.initFromData(addNoise(pixels, width, width), width, width, selectedFilter, selectedWrap);
    }

    if (inDir.get() == "YY")
    {
        const rpixels = new Uint8Array(width * width * 4);
        for (let x = 0; x < width; x++)
            for (let y = 0; y < width; y++)
            {
                const aa = x * 4;
                rpixels[(y * 4) + (x * 4 * width) + 0] = pixels[aa + 0];
                rpixels[(y * 4) + (x * 4 * width) + 1] = pixels[aa + 1];
                rpixels[(y * 4) + (x * 4 * width) + 2] = pixels[aa + 2];
                rpixels[(y * 4) + (x * 4 * width) + 3] = Math.round(255);
            }
        pixels = rpixels;
        tex.initFromData(addNoise(pixels, width, width), width, width, selectedFilter, selectedWrap);
    }

    if (inDir.get() == "XY" || inDir.get() == "YX")
    {
        const rpixels = new Uint8Array(width * width * 4);

        for (let x = 0; x < width; x++)
        {
            let xx = x;
            if (inDir.get() == "YX")xx = width - x - 1;

            for (let y = 0; y < width; y++)
            {
                let aa = Math.round(((xx) + y) / 2) * 4;

                rpixels[(x * 4) + (y * 4 * width) + 0] = pixels[aa + 0];
                rpixels[(x * 4) + (y * 4 * width) + 1] = pixels[aa + 1];
                rpixels[(x * 4) + (y * 4 * width) + 2] = pixels[aa + 2];
                rpixels[(x * 4) + (y * 4 * width) + 3] = Math.round(255);
            }
        }

        pixels = rpixels;

        tex.initFromData(addNoise(pixels, width, width), width, width, selectedFilter, selectedWrap);
    }

    const colorArr = [];
    for (let i = 0; i < keys.length - 1; i++)
    {
        colorArr.push(keys[i].r, keys[i].g, keys[i].b);
    }

    const colorPosArr = [];
    for (let i = 0; i < keys.length - 1; i++)
    {
        colorPosArr.push(keys[i].pos);
    }

    outColors.set(colorArr);
    outColorPos.set(colorPosArr);

    // outTex.set(null);
    outTex.setRef(tex);
}

}
};

CABLES.OPS["01380a50-2dbb-4465-ae80-86349b0b717a"]={f:Ops.Gl.GradientTexture,objName:"Ops.Gl.GradientTexture"};




// **************************************************************
// 
// Ops.Array.ArrayMerge_v3
// 
// **************************************************************

Ops.Array.ArrayMerge_v3= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
const numArrays = 8;
const inArrs = [];

for (let i = 0; i < numArrays; i++)
{
    inArrs[i] = op.inArray("Array " + i);
    inArrs[i].onChange = function ()
    {
        update();
    };
}

const
    outArr = op.outArray("Result"),
    outArrayLength = op.outNumber("Array length");

let arr = [];

function update()
{
    arr.length = 0;

    for (let i = 0; i < numArrays; i++)
    {
        const ar = inArrs[i].get();
        if (ar)arr = arr.concat(ar);
    }

    outArr.setRef(arr);
    outArrayLength.set(arr.length);
}

}
};

CABLES.OPS["753d053a-04a3-44c7-abf0-ae2676ced13e"]={f:Ops.Array.ArrayMerge_v3,objName:"Ops.Array.ArrayMerge_v3"};




// **************************************************************
// 
// Ops.Trigger.GateTrigger
// 
// **************************************************************

Ops.Trigger.GateTrigger= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
const
    exe = op.inTrigger('Execute'),
    passThrough = op.inValueBool('Pass Through',true),
    triggerOut = op.outTrigger('Trigger out');

exe.onTriggered = function()
{
    if(passThrough.get())
        triggerOut.trigger();
}

}
};

CABLES.OPS["65e8b8a2-ba13-485f-883a-2bcf377989da"]={f:Ops.Trigger.GateTrigger,objName:"Ops.Trigger.GateTrigger"};




// **************************************************************
// 
// Ops.Trigger.TriggerExtender
// 
// **************************************************************

Ops.Trigger.TriggerExtender= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
const
    inTriggerPort = op.inTriggerButton("Execute"),
    outTriggerPort = op.outTrigger("Next");

inTriggerPort.onTriggered = function ()
{
    outTriggerPort.trigger();
};

}
};

CABLES.OPS["7ef594f3-4907-47b0-a2d3-9854eda1679d"]={f:Ops.Trigger.TriggerExtender,objName:"Ops.Trigger.TriggerExtender"};




// **************************************************************
// 
// Ops.Graphics.Meshes.Circle_v3
// 
// **************************************************************

Ops.Graphics.Meshes.Circle_v3= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
const
    render = op.inTrigger("render"),
    radius = op.inValue("radius", 0.5),
    innerRadius = op.inValueSlider("innerRadius", 0),
    segments = op.inValueInt("segments", 40),
    percent = op.inValueSlider("percent", 1),
    steps = op.inValue("steps", 0),
    invertSteps = op.inValueBool("invertSteps", false),
    mapping = op.inSwitch("mapping", ["flat", "round"]),
    drawSpline = op.inValueBool("Spline", false),
    inDraw = op.inValueBool("Draw", true),
    trigger = op.outTrigger("trigger"),
    geomOut = op.outObject("geometry", null, "geometry");

op.setPortGroup("Size", [radius, innerRadius]);
op.setPortGroup("Display", [percent, steps, invertSteps]);
op.toWorkShouldNotBeChild("Ops.Gl.TextureEffects.ImageCompose", CABLES.OP_PORT_TYPE_FUNCTION);

inDraw.setUiAttribs({ "title": "Render mesh" });

mapping.set("flat");

mapping.onChange =
    segments.onChange =
    radius.onChange =
    innerRadius.onChange =
    percent.onChange =
    steps.onChange =
    invertSteps.onChange =
    drawSpline.onChange = calcLater;

geomOut.ignoreValueSerialize = true;
const cgl = op.patch.cgl;

let geom = new CGL.Geometry("circle");
let mesh = null;
const lastSegs = -1;

let oldPrim = 0;
let shader = null;
let needsCalc = true;

render.onTriggered = renderMesh;
op.onDelete = function () { if (mesh)mesh.dispose(); };

op.preRender = () =>
{
    renderMesh();
};

render.onLinkChanged = function ()
{
    if (!render.isLinked()) geomOut.set(null);
    else geomOut.setRef(geom);
};

function renderMesh()
{
    if (!op.patch.cg) return;
    if (needsCalc)calc();

    if (!CGL.TextureEffect.checkOpNotInTextureEffect(op)) return;

    shader = op.patch.cg.getShader();
    if (!shader) return;
    oldPrim = shader.glPrimitive;

    if (drawSpline.get()) shader.glPrimitive = cgl.gl.LINE_STRIP;

    if (inDraw.get() && mesh)
    {
        // mesh.instances = 3;
        mesh.render(shader);
    }
    trigger.trigger();

    shader.glPrimitive = oldPrim;
}

function calc()
{
    const segs = Math.max(3, Math.floor(segments.get()));

    geom.clear();

    const faces = [];
    const texCoords = [];
    const vertexNormals = [];
    const tangents = [];
    const biTangents = [];

    let i = 0, degInRad = 0;
    let oldPosX = 0, oldPosY = 0;
    let oldPosXTexCoord = 0, oldPosYTexCoord = 0;

    let oldPosXIn = 0, oldPosYIn = 0;
    let oldPosXTexCoordIn = 0, oldPosYTexCoordIn = 0;

    let posxTexCoordIn = 0, posyTexCoordIn = 0;
    let posxTexCoord = 0, posyTexCoord = 0;
    let posx = 0, posy = 0;

    const perc = Math.max(0.0, percent.get());
    const verts = [];

    if (drawSpline.get())
    {
        let lastX = 0;
        let lastY = 0;
        const tc = [];
        for (i = 0; i <= segs * perc; i++)
        {
            degInRad = (360 / segs) * i * CGL.DEG2RAD;
            posx = Math.cos(degInRad) * radius.get();
            posy = Math.sin(degInRad) * radius.get();

            posyTexCoord = 0.5;

            if (i > 0)
            {
                verts.push(lastX);
                verts.push(lastY);
                verts.push(0);
                posxTexCoord = 1.0 - (i - 1) / segs;

                tc.push(posxTexCoord, posyTexCoord);
            }
            verts.push(posx);
            verts.push(posy);
            verts.push(0);

            lastX = posx;
            lastY = posy;
        }
        geom.setPointVertices(verts);
    }
    else
    if (innerRadius.get() <= 0)
    {
        for (i = 0; i <= segs * perc; i++)
        {
            degInRad = (360 / segs) * i * CGL.DEG2RAD;
            posx = Math.cos(degInRad) * radius.get();
            posy = Math.sin(degInRad) * radius.get();

            if (mapping.get() == "flat")
            {
                posxTexCoord = (Math.cos(degInRad) + 1.0) / 2;
                posyTexCoord = 1.0 - (Math.sin(degInRad) + 1.0) / 2;
                posxTexCoordIn = 0.5;
                posyTexCoordIn = 0.5;
            }
            else if (mapping.get() == "round")
            {
                posxTexCoord = 1.0 - i / segs;
                posyTexCoord = 0;
                posxTexCoordIn = posxTexCoord;
                posyTexCoordIn = 1;
            }

            faces.push(
                [0, 0, 0],
                [oldPosX, oldPosY, 0],
                [posx, posy, 0]
            );

            texCoords.push(
                posxTexCoordIn, posyTexCoordIn, oldPosXTexCoord, oldPosYTexCoord, posxTexCoord, posyTexCoord
            );
            vertexNormals.push(0, 0, 1, 0, 0, 1, 0, 0, 1);
            tangents.push(1, 0, 0, 1, 0, 0, 1, 0, 0);
            biTangents.push(0, -1, 0, 0, -1, 0, 0, -1, 0);

            oldPosXTexCoord = posxTexCoord;
            oldPosYTexCoord = posyTexCoord;

            oldPosX = posx;
            oldPosY = posy;
        }

        geom = CGL.Geometry.buildFromFaces(faces, "circle");
        geom.vertexNormals = vertexNormals;
        geom.tangents = tangents;
        geom.biTangents = biTangents;
        geom.texCoords = texCoords;
    }
    else
    {
        let count = 0;
        const numSteps = segs * perc;
        const pos = 0;

        for (i = 0; i <= numSteps; i++)
        {
            count++;

            degInRad = (360 / segs) * i * CGL.DEG2RAD;
            posx = Math.cos(degInRad) * radius.get();
            posy = Math.sin(degInRad) * radius.get();

            const posxIn = Math.cos(degInRad) * innerRadius.get() * radius.get();
            const posyIn = Math.sin(degInRad) * innerRadius.get() * radius.get();

            if (mapping.get() == "round")
            {
                posxTexCoord = 1.0 - i / segs;
                posyTexCoord = 0;
                posxTexCoordIn = posxTexCoord;
                posyTexCoordIn = 1;
            }

            if (steps.get() === 0.0 ||
                (count % parseInt(steps.get(), 10) === 0 && !invertSteps.get()) ||
                (count % parseInt(steps.get(), 10) !== 0 && invertSteps.get()))
            {
                faces.push(
                    [posxIn, posyIn, 0],
                    [oldPosX, oldPosY, 0],
                    [posx, posy, 0]
                );

                faces.push(
                    [oldPosXIn, oldPosYIn, 0],
                    [oldPosX, oldPosY, 0],
                    [posxIn, posyIn, 0]
                );

                texCoords.push(
                    posxTexCoord, 0, oldPosXTexCoord, 0, posxTexCoordIn, 1, posxTexCoord, 1, oldPosXTexCoord, 0, oldPosXTexCoordIn, 1);

                vertexNormals.push(0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1);
                tangents.push(1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0);
                biTangents.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);
            }

            oldPosXTexCoordIn = posxTexCoordIn;
            oldPosYTexCoordIn = posyTexCoordIn;

            oldPosXTexCoord = posxTexCoord;
            oldPosYTexCoord = posyTexCoord;

            oldPosX = posx;
            oldPosY = posy;

            oldPosXIn = posxIn;
            oldPosYIn = posyIn;
        }

        geom = CGL.Geometry.buildFromFaces(faces, "circle");
        geom.vertexNormals = vertexNormals;
        geom.tangents = tangents;
        geom.biTangents = biTangents;

        if (mapping.get() == "flat") geom.mapTexCoords2d();
        else geom.texCoords = texCoords;
    }

    geomOut.setRef(geom);

    if (geom.vertices.length == 0) return;
    if (mesh) mesh.dispose();
    mesh = null;
    if (op.patch.cg)
        mesh = op.patch.cg.createMesh(geom, { "opId": op.id });
    needsCalc = false;
}

function calcLater()
{
    needsCalc = true;
}

}
};

CABLES.OPS["ae07830b-91c3-4cbe-a7d6-d3b737392c16"]={f:Ops.Graphics.Meshes.Circle_v3,objName:"Ops.Graphics.Meshes.Circle_v3"};




// **************************************************************
// 
// Ops.Array.ArrayUnpack2
// 
// **************************************************************

Ops.Array.ArrayUnpack2= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
const inArray1 = op.inArray("Array in xyz"),
    outArray1 = op.outArray("Array 1 out"),
    outArray2 = op.outArray("Array 2 out"),
    outArrayLength = op.outNumber("Array lengths");

let showingError = false;

const arr1 = [];
const arr2 = [];

inArray1.onChange = update;

function update()
{
    let array1 = inArray1.get();

    if (!array1)
    {
        outArray1.set(null);
        return;
    }

    if (array1.length % 2 !== 0)
    {
        if (!showingError)
        {
            op.uiAttr({ "error": "Arrays length not divisible by 2 !" });
            outArrayLength.set(0);
            showingError = true;
        }
        return;
    }
    if (array1.length === 0)
    {
        outArrayLength.set(0);
        outArray1.set(null);
        outArray2.set(null);
    }

    if (showingError)
    {
        showingError = false;
        op.uiAttr({ "error": null });
    }

    arr1.length = Math.floor(array1.length / 2);
    arr2.length = Math.floor(array1.length / 2);

    for (let i = 0; i < array1.length / 2; i++)
    {
        arr1[i] = array1[i * 2];
        arr2[i] = array1[i * 2 + 1];
    }

    // outArray1.set(null);
    // outArray2.set(null);
    outArray1.setRef(arr1);
    outArray2.setRef(arr2);
    outArrayLength.set(arr1.length);
}

}
};

CABLES.OPS["3f789664-9937-4478-ba28-63ccb67e5114"]={f:Ops.Array.ArrayUnpack2,objName:"Ops.Array.ArrayUnpack2"};




// **************************************************************
// 
// Ops.Math.Sum
// 
// **************************************************************

Ops.Math.Sum= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
const
    number1 = op.inValueFloat("number1", 0),
    number2 = op.inValueFloat("number2", 0),
    result = op.outNumber("result");

op.setUiAttribs({ "mathTitle": true });

number1.onChange =
number2.onChange = exec;
exec();

function exec()
{
    const v = number1.get() + number2.get();
    if (!isNaN(v))
        result.set(v);
}

}
};

CABLES.OPS["c8fb181e-0b03-4b41-9e55-06b6267bc634"]={f:Ops.Math.Sum,objName:"Ops.Math.Sum"};




// **************************************************************
// 
// Ops.Math.Compare.GreaterOrEquals
// 
// **************************************************************

Ops.Math.Compare.GreaterOrEquals= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
const
    result = op.outBoolNum("result"),
    number1 = op.inValueFloat("number1"),
    number2 = op.inValueFloat("number2");

number1.onLinkChanged =
    number2.onLinkChanged =
    number1.onChange =
    number2.onChange = exec;

function exec()
{
    result.set(number1.get() >= number2.get());
}

}
};

CABLES.OPS["5f9ce320-1e8d-49cb-9927-337e0b3f4d45"]={f:Ops.Math.Compare.GreaterOrEquals,objName:"Ops.Math.Compare.GreaterOrEquals"};




// **************************************************************
// 
// Ops.Trigger.SwitchTrigger
// 
// **************************************************************

Ops.Trigger.SwitchTrigger= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
const NUM_PORTS = 16;

const
    inIndex = op.inValueInt("Trigger Index", 0),
    triggerPorts = [],
    outTrig = op.outTrigger("Trigger out");

for (let i = 0; i < NUM_PORTS; i++)
{
    const port = op.inTrigger("Trigger in " + i);
    port.onTriggered = function () { update(i); };
    triggerPorts.onChange = function () { update(i); };
    triggerPorts.push(port);
}

function update(inputNum)
{
    const index = Math.min(Math.max(inIndex.get(), 0), 15);
    if (inputNum == index) outTrig.trigger();
}

}
};

CABLES.OPS["aee29293-0c4f-404d-b724-484bbb57361e"]={f:Ops.Trigger.SwitchTrigger,objName:"Ops.Trigger.SwitchTrigger"};




// **************************************************************
// 
// Ops.Patch.PLH3vXR.IsImageVisible1
// 
// **************************************************************

Ops.Patch.PLH3vXR.IsImageVisible1= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={"inc_gen_ports_js":"const port_x4u8fkg49=op.inFloat(\"x4u8fkg49\",0);\nport_x4u8fkg49.setUiAttribs({title:\"ImageIndex\",increment:\"integer\",});\nport_x4u8fkg49.setUiAttribs({\"values\":[\"\"]});\n\nconst port_5i5pamobs=op.outNumber(\"5i5pamobs\");\nport_5i5pamobs.setUiAttribs({title:\"Visible\",display:\"bool\",});\nport_5i5pamobs.setUiAttribs({\"values\":[\"\"]});\n\nop.initInnerPorts=function(addedOps)\n{\n  for(let i=0;i<addedOps.length;i++)\n  {\n    if(addedOps[i].innerInput)\n    {\nconst innerOut_x4u8fkg49 = addedOps[i].outNumber(\"innerOut_x4u8fkg49\");\ninnerOut_x4u8fkg49.set(port_x4u8fkg49.get() );\ninnerOut_x4u8fkg49.setUiAttribs({title:\"ImageIndex\"});\nport_x4u8fkg49.on(\"change\", (a,v) => { innerOut_x4u8fkg49.set(a); });\n\n    }\nif(addedOps[i].innerOutput)\n{\nconst innerIn_5i5pamobs = addedOps[i].inFloat(\"innerIn_5i5pamobs\");\ninnerIn_5i5pamobs.setUiAttribs({title:\"Visible\"});\ninnerIn_5i5pamobs.on(\"change\", (a,v) => { port_5i5pamobs.set(a); });\n\n}\n}\n};\n","subpatch_json":"{\"ops\":[{\"id\":\"sp0-0\",\"uiAttribs\":{\"subPatch\":\"6ep585zgi\"},\"storage\":{\"blueprintVer\":2},\"portsOut\":[{\"name\":\"result\",\"links\":[{\"portIn\":\"number2\",\"portOut\":\"result\",\"objIn\":\"sp0-12\",\"objOut\":\"sp0-0\"}]}],\"objName\":\"Ops.Number.Number\"},{\"id\":\"sp0-1\",\"uiAttribs\":{\"subPatch\":\"6ep585zgi\"},\"storage\":{\"blueprintVer\":2},\"portsOut\":[{\"name\":\"result\",\"links\":[{\"portIn\":\"Boolean\",\"portOut\":\"result\",\"objIn\":\"sp0-2\",\"objOut\":\"sp0-1\"}]}],\"objName\":\"Ops.Number.Number\"},{\"id\":\"sp0-2\",\"uiAttribs\":{\"subPatch\":\"6ep585zgi\"},\"storage\":{\"blueprintVer\":2},\"portsOut\":[{\"name\":\"Result\",\"links\":[{\"portIn\":\"bool 1\",\"portOut\":\"Result\",\"objIn\":\"sp0-13\",\"objOut\":\"sp0-2\"}]}],\"objName\":\"Ops.Boolean.Not\"},{\"id\":\"sp0-3\",\"uiAttribs\":{\"subPatch\":\"6ep585zgi\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"Variable\",\"value\":\"Debug_BuildingLayerIndex\"}],\"portsOut\":[{\"name\":\"Value\",\"links\":[{\"portIn\":\"Index\",\"portOut\":\"Value\",\"objIn\":\"sp0-9\",\"objOut\":\"sp0-3\"}]}],\"objName\":\"Ops.Vars.VarGetNumber_v2\"},{\"id\":\"sp0-4\",\"uiAttribs\":{\"subPatch\":\"6ep585zgi\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"Variable\",\"value\":\"Debug_ShowSpecific\"}],\"portsOut\":[{\"name\":\"Value\",\"links\":[{\"portIn\":\"value\",\"portOut\":\"Value\",\"objIn\":\"sp0-1\",\"objOut\":\"sp0-4\"}]}],\"objName\":\"Ops.Vars.VarGetNumber_v2\"},{\"id\":\"sp0-5\",\"uiAttribs\":{\"subPatch\":\"6ep585zgi\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"Variable\",\"value\":\"Debug_Image_Index\"}],\"portsOut\":[{\"name\":\"Value\",\"links\":[{\"portIn\":\"value\",\"portOut\":\"Value\",\"objIn\":\"sp0-0\",\"objOut\":\"sp0-5\"}]}],\"objName\":\"Ops.Vars.VarGetNumber_v2\"},{\"id\":\"sp0-6\",\"uiAttribs\":{\"subPatch\":\"6ep585zgi\"},\"storage\":{\"blueprintVer\":2},\"portsOut\":[{\"name\":\"innerOut_x4u8fkg49\",\"title\":\"ImageIndex\",\"links\":[{\"portIn\":\"number1\",\"portOut\":\"innerOut_x4u8fkg49\",\"objIn\":\"sp0-10\",\"objOut\":\"sp0-6\"},{\"portIn\":\"number1\",\"portOut\":\"innerOut_x4u8fkg49\",\"objIn\":\"sp0-12\",\"objOut\":\"sp0-6\"}]}],\"objName\":\"Ops.Ui.SubPatchInput\"},{\"id\":\"sp0-7\",\"uiAttribs\":{\"subPatch\":\"6ep585zgi\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"innerIn_5i5pamobs\",\"title\":\"Visible\"}],\"objName\":\"Ops.Ui.SubPatchOutput\"},{\"id\":\"sp0-8\",\"uiAttribs\":{\"subPatch\":\"6ep585zgi\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"Variable\",\"value\":\"BarCount\"}],\"portsOut\":[{\"name\":\"Value\",\"links\":[{\"portIn\":\"number2\",\"portOut\":\"Value\",\"objIn\":\"sp0-10\",\"objOut\":\"sp0-8\"}]}],\"objName\":\"Ops.Vars.VarGetNumber_v2\"},{\"id\":\"sp0-9\",\"uiAttribs\":{\"subPatch\":\"6ep585zgi\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"Value 0\",\"value\":1},{\"name\":\"Value 3\",\"value\":0},{\"name\":\"Value 4\",\"value\":0},{\"name\":\"Value 5\",\"value\":0},{\"name\":\"Value 6\",\"value\":0},{\"name\":\"Value 7\",\"value\":0},{\"name\":\"Value 8\",\"value\":0},{\"name\":\"Value 9\",\"value\":0},{\"name\":\"Value 10\",\"value\":0},{\"name\":\"Value 11\",\"value\":0},{\"name\":\"Value 12\",\"value\":0},{\"name\":\"Value 13\",\"value\":0},{\"name\":\"Value 14\",\"value\":0},{\"name\":\"Value 15\",\"value\":0}],\"portsOut\":[{\"name\":\"Result\",\"links\":[{\"portIn\":\"bool 1\",\"portOut\":\"Result\",\"objIn\":\"sp0-14\",\"objOut\":\"sp0-9\"}]}],\"objName\":\"Ops.Number.SwitchNumber\"},{\"id\":\"sp0-10\",\"uiAttribs\":{\"subPatch\":\"6ep585zgi\"},\"storage\":{\"blueprintVer\":2},\"portsOut\":[{\"name\":\"result\",\"links\":[{\"portIn\":\"Value 1\",\"portOut\":\"result\",\"objIn\":\"sp0-9\",\"objOut\":\"sp0-10\"},{\"portIn\":\"Boolean\",\"portOut\":\"result\",\"objIn\":\"sp0-11\",\"objOut\":\"sp0-10\"}]}],\"objName\":\"Ops.Math.Compare.LessThan\"},{\"id\":\"sp0-11\",\"uiAttribs\":{\"subPatch\":\"6ep585zgi\"},\"storage\":{\"blueprintVer\":2},\"portsOut\":[{\"name\":\"Result\",\"links\":[{\"portIn\":\"Value 2\",\"portOut\":\"Result\",\"objIn\":\"sp0-9\",\"objOut\":\"sp0-11\"}]}],\"objName\":\"Ops.Boolean.Not\"},{\"id\":\"sp0-12\",\"uiAttribs\":{\"subPatch\":\"6ep585zgi\"},\"storage\":{\"blueprintVer\":2},\"portsOut\":[{\"name\":\"result\",\"links\":[{\"portIn\":\"bool 2\",\"portOut\":\"result\",\"objIn\":\"sp0-13\",\"objOut\":\"sp0-12\"}]}],\"objName\":\"Ops.Math.Compare.Equals\"},{\"id\":\"sp0-13\",\"uiAttribs\":{\"subPatch\":\"6ep585zgi\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"bool 3\",\"value\":0},{\"name\":\"bool 4\",\"value\":0},{\"name\":\"bool 5\",\"value\":0},{\"name\":\"bool 6\",\"value\":0},{\"name\":\"bool 7\",\"value\":0},{\"name\":\"bool 8\",\"value\":0},{\"name\":\"bool 9\",\"value\":0},{\"name\":\"bool 10\",\"value\":0}],\"portsOut\":[{\"name\":\"result\",\"links\":[{\"portIn\":\"bool 2\",\"portOut\":\"result\",\"objIn\":\"sp0-14\",\"objOut\":\"sp0-13\"}]}],\"objName\":\"Ops.Boolean.Or\"},{\"id\":\"sp0-14\",\"uiAttribs\":{\"subPatch\":\"6ep585zgi\"},\"storage\":{\"blueprintVer\":2},\"portsOut\":[{\"name\":\"result\",\"links\":[{\"portIn\":\"innerIn_5i5pamobs\",\"portOut\":\"result\",\"objIn\":\"sp0-7\",\"objOut\":\"sp0-14\"}]}],\"objName\":\"Ops.Boolean.And\"}]}",};
const port_x4u8fkg49=op.inFloat("x4u8fkg49",0);
port_x4u8fkg49.setUiAttribs({title:"ImageIndex",increment:"integer",});
port_x4u8fkg49.setUiAttribs({"values":[""]});

const port_5i5pamobs=op.outNumber("5i5pamobs");
port_5i5pamobs.setUiAttribs({title:"Visible",display:"bool",});
port_5i5pamobs.setUiAttribs({"values":[""]});

op.initInnerPorts=function(addedOps)
{
  for(let i=0;i<addedOps.length;i++)
  {
    if(addedOps[i].innerInput)
    {
const innerOut_x4u8fkg49 = addedOps[i].outNumber("innerOut_x4u8fkg49");
innerOut_x4u8fkg49.set(port_x4u8fkg49.get() );
innerOut_x4u8fkg49.setUiAttribs({title:"ImageIndex"});
port_x4u8fkg49.on("change", (a,v) => { innerOut_x4u8fkg49.set(a); });

    }
if(addedOps[i].innerOutput)
{
const innerIn_5i5pamobs = addedOps[i].inFloat("innerIn_5i5pamobs");
innerIn_5i5pamobs.setUiAttribs({title:"Visible"});
innerIn_5i5pamobs.on("change", (a,v) => { port_5i5pamobs.set(a); });

}
}
};

const patchId = "bp2sub_" + op.id;

new CABLES.SubPatchOp(op, { "subId": patchId });

initializeSubpatch();

function initializeSubpatch()
{
    const p = JSON.parse(attachments.subpatch_json);

    CABLES.Patch.replaceOpIds(p,
        {
            "parentSubPatchId": patchId,
            "prefixHash": patchId,
            "oldIdAsRef": true,
            "doNotUnlinkLostLinks": true
        });

    for (let i = 0; i < p.ops.length; i++)
    {
        p.ops[i].uiAttribs.blueprintSubpatch2 = true;
    }

    op.loadDependencies(p, () =>
    {
        op.patch.deSerialize(p, { "opsCreated": op.initInnerPorts });
        if (CABLES.UI)gui.savedState.setSaved("blueprintloaded", patchId);
        op.patch.emitEvent("subpatchExpose", patchId);
        op.setStorage({ "blueprintVer": 2 });
        op.patch.emitEvent("subpatchExpose", patchId);
    });
}

}
};

CABLES.OPS["c7718295-4dd7-4736-9fc2-d2797a6f2223"]={f:Ops.Patch.PLH3vXR.IsImageVisible1,objName:"Ops.Patch.PLH3vXR.IsImageVisible1"};




// **************************************************************
// 
// Ops.Trigger.TriggerReceive
// 
// **************************************************************

Ops.Trigger.TriggerReceive= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
const next = op.outTrigger("Triggered");
op.varName = op.inValueSelect("Named Trigger", [], "", true);

op.varName.setUiAttribs({ "_triggerSelect": true });

updateVarNamesDropdown();
op.patch.addEventListener("namedTriggersChanged", updateVarNamesDropdown);

let oldName = null;

function doTrigger()
{
    next.trigger();
}

function updateVarNamesDropdown()
{
    if (CABLES.UI)
    {
        let varnames = [];
        let vars = op.patch.namedTriggers;

        for (let i in vars) varnames.push(i);
        varnames = varnames.sort();
        op.varName.uiAttribs.values = varnames;
    }
}

op.varName.onChange = function ()
{
    if (oldName)
    {
        let oldCbs = op.patch.namedTriggers[oldName];
        let a = oldCbs.indexOf(doTrigger);
        if (a != -1) oldCbs.splice(a, 1);
    }

    op.setTitle(">" + op.varName.get());
    op.patch.namedTriggers[op.varName.get()] = op.patch.namedTriggers[op.varName.get()] || [];
    let cbs = op.patch.namedTriggers[op.varName.get()];

    cbs.push(doTrigger);
    oldName = op.varName.get();
    updateError();
    op.patch.emitEvent("opTriggerNameChanged", op, op.varName.get());
};

op.on("uiParamPanel", updateError);

function updateError()
{
    if (!op.varName.get())
    {
        op.setUiError("unknowntrigger", "unknown trigger");
    }
    else op.setUiError("unknowntrigger", null);
}

}
};

CABLES.OPS["0816c999-f2db-466b-9777-2814573574c5"]={f:Ops.Trigger.TriggerReceive,objName:"Ops.Trigger.TriggerReceive"};




// **************************************************************
// 
// Ops.Json.SwitchObject
// 
// **************************************************************

Ops.Json.SwitchObject= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
const inIndex = op.inValueInt("Object Index", 0);
const outObject = op.outObject("object out");

const NUM_PORTS = 8;
const objectPorts = [];

op.onLoaded = function () { indexChanged(); };
inIndex.onChange = indexChanged;

for (let i = 0; i < NUM_PORTS; i++)
{
    let port = op.inObject("object port " + i);
    port.inputNum = i;
    port.onChange = onPortChange.bind(port);
    objectPorts[i] = port;
}

function indexChanged()
{
    let index = Math.max(0, Math.floor(inIndex.get()));
    if (index < 0) index = 0;
    else if (index > NUM_PORTS - 1) index = NUM_PORTS - 1;

    outObject.setRef(objectPorts[index].get());
}

function onPortChange()
{
    if (this.inputNum != inIndex.get()) return;

    outObject.setRef(this.get());
}

}
};

CABLES.OPS["345d535e-267d-49fb-98c0-c8a8f9424160"]={f:Ops.Json.SwitchObject,objName:"Ops.Json.SwitchObject"};




// **************************************************************
// 
// Ops.Gl.Texture_v2
// 
// **************************************************************

Ops.Gl.Texture_v2= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
const
    filename = op.inUrl("File", [".jpg", ".png", ".webp", ".jpeg", ".avif"]),
    tfilter = op.inSwitch("Filter", ["nearest", "linear", "mipmap"]),
    wrap = op.inValueSelect("Wrap", ["repeat", "mirrored repeat", "clamp to edge"], "clamp to edge"),
    aniso = op.inSwitch("Anisotropic", ["0", "1", "2", "4", "8", "16"], "0"),
    dataFrmt = op.inSwitch("Data Format", ["R", "RG", "RGB", "RGBA", "SRGBA"], "RGBA"),
    flip = op.inValueBool("Flip", false),
    unpackAlpha = op.inValueBool("Pre Multiplied Alpha", false),
    active = op.inValueBool("Active", true),
    inFreeMemory = op.inBool("Save Memory", true),
    textureOut = op.outTexture("Texture"),
    addCacheBust = op.inBool("Add Cachebuster", false),
    inReload = op.inTriggerButton("Reload"),
    width = op.outNumber("Width"),
    height = op.outNumber("Height"),
    ratio = op.outNumber("Aspect Ratio"),
    loaded = op.outBoolNum("Loaded", 0),
    loading = op.outBoolNum("Loading", 0);

const cgl = op.patch.cgl;

op.toWorkPortsNeedToBeLinked(textureOut);
op.setPortGroup("Size", [width, height]);

let loadedFilename = null;
let loadingId = null;
let tex = null;
let cgl_filter = CGL.Texture.FILTER_MIPMAP;
let cgl_wrap = CGL.Texture.WRAP_REPEAT;
let cgl_aniso = 0;
let timedLoader = 0;

unpackAlpha.setUiAttribs({ "hidePort": true });
unpackAlpha.onChange =
    filename.onChange =
    dataFrmt.onChange =
    addCacheBust.onChange =
    flip.onChange = reloadSoon;
aniso.onChange = tfilter.onChange = onFilterChange;
wrap.onChange = onWrapChange;

tfilter.set("mipmap");
wrap.set("repeat");

textureOut.setRef(CGL.Texture.getEmptyTexture(cgl));

inReload.onTriggered = reloadSoon;

active.onChange = function ()
{
    if (active.get())
    {
        if (loadedFilename != filename.get() || !tex) reloadSoon();
        else textureOut.setRef(tex);
    }
    else
    {
        textureOut.setRef(CGL.Texture.getEmptyTexture(cgl));
        width.set(CGL.Texture.getEmptyTexture(cgl).width);
        height.set(CGL.Texture.getEmptyTexture(cgl).height);
        if (tex)tex.delete();
        op.setUiAttrib({ "extendTitle": "" });
        tex = null;
    }
};

const setTempTexture = function ()
{
    const t = CGL.Texture.getTempTexture(cgl);
    textureOut.setRef(t);
};

function reloadSoon(nocache)
{
    clearTimeout(timedLoader);
    timedLoader = setTimeout(function ()
    {
        realReload(nocache);
    }, 1);
}

function getPixelFormat()
{
    if (dataFrmt.get() == "R") return CGL.Texture.PFORMATSTR_R8UB;
    if (dataFrmt.get() == "RG") return CGL.Texture.PFORMATSTR_RG8UB;
    if (dataFrmt.get() == "RGB") return CGL.Texture.PFORMATSTR_RGB8UB;
    if (dataFrmt.get() == "SRGBA") return CGL.Texture.PFORMATSTR_SRGBA8;

    return CGL.Texture.PFORMATSTR_RGBA8UB;
}

function realReload(nocache)
{
    op.checkMainloopExists();
    if (!active.get()) return;
    if (loadingId)loadingId = cgl.patch.loading.finished(loadingId);

    loadingId = cgl.patch.loading.start(op.objName, filename.get(), op);

    let url = op.patch.getFilePath(String(filename.get()));

    if (addCacheBust.get() || nocache === true) url = CABLES.cacheBust(url);

    if (String(filename.get()).indexOf("data:") == 0) url = filename.get();

    let needsRefresh = false;
    loadedFilename = filename.get();

    if ((filename.get() && filename.get().length > 1))
    {
        loaded.set(false);
        loading.set(true);

        const fileToLoad = filename.get();

        op.setUiAttrib({ "extendTitle": CABLES.basename(url) });
        if (needsRefresh) op.refreshParams();

        cgl.patch.loading.addAssetLoadingTask(() =>
        {
            op.setUiError("urlerror", null);
            CGL.Texture.load(cgl, url, function (err, newTex)
            {
                // cgl.checkFrameStarted("texture inittexture");

                if (filename.get() != fileToLoad)
                {
                    loadingId = cgl.patch.loading.finished(loadingId);
                    return;
                }

                if (tex)tex.delete();

                if (err)
                {
                    const t = CGL.Texture.getErrorTexture(cgl);
                    textureOut.setRef(t);

                    op.setUiError("urlerror", "could not load texture: \"" + filename.get() + "\"", 2);
                    loadingId = cgl.patch.loading.finished(loadingId);
                    return;
                }

                // textureOut.setRef(newTex);

                width.set(newTex.width);
                height.set(newTex.height);
                ratio.set(newTex.width / newTex.height);

                // if (!newTex.isPowerOfTwo()) op.setUiError("npot", "Texture dimensions not power of two! - Texture filtering will not work in WebGL 1.", 0);
                // else op.setUiError("npot", null);

                tex = newTex;
                // textureOut.setRef(null);
                textureOut.setRef(tex);

                loading.set(false);
                loaded.set(true);

                if (inFreeMemory.get()) tex.image = null;

                if (loadingId)
                {
                    loadingId = cgl.patch.loading.finished(loadingId);
                }
                op.checkMainloopExists();
            }, {
                "anisotropic": cgl_aniso,
                "wrap": cgl_wrap,
                "flip": flip.get(),
                "unpackAlpha": unpackAlpha.get(),
                "pixelFormat": getPixelFormat(),
                "filter": cgl_filter
            });

            op.checkMainloopExists();
        });
    }
    else
    {
        setTempTexture();
        loadingId = cgl.patch.loading.finished(loadingId);
    }
}

function onFilterChange()
{
    if (tfilter.get() == "nearest") cgl_filter = CGL.Texture.FILTER_NEAREST;
    else if (tfilter.get() == "linear") cgl_filter = CGL.Texture.FILTER_LINEAR;
    else if (tfilter.get() == "mipmap") cgl_filter = CGL.Texture.FILTER_MIPMAP;
    else if (tfilter.get() == "Anisotropic") cgl_filter = CGL.Texture.FILTER_ANISOTROPIC;
    aniso.setUiAttribs({ "greyout": cgl_filter != CGL.Texture.FILTER_MIPMAP });

    cgl_aniso = parseFloat(aniso.get());

    reloadSoon();
}

function onWrapChange()
{
    if (wrap.get() == "repeat") cgl_wrap = CGL.Texture.WRAP_REPEAT;
    if (wrap.get() == "mirrored repeat") cgl_wrap = CGL.Texture.WRAP_MIRRORED_REPEAT;
    if (wrap.get() == "clamp to edge") cgl_wrap = CGL.Texture.WRAP_CLAMP_TO_EDGE;

    reloadSoon();
}

op.onFileChanged = function (fn)
{
    if (filename.get() && filename.get().indexOf(fn) > -1)
    {
        textureOut.setRef(CGL.Texture.getEmptyTexture(op.patch.cgl));
        textureOut.setRef(CGL.Texture.getTempTexture(cgl));
        realReload(true);
    }
};

}
};

CABLES.OPS["790f3702-9833-464e-8e37-6f0f813f7e16"]={f:Ops.Gl.Texture_v2,objName:"Ops.Gl.Texture_v2"};




// **************************************************************
// 
// Ops.Color.ColorValue
// 
// **************************************************************

Ops.Color.ColorValue= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
const r = op.inValueSlider("r", Math.random());
const g = op.inValueSlider("g", Math.random());
const b = op.inValueSlider("b", Math.random());
r.setUiAttribs({ "colorPick": true });
const a = op.inValueSlider("a", 1);

const outR = op.outNumber("outr");
const outG = op.outNumber("outg");
const outB = op.outNumber("outb");
const outA = op.outNumber("outa");
const outHex = op.outNumber("Hex", "000000");
const arrOut = op.outArray("Array");

r.onChange = g.onChange = b.onChange = a.onChange = exec;

/**
 * Float [0..1] -> Hex String [00..FF]
 */
function floatToHex(f)
{
    let s = Math.round(f * 255).toString(16);
    if (s.length === 1)
    {
        s = "0" + s;
    }
    return s.toUpperCase();
}

function exec()
{
    outR.set(r.get());
    outG.set(g.get());
    outB.set(b.get());
    outA.set(a.get());

    let hex = floatToHex(r.get()) + floatToHex(g.get()) + floatToHex(b.get());
    outHex.set(hex);

    arrOut.set([r.get(), g.get(), b.get(), a.get()]);
}

exec();

}
};

CABLES.OPS["7caa37c8-f2a7-49f2-a29c-96af362abca0"]={f:Ops.Color.ColorValue,objName:"Ops.Color.ColorValue"};




// **************************************************************
// 
// Ops.Trigger.Sequence
// 
// **************************************************************

Ops.Trigger.Sequence= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
const
    exe = op.inTrigger("exe"),
    cleanup = op.inTriggerButton("Clean up connections");

op.setUiAttrib({ "resizable": true, "resizableY": false, "stretchPorts": true });
const
    exes = [],
    triggers = [],
    num = 16;

let
    updateTimeout = null,
    connectedOuts = [];

exe.onTriggered = triggerAll;
cleanup.onTriggered = clean;
cleanup.setUiAttribs({ "hideParam": true, "hidePort": true });

for (let i = 0; i < num; i++)
{
    const p = op.outTrigger("trigger " + i);
    triggers.push(p);
    p.onLinkChanged = updateButton;

    if (i < num - 1)
    {
        let newExe = op.inTrigger("exe " + i);
        newExe.onTriggered = triggerAll;
        exes.push(newExe);
    }
}

updateConnected();

function updateConnected()
{
    connectedOuts.length = 0;
    for (let i = 0; i < triggers.length; i++)
        if (triggers[i].links.length > 0) connectedOuts.push(triggers[i]);
}

function updateButton()
{
    updateConnected();
    clearTimeout(updateTimeout);
    updateTimeout = setTimeout(() =>
    {
        let show = false;
        for (let i = 0; i < triggers.length; i++)
            if (triggers[i].links.length > 1) show = true;

        cleanup.setUiAttribs({ "hideParam": !show });

        if (op.isCurrentUiOp()) op.refreshParams();
    }, 60);
}

function triggerAll()
{
    // for (let i = 0; i < triggers.length; i++) triggers[i].trigger();
    for (let i = 0; i < connectedOuts.length; i++) connectedOuts[i].trigger();
}

function clean()
{
    let count = 0;
    for (let i = 0; i < triggers.length; i++)
    {
        let removeLinks = [];

        if (triggers[i].links.length > 1)
            for (let j = 1; j < triggers[i].links.length; j++)
            {
                while (triggers[count].links.length > 0) count++;

                removeLinks.push(triggers[i].links[j]);
                const otherPort = triggers[i].links[j].getOtherPort(triggers[i]);
                op.patch.link(op, "trigger " + count, otherPort.op, otherPort.name);
                count++;
            }

        for (let j = 0; j < removeLinks.length; j++) removeLinks[j].remove();
    }
    updateButton();
    updateConnected();
}

}
};

CABLES.OPS["a466bc1f-06e9-4595-8849-bffb9fe22f99"]={f:Ops.Trigger.Sequence,objName:"Ops.Trigger.Sequence"};




// **************************************************************
// 
// Ops.Gl.ImageCompose.ImageCompose_v4
// 
// **************************************************************

Ops.Gl.ImageCompose.ImageCompose_v4= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={"imgcomp_frag":"IN vec2 texCoord;\nUNI vec4 bgColor;\nUNI sampler2D tex;\n#ifdef USE_UVTEX\nUNI sampler2D UVTex;\n#endif\n\nvoid main()\n{\n\n    #ifndef USE_TEX\n        outColor=bgColor;\n    #endif\n    #ifdef USE_TEX\n        #ifndef USE_UVTEX\n        outColor=texture(tex,texCoord);\n        #else\n        outColor=texture(tex,texture(UVTex,texCoord).xy);\n        #endif\n    #endif\n\n\n\n}\n",};
const
    cgl = op.patch.cgl,
    render = op.inTrigger("Render"),
    inTex = op.inTexture("Base Texture"),
    inUVTex = op.inTexture("UV Texture"),
    inSize = op.inSwitch("Size", ["Auto", "Canvas", "Manual"], "Auto"),
    width = op.inValueInt("Width", 640),
    height = op.inValueInt("Height", 480),
    inFilter = op.inSwitch("Filter", ["nearest", "linear", "mipmap"], "linear"),
    inWrap = op.inValueSelect("Wrap", ["clamp to edge", "repeat", "mirrored repeat"], "repeat"),
    aniso = op.inSwitch("Anisotropic", ["0", "1", "2", "4", "8", "16"], "0"),

    inPixelFormat = op.inDropDown("Pixel Format", CGL.Texture.PIXELFORMATS, CGL.Texture.PFORMATSTR_RGBA8UB),

    inClear = op.inBool("Clear", true),
    r = op.inValueSlider("R", 0),
    g = op.inValueSlider("G", 0),
    b = op.inValueSlider("B", 0),
    a = op.inValueSlider("A", 0),

    trigger = op.outTrigger("Next"),
    texOut = op.outTexture("texture_out", CGL.Texture.getEmptyTexture(cgl)),
    outRatio = op.outNumber("Aspect Ratio"),
    outWidth = op.outNumber("Texture Width"),
    outHeight = op.outNumber("Texture Height");

op.setPortGroup("Texture Size", [inSize, width, height]);
op.setPortGroup("Texture Parameters", [inWrap, aniso, inFilter, inPixelFormat]);

r.setUiAttribs({ "colorPick": true });
op.setPortGroup("Color", [r, g, b, a, inClear]);

op.toWorkPortsNeedToBeLinked(render);

const prevViewPort = [0, 0, 0, 0];
let effect = null;
let tex = null;
let reInitEffect = true;
let isFloatTex = false;
let copyShader = null;
let copyShaderTexUni = null;
let copyShaderUVTexUni = null;
let copyShaderRGBAUni = null;

inWrap.onChange =
inFilter.onChange =
aniso.onChange =
inPixelFormat.onChange = reInitLater;

inTex.onLinkChanged =
inClear.onChange =
    inSize.onChange =
    inUVTex.onChange = updateUi;

render.onTriggered =
    op.preRender = doRender;

updateUi();

function initEffect()
{
    if (effect)effect.delete();
    if (tex)tex.delete();
    tex = null;
    effect = new CGL.TextureEffect(cgl, { "isFloatingPointTexture": CGL.Texture.isPixelFormatFloat(inPixelFormat.get()), "name": op.name });

    const cgl_aniso = Math.min(cgl.maxAnisotropic, parseFloat(aniso.get()));

    tex = new CGL.Texture(cgl,
        {
            "anisotropic": cgl_aniso,
            "name": "image_compose_v2_" + op.id,
            "pixelFormat": inPixelFormat.get(),
            "filter": getFilter(),
            "wrap": getWrap(),
            "width": getWidth(),
            "height": getHeight()
        });

    effect.setSourceTexture(tex);

    outWidth.set(getWidth());
    outHeight.set(getHeight());
    outRatio.set(getWidth() / getHeight());

    texOut.setRef(CGL.Texture.getEmptyTexture(cgl));

    reInitEffect = false;
    updateUi();
}

function getFilter()
{
    if (inFilter.get() == "nearest") return CGL.Texture.FILTER_NEAREST;
    else if (inFilter.get() == "linear") return CGL.Texture.FILTER_LINEAR;
    else if (inFilter.get() == "mipmap") return CGL.Texture.FILTER_MIPMAP;
}

function getWrap()
{
    if (inWrap.get() == "repeat") return CGL.Texture.WRAP_REPEAT;
    else if (inWrap.get() == "mirrored repeat") return CGL.Texture.WRAP_MIRRORED_REPEAT;
    else if (inWrap.get() == "clamp to edge") return CGL.Texture.WRAP_CLAMP_TO_EDGE;
}

function getWidth()
{
    let x = 0;
    if (inTex.get() && inSize.get() == "Auto") x = inTex.get().width;
    else if (inSize.get() == "Auto" || inSize.get() == "Canvas") x = cgl.canvasWidth;
    else if (inSize.get() == "ViewPort") x = cgl.getViewPort()[2];
    else x = Math.ceil(width.get());
    return op.patch.cgl.checkTextureSize(x);
}

function getHeight()
{
    let x = 0;

    if (inTex.get() && inSize.get() == "Auto") x = inTex.get().height;
    else if (inSize.get() == "Auto" || inSize.get() == "Canvas") x = cgl.canvasHeight;
    else if (inSize.get() == "ViewPort") x = cgl.getViewPort()[3];
    else x = Math.ceil(height.get());
    return op.patch.cgl.checkTextureSize(x);
}

function reInitLater()
{
    reInitEffect = true;
}

function updateResolution()
{
    if ((
        getWidth() != tex.width ||
        getHeight() != tex.height ||
        // tex.anisotropic != parseFloat(aniso.get()) ||
        // tex.isFloatingPoint() != CGL.Texture.isPixelFormatFloat(inPixelFormat.get()) ||
        tex.pixelFormat != inPixelFormat.get() ||
        tex.filter != getFilter() ||
        tex.wrap != getWrap()
    ) && (getWidth() !== 0 && getHeight() !== 0))
    {
        initEffect();
        effect.setSourceTexture(tex);
        // texOut.set(CGL.Texture.getEmptyTexture(cgl));
        texOut.setRef(tex);
        updateResolutionInfo();
        checkTypes();
    }
}

function updateResolutionInfo()
{
    let info = null;

    if (inSize.get() == "Manual")
    {
        info = null;
    }
    else if (inSize.get() == "Auto")
    {
        if (inTex.get()) info = "Input Texture";
        else info = "Canvas Size";

        info += ": " + getWidth() + " x " + getHeight();
    }

    let changed = false;
    changed = inSize.uiAttribs.info != info;
    inSize.setUiAttribs({ "info": info });
    if (changed)op.refreshParams();
}

function updateDefines()
{
    if (copyShader)copyShader.toggleDefine("USE_TEX", inTex.isLinked() || !inClear.get());
    if (copyShader)copyShader.toggleDefine("USE_UVTEX", inUVTex.isLinked());
}

function updateUi()
{
    aniso.setUiAttribs({ "greyout": getFilter() != CGL.Texture.FILTER_MIPMAP });

    r.setUiAttribs({ "greyout": inTex.isLinked() });
    b.setUiAttribs({ "greyout": inTex.isLinked() });
    g.setUiAttribs({ "greyout": inTex.isLinked() });
    a.setUiAttribs({ "greyout": inTex.isLinked() });

    inClear.setUiAttribs({ "greyout": inTex.isLinked() });
    width.setUiAttribs({ "greyout": inSize.get() != "Manual" });
    height.setUiAttribs({ "greyout": inSize.get() != "Manual" });

    // width.setUiAttribs({ "hideParam": inSize.get() != "Manual" });
    // height.setUiAttribs({ "hideParam": inSize.get() != "Manual" });

    if (tex)
        if (CGL.Texture.isPixelFormatFloat(inPixelFormat.get()) && getFilter() == CGL.Texture.FILTER_MIPMAP) op.setUiError("fpmipmap", "Don't use mipmap and 32bit at the same time, many systems do not support this.");
        else op.setUiError("fpmipmap", null);

    updateResolutionInfo();
    updateDefines();
    checkTypes();
}

function checkTypes()
{
    if (tex)
        if (inTex.isLinked() && inTex.get() && (tex.isFloatingPoint() < inTex.get().isFloatingPoint()))
            op.setUiError("textypediff", "Warning: Mixing floating point and non floating point texture can result in data/precision loss", 1);
        else
            op.setUiError("textypediff", null);
}

op.preRender = () =>
{
    doRender();
};

function copyTexture()
{
    if (!copyShader)
    {
        copyShader = new CGL.Shader(cgl, "copytextureshader");
        copyShader.setSource(copyShader.getDefaultVertexShader(), attachments.imgcomp_frag);
        copyShaderTexUni = new CGL.Uniform(copyShader, "t", "tex", 0);
        copyShaderUVTexUni = new CGL.Uniform(copyShader, "t", "UVTex", 1);
        copyShaderRGBAUni = new CGL.Uniform(copyShader, "4f", "bgColor", r, g, b, a);
        updateDefines();
    }

    cgl.pushShader(copyShader);
    cgl.currentTextureEffect.bind();

    if (inTex.get()) cgl.setTexture(0, inTex.get().tex);
    else if (!inClear.get() && texOut.get()) cgl.setTexture(0, texOut.get().tex);
    if (inUVTex.get()) cgl.setTexture(1, inUVTex.get().tex);

    cgl.currentTextureEffect.finish();
    cgl.popShader();
}

function doRender()
{
    if (!effect || reInitEffect) initEffect();

    cgl.pushBlend(false);

    updateResolution();

    const oldEffect = cgl.currentTextureEffect;
    cgl.currentTextureEffect = effect;
    cgl.currentTextureEffect.imgCompVer = 3;
    cgl.currentTextureEffect.width = width.get();
    cgl.currentTextureEffect.height = height.get();
    effect.setSourceTexture(tex);

    effect.startEffect(inTex.get() || CGL.Texture.getEmptyTexture(cgl, isFloatTex), true);
    copyTexture();

    trigger.trigger();

    cgl.pushViewPort(0, 0, width.get(), height.get());

    effect.endEffect();
    texOut.setRef(effect.getCurrentSourceTexture());

    cgl.popViewPort();

    cgl.popBlend();
    cgl.currentTextureEffect = oldEffect;
}

}
};

CABLES.OPS["17212e2b-d692-464c-8f8d-2d511dd3410a"]={f:Ops.Gl.ImageCompose.ImageCompose_v4,objName:"Ops.Gl.ImageCompose.ImageCompose_v4"};




// **************************************************************
// 
// Ops.Gl.ImageCompose.DrawImage_v3
// 
// **************************************************************

Ops.Gl.ImageCompose.DrawImage_v3= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={"drawimage_frag":"#ifdef HAS_TEXTURES\n    IN vec2 texCoord;\n    UNI sampler2D tex;\n    UNI sampler2D image;\n#endif\n\n#ifdef TEX_TRANSFORM\n    IN mat3 transform;\n#endif\n// UNI float rotate;\n\n{{CGL.BLENDMODES}}\n\n#ifdef HAS_TEXTUREALPHA\n   UNI sampler2D imageAlpha;\n#endif\n\nUNI float amount;\n\n#ifdef ASPECT_RATIO\n    UNI float aspectTex;\n    UNI float aspectPos;\n#endif\n\nvoid main()\n{\n    vec4 blendRGBA=vec4(0.0,0.0,0.0,1.0);\n\n    #ifdef HAS_TEXTURES\n        vec2 tc=texCoord;\n\n        #ifdef TEX_FLIP_X\n            tc.x=1.0-tc.x;\n        #endif\n        #ifdef TEX_FLIP_Y\n            tc.y=1.0-tc.y;\n        #endif\n\n        #ifdef ASPECT_RATIO\n            #ifdef ASPECT_AXIS_X\n                tc.y=(1.0-aspectPos)-(((1.0-aspectPos)-tc.y)*aspectTex);\n            #endif\n            #ifdef ASPECT_AXIS_Y\n                tc.x=(1.0-aspectPos)-(((1.0-aspectPos)-tc.x)/aspectTex);\n            #endif\n        #endif\n\n        #ifdef TEX_TRANSFORM\n            vec3 coordinates=vec3(tc.x, tc.y,1.0);\n            tc=(transform * coordinates ).xy;\n        #endif\n\n        blendRGBA=texture(image,tc);\n\n        vec3 blend=blendRGBA.rgb;\n        vec4 baseRGBA=texture(tex,texCoord);\n        vec3 base=baseRGBA.rgb;\n\n\n        #ifdef PREMUL\n            blend.rgb = (blend.rgb) + (base.rgb * (1.0 - blendRGBA.a));\n        #endif\n\n        vec3 colNew=_blend(base,blend);\n\n\n\n\n        #ifdef REMOVE_ALPHA_SRC\n            blendRGBA.a=1.0;\n        #endif\n\n        #ifdef HAS_TEXTUREALPHA\n            vec4 colImgAlpha=texture(imageAlpha,tc);\n            float colImgAlphaAlpha=colImgAlpha.a;\n\n            #ifdef ALPHA_FROM_LUMINANCE\n                vec3 gray = vec3(dot(vec3(0.2126,0.7152,0.0722), colImgAlpha.rgb ));\n                colImgAlphaAlpha=(gray.r+gray.g+gray.b)/3.0;\n            #endif\n\n            #ifdef ALPHA_FROM_INV_UMINANCE\n                vec3 gray = vec3(dot(vec3(0.2126,0.7152,0.0722), colImgAlpha.rgb ));\n                colImgAlphaAlpha=1.0-(gray.r+gray.g+gray.b)/3.0;\n            #endif\n\n            #ifdef INVERT_ALPHA\n                colImgAlphaAlpha=clamp(colImgAlphaAlpha,0.0,1.0);\n                colImgAlphaAlpha=1.0-colImgAlphaAlpha;\n            #endif\n\n            blendRGBA.a=colImgAlphaAlpha*blendRGBA.a;\n        #endif\n    #endif\n\n    float am=amount;\n\n    #ifdef CLIP_REPEAT\n        if(tc.y>1.0 || tc.y<0.0 || tc.x>1.0 || tc.x<0.0)\n        {\n            // colNew.rgb=vec3(0.0);\n            am=0.0;\n        }\n    #endif\n\n    #ifdef ASPECT_RATIO\n        #ifdef ASPECT_CROP\n            if(tc.y>1.0 || tc.y<0.0 || tc.x>1.0 || tc.x<0.0)\n            {\n                colNew.rgb=base.rgb;\n                am=0.0;\n            }\n\n        #endif\n    #endif\n\n\n\n    #ifndef PREMUL\n        blendRGBA.rgb=mix(colNew,base,1.0-(am*blendRGBA.a));\n        blendRGBA.a=clamp(baseRGBA.a+(blendRGBA.a*am),0.,1.);\n    #endif\n\n    #ifdef PREMUL\n        // premultiply\n        // blendRGBA.rgb = (blendRGBA.rgb) + (baseRGBA.rgb * (1.0 - blendRGBA.a));\n        blendRGBA=vec4(\n            mix(colNew.rgb,base,1.0-(am*blendRGBA.a)),\n            blendRGBA.a*am+baseRGBA.a\n            );\n    #endif\n\n    #ifdef ALPHA_MASK\n    blendRGBA.a=baseRGBA.a;\n    #endif\n\n    outColor=blendRGBA;\n}\n\n\n\n\n\n\n\n","drawimage_vert":"IN vec3 vPosition;\nIN vec2 attrTexCoord;\nIN vec3 attrVertNormal;\n\nUNI mat4 projMatrix;\nUNI mat4 mvMatrix;\n\nOUT vec2 texCoord;\n// OUT vec3 norm;\n\n#ifdef TEX_TRANSFORM\n    UNI float posX;\n    UNI float posY;\n    UNI float scaleX;\n    UNI float scaleY;\n    UNI float rotate;\n    OUT mat3 transform;\n#endif\n\nvoid main()\n{\n   texCoord=attrTexCoord;\n//   norm=attrVertNormal;\n\n   #ifdef TEX_TRANSFORM\n        vec3 coordinates=vec3(attrTexCoord.x, attrTexCoord.y,1.0);\n        float angle = radians( rotate );\n        vec2 scale= vec2(scaleX,scaleY);\n        vec2 translate= vec2(posX,posY);\n\n        transform = mat3(   scale.x * cos( angle ), scale.x * sin( angle ), 0.0,\n            - scale.y * sin( angle ), scale.y * cos( angle ), 0.0,\n            - 0.5 * scale.x * cos( angle ) + 0.5 * scale.y * sin( angle ) - 0.5 * translate.x*2.0 + 0.5,  - 0.5 * scale.x * sin( angle ) - 0.5 * scale.y * cos( angle ) - 0.5 * translate.y*2.0 + 0.5, 1.0);\n   #endif\n\n   gl_Position = projMatrix * mvMatrix * vec4(vPosition,  1.0);\n}\n",};
const
    render = op.inTrigger("render"),
    blendMode = CGL.TextureEffect.AddBlendSelect(op, "blendMode"),
    amount = op.inValueSlider("amount", 1),

    image = op.inTexture("Image"),
    inAlphaPremul = op.inValueBool("Premultiplied", false),
    inAlphaMask = op.inValueBool("Alpha Mask", false),
    removeAlphaSrc = op.inValueBool("removeAlphaSrc", false),

    imageAlpha = op.inTexture("Mask"),
    alphaSrc = op.inValueSelect("Mask Src", ["alpha channel", "luminance", "luminance inv"], "luminance"),
    invAlphaChannel = op.inBool("Invert alpha channel"),

    inAspect = op.inValueBool("Aspect Ratio", false),
    inAspectAxis = op.inValueSelect("Stretch Axis", ["X", "Y"], "X"),
    inAspectPos = op.inValueSlider("Position", 0.0),
    inAspectCrop = op.inValueBool("Crop", false),

    trigger = op.outTrigger("trigger");

blendMode.set("normal");
const cgl = op.patch.cgl;
const shader = new CGL.Shader(cgl, "drawimage");

imageAlpha.onLinkChanged = updateAlphaPorts;

op.setPortGroup("Aspect Ratio", [inAspect, inAspectPos, inAspectCrop, inAspectAxis]);
op.setPortGroup("Mask", [imageAlpha, alphaSrc, invAlphaChannel]);

function updateAlphaPorts()
{
    if (imageAlpha.isLinked())
    {
        removeAlphaSrc.setUiAttribs({ "greyout": true });
        alphaSrc.setUiAttribs({ "greyout": false });
        invAlphaChannel.setUiAttribs({ "greyout": false });
    }
    else
    {
        removeAlphaSrc.setUiAttribs({ "greyout": false });
        alphaSrc.setUiAttribs({ "greyout": true });
        invAlphaChannel.setUiAttribs({ "greyout": true });
    }
}

op.toWorkPortsNeedToBeLinked(image);

shader.setSource(attachments.drawimage_vert, attachments.drawimage_frag);

const
    textureUniform = new CGL.Uniform(shader, "t", "tex", 0),
    textureImaghe = new CGL.Uniform(shader, "t", "image", 1),
    textureAlpha = new CGL.Uniform(shader, "t", "imageAlpha", 2),
    uniTexAspect = new CGL.Uniform(shader, "f", "aspectTex", 1),
    uniAspectPos = new CGL.Uniform(shader, "f", "aspectPos", inAspectPos);

inAspect.onChange =
    inAspectCrop.onChange =
    inAspectAxis.onChange = updateAspectRatio;

function updateAspectRatio()
{
    shader.removeDefine("ASPECT_AXIS_X");
    shader.removeDefine("ASPECT_AXIS_Y");
    shader.removeDefine("ASPECT_CROP");

    inAspectPos.setUiAttribs({ "greyout": !inAspect.get() });
    inAspectCrop.setUiAttribs({ "greyout": !inAspect.get() });
    inAspectAxis.setUiAttribs({ "greyout": !inAspect.get() });

    if (inAspect.get())
    {
        shader.define("ASPECT_RATIO");

        if (inAspectCrop.get()) shader.define("ASPECT_CROP");

        if (inAspectAxis.get() == "X") shader.define("ASPECT_AXIS_X");
        if (inAspectAxis.get() == "Y") shader.define("ASPECT_AXIS_Y");
    }
    else
    {
        shader.removeDefine("ASPECT_RATIO");
        if (inAspectCrop.get()) shader.define("ASPECT_CROP");

        if (inAspectAxis.get() == "X") shader.define("ASPECT_AXIS_X");
        if (inAspectAxis.get() == "Y") shader.define("ASPECT_AXIS_Y");
    }
}

//
// texture flip
//
const flipX = op.inValueBool("flip x");
const flipY = op.inValueBool("flip y");

//
// texture transform
//

let doTransform = op.inValueBool("Transform");

let scaleX = op.inValueSlider("Scale X", 1);
let scaleY = op.inValueSlider("Scale Y", 1);

let posX = op.inValue("Position X", 0);
let posY = op.inValue("Position Y", 0);

let rotate = op.inValue("Rotation", 0);

const inClipRepeat = op.inValueBool("Clip Repeat", false);

const uniScaleX = new CGL.Uniform(shader, "f", "scaleX", scaleX);
const uniScaleY = new CGL.Uniform(shader, "f", "scaleY", scaleY);
const uniPosX = new CGL.Uniform(shader, "f", "posX", posX);
const uniPosY = new CGL.Uniform(shader, "f", "posY", posY);
const uniRotate = new CGL.Uniform(shader, "f", "rotate", rotate);

doTransform.onChange = updateTransformPorts;

function updateTransformPorts()
{
    shader.toggleDefine("TEX_TRANSFORM", doTransform.get());

    scaleX.setUiAttribs({ "greyout": !doTransform.get() });
    scaleY.setUiAttribs({ "greyout": !doTransform.get() });
    posX.setUiAttribs({ "greyout": !doTransform.get() });
    posY.setUiAttribs({ "greyout": !doTransform.get() });
    rotate.setUiAttribs({ "greyout": !doTransform.get() });
}

CGL.TextureEffect.setupBlending(op, shader, blendMode, amount);

const amountUniform = new CGL.Uniform(shader, "f", "amount", amount);

render.onTriggered = doRender;

inClipRepeat.onChange =
    imageAlpha.onChange =
    inAlphaPremul.onChange =
    inAlphaMask.onChange =
    invAlphaChannel.onChange =
    flipY.onChange =
    flipX.onChange =
    removeAlphaSrc.onChange =
    alphaSrc.onChange = updateDefines;

updateTransformPorts();
updateAlphaPorts();
updateAspectRatio();
updateDefines();

function updateDefines()
{
    shader.toggleDefine("REMOVE_ALPHA_SRC", removeAlphaSrc.get());
    shader.toggleDefine("ALPHA_MASK", inAlphaMask.get());

    shader.toggleDefine("CLIP_REPEAT", inClipRepeat.get());

    shader.toggleDefine("HAS_TEXTUREALPHA", imageAlpha.get() && imageAlpha.get().tex);

    shader.toggleDefine("TEX_FLIP_X", flipX.get());
    shader.toggleDefine("TEX_FLIP_Y", flipY.get());

    shader.toggleDefine("INVERT_ALPHA", invAlphaChannel.get());

    shader.toggleDefine("ALPHA_FROM_LUMINANCE", alphaSrc.get() == "luminance");
    shader.toggleDefine("ALPHA_FROM_INV_UMINANCE", alphaSrc.get() == "luminance_inv");
    shader.toggleDefine("PREMUL", inAlphaPremul.get());
}

function doRender()
{
    if (!CGL.TextureEffect.checkOpInEffect(op)) return;

    const tex = image.get();
    if (tex && tex.tex && amount.get() > 0.0)
    {
        cgl.pushShader(shader);
        cgl.currentTextureEffect.bind();

        const imgTex = cgl.currentTextureEffect.getCurrentSourceTexture();
        cgl.setTexture(0, imgTex.tex);

        // if (imgTex && tex)
        // {
        //     if (tex.textureType != imgTex.textureType && (tex.textureType == CGL.Texture.TYPE_FLOAT))
        //         op.setUiError("textypediff", "Drawing 32bit texture into an 8 bit can result in data/precision loss", 1);
        //     else
        //         op.setUiError("textypediff", null);
        // }

        const asp = 1 / (cgl.currentTextureEffect.getWidth() / cgl.currentTextureEffect.getHeight()) * (tex.width / tex.height);
        // uniTexAspect.setValue(1 / (tex.height / tex.width * imgTex.width / imgTex.height));

        uniTexAspect.setValue(asp);

        cgl.setTexture(1, tex.tex);
        // cgl.gl.bindTexture(cgl.gl.TEXTURE_2D, image.get().tex );

        if (imageAlpha.get() && imageAlpha.get().tex)
        {
            cgl.setTexture(2, imageAlpha.get().tex);
            // cgl.gl.bindTexture(cgl.gl.TEXTURE_2D, imageAlpha.get().tex );
        }

        // cgl.pushBlend(false);

        cgl.pushBlendMode(CGL.BLEND_NONE, true);

        cgl.currentTextureEffect.finish();
        cgl.popBlendMode();

        // cgl.popBlend();

        cgl.popShader();
    }

    trigger.trigger();
}

}
};

CABLES.OPS["8f6b2f15-fcb0-4597-90c0-e5173f2969fe"]={f:Ops.Gl.ImageCompose.DrawImage_v3,objName:"Ops.Gl.ImageCompose.DrawImage_v3"};




// **************************************************************
// 
// Ops.Gl.Meshes.FullscreenRectangle_v2
// 
// **************************************************************

Ops.Gl.Meshes.FullscreenRectangle_v2= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={"shader_frag":"UNI sampler2D tex;\nIN vec2 texCoord;\n\nvoid main()\n{\n    outColor= texture(tex,texCoord);\n}\n\n","shader_vert":"{{MODULES_HEAD}}\n\nIN vec3 vPosition;\nUNI mat4 projMatrix;\nUNI mat4 mvMatrix;\n\nOUT vec2 texCoord;\nIN vec2 attrTexCoord;\n\nvoid main()\n{\n   vec4 pos=vec4(vPosition,  1.0);\n\n   texCoord=vec2(attrTexCoord.x,(1.0-attrTexCoord.y));\n\n   gl_Position = projMatrix * mvMatrix * pos;\n}\n",};
const
    render = op.inTrigger("render"),
    inScale = op.inSwitch("Scale", ["Stretch", "Fit"], "Fit"),
    flipY = op.inValueBool("Flip Y"),
    flipX = op.inValueBool("Flip X"),
    inTexture = op.inTexture("Texture"),
    trigger = op.outTrigger("trigger");

const cgl = op.patch.cgl;
let mesh = null;
let geom = new CGL.Geometry("fullscreen rectangle");
let x = 0, y = 0, w = 0, h = 0;

op.toWorkShouldNotBeChild("Ops.Gl.TextureEffects.ImageCompose", CABLES.OP_PORT_TYPE_FUNCTION);
op.toWorkPortsNeedToBeLinked(render);

flipX.onChange = rebuildFlip;
flipY.onChange = rebuildFlip;
render.onTriggered = doRender;
inTexture.onLinkChanged = updateUi;
inScale.onChange = updateScale;

const shader = new CGL.Shader(cgl, "fullscreenrectangle", this);
shader.setModules(["MODULE_VERTEX_POSITION", "MODULE_COLOR", "MODULE_BEGIN_FRAG"]);

shader.setSource(attachments.shader_vert, attachments.shader_frag);
shader.fullscreenRectUniform = new CGL.Uniform(shader, "t", "tex", 0);
shader.aspectUni = new CGL.Uniform(shader, "f", "aspectTex", 0);

let useShader = false;
let updateShaderLater = true;
let fitImageAspect = false;

updateUi();
updateScale();

inTexture.onChange = function ()
{
    updateShaderLater = true;
};

function updateUi()
{
    if (!CABLES.UI) return;
    flipY.setUiAttribs({ "greyout": !inTexture.isLinked() });
    flipX.setUiAttribs({ "greyout": !inTexture.isLinked() });
    inScale.setUiAttribs({ "greyout": !inTexture.isLinked() });
}

function updateShader()
{
    let tex = inTexture.get();
    if (tex) useShader = true;
    else useShader = false;
}

op.preRender = function ()
{
    updateShader();
    shader.bind();
    if (mesh)mesh.render(shader);
    doRender();
};

function updateScale()
{
    fitImageAspect = inScale.get() == "Fit";
}

function doRender()
{
    if (cgl.viewPort[2] != w || cgl.viewPort[3] != h || !mesh) rebuild();

    if (updateShaderLater) updateShader();

    cgl.pushPMatrix();
    mat4.identity(cgl.pMatrix);
    mat4.ortho(cgl.pMatrix, 0, w, h, 0, -10.0, 1000);

    cgl.pushModelMatrix();
    mat4.identity(cgl.mMatrix);

    cgl.pushViewMatrix();
    mat4.identity(cgl.vMatrix);

    if (fitImageAspect && inTexture.get())
    {
        const rat = inTexture.get().width / inTexture.get().height;

        let _h = h;
        let _w = h * rat;

        if (_w > w)
        {
            _h = w * 1 / rat;
            _w = w;
        }

        cgl.pushViewPort((w - _w) / 2, (h - _h) / 2, _w, _h);
    }

    if (useShader)
    {
        if (inTexture.get()) cgl.setTexture(0, inTexture.get().tex);
        mesh.render(shader);
    }
    else
    {
        mesh.render(cgl.getShader());
    }

    cgl.gl.clear(cgl.gl.DEPTH_BUFFER_BIT);

    cgl.popPMatrix();
    cgl.popModelMatrix();
    cgl.popViewMatrix();

    if (fitImageAspect && inTexture.get()) cgl.popViewPort();

    trigger.trigger();
}

function rebuildFlip()
{
    mesh = null;
}

function rebuild()
{
    if (cgl.viewPort[2] == w && cgl.viewPort[3] == h && mesh) return;

    let xx = 0, xy = 0;

    w = cgl.viewPort[2];
    h = cgl.viewPort[3];

    geom.vertices = new Float32Array([
        xx + w, xy + h, 0.0,
        xx, xy + h, 0.0,
        xx + w, xy, 0.0,
        xx, xy, 0.0
    ]);

    let tc = null;

    if (flipY.get())
        tc = new Float32Array([
            1.0, 0.0,
            0.0, 0.0,
            1.0, 1.0,
            0.0, 1.0
        ]);
    else
        tc = new Float32Array([
            1.0, 1.0,
            0.0, 1.0,
            1.0, 0.0,
            0.0, 0.0
        ]);

    if (flipX.get())
    {
        tc[0] = 0.0;
        tc[2] = 1.0;
        tc[4] = 0.0;
        tc[6] = 1.0;
    }

    geom.setTexCoords(tc);

    geom.verticesIndices = new Uint16Array([
        2, 1, 0,
        3, 1, 2
    ]);

    geom.vertexNormals = new Float32Array([
        0, 0, 1,
        0, 0, 1,
        0, 0, 1,
        0, 0, 1,
    ]);
    geom.tangents = new Float32Array([
        -1, 0, 0,
        -1, 0, 0,
        -1, 0, 0,
        -1, 0, 0]);
    geom.biTangents == new Float32Array([
        0, -1, 0,
        0, -1, 0,
        0, -1, 0,
        0, -1, 0]);

    if (!mesh) mesh = new CGL.Mesh(cgl, geom);
    else mesh.setGeom(geom);
}

}
};

CABLES.OPS["fb70721a-eac2-4ff5-a5a2-5c59e2393972"]={f:Ops.Gl.Meshes.FullscreenRectangle_v2,objName:"Ops.Gl.Meshes.FullscreenRectangle_v2"};




// **************************************************************
// 
// Ops.Gl.ImageCompose.Blur
// 
// **************************************************************

Ops.Gl.ImageCompose.Blur= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={"blur_frag":"IN vec2 texCoord;\nUNI sampler2D tex;\nUNI float dirX;\nUNI float dirY;\nUNI float amount;\n\n#ifdef HAS_MASK\n    UNI sampler2D imageMask;\n#endif\n\nfloat random(vec3 scale, float seed)\n{\n    return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);\n}\n\nvoid main()\n{\n    vec4 color = vec4(0.0);\n    float total = 0.0;\n\n    float am=amount;\n    #ifdef HAS_MASK\n        am=amount*texture(imageMask,texCoord).r;\n        if(am<=0.02)\n        {\n            outColor=texture(tex, texCoord);\n            return;\n        }\n    #endif\n\n    vec2 delta=vec2(dirX*am*0.01,dirY*am*0.01);\n\n\n    float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);\n\n    #ifdef MOBILE\n        offset = 0.1;\n    #endif\n\n    #if defined(FASTBLUR) && !defined(MOBILE)\n        const float range=5.0;\n    #else\n        const float range=20.0;\n    #endif\n\n    for (float t = -range; t <= range; t+=1.0)\n    {\n        float percent = (t + offset - 0.5) / range;\n        float weight = 1.0 - abs(percent);\n        vec4 smpl = texture(tex, texCoord + delta * percent);\n\n        smpl.rgb *= smpl.a;\n\n        color += smpl * weight;\n        total += weight;\n    }\n\n    outColor= color / total;\n\n    outColor.rgb /= outColor.a + 0.00001;\n\n\n\n}\n",};
const render = op.inTrigger("render");
const trigger = op.outTrigger("trigger");
const amount = op.inValueFloat("amount");
const direction = op.inSwitch("direction", ["both", "vertical", "horizontal"], "both");
const fast = op.inValueBool("Fast", true);
const cgl = op.patch.cgl;

amount.set(10);

let shader = new CGL.Shader(cgl, "blur");

shader.define("FASTBLUR");

fast.onChange = function ()
{
    if (fast.get()) shader.define("FASTBLUR");
    else shader.removeDefine("FASTBLUR");
};

shader.setSource(shader.getDefaultVertexShader(), attachments.blur_frag);
let textureUniform = new CGL.Uniform(shader, "t", "tex", 0);

let uniDirX = new CGL.Uniform(shader, "f", "dirX", 0);
let uniDirY = new CGL.Uniform(shader, "f", "dirY", 0);

let uniWidth = new CGL.Uniform(shader, "f", "width", 0);
let uniHeight = new CGL.Uniform(shader, "f", "height", 0);

let uniAmount = new CGL.Uniform(shader, "f", "amount", amount.get());
amount.onChange = function () { uniAmount.setValue(amount.get()); };

let textureAlpha = new CGL.Uniform(shader, "t", "imageMask", 1);

let showingError = false;

function fullScreenBlurWarning()
{
    if (cgl.currentTextureEffect.getCurrentSourceTexture().width == cgl.canvasWidth &&
        cgl.currentTextureEffect.getCurrentSourceTexture().height == cgl.canvasHeight)
    {
        op.setUiError("warning", "Full screen blurs are slow! Try reducing the resolution to 1/2 or a 1/4", 0);
    }
    else
    {
        op.setUiError("warning", null);
    }
}

let dir = 0;
direction.onChange = function ()
{
    if (direction.get() == "both")dir = 0;
    if (direction.get() == "horizontal")dir = 1;
    if (direction.get() == "vertical")dir = 2;
};

let mask = op.inTexture("mask");

mask.onChange = function ()
{
    if (mask.get() && mask.get().tex) shader.define("HAS_MASK");
    else shader.removeDefine("HAS_MASK");
};

render.onTriggered = function ()
{
    if (!CGL.TextureEffect.checkOpInEffect(op)) return;

    cgl.pushShader(shader);

    uniWidth.setValue(cgl.currentTextureEffect.getCurrentSourceTexture().width);
    uniHeight.setValue(cgl.currentTextureEffect.getCurrentSourceTexture().height);

    fullScreenBlurWarning();

    // first pass
    if (dir === 0 || dir == 2)
    {
        cgl.currentTextureEffect.bind();
        cgl.setTexture(0, cgl.currentTextureEffect.getCurrentSourceTexture().tex);

        if (mask.get() && mask.get().tex)
        {
            cgl.setTexture(1, mask.get().tex);
            // cgl.gl.bindTexture(cgl.gl.TEXTURE_2D, mask.get().tex );
        }

        uniDirX.setValue(0.0);
        uniDirY.setValue(1.0);

        cgl.currentTextureEffect.finish();
    }

    // second pass
    if (dir === 0 || dir == 1)
    {
        cgl.currentTextureEffect.bind();
        cgl.setTexture(0, cgl.currentTextureEffect.getCurrentSourceTexture().tex);

        if (mask.get() && mask.get().tex)
        {
            cgl.setTexture(1, mask.get().tex);
            // cgl.gl.bindTexture(cgl.gl.TEXTURE_2D, mask.get().tex );
        }

        uniDirX.setValue(1.0);
        uniDirY.setValue(0.0);

        cgl.currentTextureEffect.finish();
    }

    cgl.popShader();
    trigger.trigger();
};

}
};

CABLES.OPS["54f26f53-f637-44c1-9bfb-a2f2b722e998"]={f:Ops.Gl.ImageCompose.Blur,objName:"Ops.Gl.ImageCompose.Blur"};




// **************************************************************
// 
// Ops.Gl.ImageCompose.BrightnessContrast
// 
// **************************************************************

Ops.Gl.ImageCompose.BrightnessContrast= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={"brightness_contrast_frag":"IN vec2 texCoord;\nUNI sampler2D tex;\nUNI float amount;\nUNI float amountbright;\n\nvoid main()\n{\n    vec4 col=vec4(1.0,0.0,0.0,1.0);\n    col=texture(tex,texCoord);\n\n    // apply contrast\n    col.rgb = ((col.rgb - 0.5) * max(amount*2.0, 0.0))+0.5;\n\n    // apply brightness\n    col.rgb *= amountbright*2.0;\n\n    outColor = col;\n}",};
const
    render = op.inTrigger("render"),
    amount = op.inValueSlider("contrast", 0.5),
    amountBright = op.inValueSlider("brightness", 0.5),
    trigger = op.outTrigger("trigger");

const cgl = op.patch.cgl;

const shader = new CGL.Shader(cgl, "brightnesscontrast");
shader.setSource(shader.getDefaultVertexShader(), attachments.brightness_contrast_frag);
const textureUniform = new CGL.Uniform(shader, "t", "tex", 0);
const amountUniform = new CGL.Uniform(shader, "f", "amount", amount);
const amountBrightUniform = new CGL.Uniform(shader, "f", "amountbright", amountBright);

render.onTriggered = function ()
{
    if (!CGL.TextureEffect.checkOpInEffect(op)) return;

    if (!cgl.currentTextureEffect.getCurrentSourceTexture()) return;
    if (!CGL.TextureEffect.checkOpInEffect(op)) return;

    cgl.pushShader(shader);
    cgl.currentTextureEffect.bind();

    cgl.setTexture(0, cgl.currentTextureEffect.getCurrentSourceTexture().tex);

    cgl.currentTextureEffect.finish();
    cgl.popShader();

    trigger.trigger();
};

}
};

CABLES.OPS["54b89199-c594-4dff-bc48-82d6c7a55e8a"]={f:Ops.Gl.ImageCompose.BrightnessContrast,objName:"Ops.Gl.ImageCompose.BrightnessContrast"};




// **************************************************************
// 
// Ops.Gl.ImageCompose.Desaturate
// 
// **************************************************************

Ops.Gl.ImageCompose.Desaturate= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={"desaturate_frag":"\nIN vec2 texCoord;\nUNI sampler2D tex;\nUNI float amount;\n\n#ifdef MASK\n    UNI sampler2D mask;\n#endif\n\nvec3 desaturate(vec3 color, float amount)\n{\n   vec3 gray = vec3(dot(vec3(0.2126,0.7152,0.0722), color));\n   return vec3(mix(color, gray, amount));\n}\n\nvoid main()\n{\n    vec4 col=texture(tex,texCoord);\n\n    float am=amount;\n    #ifdef MASK\n        am*=1.0-texture(mask,texCoord).r;\n        #ifdef INVERTMASK\n        am=1.0-am;\n        #endif\n    #endif\n\n    col.rgb=desaturate(col.rgb,am);\n    outColor= col;\n}",};
const render = op.inTrigger("render");
const trigger = op.outTrigger("trigger");
const amount = op.inValueSlider("amount", 1);
const inMask = op.inTexture("Mask");
const invertMask = op.inValueBool("Invert Mask");

const cgl = op.patch.cgl;
const shader = new CGL.Shader(cgl, op.name, op);

shader.setSource(shader.getDefaultVertexShader(), attachments.desaturate_frag);
let textureUniform = new CGL.Uniform(shader, "t", "tex", 0);
let masktextureUniform = new CGL.Uniform(shader, "t", "mask", 1);
let amountUniform = new CGL.Uniform(shader, "f", "amount", amount);

invertMask.onChange = function ()
{
    if (invertMask.get())shader.define("INVERTMASK");
    else shader.removeDefine("INVERTMASK");
};

inMask.onChange = function ()
{
    if (inMask.get())shader.define("MASK");
    else shader.removeDefine("MASK");
};

render.onTriggered = function ()
{
    if (!CGL.TextureEffect.checkOpInEffect(op)) return;

    cgl.pushShader(shader);
    cgl.currentTextureEffect.bind();

    cgl.setTexture(0, cgl.currentTextureEffect.getCurrentSourceTexture().tex);

    if (inMask.get()) cgl.setTexture(1, inMask.get().tex);

    cgl.currentTextureEffect.finish();
    cgl.popShader();

    trigger.trigger();
};

}
};

CABLES.OPS["340efbd5-be53-4bd5-92ad-8f38d8eeecf1"]={f:Ops.Gl.ImageCompose.Desaturate,objName:"Ops.Gl.ImageCompose.Desaturate"};




// **************************************************************
// 
// Ops.Color.ColorPalettes
// 
// **************************************************************

Ops.Color.ColorPalettes= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
const index = op.inValueInt("Index", 0);
const textureOut = op.outTexture("Texture");
const inLinear = op.inValueBool("Smooth");
const arrOut = op.outArray("Color Array");

let canvas = document.createElement("canvas");
canvas.id = "canvas_" + CABLES.generateUUID();
canvas.width = 5;
canvas.height = 8;
canvas.style.display = "none";

let body = document.getElementsByTagName("body")[0];
body.appendChild(canvas);
let ctx = canvas.getContext("2d");

index.onChange =
inLinear.onChange = buildTextureLater;

let arr = [];
arr.length = 5 * 3;
let lastFilter = null;

buildTextureLater();

function hexToR(h)
{
    return parseInt((cutHex(h)).substring(0, 2), 16);
}

function hexToG(h)
{
    return parseInt((cutHex(h)).substring(2, 4), 16);
}

function hexToB(h)
{
    return parseInt((cutHex(h)).substring(4, 6), 16);
}

function cutHex(h = "")
{
    return (h.charAt(0) == "#") ? h.substring(1, 7) : h;
}

function buildTextureLater()
{
    op.patch.cgl.addNextFrameOnceCallback(buildTexture);
}

function buildTexture()
{
    let ind = Math.round(index.get()) * 5;
    if (ind >= colors.length - 5)ind = 0;
    if (ind < 0)ind = 0;
    if (ind != ind)ind = 0;

    for (let i = 0; i < 5; i++)
    {
        let r = hexToR(colors[ind + i]);
        let g = hexToG(colors[ind + i]);
        let b = hexToB(colors[ind + i]);

        arr[i * 3 + 0] = r / 255;
        arr[i * 3 + 1] = g / 255;
        arr[i * 3 + 2] = b / 255;

        ctx.fillStyle = "rgb(" + r + "," + g + "," + b + ")";
        ctx.fillRect(
            canvas.width / 5 * i,
            0,
            canvas.width / 5,
            canvas.height
        );
    }

    let filter = CGL.Texture.FILTER_NEAREST;
    if (inLinear.get())filter = CGL.Texture.FILTER_LINEAR;

    if (lastFilter == filter && textureOut.get()) textureOut.get().initTexture(canvas, filter);
    else textureOut.set(new CGL.Texture.createFromImage(op.patch.cgl, canvas, { "filter": filter }));

    arrOut.set(null);
    arrOut.set(arr);
    textureOut.get().unpackAlpha = false;
    lastFilter = filter;
}

op.onDelete = function ()
{
    canvas.remove();
};

const colors = [
    "#E6E2AF", "#A7A37E", "#EFECCA", "#046380", "002F2F",
    "#468966", "#FFF0A5", "#FFB03B", "#B64926", "8E2800",
    "#FCFFF5", "#D1DBBD", "#91AA9D", "#3E606F", "193441",
    "#FF6138", "#FFFF9D", "#BEEB9F", "#79BD8F", "00A388",
    "#105B63", "#FFFAD5", "#FFD34E", "#DB9E36", "BD4932",
    "#225378", "#1695A3", "#ACF0F2", "#F3FFE2", "EB7F00",
    "#2C3E50", "#E74C3C", "#ECF0F1", "#3498DB", "2980B9",
    "#000000", "#263248", "#7E8AA2", "#FFFFFF", "FF9800",
    "#004358", "#1F8A70", "#BEDB39", "#FFE11A", "FD7400",
    "#DC3522", "#D9CB9E", "#374140", "#2A2C2B", "1E1E20",
    "#7D8A2E", "#C9D787", "#FFFFFF", "#FFC0A9", "FF8598",
    "#B9121B", "#4C1B1B", "#F6E497", "#FCFAE1", "BD8D46",
    "#2E0927", "#D90000", "#FF2D00", "#FF8C00", "04756F",
    "#595241", "#B8AE9C", "#FFFFFF", "#ACCFCC", "8A0917",
    "#10222B", "#95AB63", "#BDD684", "#E2F0D6", "F6FFE0",
    "#F6F792", "#333745", "#77C4D3", "#DAEDE2", "EA2E49",
    "#703030", "#2F343B", "#7E827A", "#E3CDA4", "C77966",
    "#2F2933", "#01A2A6", "#29D9C2", "#BDF271", "FFFFA6",
    "#D8CAA8", "#5C832F", "#284907", "#382513", "363942",
    "#FFF8E3", "#CCCC9F", "#33332D", "#9FB4CC", "DB4105",
    "#85DB18", "#CDE855", "#F5F6D4", "#A7C520", "493F0B",
    "#04BFBF", "#CAFCD8", "#F7E967", "#A9CF54", "588F27",
    "#292929", "#5B7876", "#8F9E8B", "#F2E6B6", "412A22",
    "#332532", "#644D52", "#F77A52", "#FF974F", "A49A87",
    "#405952", "#9C9B7A", "#FFD393", "#FF974F", "F54F29",
    "#2B3A42", "#3F5765", "#BDD4DE", "#EFEFEF", "FF530D",
    "#962D3E", "#343642", "#979C9C", "#F2EBC7", "348899",
    "#96CA2D", "#B5E655", "#EDF7F2", "#4BB5C1", "7FC6BC",
    "#1C1D21", "#31353D", "#445878", "#92CDCF", "EEEFF7",
    "#3E454C", "#2185C5", "#7ECEFD", "#FFF6E5", "FF7F66",
    "#00585F", "#009393", "#FFFCC4", "#F0EDBB", "FF3800",
    "#B4AF91", "#787746", "#40411E", "#32331D", "C03000",
    "#63A69F", "#F2E1AC", "#F2836B", "#F2594B", "CD2C24",
    "#88A825", "#35203B", "#911146", "#CF4A30", "ED8C2B",
    "#F2385A", "#F5A503", "#E9F1DF", "#4AD9D9", "36B1BF",
    "#CFC291", "#FFF6C5", "#A1E8D9", "#FF712C", "695D46",
    "#FF5335", "#B39C85", "#306E73", "#3B424D", "1D181F",
    "#000000", "#333333", "#FF358B", "#01B0F0", "AEEE00",
    "#E8E595", "#D0A825", "#40627C", "#26393D", "FFFAE4",
    "#E7E8D1", "#D3CEAA", "#FBF7E4", "#424242", "8E001C",
    "#354242", "#ACEBAE", "#FFFF9D", "#C9DE55", "7D9100",
    "#2F2933", "#01A2A6", "#29D9C2", "#BDF271", "FFFFA6",
    "#DDDCC5", "#958976", "#611427", "#1D2326", "6A6A61",
    "#6C6E58", "#3E423A", "#417378", "#A4CFBE", "F4F7D9",
    "#E1E6FA", "#C4D7ED", "#ABC8E2", "#375D81", "183152",
    "#6B0C22", "#D9042B", "#F4CB89", "#588C8C", "011C26",
    "#304269", "#91BED4", "#D9E8F5", "#FFFFFF", "F26101",
    "#96CEB4", "#FFEEAD", "#FF6F69", "#FFCC5C", "AAD8B0",
    "#B0CC99", "#677E52", "#B7CA79", "#F6E8B1", "89725B",
    "#334D5C", "#45B29D", "#EFC94C", "#E27A3F", "DF5A49",
    "#16193B", "#35478C", "#4E7AC7", "#7FB2F0", "ADD5F7",
    "#00261C", "#044D29", "#168039", "#45BF55", "96ED89",
    "#36362C", "#5D917D", "#A8AD80", "#E6D4A7", "825534",
    "#F9E4AD", "#E6B098", "#CC4452", "#723147", "31152B",
    "#2C3E50", "#FC4349", "#D7DADB", "#6DBCDB", "FFFFFF",
    "#002635", "#013440", "#AB1A25", "#D97925", "EFE7BE",
    "#FF8000", "#FFD933", "#CCCC52", "#8FB359", "192B33",
    "#272F32", "#9DBDC6", "#FFFFFF", "#FF3D2E", "DAEAEF",
    "#B8ECD7", "#083643", "#B1E001", "#CEF09D", "476C5E",
    "#002F32", "#42826C", "#A5C77F", "#FFC861", "C84663",
    "#5C4B51", "#8CBEB2", "#F2EBBF", "#F3B562", "F06060",
    "#5A1F00", "#D1570D", "#FDE792", "#477725", "A9CC66",
    "#5E0042", "#2C2233", "#005869", "#00856A", "8DB500",
    "#52656B", "#FF3B77", "#CDFF00", "#FFFFFF", "B8B89F",
    "#801637", "#047878", "#FFB733", "#F57336", "C22121",
    "#730046", "#BFBB11", "#FFC200", "#E88801", "C93C00",
    "#24221F", "#363F45", "#4B5F6D", "#5E7C88", "FEB41C",
    "#E64661", "#FFA644", "#998A2F", "#2C594F", "002D40",
    "#C24704", "#D9CC3C", "#FFEB79", "#A0E0A9", "00ADA7",
    "#484A47", "#C1CE96", "#ECEBF0", "#687D77", "353129",
    "#588C7E", "#F2E394", "#F2AE72", "#D96459", "8C4646",
    "#BAB293", "#A39770", "#EFE4BD", "#A32500", "2B2922",
    "#6A7059", "#FDEEA7", "#9BCC93", "#1A9481", "003D5C",
    "#174C4F", "#207178", "#FF9666", "#FFE184", "F5E9BE",
    "#D5FBFF", "#9FBCBF", "#647678", "#2F3738", "59D8E6",
    "#DB5800", "#FF9000", "#F0C600", "#8EA106", "59631E",
    "#450003", "#5C0002", "#94090D", "#D40D12", "FF1D23",
    "#211426", "#413659", "#656F8C", "#9BBFAB", "F2EFDF",
    "#EA6045", "#F8CA4D", "#F5E5C0", "#3F5666", "2F3440",
    "#F2F2F2", "#C6E070", "#91C46C", "#287D7D", "1C344D",
    "#334D5C", "#45B29D", "#EFC94C", "#E27A3F", "DF5A49",
    "#705B35", "#C7B07B", "#E8D9AC", "#FFF6D9", "570026",
    "#F7F2B2", "#ADCF4F", "#84815B", "#4A1A2C", "8E3557",
    "#1A1F2B", "#30395C", "#4A6491", "#85A5CC", "D0E4F2",
    "#25064D", "#36175E", "#553285", "#7B52AB", "9768D1",
    "#004056", "#2C858D", "#74CEB7", "#C9FFD5", "FFFFCB",
    "#CFCA4C", "#FCF5BF", "#9FE5C2", "#5EB299", "745A33",
    "#776045", "#A8C545", "#DFD3B6", "#FFFFFF", "0092B2",
    "#CC3910", "#F1F2C0", "#CCC59E", "#8FA68E", "332F29",
    "#FF6600", "#C13B00", "#5E6D70", "#424E4F", "1B1D1E",
    "#690011", "#BF0426", "#CC2738", "#F2D99C", "E5B96F",
    "#1B1D26", "#425955", "#778C7A", "#F1F2D8", "BFBD9F",
    "#F6B1C3", "#F0788C", "#DE264C", "#BC0D35", "A20D1E",
    "#597533", "#332F28", "#61B594", "#E6DEA5", "C44E18",
    "#3FB8AF", "#7FC7AF", "#DAD8A7", "#FF9E9D", "FF3D7F",
    "#0F2D40", "#194759", "#296B73", "#3E8C84", "D8F2F0",
    "#42282F", "#74A588", "#D6CCAD", "#DC9C76", "D6655A",
    "#002A4A", "#17607D", "#FFF1CE", "#FF9311", "D64700",
    "#003056", "#04518C", "#00A1D9", "#47D9BF", "F2D03B",
    "#13140F", "#D4FF00", "#E4FFE6", "#68776C", "00D6DD",
    "#FCFAD0", "#A1A194", "#5B605F", "#464646", "A90641",
    "#289976", "#67CC8E", "#B1FF91", "#FFE877", "FF5600",
    "#302B1D", "#3F522B", "#737D26", "#A99E46", "D9CB84",
    "#56626B", "#6C9380", "#C0CA55", "#F07C6C", "AD5472",
    "#32450C", "#717400", "#DC8505", "#EC5519", "BE2805",
    "#C7B773", "#E3DB9A", "#F5FCD0", "#B1C2B3", "778691",
    "#E83A25", "#FFE9A3", "#98CC96", "#004563", "191B28",
    "#3399CC", "#67B8DE", "#91C9E8", "#B4DCED", "E8F8FF",
    "#1A212C", "#1D7872", "#71B095", "#DEDBA7", "D13F32",
    "#7D2A35", "#CC9258", "#917A56", "#B4BA6C", "FEFFC2",
    "#E7E9D1", "#D3D4AA", "#FCFAE6", "#444444", "901808",
    "#FFFFFF", "#AEAEAE", "#E64C66", "#2D3E50", "1BBC9B",
    "#E0FFB3", "#61C791", "#31797D", "#2A2F36", "F23C55",
    "#EB5937", "#1C1919", "#403D3C", "#456F74", "D3CBBD",
    "#E6DD00", "#8CB302", "#008C74", "#004C66", "332B40",
    "#14A697", "#F2C12E", "#F29D35", "#F27649", "F25252",
    "#261822", "#40152A", "#731630", "#CC1E2C", "FF5434",
    "#261F27", "#FEE169", "#CDD452", "#F9722E", "C9313D",
    "#5C4B51", "#8CBEB2", "#F2EBBF", "#F3B562", "F06060",
    "#2F3837", "#C5C7B6", "#FFF8D3", "#4C493E", "222028",
    "#E3CBAC", "#9C9985", "#C46D3B", "#788880", "324654",
    "#3F0B1B", "#7A1631", "#CF423C", "#FC7D49", "FFD462",
    "#14212B", "#293845", "#4F6373", "#8F8164", "D9D7AC",
    "#98A89E", "#BAC0AC", "#FAFAC6", "#FF4411", "D40015",
    "#FEFFFF", "#3C3F36", "#9FB03E", "#EBE9DC", "72918B",
    "#CC6B32", "#FFAB48", "#FFE7AD", "#A7C9AE", "888A63",
    "#262526", "#404040", "#8C8979", "#F2F2F2", "F60A20",
    "#00305A", "#004B8D", "#0074D9", "#4192D9", "7ABAF2",
    "#0C273D", "#54D0ED", "#FFFEF1", "#70B85D", "2C5E2E",
    "#4C1B33", "#EFE672", "#98A942", "#2D6960", "141D14",
    "#2F3540", "#666A73", "#F2EDE4", "#D9D1C7", "8C8681",
    "#0D1F30", "#3B6670", "#8BADA3", "#F0E3C0", "DB6C0F",
    "#FFBC67", "#DA727E", "#AC6C82", "#685C79", "455C7B",
    "#092140", "#024959", "#F2C777", "#F24738", "BF2A2A",
    "#133463", "#365FB7", "#799AE0", "#F4EFDC", "BA9B65",
    "#C4D4CB", "#55665E", "#30282A", "#542733", "E84167",
    "#CDDEC6", "#4DAAAB", "#1E4F6A", "#2A423C", "93A189",
    "#EF5411", "#FA5B0F", "#FF6517", "#FF6D1F", "FF822E",
    "#41434A", "#6E9489", "#DEDCC3", "#F2F1E9", "877963",
    "#292929", "#2BBFBD", "#F2B33D", "#F29B30", "F22E2E",
    "#F2385A", "#F5A503", "#E9F1DF", "#56D9CD", "3AA1BF",
    "#D5F8B4", "#A6E3A8", "#8A9A85", "#7E566B", "422335",
    "#3CBAC8", "#93EDD4", "#F3F5C4", "#F9CB8F", "F19181",
    "#979926", "#38CCB5", "#EEFF8E", "#FFD767", "CC2A09",
    "#404040", "#024959", "#037E8C", "#F2EFDC", "F24C27",
    "#94B34D", "#D3FF82", "#363D52", "#121D2B", "111B1C",
    "#282E33", "#25373A", "#164852", "#495E67", "FF3838",
    "#313732", "#8AA8B0", "#DEDEDE", "#FFFFFF", "F26101",
    "#FFFFFF", "#E5E1D1", "#52616D", "#2C343B", "C44741",
    "#FFF6B8", "#ABCCA7", "#403529", "#7A5E2F", "A68236",
    "#4F1025", "#C5003E", "#D9FF5B", "#78AA00", "15362D",
    "#49404F", "#596166", "#D1FFCD", "#A9BD8B", "948A54",
    "#FF2151", "#FF7729", "#FFAD29", "#FFEBCA", "1AB58A",
    "#73603D", "#BF8A49", "#F2CA80", "#5E5A59", "0D0D0D",
    "#3D4C53", "#70B7BA", "#F1433F", "#E7E1D4", "FFFFFF",
    "#006D8D", "#008A6E", "#549E39", "#8AB833", "C0CF3A",
    "#BDDFB3", "#2BAA9C", "#2F2E2E", "#0F2625", "465F3F",
    "#F2F2F2", "#BF0404", "#8C0303", "#590202", "400101",
    "#76A19A", "#272123", "#A68D60", "#B0C5BB", "D9593D",
    "#0E3D59", "#88A61B", "#F29F05", "#F25C05", "D92525",
    "#C1E1ED", "#76C7C6", "#273D3B", "#131A19", "E35C14",
    "#2D112C", "#530031", "#820233", "#CA293E", "EF4339",
    "#AF7575", "#EFD8A1", "#BCD693", "#AFD7DB", "3D9CA8",
    "#D74B4B", "#DCDDD8", "#475F77", "#354B5E", "FFFFFF",
    "#FFF6C9", "#C8E8C7", "#A4DEAB", "#85CC9F", "499E8D",
    "#229396", "#8BA88F", "#C7C5A7", "#F0DFD0", "F23C3C",
    "#57385C", "#A75265", "#EC7263", "#FEBE7E", "FFEDBC",
    "#96526B", "#D17869", "#EBAD60", "#F5CF66", "8BAB8D",
    "#0D1C33", "#17373C", "#2B6832", "#4F9300", "A1D700",
    "#1B2B32", "#37646F", "#A3ABAF", "#E1E7E8", "B22E2F",
    "#C5D9B2", "#53A194", "#572C2C", "#3D2324", "695A3B",
    "#425957", "#81AC8B", "#F2E5A2", "#F89883", "D96666",
    "#002E40", "#2A5769", "#FFFFFF", "#FABD4A", "FA9600",
    "#FFFEFC", "#E2E3DF", "#515B5E", "#2E3233", "CAF200",
    "#FFF0A3", "#B8CC6E", "#4B6000", "#E4F8FF", "004460",
    "#3B596A", "#427676", "#3F9A82", "#A1CD73", "ECDB60",
    "#F2E6CE", "#8AB39F", "#606362", "#593325", "1D1D1F",
    "#212B40", "#C2E078", "#FFFFFF", "#BADCDD", "547B97",
    "#0B3C4D", "#0E5066", "#136480", "#127899", "1A8BB3",
    "#222130", "#464D57", "#D4E8D3", "#FFFCFB", "ED8917",
    "#B33600", "#FF8A00", "#FFC887", "#CC5400", "B31E00",
    "#012530", "#28544B", "#ACBD86", "#FFD6A0", "FF302C",
    "#2E95A3", "#50B8B4", "#C6FFFA", "#E2FFA8", "D6E055",
    "#112F41", "#068587", "#4FB99F", "#F2B134", "ED553B",
    "#202B30", "#4E7178", "#4FA9B8", "#74C0CF", "F1F7E2",
    "#302B2F", "#696153", "#FFA600", "#9BB58F", "FFD596",
    "#458C6B", "#F2D8A7", "#D9A86C", "#D94436", "A62424",
    "#22475E", "#75B08A", "#F0E797", "#FF9D84", "FF5460",
    "#FFAA5C", "#DA727E", "#AC6C82", "#685C79", "455C7B",
    "#686E75", "#9BAAC1", "#82787B", "#E4F1DB", "AAC19B",
    "#F0C755", "#E2AD3B", "#BF5C00", "#901811", "5C110F",
    "#FFFBDC", "#BFBCA5", "#7F7D6E", "#3F3E37", "E5E2C6",
    "#BEBEBE", "#F1E4D8", "#594735", "#94C7BA", "D8F1E4",
    "#1B1E26", "#F2EFBD", "#B6D051", "#70A99A", "2F6D7A",
    "#F7E4A2", "#A7BD5B", "#DC574E", "#8DC7B8", "ED9355",
    "#70E8CB", "#FFE9C7", "#FF5B5B", "#545454", "2D2D2F",
    "#17111A", "#321433", "#660C47", "#B33467", "CCBB51",
    "#2B2E2E", "#595855", "#A2ABA5", "#CAE6E8", "313F54",
    "#023B47", "#295E52", "#F2E085", "#FCAB55", "EE7F38",
    "#302C29", "#D1D1BC", "#A7C4BB", "#6C8C84", "466964",
    "#212629", "#067778", "#49B8A8", "#85EDB6", "D9E5CD",
    "#334D5C", "#45B29D", "#EFC94C", "#E27A3F", "DF4949",
    "#2C3E50", "#FC4349", "#6DBCDB", "#D7DADB", "FFFFFF",
    "#35262D", "#FFFBFF", "#E8ECED", "#A4B7BB", "76A0B0",
    "#61E8D2", "#FCEEB9", "#302F25", "#704623", "BBE687",
    "#E1E6B9", "#C4D7A4", "#ABC8A4", "#375D3B", "183128",
    "#C98B2F", "#803C27", "#C56520", "#E1B41B", "807916",
    "#A3D9B0", "#93BF9E", "#F2F0D5", "#8C8474", "40362E",
    "#524656", "#CF4747", "#EA7A58", "#E4DCCB", "A6C4BC",
    "#5C2849", "#A73E5C", "#EC4863", "#FFDA66", "1FCECB",
    "#0EEAFF", "#15A9FA", "#1B76FF", "#1C3FFD", "2C1DFF",
    "#010000", "#393845", "#9B96A3", "#5C0009", "940315",
    "#468071", "#FFE87A", "#FFCA53", "#FF893B", "E62738",
    "#404040", "#024959", "#037E8C", "#F2EFDC", "F24C27",
    "#FF765E", "#C2AE8B", "#FCCF65", "#FFE5C6", "B7BDC4",
    "#003647", "#00717D", "#F2D8A7", "#A4A66A", "515932",
    "#FAFAC0", "#C4BE90", "#8C644C", "#594D37", "293033",
    "#2B3A42", "#3F5765", "#BDD4DE", "#EFEFEF", "E74C3C",
    "#3B3B3B", "#A8877E", "#FFA49D", "#FF7474", "FF476C",
    "#0A3A4A", "#196674", "#33A6B2", "#9AC836", "D0E64B",
    "#FFA340", "#38001C", "#571133", "#017A74", "00C2BA",
    "#DCEBDD", "#A0D5D6", "#789AA1", "#304345", "AD9A27",
    "#588C7E", "#F2E394", "#F2AE72", "#D96459", "8C4646",
    "#F0E6B1", "#B5D6AA", "#99A37A", "#70584B", "3D3536",
    "#2F400D", "#8CBF26", "#A8CA65", "#E8E5B0", "419184",
    "#010712", "#13171F", "#1C1F26", "#24262D", "961227",
    "#403F33", "#6E755F", "#AFC2AA", "#FFDEA1", "E64C10",
    "#C74029", "#FAE8CD", "#128085", "#385052", "F0AD44",
    "#CFF09E", "#A8DBA8", "#79BD9A", "#3B8686", "0B486B",
    "#E0401C", "#E6B051", "#272F30", "#F7EDB7", "9E2B20",
    "#FFE2C5", "#FFEEDD", "#FFDDAA", "#FFC484", "FFDD99",
    "#FFFFE4", "#F2E5BD", "#B9BF8E", "#A69F7C", "8C6865",
    "#5C8A2D", "#AFD687", "#FFFFFF", "#00C3A9", "008798",
    "#4F3130", "#FF1F3D", "#5BE3E3", "#FDFFF1", "8B9698",
    "#D23600", "#D95100", "#DE6D00", "#EE8900", "FCA600",
    "#FFFFFA", "#A1A194", "#5B605F", "#464646", "FF6600",
    "#F34A53", "#FAE3B4", "#AAC789", "#437356", "1E4147",
    "#2A7A8C", "#176273", "#063540", "#E6D9CF", "403D3A",
    "#21455B", "#567D8C", "#A59E8C", "#8C8372", "F2F2F2",
    "#012340", "#026873", "#83A603", "#BBBF45", "F2F0CE",
    "#FDFF98", "#A7DB9E", "#211426", "#6B073B", "DA8C25",
    "#002F36", "#142426", "#D1B748", "#EDDB43", "FFFD84",
    "#420000", "#600000", "#790000", "#931111", "BF1616",
    "#3C989E", "#5DB5A4", "#F4CDA5", "#F57A82", "ED5276",
    "#23A38F", "#B7C11E", "#EFF1C2", "#F0563D", "2E313D",
    "#F5ECD9", "#2BACB5", "#B4CCB9", "#E84D5B", "3B3B3B",
    "#A5EB3C", "#60C21E", "#159E31", "#53DB50", "C5FFCB",
    "#263138", "#406155", "#7C9C71", "#DBC297", "FF5755",
    "#0A111F", "#263248", "#7E8AA2", "#E3E3E3", "C73226",
    "#003B59", "#00996D", "#A5D900", "#F2E926", "FF930E",
    "#00A19A", "#04BF9D", "#F2E85C", "#F53D54", "404040",
    "#324152", "#47535E", "#796466", "#C1836A", "DEA677",
    "#036F73", "#84CDC2", "#FEF2D8", "#F18C79", "EF504F",
    "#174040", "#888C65", "#D9CA9C", "#D98162", "A65858",
    "#56797F", "#87A0A4", "#FCFBDC", "#F2DDB6", "A6937C",
    "#A8BAA9", "#FFF5CF", "#DBCDAD", "#B39C7D", "806854",
    "#60655F", "#AB9675", "#FFE0C9", "#D4CCBA", "CF8442",
    "#BDDFB3", "#009D57", "#2C372E", "#0F2925", "465F3F",
    "#3E3947", "#735360", "#D68684", "#F1B0B0", "EBD0C4",
    "#0A7B83", "#2AA876", "#FFD265", "#F19C65", "CE4D45",
    "#FFFFFF", "#F4921E", "#858585", "#C5D2DB", "3E6B85",
    "#11151E", "#212426", "#727564", "#B9AA81", "690C07",
    "#000000", "#910000", "#CBB370", "#FFFBF1", "21786C",
    "#F78F00", "#C43911", "#75003C", "#37154A", "0F2459",
    "#003354", "#91BED4", "#D9E8F5", "#FFFFFF", "F26101",
    "#3DA8A4", "#7ACCBE", "#FFFFF7", "#FF99A1", "FF5879",
    "#64C733", "#F0F0F0", "#3E879E", "#57524D", "36302B",
    "#343844", "#2AB69D", "#E65848", "#FDC536", "FCF2D7",
    "#E34517", "#F5FF53", "#B4E85E", "#00BD72", "0B4239",
    "#A84B3A", "#FF9F67", "#233138", "#FFF7F5", "4C646B",
    "#59535E", "#FAEEFF", "#F1BAF3", "#5D4970", "372049",
    "#FF6F22", "#D9984F", "#FFE8A9", "#3E4237", "32948A",
    "#5D7370", "#7FA6A1", "#B8D9B8", "#D6EDBD", "FFF5BC",
    "#FFBE00", "#FFDC00", "#FFD10F", "#FFDE20", "E8CA00",
    "#003840", "#005A5B", "#007369", "#008C72", "02A676",
    "#E1E6FA", "#C4D7ED", "#ABC8E2", "#375D81", "183152",
    "#BA2F1D", "#FFF8A4", "#F5E67F", "#264A59", "1E2C30",
    "#222526", "#FFBB6E", "#F28D00", "#D94F00", "80203B",
    "#EBD096", "#D1B882", "#5D8A66", "#1A6566", "21445B",
    "#F00807", "#5F6273", "#A4ABBF", "#CCC9D1", "E2E1E9",
    "#DFE0AF", "#A4BAA2", "#569492", "#41505E", "383245",
    "#152737", "#2B4E69", "#799AA5", "#FFFFF0", "682321",
    "#C44C51", "#FFB6B8", "#FFEFB6", "#A2B5BF", "5F8CA3",
    "#5ADED4", "#4DAAAB", "#26596A", "#163342", "6C98A1",
    "#FF5B2B", "#B1221C", "#34393E", "#8CC6D7", "FFDA8C",
    "#3D4D4D", "#99992E", "#E6E666", "#F2FFBF", "800033",
    "#242424", "#437346", "#97D95C", "#D9FF77", "E9EB9B",
    "#FFEBB0", "#FFB05A", "#F84322", "#C33A1A", "9F3818",
    "#4D2B2F", "#E57152", "#E8DE67", "#FFEFC3", "C0CCAB",
    "#A82221", "#DB5E31", "#EDA23E", "#F2CB67", "BFB840",
    "#3B3140", "#BFB8A3", "#F2E0C9", "#F2B9AC", "D97E7E",
    "#43464D", "#9197A6", "#D3DCF2", "#7690CF", "48577D",
    "#EFDFBB", "#9EBEA6", "#335D6A", "#D64F2A", "7A8A7F",
    "#000001", "#313634", "#C7CECF", "#5C0402", "941515",
    "#334D5C", "#45B29D", "#EFC94C", "#E27A3F", "DF5A49",
    "#F5F4E1", "#D6C9B5", "#B4AA97", "#D44917", "82877A",
    "#19162B", "#1C425C", "#6ABDC4", "#F0E4C5", "D6C28F",
    "#00132B", "#7F9DB0", "#C5E2ED", "#FFFFFF", "F95900",
    "#1F3642", "#6D968D", "#B6CCB8", "#FFE2B3", "56493F",
    "#08A689", "#82BF56", "#C7D93D", "#E9F2A0", "F2F2F2",
    "#DE3961", "#A4E670", "#FFFFDC", "#B3EECC", "00ADA7",
    "#849972", "#D9D094", "#A6A23E", "#4F2F1D", "8F5145",
    "#F41C54", "#FF9F00", "#FBD506", "#A8BF12", "00AAB5",
    "#00585F", "#009393", "#F5F3DC", "#454445", "FF5828",
    "#FF6138", "#FFFF9D", "#BEEB9F", "#79BD8F", "00A388",
    "#140B04", "#332312", "#B59D75", "#E3D2B4", "FFF7EA",
    "#ED3B3B", "#171F26", "#77B59C", "#F2E7B1", "635656",
    "#46594B", "#A6977C", "#D9B384", "#734F30", "260B01",
    "#CCB8A3", "#FF8FB1", "#FFF5EA", "#4E382F", "B29882",
    "#B70000", "#FFFFFF", "#FFCA3D", "#94C4F4", "0092B3",
    "#053B44", "#06736C", "#A53539", "#B9543C", "EAD075",
    "#E8C1B9", "#FFB3AB", "#FFCAB8", "#E8B69C", "FFCEAB",
    "#E7F2DF", "#69043B", "#59023B", "#231E2D", "161726",
    "#E82B1E", "#E5DEAF", "#A0B688", "#557A66", "453625",
    "#F1E6D4", "#BA3D49", "#791F33", "#9F9694", "E3E1DC",
    "#CED59F", "#F1EDC0", "#B1BEA4", "#647168", "282828",
    "#2C3E50", "#E74C3C", "#ECF0F1", "#3498DB", "646464",
    "#DE7047", "#FFDE8D", "#FFFFFF", "#CDDE47", "528540",
    "#8EAB99", "#40232B", "#D95829", "#D97338", "DEC085",
    "#E9662C", "#EBAF3C", "#00AC65", "#068894", "2B2B2B",
    "#46483C", "#A0AA8F", "#EBE3CB", "#FFFFFF", "F26101",
    "#170F0E", "#290418", "#505217", "#FFD372", "FFF1AF",
    "#263545", "#C4273C", "#D7DADB", "#6DBCDB", "FFFFFF",
    "#DCFAC0", "#B1E1AE", "#85C79C", "#56AE8B", "00968B",
    "#075807", "#097609", "#70AF1A", "#B9D40B", "E5EB0B",
    "#521000", "#712800", "#744E1D", "#879666", "F1D98C",
    "#261F26", "#3F3B40", "#6C7367", "#BFBF8A", "F2E086",
    "#2C3E50", "#FC4349", "#D7DADB", "#6DBCDB", "FFFFFF",
    "#506D7D", "#94CCB9", "#FFECA7", "#FFB170", "F07D65",
    "#3F4036", "#8DA681", "#F2E1C2", "#BF2806", "8C1D04",
    "#990700", "#CC542E", "#FF964F", "#FFCB7C", "787730",
    "#195073", "#7F8C1F", "#EE913F", "#F2E5BD", "9FD7C7",
    "#1B3E59", "#F2F0F0", "#FFAC00", "#BF0404", "730202",
    "#EA6045", "#F8CA4D", "#F5E5C0", "#3F5666", "2F3440",
    "#F95759", "#FDA099", "#FFFFFF", "#D9F3CB", "8AC2B0",
    "#265573", "#386D73", "#81A68A", "#9FBF8F", "D4D9B0",
    "#E1DA36", "#FFEA1B", "#6FE4DA", "#1DB0BC", "007BBC",
    "#013859", "#185E65", "#F9CC7F", "#F15C25", "9E1617",
    "#36CC7C", "#D6FFBE", "#94D794", "#228765", "77A668",
    "#94201F", "#D4421F", "#478A80", "#D9E061", "F08835",
    "#F16233", "#00B5B5", "#F0F0F0", "#3E4651", "5C6D7E",
    "#2E806C", "#76CC99", "#E0FFED", "#FF5F3A", "D2413C",
    "#00393B", "#00766C", "#44A18E", "#E5EDB6", "F6695B",
    "#734854", "#F2F2E9", "#D9D7C5", "#A69580", "736766",
    "#03497E", "#0596D5", "#9DEBFC", "#8D7754", "FEB228",
    "#F0E14C", "#FFBB20", "#FA7B12", "#E85305", "59CC0D",
    "#FE4365", "#FC9D9A", "#F9CDAD", "#C8C8A9", "83AF9B",
    "#00557C", "#186D94", "#3488AD", "#81C1DC", "BBE5F3",
    "#DEE8D7", "#918773", "#420A1A", "#240001", "4D493A",
    "#FFFFFF", "#CAC535", "#97AF25", "#158471", "41342C",
    "#041F3D", "#0B2E41", "#165751", "#448C61", "9AC16D",
    "#FA8C01", "#FF6405", "#577700", "#082400", "A0A600",
    "#78C0F9", "#FFDDCE", "#FFFFFF", "#FFDBE6", "FE86A4",
    "#351330", "#CC2A41", "#E7CAA4", "#759A8A", "524549",
    "#02151A", "#043A47", "#087891", "#C8C8C8", "B31D14",
    "#F34A53", "#FAE3B4", "#AAC789", "#437356", "1E4147",
    "#58838C", "#DAD7C7", "#BF996B", "#BF5841", "A61C1C",
    "#556354", "#E68F0D", "#8C948A", "#495450", "42423F",
    "#323640", "#5B6470", "#8C94A1", "#BDC7D6", "DFE2FF",
    "#FF0000", "#FF950B", "#2FA88C", "#DEEB00", "4B2C04",
    "#0F3D48", "#174C5B", "#366774", "#ECECE7", "E96151",
    "#3DBB7E", "#A3CD39", "#FBAC1D", "#F96C1E", "EE4036",
    "#23363B", "#A44F3F", "#F8983D", "#8D9151", "BBC946",
    "#4B5657", "#969481", "#D2C9B0", "#F4E3C1", "B6B835",
    "#E8980C", "#B1F543", "#F2FF00", "#FF5E00", "59BBAB",
    "#849696", "#FEFFFB", "#232D33", "#17384D", "FF972C",
    "#555555", "#7BB38E", "#F4F1D7", "#F8AB65", "F15C4C",
    "#1D3C42", "#67BFAD", "#F2EC99", "#F2C48D", "F25050",
    "#334D5C", "#45B29D", "#EFC94C", "#E27A3F", "DF4949",
    "#B8E1F2", "#249AA7", "#ABD25E", "#F8C830", "F1594A",
    "#FDEDD0", "#BCF1ED", "#FF634D", "#FD795B", "FFF0AA",
    "#FFFFFF", "#E5E1D1", "#52616D", "#2C343B", "C44741",
    "#FFFFF1", "#D5FF9B", "#8FB87F", "#5A7B6C", "374E5A",
    "#010340", "#0E1E8C", "#0003C7", "#1510F0", "1441F7",
    "#002A4A", "#17607D", "#FFF1CE", "#FF9311", "E33200",
    "#871E31", "#CCC097", "#9E9D7B", "#687061", "262626",
    "#F16663", "#F48D6C", "#F2E07B", "#8ABE9B", "4A6D8B",
    "#001F11", "#204709", "#0C8558", "#FFD96A", "FF4533",
    "#1D1626", "#F2E0BD", "#BFAA8F", "#8C786C", "594C4C",
    "#685D47", "#913420", "#1E2729", "#C1D9C5", "FEEFB1",
    "#1D7561", "#FC8448", "#FF4138", "#A8282B", "38141B",
    "#BF0633", "#FF484E", "#FF9273", "#D1D0B4", "E5ECED",
    "#8E9E63", "#E6DBB0", "#F5EED7", "#C4BCA0", "176573",
    "#665446", "#809994", "#AECCB6", "#DEF2C4", "E6683F",
    "#3D0D26", "#660A3E", "#891C56", "#B0276F", "C93482",
    "#082136", "#00294D", "#004B8D", "#0068C4", "2998FF",
    "#3C4631", "#9A746F", "#F8A2AB", "#F1C6B3", "EAE9C0",
    "#FF534E", "#FFD7AC", "#BED194", "#499989", "176785",
    "#006D80", "#BDA44D", "#3C2000", "#84CECC", "78A419",
    "#352C2B", "#3C555C", "#9E9657", "#FFEBCD", "CD5510",
    "#2C3E50", "#FC4349", "#6DBCDB", "#D7DADB", "FFFFFF",
    "#523631", "#D1BE91", "#605E3A", "#4D462F", "592F39",
    "#18293B", "#5B5A56", "#F2DEA0", "#D0B580", "FFFBFF",
    "#C8DBB6", "#ECEBB7", "#CCC68A", "#B8B165", "827A5D ",
    "#7DA88C", "#EBE9A0", "#BED24B", "#859132", "35323C",
    "#E8574C", "#F27B29", "#E6A51B", "#D9CC3C", "399977",
    "#324032", "#B7C22C", "#FFFFE1", "#22A8B5", "2A3F42",
    "#B3A589", "#FFB896", "#FFF9B1", "#9AB385", "11929E",
    "#272433", "#343F4F", "#3D6066", "#77994D", "B2D249",
    "#250701", "#6D4320", "#B0925F", "#E7DEC0", "82ABB8",
    "#023550", "#028A9E", "#04BFBF", "#EFEFEF", "FF530D",
    "#594732", "#40342A", "#7A422E", "#D4CA9A", "EDE5AE",
    "#013C4D", "#BA5B22", "#DB913C", "#F0B650", "FAD46B",
    "#143840", "#5C6B63", "#A69E89", "#E0C297", "D96523",
    "#3FB8AF", "#7FC7AF", "#DAD8A7", "#FFB38B", "FF3F34",
    "#CA3995", "#F58220", "#FFDF05", "#BED73D", "61BC46",
    "#FFE1D0", "#FFBFB4", "#FF837E", "#FF4242", "BF1616",
    "#C4EEFF", "#7BA32D", "#094201", "#A41717", "C48726",
    "#001325", "#187072", "#90BD90", "#D7D8A2", "F2E4C2",
    "#1A4F63", "#068587", "#6FB07F", "#FCB03C", "FC5B3F",
    "#97B350", "#333230", "#736D61", "#BAAB90", "FFE5BA",
    "#403D33", "#807966", "#CCC2A3", "#8C0000", "590000",
    "#5F8A42", "#86AD59", "#F6FAA1", "#F28410", "D66011",
    "#BF355D", "#ED8168", "#FAB66A", "#F2DC86", "83BFA1",
    "#E1F03E", "#FFBA14", "#DB3A0F", "#A1003D", "630024",
    "#212226", "#45433F", "#687067", "#BDBB99", "F0EAC3",
    "#FE4365", "#FC9D9A", "#F9CDAD", "#C8C8A9", "83AF9B",
    "#293B47", "#5F7A87", "#FFFFFF", "#CBFF48", "00ADA9",
    "#282A33", "#697371", "#FFE7A6", "#F5BA52", "FA8000",
    "#0C304A", "#2B79A1", "#F3F4F1", "#85A71E", "BFD841",
    "#008B83", "#4DAE83", "#A0AE79", "#FFE499", "FF665E",
    "#5D7359", "#E0D697", "#D6AA5C", "#8C5430", "661C0E",
    "#324452", "#97BDBF", "#F2DFBB", "#F28705", "BF3604",
    "#EEEFB9", "#6ACFAE", "#369C93", "#232928", "B03831",
    "#332F45", "#015770", "#2A8782", "#9FD6AE", "FFFED2",
    "#2B2830", "#5C504F", "#ABAB8E", "#D9D7A3", "C7BE88",
    "#DC941B", "#EDC266", "#B6952C", "#E1D3A6", "E9A119",
    "#00305A", "#00448D", "#0074D9", "#4192D9", "7ABAF2",
    "#344459", "#485F73", "#5DA6A6", "#A9D9CB", "F2EAD0",
    "#060719", "#4D1B2F", "#9E332E", "#EB6528", "FC9D1C",
    "#96CEB4", "#FFEEAD", "#FF6F69", "#FFCC5C", "AAD8B0",
    "#05F2F2", "#04BFBF", "#EEF1D9", "#A60201", "7E100E",
    "#E6F1F5", "#636769", "#AAB3B6", "#6E7476", "4B4E50",
    "#DA0734", "#F1A20D", "#4AABB1", "#FCF3E7", "3F1833",
    "#202D44", "#FC4349", "#6DBCDB", "#D7DADB", "FFFFFF",
    "#CC3B37", "#398899", "#FFFCE8", "#FF857F", "CCC1A3",
    "#5DBEA9", "#EFEDDF", "#EF7247", "#4E3F35", "D1CBBA",
    "#FFC62D", "#E49400", "#DD5200", "#EFE38A", "91B166",
    "#B67D14", "#F2921F", "#F0B23E", "#A62409", "441208",
    "#C71B1B", "#D6BA8A", "#017467", "#E08F23", "0B0D0C",
    "#474143", "#A69E9D", "#E7E2DA", "#FFFFFF", "E7E8E7",
    "#435772", "#2DA4A8", "#FEAA3A", "#FD6041", "CF2257",
    "#6DD19D", "#99E89D", "#D0E8A1", "#FFF9C0", "D40049",
    "#FAF1D5", "#DEC9AC", "#CCA18B", "#11282D", "A5C4BB",
    "#000000", "#141414", "#1C1919", "#1A1716", "24201F",
    "#D5D8DD", "#5CA2BE", "#135487", "#2A4353", "989DA4",
    "#73161E", "#BF0F30", "#BFB093", "#037F8C", "0A2140",
    "#195962", "#F56F6C", "#FFFFFF", "#252932", "191C21",
    "#F8EFB6", "#FEBAC5", "#6CD1EA", "#FACFD7", "C2EAE9",
    "#91D6BC", "#768C6A", "#755F31", "#B37215", "FFBA4B",
    "#F2E6BB", "#DD4225", "#202724", "#63BD99", "F8FDD8",
    "#762B1B", "#807227", "#CCBF7A", "#FFEF98", "60B0A1",
    "#707864", "#C1D74E", "#F5FF7C", "#DFE6B4", "A6B89C",
    "#FFF3D2", "#97B48F", "#E87657", "#FF9B6F", "E8D495",
    "#33262E", "#733230", "#CC5539", "#E6D27F", "86A677",
    "#122430", "#273E45", "#FFFCE2", "#EBD2B5", "E63531",
    "#30394F", "#FF434C", "#6ACEEB", "#EDE8DF", "FFFBED",
    "#0A3A4A", "#196A73", "#32A6A6", "#A1BF36", "C8D94A",
    "#FFF7CC", "#CCC28F", "#70995C", "#33664D", "142933",
    "#43464D", "#9197A6", "#D3DCF2", "#7690CF", "48577D",
    "#DFE0AF", "#A4BAA2", "#569492", "#41505E", "383245",
    "#B52841", "#FFC051", "#FF8939", "#E85F4D", "590051",
    "#473C35", "#A36D5C", "#9C968B", "#D9CEAD", "8A866A",
    "#DB4C39", "#2D3638", "#109489", "#44D487", "D0DB86",
    "#6F8787", "#AEC2AE", "#E6DFAE", "#B0B57B", "888F51",
    "#C8385A", "#FFCF48", "#ECEABE", "#1FCECB", "1CA9C9",
    "#42282E", "#75A48B", "#D9CFB0", "#DC9B74", "D6665A",
    "#362F2D", "#4C4C4C", "#94B73E", "#B5C0AF", "FAFDF2",
    "#98293A", "#B14A58", "#C86C6B", "#DE9D76", "EFC77F",
    "#C1D301", "#76AB01", "#0E6A00", "#083500", "042200",
    "#453F22", "#7A6B26", "#CCAD5C", "#A1191F", "4E1716",
    "#541E32", "#8E3557", "#88A33E", "#C2BD86", "F7F2B2",
    "#2B1B2E", "#54344D", "#FFFFD6", "#B89E95", "6E444F",
    "#6EC1A5", "#9FBEA6", "#F5D3A3", "#FF9F88", "FB7878",
    "#2F252C", "#D3CCB2", "#99AD93", "#6E6751", "5C3122",
    "#BE333F", "#F2E9CE", "#C8C5B1", "#939F88", "307360",
    "#F0F1F2", "#232625", "#647362", "#B3D929", "D2D9B8",
    "#FA2B31", "#FFBF1F", "#FFF146", "#ABE319", "00C481",
    "#09455C", "#527E7C", "#F5FFCC", "#E0EB6E", "C4D224",
    "#F2DA91", "#F2B950", "#F29D35", "#D96704", "BF4904",
    "#A2CFA5", "#E0E7AB", "#F5974E", "#E96B56", "D24344",
    "#150033", "#310D42", "#5C2445", "#AB6946", "FFCE4C",
    "#23A38F", "#B7C11E", "#EFF1C2", "#F0563D", "2E313D",
    "#FF2468", "#E0D4B1", "#FFFFE3", "#00A5A6", "005B63",
    "#65A683", "#218777", "#3F585F", "#47384D", "F53357",
    "#000623", "#28475C", "#4A6C74", "#8BA693", "F0E3C0",
    "#E65322", "#D19552", "#B8BF73", "#B6DB83", "FFF991",
    "#112F41", "#068587", "#6FB07F", "#FCB03C", "FC5B3F",
    "#C89B41", "#A16B2B", "#77312B", "#1C2331", "152C52",
    "#C24366", "#D9C099", "#FFF8D8", "#A8E0BA", "00ADA7",
    "#CC0000", "#006600", "#FFFFEC", "#9C9178", "6C644F",
    "#3D0319", "#720435", "#C1140E", "#FC5008", "32241B",
    "#CFC7A4", "#5A9E94", "#005275", "#002344", "A38650",
    "#FFEBC3", "#CC3A00", "#FF3600", "#FF851B", "800C00",
    "#EFC164", "#F3835D", "#F35955", "#286275", "00434C",
    "#E9F29D", "#B7C29D", "#878E8F", "#67617A", "51456B",
    "#445859", "#03A696", "#49C4BE", "#F1F2E4", "FF7746",
    "#FA726C", "#FFD794", "#BAD174", "#3BA686", "5F6F8C",
    "#4D2B1F", "#635D61", "#7992A2", "#97BFD5", "BFDCF5",
    "#CC4D00", "#E6CF73", "#668059", "#264D4D", "00CCB3",
    "#4385F5", "#DC4437", "#FCBE1F", "#109D59", "FFFFFF",
    "#271F2E", "#A4A680", "#F2EBC9", "#D9B166", "A66B38",
    "#0B2C3C", "#FF6666", "#DADFE1", "#FFFFFF", "444444",
    "#CFF09E", "#A8DBA8", "#79BD9A", "#3B8686", "0B486B",
    "#302B26", "#A6B827", "#EDE9DD", "#98D3D4", "594E7A",
    "#4B0505", "#720707", "#BFB694", "#004659", "00292B",
    "#B52C38", "#EBD1B0", "#536682", "#D9964B", "DE6846",
    "#F2F1DF", "#F2B705", "#F2C84B", "#BF820F", "734002",
    "#26140C", "#3D2216", "#784E3D", "#AB8574", "D6BCB1",
    "#26221D", "#8C2C0F", "#E6E5B8", "#BFB38D", "402D1F",
    "#1F8181", "#F2BC79", "#F28972", "#BF1B39", "730240",
    "#002635", "#013440", "#AB1A25", "#D97925", "EFE7BE",
    "#8EC447", "#FFFFFF", "#96D3D4", "#636466", "2D2D2E",
    "#2D1E1E", "#4B3C37", "#96A576", "#CDE196", "FFFFBE",
    "#F06060", "#FA987D", "#F7F2CB", "#72CCA7", "10A296",
    "#1D8281", "#44BF87", "#FBD258", "#F29A3F", "DB634F",
    "#DEDE91", "#EF9950", "#F34E52", "#C91452", "492449",
    "#6D8EAD", "#1F3447", "#1A0B07", "#362416", "CFCDB4",
    "#00CD73", "#008148", "#2D9668", "#3ECD8E", "004E2C",
    "#3D8080", "#628282", "#858383", "#A38282", "C28080",
    "#475159", "#839795", "#B2BDB7", "#CCC9C0", "F2F2F2",
    "#0E6870", "#C6B599", "#C65453", "#FFDDB4", "EDAA7D",
    "#CEF0B7", "#A8DBA8", "#79BD9A", "#3B8686", "0B486B",
    "#292C44", "#FF5349", "#F0F0F1", "#18CDCA", "4F80E1",
    "#272A2B", "#383737", "#473B39", "#692B28", "940500",
    "#D6C274", "#DB9E46", "#25706B", "#3D2423", "AB362E",
    "#FFA68F", "#FF4867", "#FFF9C8", "#B5EBB9", "18B29D",
    "#A1A16A", "#727D59", "#366353", "#133C40", "03212E",
    "#D45354", "#A9DC3A", "#2FCAD8", "#818B85", "CDCDC1",
    "#F14B6A", "#3D3C3E", "#22BDAF", "#BAD7D4", "F4F4F4",
    "#FFE2C5", "#FFEEDD", "#FFDDAA", "#FFC484", "FFDD99",
    "#9FFF4A", "#1ABF93", "#087363", "#004040", "2F1933",
    "#FFDB97", "#B28F4E", "#FFFDFB", "#466CB2", "97BBFF",
    "#991C00", "#E09A25", "#FFFCDB", "#008B83", "262B30",
    "#44281A", "#00ACAE", "#F5EFD5", "#F37606", "EE4717",
    "#FF5952", "#FCEEC9", "#96D6D9", "#4FAAC9", "176075",
    "#5C4B51", "#8CBEB2", "#F2EBBF", "#A5C88F", "EF847B",
    "#105F73", "#F7F3B2", "#C6CC33", "#F28322", "CC5404",
    "#137072", "#56B292", "#B7F5AB", "#FBFFC0", "BF223D",
    "#E3F23E", "#6C821C", "#A6A53F", "#E0E0AC", "33302E",
    "#00215E", "#003CAA", "#1967F7", "#5E4000", "AA7400",
    "#273A3D", "#54695C", "#AD9970", "#FFBF87", "FF8F60",
    "#FFAA00", "#C2B93E", "#808F5D", "#576157", "302F30",
    "#BE1405", "#F2DCAC", "#AABEAA", "#736E41", "413C2D",
    "#6B1229", "#C76A61", "#FAB99A", "#F7D9B5", "CCB1A7",
    "#2D9993", "#58B3A3", "#83BFA3", "#B0D9A8", "FFFCB6",
    "#334D5C", "#45B29D", "#EFC94C", "#E27A3F", "DF5A49",
    "#F30B55", "#010326", "#012840", "#54717F", "F2E6CE",
    "#2A3411", "#73662C", "#BC9847", "#FFDFB2", "6B0031",
    "#637D74", "#403D3A", "#8C3B3B", "#AB6937", "D4A960",
    "#010A26", "#011640", "#B6D6F2", "#FFFFFF", "E83338",
    "#924847", "#EB986C", "#E4C678", "#9C7885", "372C2C",
    "#022440", "#3F95AA", "#4EC6DE", "#EAE2DF", "F7572F",
    "#2B1D2E", "#323657", "#076473", "#54B087", "D6F567",
    "#052229", "#004043", "#BCC373", "#E3FF55", "D0D90C",
    "#4C514A", "#907A62", "#879796", "#755854", "B09880",
    "#1D2939", "#1CAF9A", "#FFFFFF", "#EE4F4B", "D1DC48",
    "#004B67", "#41CCB4", "#FFEA95", "#FF7C5D", "C70151",
    "#C0272D", "#FCFBE7", "#9FD3DA", "#008C9A", "05484F",
    "#213130", "#FF5E3D", "#C9C83E", "#FDFFF1", "559398",
    "#B1E4FC", "#366D78", "#39D5F1", "#FFFFFF", "D9FF03",
    "#DECE6C", "#FCF9B6", "#BFE3B5", "#5D826E", "262E2B",
    "#520A17", "#668F91", "#F5E6AC", "#AB8E5B", "52301C",
    "#2D3032", "#DD5F18", "#FBA922", "#F7F7F7", "404333",
    "#0C2538", "#2B434F", "#638270", "#BCC98E", "EDE059",
    "#E85066", "#F28E76", "#E6CEB0", "#5A8C81", "382837",
    "#BF2633", "#A6242F", "#D9CEAD", "#C0B18F", "011C26",
    "#002A4A", "#17607D", "#FFF1CE", "#FF9311", "E33200",
    "#0A8B91", "#485956", "#C4B98F", "#FFF9BC", "EEDF2E",
    "#B89A7B", "#9BBAAC", "#F2D649", "#D95D50", "DBDBDB",
    "#BD7938", "#8D4421", "#643001", "#532700", "3A1C00",
    "#E1E6FA", "#C4D7ED", "#ABC8E2", "#375D81", "183152",
    "#2E4259", "#F7483B", "#ECF0F1", "#03C8FA", "737373",
    "#364656", "#5D6B74", "#94A4A5", "#F2F5E9", "FF8C31",
    "#3E5916", "#93A605", "#F28705", "#F25C05", "E5EFFA",
    "#248077", "#74AD8D", "#C82754", "#F7BB21", "F9E2B7",
    "#20736A", "#8BD9CA", "#B1D95B", "#93A651", "403E34",
    "#D74B4B", "#DCDDD8", "#475F77", "#354B5E", "FFFFFF",
    "#252F33", "#415C4F", "#869C80", "#93C2CC", "CEEAEE",
    "#012840", "#79C7D9", "#9BF2EA", "#497358", "9DBF8E",
    "#EE7E94", "#F8B4C4", "#C7CAC9", "#D8505C", "41424",
    "#282828", "#505050", "#FFFFFF", "#2DCEDB", "F20000",
    "#004358", "#1F8A70", "#BEDB39", "#FF5347", "FD7400",
    "#470C3B", "#802F56", "#C0576F", "#E38679", "FFBD83",
    "#573328", "#B05A3A", "#FF8548", "#29332E", "0F1B1C",
    "#461F2D", "#E1FFBB", "#BAD47F", "#849C23", "52533F",
    "#333A40", "#4C5E5E", "#ADD0E5", "#CDE4FF", "729EBF",
    "#DE5605", "#F7A035", "#B1DEB5", "#EFECCA", "65ABA6",
    "#76D6D2", "#F9E270", "#EF6F56", "#F4EED8", "596B56",
    "#403E3F", "#F2F2F2", "#D9D9D9", "#9DAABB", "8C8C8C",
    "#059E9A", "#F4F2ED", "#F5A243", "#DB3E3B", "585857",
    "#FFBF41", "#EE8943", "#C02221", "#FFF4D3", "249CA9",
    "#024E76", "#39A6B2", "#FCE138", "#F5B824", "F08106",
    "#FF0067", "#FF3D6A", "#E7FF04", "#9CFF00", "56FF00",
    "#003540", "#0D3F40", "#487360", "#8FA671", "F2D795",
    "#FF493C", "#FFFFFF", "#B3ECEF", "#31C4F5", "ADEB41",
    "#244358", "#4A8B87", "#7CBCAE", "#F0D4AF", "C5252B",
    "#EA5930", "#F8AF1E", "#F5E5C0", "#097380", "372560",
    "#A1DBB2", "#FEE5AD", "#FACA66", "#F7A541", "F45D4C",
    "#2C4A47", "#6C9A7F", "#BB523D", "#C89D11", "81810B",
    "#F0F1F2", "#232625", "#647362", "#FF5629", "D2D9B8",
    "#7C9B5F", "#B8D197", "#E3FFF3", "#9BDEC7", "568F84",
    "#E54E45", "#DBC390", "#F2F2EF", "#13A3A5", "403833",
    "#77A7FB", "#E57368", "#FBCB43", "#34B67A", "FFFFFF",
    "#001A2E", "#8F0000", "#FFFFFF", "#8A874B", "41594F",
    "#312F40", "#49A69C", "#EFEAC5", "#E89063", "BF5656",
    "#047C8C", "#018B8D", "#F3BF81", "#F49B78", "F1706D",
    "#00303E", "#7096AD", "#C1D1DE", "#FFF9EF", "EC4911",
    "#2D6891", "#70A0BF", "#F5EEDC", "#DC4C1A", "F0986C",
    "#040002", "#3D1309", "#E8B96A", "#BC5D15", "5C0F00",
    "#8B929C", "#5E6070", "#514454", "#3B313D", "FF2479",
    "#142D58", "#447F6E", "#E1B65B", "#C8782A", "9E3E17",
    "#22104D", "#2D1E5E", "#483A85", "#7067AB", "A49CFA",
    "#919C86", "#9E373E", "#2B2E36", "#D1B993", "C45A3B",
    "#332F45", "#015770", "#2A8782", "#9FD6AE", "FFFED2",
    "#37C78F", "#FEE293", "#FF4D38", "#CC2249", "380C2A",
    "#47282C", "#8C8468", "#C9B37F", "#DBDAB7", "C4C49C",
    "#14191A", "#2D2B21", "#A69055", "#CCB287", "FFB88C",
    "#F5E3CD", "#696158", "#B6A898", "#877D71", "504A43",
    "#005151", "#009393", "#F56200", "#454445", "969692",
    "#D95F47", "#FFF2C1", "#80A894", "#106153", "072C36",
    "#9E352C", "#E6E8A9", "#93C28C", "#2E5A5C", "2B2623",
    "#03013A", "#334A94", "#6B9EDF", "#83C3F2", "99E6FF",
    "#372A26", "#4D4D4D", "#6DA0A7", "#9ED5A8", "C7F5FF",
    "#03658C", "#022E40", "#F2B705", "#F28705", "F25C05",
    "#FF3B16", "#E87826", "#E8BA4A", "#80A272", "003045",
    "#00748E", "#E3DFBB", "#F4BA4D", "#E3753C", "DA3B3A",
    "#25401E", "#56732C", "#84A63C", "#B8D943", "EAF2AC",
    "#449BB5", "#043D5D", "#EB5055", "#68C39F", "FFFCF5",
    "#108F97", "#FF8B6B", "#FFE39F", "#16866D", "103636",
    "#1A4F63", "#068F86", "#6FD57F", "#FCB03C", "FC5B3F",
    "#381C19", "#472E29", "#948658", "#F0E99A", "362E29",
    "#D7E8F7", "#BBD0E3", "#9CB7CF", "#6A8BAB", "375D81",
    "#0F1C28", "#136972", "#67BFA7", "#F3CF5B", "F07444",
    "#FFFFFF", "#4EA9A0", "#969514", "#FE9C03", "FCDE8E",
    "#2F2D30", "#656566", "#65537A", "#51386E", "2A2333",
    "#4C2916", "#F05A28", "#FBAF3F", "#38B449", "FFFFFF",
    "#132537", "#006C80", "#EBCAB8", "#FE8315", "FA3113",
    "#ECEEE1", "#A8DACF", "#F05B4F", "#D8403A", "221E1F",
    "#00305A", "#004B8C", "#0074D9", "#4192D9", "7ABAF2",
    "#72CF3F", "#85FF00", "#23E000", "#2FB81B", "00FF1C",
    "#45CEEF", "#FFF5A5", "#FFD4DA", "#99D2E4", "D8CAB4",
    "#FF5B00", "#A1716C", "#728296", "#439AAB", "00CABD",
    "#EB6C2D", "#D9C8A2", "#939C80", "#496158", "232F38",
    "#D94214", "#FFF2C1", "#80A894", "#52736B", "093844",
    "#4D1B2F", "#9E332E", "#EB6528", "#FC9D1C", "FFCA50",
    "#FFEEB0", "#9AE8A4", "#C7C12D", "#F76245", "ED1C43",
    "#FFFAED", "#D4DBFF", "#879AC9", "#242942", "FF8800",
    "#022840", "#013440", "#517360", "#9DA67C", "F2DC99",
    "#331A0F", "#519994", "#BA4B3C", "#EEDDAA", "789F63",
    "#577867", "#EDCE82", "#D68644", "#AB3229", "662845",
    "#435A66", "#88A6AF", "#F5F2EB", "#D9CDB8", "424342",
    "#FF8840", "#958D4F", "#737B55", "#595540", "513E38",
    "#9D805A", "#EBC99D", "#FFE6C5", "#9DCEEA", "4B809E",
    "#272D40", "#364659", "#55736D", "#9DBF8E", "D0D991",
    "#23A38F", "#B7C11E", "#EFF1C2", "#F0563D", "2E313D",
    "#98C000", "#3D4C53", "#EA2E49", "#FFE11A", "0CDBE8",
    "#A20E30", "#E93C4F", "#DCDCD4", "#ADBCC3", "2D4255",
    "#1C2640", "#263357", "#384C80", "#4E6AB3", "5979CD",
    "#D94214", "#FFF2C1", "#80A894", "#52736B", "093844",
    "#3B596A", "#427676", "#3F9A82", "#A1CD73", "ECDB60",
    "#1E1E1F", "#424143", "#67666A", "#807F83", "CBC9CF",
    "#E04946", "#3BA686", "#B6D15D", "#FFD495", "FA847E",
    "#FFEBB0", "#FFB05A", "#F84322", "#C33A1A", "9F3818",
    "#FFA136", "#FF814A", "#E6635A", "#785D6B", "534557",
    "#CDCF91", "#EBEACC", "#D6D5B8", "#6D7D80", "41545E",
    "#011526", "#011C40", "#4E8DA6", "#F2EA79", "F2B33D",
    "#353230", "#3F4E51", "#7B8F70", "#99B2BE", "F6F4EA",
    "#063559", "#0D8C7F", "#8FBF4D", "#F2D13E", "D95929",
    "#158000", "#199900", "#20BF00", "#24D900", "29FF00",
    "#0B0D0E", "#137074", "#7EB7A3", "#F1DDBB", "EC6766",
    "#02151A", "#043A47", "#087891", "#C8C8C8", "B31D14",
    "#59361F", "#5C992E", "#A3CC52", "#E6E673", "FF5933",
    "#FE4365", "#FC9D9A", "#F9CDAD", "#C8C8A9", "83AF9B",
    "#4B1E18", "#F9E5C2", "#BBB082", "#829993", "4F5D4E",
    "#032843", "#1F595B", "#508C6D", "#71A670", "A6DB89",
    "#191724", "#4C4547", "#8C594E", "#D18952", "FDB157",
    "#191919", "#182828", "#60702D", "#AAB232", "E6FA87",
    "#212A3F", "#434F5B", "#F2F2F2", "#8AB839", "2E2E2E",
    "#004158", "#026675", "#038B8B", "#F1EEC9", "F09979",
    "#023059", "#3F7EA6", "#F2F2F2", "#D99E32", "BF5E0A",
    "#F21E52", "#FFFFFF", "#3D3B42", "#0C6F73", "63CFD4",
    "#452743", "#E7635E", "#F8E9A8", "#89E0AD", "00928C",
    "#FAAD63", "#D1714D", "#785E48", "#39403B", "3D1C24",
    "#4C0016", "#FFF7EB", "#DCCEA7", "#A17345", "104F53",
    "#BF2431", "#F24150", "#2A4557", "#3B848C", "EFF2E4",
    "#3B3013", "#8F6031", "#E88833", "#9C0C0A", "FDF3C1",
    "#1E2422", "#88BEB1", "#FF006D", "#DAFFFF", "718A94",
    "#F1F4F7", "#AF9F7B", "#775E43", "#40413C", "251C17",
    "#00182E", "#0C6BA1", "#D4D6D4", "#FFFDEB", "FF7500",
    "#FFAB4A", "#CCBAAB", "#1E2129", "#3D5E6E", "47A3A3",
    "#66B3A7", "#C0D4B6", "#EEF0BD", "#F0563D", "2C2F3B",
    "#332525", "#907465", "#EDC5B5", "#878C6D", "63674A",
    "#F04C16", "#DBDBD0", "#EDBD1F", "#4CB09C", "313B4A",
    "#2B211D", "#611C26", "#C5003E", "#8EB7A8", "F1E4B7",
    "#1A1F2B", "#30395C", "#4A6491", "#85A5CC", "D0E4F2",
    "#03497E", "#0596D5", "#9DEBFC", "#999999", "FE4B28",
    "#2F4159", "#465E73", "#88A649", "#F2ECE4", "D98841",
    "#323A46", "#22282F", "#EB4A33", "#FFFFFF", "E9F0F5",
    "#2C3E50", "#FC4349", "#6DBCDB", "#D7DADB", "FFFFFF",
    "#F29727", "#E05723", "#B0382F", "#982E4B", "713045",
    "#4D584A", "#465943", "#428552", "#3E754E", "4C694B",
    "#47191C", "#59574B", "#829690", "#B5B09A", "E1E3CB",
    "#1D5123", "#B1C661", "#FFDA68", "#FE9257", "F64448",
    "#59323C", "#260126", "#F2EEB3", "#BFAF80", "8C6954",
    "#4E0805", "#9E0522", "#FFF4D4", "#B8C591", "447622",
    "#424862", "#FB9A63", "#BFC4D5", "#F6FBF4", "FEBC98",
    "#FF2468", "#E0D4B1", "#FFFFE3", "#00A5A6", "005B63",
    "#1C2F40", "#4C6173", "#8094A6", "#D9D1BA", "F2E9D8",
    "#DFD7B7", "#EB7707", "#5C5445", "#3B2323", "9CBFC7",
    "#262E3B", "#9C8878", "#CFCAAA", "#FBF8FF", "992435",
    "#FFBC67", "#DA727E", "#AC6C82", "#685C79", "455C7B",
    "#404A69", "#516C8A", "#8AC0DE", "#FFFFFF", "FFAC00",
    "#485B61", "#4B8C74", "#74C476", "#A4E66D", "CFFC83",
    "#A31180", "#C42795", "#DE52B4", "#EA88CE", "FFBFE5",
    "#E64D2E", "#FFF5F1", "#7893AD", "#576B9C", "2D2A52",
    "#BF0436", "#8C0327", "#590219", "#F2CBA1", "8C674C",
    "#CF5B6F", "#FFF8C8", "#CAD9B1", "#8FB3A0", "648991",
    "#341D44", "#744D90", "#BB8CDD", "#3E4417", "88904D",
    "#00293E", "#003D4E", "#006269", "#00918F", "00BAB5",
    "#43212E", "#D9666F", "#F2D57E", "#A9A688", "516057",
    "#2A3B30", "#ABFFD1", "#EBFFF5", "#9DFEFF", "273B40",
    "#A63343", "#E65159", "#F5E9DB", "#F4F7CF", "BAD984",
    "#1BA68C", "#54BFAC", "#F2EDA7", "#F2E530", "D94625",
    "#1A2A40", "#3F7369", "#F2DEA0", "#CE5251", "EA895E",
    "#1E9382", "#70A758", "#EFF1C2", "#F0563D", "2E313D",
    "#A991E8", "#FFB4BB", "#ACF7FF", "#A2E891", "FFEDAE",
    "#225B66", "#17A3A5", "#8DBF67", "#FCCB5F", "FC6E59",
    "#282624", "#BFB7AA", "#403D39", "#807A71", "ABA398",
    "#334D5C", "#45B29D", "#EFC94C", "#E27A3F", "DF4949",
    "#440008", "#605521", "#988432", "#D9A54E", "9E3711",
    "#649670", "#36291E", "#69AD6C", "#92E67C", "C5FF84",
    "#42342C", "#738076", "#B2B39B", "#DFE5E1", "294359",
    "#1A3838", "#3F7A51", "#82A352", "#D1C062", "FFBE59",
    "#7D8C22", "#B3BF67", "#F2E49B", "#D9DFF4", "6791BF",
    "#8A7D6D", "#2D2D38", "#E86E48", "#FFFFE8", "9CC9C9",
    "#CFC949", "#FFF5BF", "#A9E6C4", "#6AB39F", "665841",
    "#A1172D", "#FDFFBA", "#A7DB9E", "#275C57", "1F1B19",
    "#FF6C0D", "#F29E00", "#E6C10F", "#44996F", "216273",
    "#2C3E50", "#FA4248", "#D7DADB", "#6DBCDB", "FFFFFF",
    "#627369", "#99B397", "#E2F2C6", "#91CCAD", "376266",
    "#04496E", "#66CAFF", "#A3FC7E", "#70D44A", "2C6B0F",
    "#1BA68C", "#97BF3F", "#F2ECD8", "#F2B035", "F2522E",
    "#A2D9B1", "#7CBF9E", "#F2F1B9", "#8C8575", "193741",
    "#024959", "#037E8C", "#F2EFDC", "#E74C30", "363636",
    "#212625", "#9CA6A2", "#D0D9D6", "#BF0404", "C2C6AF",
    "#00FFFF", "#00FF00", "#FFFF00", "#FF5100", "FF007C",
    "#212629", "#CDCF19", "#FFF77D", "#96C4AB", "CF2A56",
    "#CFF9FF", "#BFC7BB", "#787051", "#332730", "57324F",
    "#98CACB", "#FDEFBE", "#F0542B", "#736E5B", "ABA68E",
    "#F2F1EB", "#BFB9A4", "#262222", "#802A30", "8C0303",
    "#65356B", "#AB434F", "#C76347", "#FFA24C", "519183",
    "#78BF82", "#A4D17C", "#CFD96C", "#EBD464", "FFD970",
    "#806265", "#FFA256", "#F7DD77", "#E0D054", "ABA73C",
    "#8F323C", "#123943", "#80BDDB", "#4189AB", "C98127",
    "#683820", "#8C9A89", "#E7D6A2", "#BEAA65", "9A8234",
    "#021B21", "#032C36", "#065F73", "#E8DFD6", "FF2A1D",
    "#2D6C73", "#3FA693", "#B4D9CB", "#9ABF49", "C6D93B",
    "#141F26", "#2B4040", "#405950", "#A69E86", "F2D9BB",
    "#4A8279", "#003330", "#610400", "#003B06", "02730F",
    "#69B5E1", "#D4E4F5", "#EAF2F8", "#BEDBED", "000000",
    "#893660", "#EF7261", "#68D693", "#A0D7E2", "299CA8",
    "#073A59", "#2D9AA6", "#F2E2DC", "#F23322", "A61B1B",
    "#2A3A48", "#3E6372", "#B2D4DC", "#FAFAFF", "FF6900",
    "#F3BD8D", "#F1A280", "#BE6D6B", "#704A5B", "3E263C",
    "#1C2742", "#3C91C7", "#5A9ABE", "#95C5DE", "E0EEFB",
    "#426261", "#465A59", "#577573", "#739A97", "9AC1C0",
    "#002A4A", "#17607D", "#FFF1CE", "#FF9311", "D64700",
    "#589373", "#BFBD99", "#F2D6B3", "#C2512F", "241E1E",
    "#1F518B", "#1488C8", "#F7E041", "#E2413E", "B5292A",
    "#549494", "#E85649", "#232C2E", "#E6E8D2", "706558",
    "#392133", "#FFECBE", "#D9D098", "#C4AB6D", "AB7D3A",
    "#F0F0F0", "#1C1C1C", "#A2FDF5", "#1CCDC7", "27EDDF",
    "#011526", "#025959", "#027353", "#03A678", "03A696",
    "#004358", "#1F8A70", "#BEDB39", "#FFE11A", "FD7400",
    "#37465D", "#F2F2F2", "#9DC02E", "#779324", "051A37",
    "#580022", "#AA2C30", "#FFBE8D", "#487B80", "011D24",
    "#F9F9F9", "#03A678", "#E9EDEB", "#F44647", "00707F",
    "#800000", "#BF0000", "#E2D6C2", "#F6EDD8", "FFFFFF",
    "#F7F6AF", "#1B2124", "#D62822", "#97D6A6", "468263",
    "#432852", "#992255", "#FF3D4C", "#28656E", "00968F",
    "#444344", "#52BBB2", "#2B344D", "#EE5555", "F8F7EE",
    "#45334A", "#796B7D", "#CCC4B0", "#FFF1B5", "FFA3A3",
    "#5A4B53", "#9C3C58", "#DE2B5B", "#D86A41", "D2A825",
    "#14151C", "#0C242B", "#297059", "#84D66E", "D1FB7A",
    "#272D40", "#364659", "#55736D", "#9DBF8E", "D0D991",
    "#23A38F", "#B7C11E", "#EFF1C2", "#F0563D", "2E313D",
    "#2E064D", "#80176B", "#B356A1", "#59580B", "FFFF00",
    "#CC3333", "#FF9D33", "#F7F7F0", "#3EBBA7", "00747A",
    "#5C4B51", "#8CBEB2", "#F2EBBF", "#F3B562", "BD6060",
    "#0D3E58", "#1C848C", "#19C0C2", "#F3EDD6", "DA6260",
    "#022629", "#2A5945", "#FAFFED", "#E6DCC0", "B3371C",
    "#F4FAC7", "#7BAD8D", "#FFB159", "#F77F45", "C2454E",
    "#A2C1C6", "#86B1B7", "#AECBAD", "#CFDCB0", "D6E1D1",
    "#B0DAFF", "#325B80", "#64B7FF", "#586D80", "5092CC",
    "#0F808C", "#6C8C26", "#F2A71B", "#F26A1B", "D91818",
    "#FFBC6C", "#FE9F6C", "#BD716E", "#74495F", "3B2C4D",
    "#FF4D41", "#F2931F", "#E6CA21", "#91B321", "1E8C65",
    "#302821", "#453629", "#5C4837", "#8A735F", "BDA895",
    "#415457", "#5F7B7F", "#9ACCAF", "#E6EBC4", "F9F7C8",
    "#474143", "#A69E9D", "#E7E2DA", "#FFFFFF", "E7E8E7",
    "#805939", "#BD9962", "#E6CD7D", "#578072", "2D4B4D",
    "#03588C", "#1763A6", "#419CA6", "#54BF83", "8DBF41",
    "#00CCFF", "#A1FCFF", "#040438", "#004878", "C9FAFF",
    "#534C64", "#B7DECF", "#F0F3D7", "#7E858C", "D96557",
    "#7F7364", "#CBB08E", "#CBC1B7", "#789DCB", "646F7F",
    "#5C2849", "#A73E5C", "#EC7263", "#FE9551", "FFD285",
    "#FF0012", "#FF7D00", "#FFD900", "#5BE300", "0084B0",
    "#F24C32", "#F29471", "#FCDFA6", "#36B898", "3D7585",
    "#083157", "#0A6C87", "#459C97", "#92CCA5", "C9F0B1",
    "#DC941B", "#EDC266", "#B6952C", "#E1D3A6", "E9A119",
    "#323836", "#BAD1B5", "#DBE8CF", "#F0F7E8", "FFFEF5",
    "#081724", "#589494", "#8EBBB4", "#D0DCD0", "F5EED2",
    "#50781C", "#9CAD1C", "#EAF7E6", "#40A5DE", "0B5191",
    "#537F79", "#78A68F", "#CBD49C", "#FED457", "CB252A",
    "#F23C13", "#CBAB78", "#FFFFFF", "#898373", "1F1C17",
    "#450003", "#5C0002", "#94090D", "#D40D12", "FFED75",
    "#0770A2", "#82D9F7", "#FEFEFE", "#AEC844", "F36622",
    "#30394F", "#FF434C", "#6ACEEB", "#EDE8DF", "0E6569",
    "#FF6B6B", "#556270", "#C7F464", "#4ECDC4", "EDC8BB",
    "#D9B500", "#FFED9C", "#BFCC85", "#748F74", "454545",
    "#452E32", "#A34B1B", "#B5A187", "#EDDF9A", "A7CC31",
    "#2C2B33", "#596664", "#909980", "#CCC08D", "FF8A00",
    "#C21F1F", "#FFFFFC", "#E34446", "#FFFFDB", "E36D6F",
    "#282828", "#00AAB5", "#C1C923", "#F41C54", "F5F0F0",
    "#3A3F40", "#202627", "#151B1E", "#EFF4FF", "41444D",
    "#DEBB73", "#4D0017", "#010000", "#4D0F30", "9A002F",
    "#EB9328", "#FFA754", "#FFD699", "#FFF5DC", "4FA6B3",
    "#025E73", "#037F8C", "#D9D59A", "#D9BD6A", "590202",
    "#636266", "#E0CEA4", "#E8A579", "#7D6855", "42403E",
    "#FF0000", "#FF4000", "#FF7F00", "#FFBF00", "FFFF00",
    "#FFFFFF", "#74ADA6", "#1E5E6F", "#241B1F", "68A81E",
    "#5A0532", "#FF6745", "#FFC861", "#9DAE64", "27404A",
    "#ACCBBC", "#467847", "#E8E4C1", "#A60303", "730202",
    "#5C4B51", "#8CBEB2", "#F2EBBF", "#F3B562", "F06060",
    "#0D2557", "#93A8C9", "#FFFFFF", "#F5DED5", "558D96",
    "#F53C4A", "#565157", "#10CFC8", "#F2EEE7", "F5D662",
    "#FFD97B", "#E65029", "#A60027", "#660033", "191C26",
    "#595408", "#A6800D", "#A66D03", "#A63F03", "730C02",
    "#2E031F", "#590424", "#8C072B", "#BF0A2B", "DEEFC5",
    "#E0C882", "#A6874E", "#BFA169", "#D9B779", "F2D399",
    "#D88681", "#A67673", "#746566", "#535A5D", "324F54",
    "#FC297D", "#FB607A", "#FDA286", "#FDC188", "FEE78A",
    "#FFECA1", "#B3B27F", "#4C5E52", "#2F3436", "FFBE2C",
    "#D93312", "#B3AB82", "#45735F", "#394D47", "2C3233",
    "#324143", "#6595A3", "#C8E3E8", "#FCFFED", "B6C28B",
    "#477984", "#FEF5EB", "#C03C44", "#EEAA4D", "313E4A",
    "#334D5C", "#45B29D", "#EFC94C", "#E27A3F", "DF4949",
    "#630B11", "#33322F", "#2A2927", "#1E1D1C", "000000",
    "#D94214", "#FFF2C1", "#80A894", "#52736B", "093844",
    "#051E21", "#00302D", "#856434", "#F28C28", "FFAD4E",
    "#D7DADD", "#DDDEE3", "#E1E1E9", "#EDEFF4", "F2F3F8",
    "#BF495E", "#41A693", "#F2EC9B", "#D9CF48", "D9583B",
    "#067072", "#14A589", "#DECFA6", "#BAAE8C", "F94B06",
    "#423A38", "#47B8C8", "#E7EEE2", "#BDB9B1", "D7503E",
    "#730324", "#DFE3E6", "#B4C4D4", "#8BA2BD", "456382",
    "#537374", "#F9BD7F", "#EBD7A5", "#ADC9A5", "5C9E99",
    "#88B59E", "#B6DEC8", "#39464D", "#C04229", "ABD1AB",
    "#11A7FC", "#95D127", "#F2E415", "#FF8638", "EE3551",
    "#212640", "#5D718C", "#4B95A6", "#60BFBF", "EFF2D8",
    "#D8A64D", "#9B5422", "#351411", "#5B0D0D", "991C11",
    "#53324F", "#668D6E", "#F2E0A0", "#F19B7A", "F0756E",
    "#DFE0AF", "#A4BAA2", "#569492", "#41505E", "383245",
    "#7BBADE", "#93DE7F", "#FFED5D", "#F29E4A", "FF7050",
    "#133800", "#1B4F1B", "#398133", "#5C9548", "93E036",
    "#D9D7AD", "#91A685", "#FF6A00", "#37485C", "1C232E",
    "#008767", "#FFB27A", "#FF6145", "#AB2141", "5E1638",
    "#727B7F", "#CCEAEA", "#7A7556", "#2E2125", "44CACC",
    "#FFFFED", "#FF2C38", "#FF9A3A", "#FFF040", "67D9FF",
    "#007148", "#60A859", "#9BDA6A", "#C7F774", "F9FFEF",
    "#092740", "#45698B", "#90B0CC", "#F1FAFF", "8FD36F",
    "#E2FFA0", "#7D8076", "#FAFFED", "#C2CCBE", "8F7D70",
    "#00736A", "#00BC9F", "#F1EEC7", "#FEA301", "F2561A",
    "#26282E", "#AD5138", "#F7F7F7", "#DDDAE0", "8594AE",
    "#1A191F", "#35352F", "#484042", "#4E5252", "E64D38",
    "#49454A", "#E69B02", "#FAF4C6", "#B1D631", "324052",
    "#5F1A2B", "#1D2834", "#6F8B78", "#E4D49E", "C96466",
    "#012D3D", "#38AD9E", "#FFEB9E", "#FF6867", "D0DBED",
    "#0D1F36", "#104954", "#1E9C89", "#38CC85", "60EB7B",
    "#8C4E03", "#9FA66A", "#F2EC94", "#F23005", "8B0F03",
    "#000001", "#20201F", "#E2E2E4", "#590402", "B80000",
    "#344059", "#465973", "#F2D272", "#A69460", "595139",
    "#33454C", "#608F85", "#B6E5CB", "#8BAF95", "54584E",
    "#FBFEF6", "#B7BFA4", "#687F70", "#1A3841", "BF3847",
    "#D7E836", "#86FFC7", "#FFB048", "#E8366C", "593BFF",
    "#34A9FF", "#5982DB", "#665EB8", "#684682", "632E62",
    "#004056", "#2C858D", "#74CEB7", "#C9FFD5", "FFFFCB",
    "#BFB978", "#84945C", "#516967", "#4D3130", "281B24",
    "#103B73", "#20638C", "#3786A6", "#4EABBF", "EBEFF2",
    "#9FB1BF", "#1D2D63", "#1C5357", "#1F6E56", "196331",
    "#FFEBBA", "#C3BD91", "#88947B", "#4C3F3F", "2A2727",
    "#347373", "#4EA6A6", "#91D9D9", "#FFFFFD", "F2E205",
    "#828948", "#EFDFC2", "#006971", "#DC533E", "840000",
    "#000137", "#29003F", "#79003D", "#D04D14", "F89801",
    "#370005", "#4B0005", "#5F0005", "#730005", "870005",
    "#C3AE8D", "#F25260", "#2D5F73", "#6BADC9", "8FCED6",
    "#9E1B36", "#F7EDBA", "#E69B3D", "#EB3355", "3D241D",
    "#1D8281", "#44BF87", "#FBD258", "#F29A3F", "DB634F",
    "#035C75", "#1B808C", "#31A6A8", "#F3F1BC", "F3AD14",
    "#FF7500", "#665130", "#EBB643", "#CEDAA8", "668E84",
    "#384D3A", "#3E6653", "#728053", "#A68357", "D97C71",
    "#012326", "#17455C", "#E1CAAB", "#FE8333", "FA4913",
    "#1A2944", "#2DA7C7", "#56ACBA", "#98C4C9", "CBD5D2",
    "#BF3542", "#CDC5BA", "#EBE3D6", "#3C3C3C", "2E2E2E",
    "#231921", "#695F74", "#BEB4CB", "#EBEBF0", "D2DCEB",
    "#34373F", "#686C75", "#F3E9D0", "#BEB7A7", "8E867C",
    "#661510", "#D9351A", "#F2C76F", "#BF9727", "204D3F",
    "#3CFFEE", "#24AABC", "#356781", "#2C3D51", "1C1F24",
    "#DA3537", "#FFFCC4", "#00585F", "#6A6A61", "2A2C2B",
    "#AE3135", "#D1AF87", "#8C826B", "#3D3C33", "F2F0CE",
    "#FF0894", "#FF5E9F", "#FF91A7", "#FFB5CA", "F5F0BA",
    "#99878D", "#323232", "#646464", "#7E4A5C", "372129",
    "#3FB8AF", "#7FC7AF", "#DAD8A7", "#FFB38B", "FF3F34",
    "#402B3C", "#6AA6A6", "#D9CCA7", "#F2B263", "F26835",
    "#6AA690", "#F2BC1B", "#F2DC99", "#F29057", "BF1F1F",
    "#F4FAC7", "#7BAD8D", "#FFB158", "#F77F45", "C2454E",
    "#E5533C", "#F5E346", "#93D06D", "#50AC6A", "227864",
    "#39588A", "#A9BDD7", "#FFFFFF", "#FFEADD", "FFD0BB",
    "#B0B595", "#615F4F", "#828567", "#91A380", "EAFFCD",
    "#00427F", "#0066BD", "#66B5CC", "#F0E4C5", "D6C28F",
    "#FF6313", "#F9E4B3", "#C29689", "#74474B", "45232E",
    "#00585F", "#009393", "#FFFCC4", "#C7C49B", "EB0A00",
    "#091840", "#44A2FF", "#F7F7EA", "#B3CC63", "4C6620",
    "#5CBBE3", "#FCF1BC", "#5C8182", "#383A47", "B4F257",
    "#9E9E9E", "#E5E1D1", "#E0393D", "#253746", "425563",
    "#4D9453", "#FFFFB1", "#ADDE4E", "#FF9D27", "A62A16",
    "#B70046", "#FF850B", "#FFEBC5", "#109679", "675A4C",
    "#363636", "#0599B0", "#A4BD0A", "#FFA615", "FF2E00",
    "#7D8077", "#BBBFB2", "#FAFFED", "#E82A33", "E3DEBC",
    "#FD9F44", "#FC5C65", "#007269", "#03A679", "FAF0B9",
    "#134B57", "#81A489", "#F1D8B5", "#F2A054", "C04D31",
    "#946E49", "#394042", "#EDDBAC", "#872A0C", "BA8E3A",
    "#404040", "#024959", "#037E8C", "#FFFFFF", "F24C27",
    "#2A3342", "#163C6E", "#4E5F61", "#E6A015", "EDE7BE",
    "#445060", "#829AB5", "#849E91", "#C14543", "D6D5D1",
    "#8A9126", "#B7BF5E", "#FFE9C4", "#F5B776", "F58E45",
    "#9B2D1E", "#3C3A28", "#78A080", "#9BCD9E", "FFFFAE",
    "#FF6138", "#FFFF9D", "#BEEB9F", "#79BD8F", "00A388",
    "#990000", "#FF6600", "#FF9900", "#996633", "CC9966",
    "#DCE6DA", "#B8CCBB", "#98B3A5", "#7A9994", "62858C",
    "#0B1C29", "#3B7C8F", "#73A5A3", "#98C1B7", "F0EBD2",
    "#F6CB51", "#E25942", "#13A89E", "#3F4953", "F2E7DA",
    "#282F36", "#FFFEFC", "#BDA21D", "#BFBC5B", "D2E098",
    "#8C182D", "#DE7140", "#FCB95A", "#FAE285", "6A7349",
    "#6B9100", "#FFE433", "#FF841F", "#E03D19", "A6001C",
    "#FFEAA7", "#D9D697", "#9FC49F", "#718C6A", "543122",
    "#CFF09E", "#A8DBA8", "#79BD9A", "#3B8686", "0B486B",
    "#0C2233", "#065471", "#0A91AB", "#FFC045", "F2F2F2",
    "#BEE8E0", "#373C40", "#2E2621", "#73320B", "FF5E00",
    "#1B2C35", "#A3BFC6", "#FF005D", "#222A30", "293A42",
    "#FF8400", "#3B4044", "#494948", "#E6E1D8", "F7F2E9",
    "#6A482D", "#518C86", "#F6BF3D", "#EF7C27", "BF2424",
    "#261C2B", "#292B39", "#226468", "#608D80", "829D8F",
    "#B2AD9A", "#110E00", "#363226", "#A9A695", "ECE9D8",
    "#1B1B26", "#26394D", "#286480", "#13B3BF", "A3FF57",
    "#F2C2A7", "#F5E5C5", "#593D28", "#422C21", "93DEDB",
    "#001028", "#033140", "#1E5A5B", "#7BA78C", "EBEDC6",
    "#544E6E", "#808CB0", "#ABD1D9", "#D9FFF7", "DDF556",
    "#323A45", "#596677", "#758194", "#FFFFFF", "E74C3C",
    "#45291A", "#AB926D", "#DBD1BC", "#4999C3", "5FCBEC",
    "#6B151D", "#2E1615", "#A8553A", "#DB8F5A", "F2C18E",
    "#000623", "#28475C", "#4A6C74", "#8BA693", "F0E3B1",
    "#60807B", "#81B37A", "#BCCC5F", "#FFEE65", "E64964",
    "#FFFFFA", "#A1A194", "#5B605F", "#464646", "FF6600",
    "#1E1B17", "#577270", "#9C9A79", "#C7BDA1", "580E0C",
    "#452F27", "#5E504A", "#6B6865", "#9BBAB2", "B0FFED",
    "#1B5257", "#F7F6C3", "#F28159", "#CC5850", "4F1C2E",
    "#FAA51B", "#BF511F", "#2C445E", "#2F6D82", "5EE4EB",
    "#BF3952", "#59364A", "#556D73", "#D9D1A9", "D95F5F",
    "#024959", "#037E8C", "#F2EFDC", "#E74C30", "363636",
    "#221A26", "#544759", "#A197A6", "#F27405", "D93D04",
    "#C4A44A", "#E6D399", "#9AB8A9", "#7C8A7F", "4E4B44",
    "#FFFEC8", "#B1BF99", "#5B604D", "#39382B", "26181E",
    "#4E3C51", "#21A68D", "#3BBF9A", "#F2E8B6", "F25749",
    "#102144", "#1B325E", "#254580", "#3C63B0", "5D8AEA",
    "#2A3A48", "#3E6372", "#B2D4DC", "#FAFAFF", "FF4B00",
    "#FFF1BF", "#F20058", "#FFAEAC", "#000001", "7D7A96",
    "#FDFFC6", "#F2F096", "#FF0080", "#DE0049", "521218",
    "#5B0E00", "#FBB500", "#FBD864", "#807D1A", "59233C",
    "#1E1E1F", "#424143", "#67666A", "#807F83", "CBC9CF",
    "#3C3658", "#3EC8B7", "#7CD0B4", "#B9D8B1", "F7E0AE",
    "#FFFFFF", "#99B75F", "#D5DD98", "#EBF4DB", "D8D8D8",
    "#248A8A", "#C9FA58", "#F9E555", "#FAAC38", "F2572A",
    "#086B63", "#77A490", "#E2D8C1", "#BFAE95", "7C7159",
    "#5C4B51", "#8CBEB2", "#F2EBBF", "#A5C88F", "EF847B",
    "#17162F", "#89346D", "#C76058", "#FFB248", "E8C475",
    "#6E8F4A", "#65D9C5", "#F2E7B6", "#EDA430", "AB3E2C",
    "#30394F", "#FF434C", "#6ACEEB", "#EDE8DF", "0E6569",
    "#8E1B13", "#F9E4B3", "#849689", "#46464A", "29232E",
    "#686B30", "#AB9A52", "#E8BA67", "#D68F4F", "BA512E",
    "#E54E45", "#DBC390", "#F2F2EF", "#13A3A5", "403833",
    "#65BA99", "#59A386", "#F1DDBB", "#D6C4A6", "E74C3C",
    "#A6FFBC", "#4ACFAF", "#00A995", "#006161", "003D4C",
    "#33271E", "#8B7653", "#C8D9A0", "#FDEE9D", "233331",
    "#048789", "#503D2E", "#D44D27", "#E2A72E", "EFEBC8",
    "#E5FF1E", "#A9D943", "#75A660", "#698070", "494D4B",
    "#2DEBA2", "#91F57F", "#EBAA69", "#E70049", "2B0027",
    "#990000", "#336699", "#DDDDDD", "#999999", "333333",
    "#F13A4B", "#3D3C3E", "#22BDAF", "#F4F4F4", "D7D7D7",
    "#F53A59", "#001D2D", "#15A88C", "#B7D9C8", "F3F5F4",];

}
};

CABLES.OPS["31d33a1e-9a0a-49f7-8bc8-9e83ab71e23e"]={f:Ops.Color.ColorPalettes,objName:"Ops.Color.ColorPalettes"};




// **************************************************************
// 
// Ops.Gl.ImageCompose.ColorMap_v2
// 
// **************************************************************

Ops.Gl.ImageCompose.ColorMap_v2= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={"colormap_frag":"IN vec2 texCoord;\nUNI sampler2D tex;\nUNI sampler2D gradient;\nUNI float pos;\nUNI float amount;\nUNI float vmin;\nUNI float vmax;\n\n{{CGL.BLENDMODES3}}\n\n\nfloat lumi(vec3 color)\n{\n   return vec3(dot(vec3(0.2126,0.7152,0.0722), color)).r;\n}\n\nvoid main()\n{\n    vec4 base=texture(tex,texCoord);\n    float a=base.a;\n\n    base=clamp(base,vmin,vmax);\n\n    #ifdef METH_LUMI\n        vec4 color=texture(gradient,vec2(lumi(base.rgb),pos));\n    #endif\n\n    #ifdef METH_CHANNELS\n        vec4 color=vec4(1.0);\n        color.r=texture(gradient,vec2(base.r,pos)).r;\n        color.g=texture(gradient,vec2(base.g,pos)).g;\n        color.b=texture(gradient,vec2(base.b,pos)).b;\n    #endif\n\n    base.a=color.a=a;\n\n\n    outColor=cgl_blendPixel(base,color,amount);\n\n}\n",};
let render = op.inTrigger("render");
let trigger = op.outTrigger("trigger");

const blendMode = CGL.TextureEffect.AddBlendSelect(op, "Blend Mode", "normal");
const amount = op.inValueSlider("Amount", 1);

let inGradient = op.inTexture("Gradient");
let inMethod = op.inSwitch("Method", ["Luminance", "Channels"], "Luminance");

let inMin = op.inFloatSlider("Min", 0);
let inMax = op.inFloatSlider("Max", 1);

let inPos = op.inValueSlider("Position", 0.5);

op.setPortGroup("Vertical Position", [inMin, inMax, inPos]);

let cgl = op.patch.cgl;
let shader = new CGL.Shader(cgl, op.name, op);
shader.define("METH_LUMI");

shader.setSource(shader.getDefaultVertexShader(), attachments.colormap_frag);
let textureUniform = new CGL.Uniform(shader, "t", "tex", 0);
let textureUniform2 = new CGL.Uniform(shader, "t", "gradient", 1);
let uniPos = new CGL.Uniform(shader, "f", "pos", inPos);
let uniMin = new CGL.Uniform(shader, "f", "vmin", inMin);
let uniMax = new CGL.Uniform(shader, "f", "vmax", inMax);
let uniAmount = new CGL.Uniform(shader, "f", "amount", amount);

CGL.TextureEffect.setupBlending(op, shader, blendMode, amount);

inMethod.onChange = () =>
{
    shader.toggleDefine("METH_LUMI", inMethod.get() == "Luminance");
    shader.toggleDefine("METH_CHANNELS", inMethod.get() == "Channels");
};

render.onTriggered = function ()
{
    if (!CGL.TextureEffect.checkOpInEffect(op, 3)) return;
    if (!inGradient.get()) return;

    cgl.pushShader(shader);
    cgl.currentTextureEffect.bind();

    cgl.setTexture(0, cgl.currentTextureEffect.getCurrentSourceTexture().tex);

    cgl.setTexture(1, inGradient.get().tex);

    cgl.currentTextureEffect.finish();
    cgl.popShader();

    trigger.trigger();
};

}
};

CABLES.OPS["440c1675-122d-411f-b848-16c60b677120"]={f:Ops.Gl.ImageCompose.ColorMap_v2,objName:"Ops.Gl.ImageCompose.ColorMap_v2"};




// **************************************************************
// 
// Ops.Gl.ImageCompose.ColorBalance_v2
// 
// **************************************************************

Ops.Gl.ImageCompose.ColorBalance_v2= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={"colorbalance_frag":"IN vec2 texCoord;\nUNI sampler2D tex;\nUNI float r;\nUNI float g;\nUNI float b;\n\nfloat lumi(vec3 color)\n{\n    return vec3(dot(vec3(0.2126,0.7152,0.0722), color)).r;\n}\n\nvoid main()\n{\n    vec4 base=texture(tex,texCoord);\n    float l=lumi(base.rgb);\n\n    #ifdef TONE_MID\n        l=smoothstep(0.33,0.66,l);\n    #endif\n\n    #ifdef TONE_LOW\n        l=1.0-l;\n    #endif\n\n    l=l*l;\n    vec3 color=base.rgb+vec3(l*r*0.1,l*g*0.1,l*b*0.1);\n    outColor= vec4(color,base.a);\n}\n",};
const
    render = op.inTrigger("render"),
    trigger = op.outTrigger("trigger"),
    tone = op.inValueSelect("Tone", ["Highlights", "Midtones", "Shadows"], "Highlights"),
    r = op.inValue("r"),
    g = op.inValue("g"),
    b = op.inValue("b");

const cgl = op.patch.cgl;
const shader = new CGL.Shader(cgl, op.name, op);

shader.setSource(shader.getDefaultVertexShader(), attachments.colorbalance_frag);
const
    textureUniform = new CGL.Uniform(shader, "t", "tex", 0),
    uniR = new CGL.Uniform(shader, "f", "r", r),
    uniG = new CGL.Uniform(shader, "f", "g", g),
    uniB = new CGL.Uniform(shader, "f", "b", b);

tone.onChange = function ()
{
    shader.toggleDefine("TONE_HIGH", tone.get() == "Highlights");
    shader.toggleDefine("TONE_MID", tone.get() == "Midtones");
    shader.toggleDefine("TONE_LOW", tone.get() == "Shadows");
};

render.onTriggered = function ()
{
    if (!CGL.TextureEffect.checkOpInEffect(op, 3)) return;

    cgl.pushShader(shader);
    cgl.currentTextureEffect.bind();

    cgl.setTexture(0, cgl.currentTextureEffect.getCurrentSourceTexture().tex);

    cgl.currentTextureEffect.finish();
    cgl.popShader();

    trigger.trigger();
};

}
};

CABLES.OPS["5af81475-2aa6-451b-a1f3-0980f641a72e"]={f:Ops.Gl.ImageCompose.ColorBalance_v2,objName:"Ops.Gl.ImageCompose.ColorBalance_v2"};




// **************************************************************
// 
// Ops.Array.PaletteLibrary
// 
// **************************************************************

Ops.Array.PaletteLibrary= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
const outArrayPalette = op.outArray("Palette Array out");

const colors=[
'#E6E2AF','#A7A37E','#EFECCA','#046380','002F2F',
'#468966','#FFF0A5','#FFB03B','#B64926','8E2800',
'#FCFFF5','#D1DBBD','#91AA9D','#3E606F','193441',
'#FF6138','#FFFF9D','#BEEB9F','#79BD8F','00A388',
'#105B63','#FFFAD5','#FFD34E','#DB9E36','BD4932',
'#225378','#1695A3','#ACF0F2','#F3FFE2','EB7F00',
'#2C3E50','#E74C3C','#ECF0F1','#3498DB','2980B9',
'#000000','#263248','#7E8AA2','#FFFFFF','FF9800',
'#004358','#1F8A70','#BEDB39','#FFE11A','FD7400',
'#DC3522','#D9CB9E','#374140','#2A2C2B','1E1E20',
'#7D8A2E','#C9D787','#FFFFFF','#FFC0A9','FF8598',
'#B9121B','#4C1B1B','#F6E497','#FCFAE1','BD8D46',
'#2E0927','#D90000','#FF2D00','#FF8C00','04756F',
'#595241','#B8AE9C','#FFFFFF','#ACCFCC','8A0917',
'#10222B','#95AB63','#BDD684','#E2F0D6','F6FFE0',
'#F6F792','#333745','#77C4D3','#DAEDE2','EA2E49',
'#703030','#2F343B','#7E827A','#E3CDA4','C77966',
'#2F2933','#01A2A6','#29D9C2','#BDF271','FFFFA6',
'#D8CAA8','#5C832F','#284907','#382513','363942',
'#FFF8E3','#CCCC9F','#33332D','#9FB4CC','DB4105',
'#85DB18','#CDE855','#F5F6D4','#A7C520','493F0B',
'#04BFBF','#CAFCD8','#F7E967','#A9CF54','588F27',
'#292929','#5B7876','#8F9E8B','#F2E6B6','412A22',
'#332532','#644D52','#F77A52','#FF974F','A49A87',
'#405952','#9C9B7A','#FFD393','#FF974F','F54F29',
'#2B3A42','#3F5765','#BDD4DE','#EFEFEF','FF530D',
'#962D3E','#343642','#979C9C','#F2EBC7','348899',
'#96CA2D','#B5E655','#EDF7F2','#4BB5C1','7FC6BC',
'#1C1D21','#31353D','#445878','#92CDCF','EEEFF7',
'#3E454C','#2185C5','#7ECEFD','#FFF6E5','FF7F66',
'#00585F','#009393','#FFFCC4','#F0EDBB','FF3800',
'#B4AF91','#787746','#40411E','#32331D','C03000',
'#63A69F','#F2E1AC','#F2836B','#F2594B','CD2C24',
'#88A825','#35203B','#911146','#CF4A30','ED8C2B',
'#F2385A','#F5A503','#E9F1DF','#4AD9D9','36B1BF',
'#CFC291','#FFF6C5','#A1E8D9','#FF712C','695D46',
'#FF5335','#B39C85','#306E73','#3B424D','1D181F',
'#000000','#333333','#FF358B','#01B0F0','AEEE00',
'#E8E595','#D0A825','#40627C','#26393D','FFFAE4',
'#E7E8D1','#D3CEAA','#FBF7E4','#424242','8E001C',
'#354242','#ACEBAE','#FFFF9D','#C9DE55','7D9100',
'#2F2933','#01A2A6','#29D9C2','#BDF271','FFFFA6',
'#DDDCC5','#958976','#611427','#1D2326','6A6A61',
'#6C6E58','#3E423A','#417378','#A4CFBE','F4F7D9',
'#E1E6FA','#C4D7ED','#ABC8E2','#375D81','183152',
'#6B0C22','#D9042B','#F4CB89','#588C8C','011C26',
'#304269','#91BED4','#D9E8F5','#FFFFFF','F26101',
'#96CEB4','#FFEEAD','#FF6F69','#FFCC5C','AAD8B0',
'#B0CC99','#677E52','#B7CA79','#F6E8B1','89725B',
'#334D5C','#45B29D','#EFC94C','#E27A3F','DF5A49',
'#16193B','#35478C','#4E7AC7','#7FB2F0','ADD5F7',
'#00261C','#044D29','#168039','#45BF55','96ED89',
'#36362C','#5D917D','#A8AD80','#E6D4A7','825534',
'#F9E4AD','#E6B098','#CC4452','#723147','31152B',
'#2C3E50','#FC4349','#D7DADB','#6DBCDB','FFFFFF',
'#002635','#013440','#AB1A25','#D97925','EFE7BE',
'#FF8000','#FFD933','#CCCC52','#8FB359','192B33',
'#272F32','#9DBDC6','#FFFFFF','#FF3D2E','DAEAEF',
'#B8ECD7','#083643','#B1E001','#CEF09D','476C5E',
'#002F32','#42826C','#A5C77F','#FFC861','C84663',
'#5C4B51','#8CBEB2','#F2EBBF','#F3B562','F06060',
'#5A1F00','#D1570D','#FDE792','#477725','A9CC66',
'#5E0042','#2C2233','#005869','#00856A','8DB500',
'#52656B','#FF3B77','#CDFF00','#FFFFFF','B8B89F',
'#801637','#047878','#FFB733','#F57336','C22121',
'#730046','#BFBB11','#FFC200','#E88801','C93C00',
'#24221F','#363F45','#4B5F6D','#5E7C88','FEB41C',
'#E64661','#FFA644','#998A2F','#2C594F','002D40',
'#C24704','#D9CC3C','#FFEB79','#A0E0A9','00ADA7',
'#484A47','#C1CE96','#ECEBF0','#687D77','353129',
'#588C7E','#F2E394','#F2AE72','#D96459','8C4646',
'#BAB293','#A39770','#EFE4BD','#A32500','2B2922',
'#6A7059','#FDEEA7','#9BCC93','#1A9481','003D5C',
'#174C4F','#207178','#FF9666','#FFE184','F5E9BE',
'#D5FBFF','#9FBCBF','#647678','#2F3738','59D8E6',
'#DB5800','#FF9000','#F0C600','#8EA106','59631E',
'#450003','#5C0002','#94090D','#D40D12','FF1D23',
'#211426','#413659','#656F8C','#9BBFAB','F2EFDF',
'#EA6045','#F8CA4D','#F5E5C0','#3F5666','2F3440',
'#F2F2F2','#C6E070','#91C46C','#287D7D','1C344D',
'#334D5C','#45B29D','#EFC94C','#E27A3F','DF5A49',
'#705B35','#C7B07B','#E8D9AC','#FFF6D9','570026',
'#F7F2B2','#ADCF4F','#84815B','#4A1A2C','8E3557',
'#1A1F2B','#30395C','#4A6491','#85A5CC','D0E4F2',
'#25064D','#36175E','#553285','#7B52AB','9768D1',
'#004056','#2C858D','#74CEB7','#C9FFD5','FFFFCB',
'#CFCA4C','#FCF5BF','#9FE5C2','#5EB299','745A33',
'#776045','#A8C545','#DFD3B6','#FFFFFF','0092B2',
'#CC3910','#F1F2C0','#CCC59E','#8FA68E','332F29',
'#FF6600','#C13B00','#5E6D70','#424E4F','1B1D1E',
'#690011','#BF0426','#CC2738','#F2D99C','E5B96F',
'#1B1D26','#425955','#778C7A','#F1F2D8','BFBD9F',
'#F6B1C3','#F0788C','#DE264C','#BC0D35','A20D1E',
'#597533','#332F28','#61B594','#E6DEA5','C44E18',
'#3FB8AF','#7FC7AF','#DAD8A7','#FF9E9D','FF3D7F',
'#0F2D40','#194759','#296B73','#3E8C84','D8F2F0',
'#42282F','#74A588','#D6CCAD','#DC9C76','D6655A',
'#002A4A','#17607D','#FFF1CE','#FF9311','D64700',
'#003056','#04518C','#00A1D9','#47D9BF','F2D03B',
'#13140F','#D4FF00','#E4FFE6','#68776C','00D6DD',
'#FCFAD0','#A1A194','#5B605F','#464646','A90641',
'#289976','#67CC8E','#B1FF91','#FFE877','FF5600',
'#302B1D','#3F522B','#737D26','#A99E46','D9CB84',
'#56626B','#6C9380','#C0CA55','#F07C6C','AD5472',
'#32450C','#717400','#DC8505','#EC5519','BE2805',
'#C7B773','#E3DB9A','#F5FCD0','#B1C2B3','778691',
'#E83A25','#FFE9A3','#98CC96','#004563','191B28',
'#3399CC','#67B8DE','#91C9E8','#B4DCED','E8F8FF',
'#1A212C','#1D7872','#71B095','#DEDBA7','D13F32',
'#7D2A35','#CC9258','#917A56','#B4BA6C','FEFFC2',
'#E7E9D1','#D3D4AA','#FCFAE6','#444444','901808',
'#FFFFFF','#AEAEAE','#E64C66','#2D3E50','1BBC9B',
'#E0FFB3','#61C791','#31797D','#2A2F36','F23C55',
'#EB5937','#1C1919','#403D3C','#456F74','D3CBBD',
'#E6DD00','#8CB302','#008C74','#004C66','332B40',
'#14A697','#F2C12E','#F29D35','#F27649','F25252',
'#261822','#40152A','#731630','#CC1E2C','FF5434',
'#261F27','#FEE169','#CDD452','#F9722E','C9313D',
'#5C4B51','#8CBEB2','#F2EBBF','#F3B562','F06060',
'#2F3837','#C5C7B6','#FFF8D3','#4C493E','222028',
'#E3CBAC','#9C9985','#C46D3B','#788880','324654',
'#3F0B1B','#7A1631','#CF423C','#FC7D49','FFD462',
'#14212B','#293845','#4F6373','#8F8164','D9D7AC',
'#98A89E','#BAC0AC','#FAFAC6','#FF4411','D40015',
'#FEFFFF','#3C3F36','#9FB03E','#EBE9DC','72918B',
'#CC6B32','#FFAB48','#FFE7AD','#A7C9AE','888A63',
'#262526','#404040','#8C8979','#F2F2F2','F60A20',
'#00305A','#004B8D','#0074D9','#4192D9','7ABAF2',
'#0C273D','#54D0ED','#FFFEF1','#70B85D','2C5E2E',
'#4C1B33','#EFE672','#98A942','#2D6960','141D14',
'#2F3540','#666A73','#F2EDE4','#D9D1C7','8C8681',
'#0D1F30','#3B6670','#8BADA3','#F0E3C0','DB6C0F',
'#FFBC67','#DA727E','#AC6C82','#685C79','455C7B',
'#092140','#024959','#F2C777','#F24738','BF2A2A',
'#133463','#365FB7','#799AE0','#F4EFDC','BA9B65',
'#C4D4CB','#55665E','#30282A','#542733','E84167',
'#CDDEC6','#4DAAAB','#1E4F6A','#2A423C','93A189',
'#EF5411','#FA5B0F','#FF6517','#FF6D1F','FF822E',
'#41434A','#6E9489','#DEDCC3','#F2F1E9','877963',
'#292929','#2BBFBD','#F2B33D','#F29B30','F22E2E',
'#F2385A','#F5A503','#E9F1DF','#56D9CD','3AA1BF',
'#D5F8B4','#A6E3A8','#8A9A85','#7E566B','422335',
'#3CBAC8','#93EDD4','#F3F5C4','#F9CB8F','F19181',
'#979926','#38CCB5','#EEFF8E','#FFD767','CC2A09',
'#404040','#024959','#037E8C','#F2EFDC','F24C27',
'#94B34D','#D3FF82','#363D52','#121D2B','111B1C',
'#282E33','#25373A','#164852','#495E67','FF3838',
'#313732','#8AA8B0','#DEDEDE','#FFFFFF','F26101',
'#FFFFFF','#E5E1D1','#52616D','#2C343B','C44741',
'#FFF6B8','#ABCCA7','#403529','#7A5E2F','A68236',
'#4F1025','#C5003E','#D9FF5B','#78AA00','15362D',
'#49404F','#596166','#D1FFCD','#A9BD8B','948A54',
'#FF2151','#FF7729','#FFAD29','#FFEBCA','1AB58A',
'#73603D','#BF8A49','#F2CA80','#5E5A59','0D0D0D',
'#3D4C53','#70B7BA','#F1433F','#E7E1D4','FFFFFF',
'#006D8D','#008A6E','#549E39','#8AB833','C0CF3A',
'#BDDFB3','#2BAA9C','#2F2E2E','#0F2625','465F3F',
'#F2F2F2','#BF0404','#8C0303','#590202','400101',
'#76A19A','#272123','#A68D60','#B0C5BB','D9593D',
'#0E3D59','#88A61B','#F29F05','#F25C05','D92525',
'#C1E1ED','#76C7C6','#273D3B','#131A19','E35C14',
'#2D112C','#530031','#820233','#CA293E','EF4339',
'#AF7575','#EFD8A1','#BCD693','#AFD7DB','3D9CA8',
'#D74B4B','#DCDDD8','#475F77','#354B5E','FFFFFF',
'#FFF6C9','#C8E8C7','#A4DEAB','#85CC9F','499E8D',
'#229396','#8BA88F','#C7C5A7','#F0DFD0','F23C3C',
'#57385C','#A75265','#EC7263','#FEBE7E','FFEDBC',
'#96526B','#D17869','#EBAD60','#F5CF66','8BAB8D',
'#0D1C33','#17373C','#2B6832','#4F9300','A1D700',
'#1B2B32','#37646F','#A3ABAF','#E1E7E8','B22E2F',
'#C5D9B2','#53A194','#572C2C','#3D2324','695A3B',
'#425957','#81AC8B','#F2E5A2','#F89883','D96666',
'#002E40','#2A5769','#FFFFFF','#FABD4A','FA9600',
'#FFFEFC','#E2E3DF','#515B5E','#2E3233','CAF200',
'#FFF0A3','#B8CC6E','#4B6000','#E4F8FF','004460',
'#3B596A','#427676','#3F9A82','#A1CD73','ECDB60',
'#F2E6CE','#8AB39F','#606362','#593325','1D1D1F',
'#212B40','#C2E078','#FFFFFF','#BADCDD','547B97',
'#0B3C4D','#0E5066','#136480','#127899','1A8BB3',
'#222130','#464D57','#D4E8D3','#FFFCFB','ED8917',
'#B33600','#FF8A00','#FFC887','#CC5400','B31E00',
'#012530','#28544B','#ACBD86','#FFD6A0','FF302C',
'#2E95A3','#50B8B4','#C6FFFA','#E2FFA8','D6E055',
'#112F41','#068587','#4FB99F','#F2B134','ED553B',
'#202B30','#4E7178','#4FA9B8','#74C0CF','F1F7E2',
'#302B2F','#696153','#FFA600','#9BB58F','FFD596',
'#458C6B','#F2D8A7','#D9A86C','#D94436','A62424',
'#22475E','#75B08A','#F0E797','#FF9D84','FF5460',
'#FFAA5C','#DA727E','#AC6C82','#685C79','455C7B',
'#686E75','#9BAAC1','#82787B','#E4F1DB','AAC19B',
'#F0C755','#E2AD3B','#BF5C00','#901811','5C110F',
'#FFFBDC','#BFBCA5','#7F7D6E','#3F3E37','E5E2C6',
'#BEBEBE','#F1E4D8','#594735','#94C7BA','D8F1E4',
'#1B1E26','#F2EFBD','#B6D051','#70A99A','2F6D7A',
'#F7E4A2','#A7BD5B','#DC574E','#8DC7B8','ED9355',
'#70E8CB','#FFE9C7','#FF5B5B','#545454','2D2D2F',
'#17111A','#321433','#660C47','#B33467','CCBB51',
'#2B2E2E','#595855','#A2ABA5','#CAE6E8','313F54',
'#023B47','#295E52','#F2E085','#FCAB55','EE7F38',
'#302C29','#D1D1BC','#A7C4BB','#6C8C84','466964',
'#212629','#067778','#49B8A8','#85EDB6','D9E5CD',
'#334D5C','#45B29D','#EFC94C','#E27A3F','DF4949',
'#2C3E50','#FC4349','#6DBCDB','#D7DADB','FFFFFF',
'#35262D','#FFFBFF','#E8ECED','#A4B7BB','76A0B0',
'#61E8D2','#FCEEB9','#302F25','#704623','BBE687',
'#E1E6B9','#C4D7A4','#ABC8A4','#375D3B','183128',
'#C98B2F','#803C27','#C56520','#E1B41B','807916',
'#A3D9B0','#93BF9E','#F2F0D5','#8C8474','40362E',
'#524656','#CF4747','#EA7A58','#E4DCCB','A6C4BC',
'#5C2849','#A73E5C','#EC4863','#FFDA66','1FCECB',
'#0EEAFF','#15A9FA','#1B76FF','#1C3FFD','2C1DFF',
'#010000','#393845','#9B96A3','#5C0009','940315',
'#468071','#FFE87A','#FFCA53','#FF893B','E62738',
'#404040','#024959','#037E8C','#F2EFDC','F24C27',
'#FF765E','#C2AE8B','#FCCF65','#FFE5C6','B7BDC4',
'#003647','#00717D','#F2D8A7','#A4A66A','515932',
'#FAFAC0','#C4BE90','#8C644C','#594D37','293033',
'#2B3A42','#3F5765','#BDD4DE','#EFEFEF','E74C3C',
'#3B3B3B','#A8877E','#FFA49D','#FF7474','FF476C',
'#0A3A4A','#196674','#33A6B2','#9AC836','D0E64B',
'#FFA340','#38001C','#571133','#017A74','00C2BA',
'#DCEBDD','#A0D5D6','#789AA1','#304345','AD9A27',
'#588C7E','#F2E394','#F2AE72','#D96459','8C4646',
'#F0E6B1','#B5D6AA','#99A37A','#70584B','3D3536',
'#2F400D','#8CBF26','#A8CA65','#E8E5B0','419184',
'#010712','#13171F','#1C1F26','#24262D','961227',
'#403F33','#6E755F','#AFC2AA','#FFDEA1','E64C10',
'#C74029','#FAE8CD','#128085','#385052','F0AD44',
'#CFF09E','#A8DBA8','#79BD9A','#3B8686','0B486B',
'#E0401C','#E6B051','#272F30','#F7EDB7','9E2B20',
'#FFE2C5','#FFEEDD','#FFDDAA','#FFC484','FFDD99',
'#FFFFE4','#F2E5BD','#B9BF8E','#A69F7C','8C6865',
'#5C8A2D','#AFD687','#FFFFFF','#00C3A9','008798',
'#4F3130','#FF1F3D','#5BE3E3','#FDFFF1','8B9698',
'#D23600','#D95100','#DE6D00','#EE8900','FCA600',
'#FFFFFA','#A1A194','#5B605F','#464646','FF6600',
'#F34A53','#FAE3B4','#AAC789','#437356','1E4147',
'#2A7A8C','#176273','#063540','#E6D9CF','403D3A',
'#21455B','#567D8C','#A59E8C','#8C8372','F2F2F2',
'#012340','#026873','#83A603','#BBBF45','F2F0CE',
'#FDFF98','#A7DB9E','#211426','#6B073B','DA8C25',
'#002F36','#142426','#D1B748','#EDDB43','FFFD84',
'#420000','#600000','#790000','#931111','BF1616',
'#3C989E','#5DB5A4','#F4CDA5','#F57A82','ED5276',
'#23A38F','#B7C11E','#EFF1C2','#F0563D','2E313D',
'#F5ECD9','#2BACB5','#B4CCB9','#E84D5B','3B3B3B',
'#A5EB3C','#60C21E','#159E31','#53DB50','C5FFCB',
'#263138','#406155','#7C9C71','#DBC297','FF5755',
'#0A111F','#263248','#7E8AA2','#E3E3E3','C73226',
'#003B59','#00996D','#A5D900','#F2E926','FF930E',
'#00A19A','#04BF9D','#F2E85C','#F53D54','404040',
'#324152','#47535E','#796466','#C1836A','DEA677',
'#036F73','#84CDC2','#FEF2D8','#F18C79','EF504F',
'#174040','#888C65','#D9CA9C','#D98162','A65858',
'#56797F','#87A0A4','#FCFBDC','#F2DDB6','A6937C',
'#A8BAA9','#FFF5CF','#DBCDAD','#B39C7D','806854',
'#60655F','#AB9675','#FFE0C9','#D4CCBA','CF8442',
'#BDDFB3','#009D57','#2C372E','#0F2925','465F3F',
'#3E3947','#735360','#D68684','#F1B0B0','EBD0C4',
'#0A7B83','#2AA876','#FFD265','#F19C65','CE4D45',
'#FFFFFF','#F4921E','#858585','#C5D2DB','3E6B85',
'#11151E','#212426','#727564','#B9AA81','690C07',
'#000000','#910000','#CBB370','#FFFBF1','21786C',
'#F78F00','#C43911','#75003C','#37154A','0F2459',
'#003354','#91BED4','#D9E8F5','#FFFFFF','F26101',
'#3DA8A4','#7ACCBE','#FFFFF7','#FF99A1','FF5879',
'#64C733','#F0F0F0','#3E879E','#57524D','36302B',
'#343844','#2AB69D','#E65848','#FDC536','FCF2D7',
'#E34517','#F5FF53','#B4E85E','#00BD72','0B4239',
'#A84B3A','#FF9F67','#233138','#FFF7F5','4C646B',
'#59535E','#FAEEFF','#F1BAF3','#5D4970','372049',
'#FF6F22','#D9984F','#FFE8A9','#3E4237','32948A',
'#5D7370','#7FA6A1','#B8D9B8','#D6EDBD','FFF5BC',
'#FFBE00','#FFDC00','#FFD10F','#FFDE20','E8CA00',
'#003840','#005A5B','#007369','#008C72','02A676',
'#E1E6FA','#C4D7ED','#ABC8E2','#375D81','183152',
'#BA2F1D','#FFF8A4','#F5E67F','#264A59','1E2C30',
'#222526','#FFBB6E','#F28D00','#D94F00','80203B',
'#EBD096','#D1B882','#5D8A66','#1A6566','21445B',
'#F00807','#5F6273','#A4ABBF','#CCC9D1','E2E1E9',
'#DFE0AF','#A4BAA2','#569492','#41505E','383245',
'#152737','#2B4E69','#799AA5','#FFFFF0','682321',
'#C44C51','#FFB6B8','#FFEFB6','#A2B5BF','5F8CA3',
'#5ADED4','#4DAAAB','#26596A','#163342','6C98A1',
'#FF5B2B','#B1221C','#34393E','#8CC6D7','FFDA8C',
'#3D4D4D','#99992E','#E6E666','#F2FFBF','800033',
'#242424','#437346','#97D95C','#D9FF77','E9EB9B',
'#FFEBB0','#FFB05A','#F84322','#C33A1A','9F3818',
'#4D2B2F','#E57152','#E8DE67','#FFEFC3','C0CCAB',
'#A82221','#DB5E31','#EDA23E','#F2CB67','BFB840',
'#3B3140','#BFB8A3','#F2E0C9','#F2B9AC','D97E7E',
'#43464D','#9197A6','#D3DCF2','#7690CF','48577D',
'#EFDFBB','#9EBEA6','#335D6A','#D64F2A','7A8A7F',
'#000001','#313634','#C7CECF','#5C0402','941515',
'#334D5C','#45B29D','#EFC94C','#E27A3F','DF5A49',
'#F5F4E1','#D6C9B5','#B4AA97','#D44917','82877A',
'#19162B','#1C425C','#6ABDC4','#F0E4C5','D6C28F',
'#00132B','#7F9DB0','#C5E2ED','#FFFFFF','F95900',
'#1F3642','#6D968D','#B6CCB8','#FFE2B3','56493F',
'#08A689','#82BF56','#C7D93D','#E9F2A0','F2F2F2',
'#DE3961','#A4E670','#FFFFDC','#B3EECC','00ADA7',
'#849972','#D9D094','#A6A23E','#4F2F1D','8F5145',
'#F41C54','#FF9F00','#FBD506','#A8BF12','00AAB5',
'#00585F','#009393','#F5F3DC','#454445','FF5828',
'#FF6138','#FFFF9D','#BEEB9F','#79BD8F','00A388',
'#140B04','#332312','#B59D75','#E3D2B4','FFF7EA',
'#ED3B3B','#171F26','#77B59C','#F2E7B1','635656',
'#46594B','#A6977C','#D9B384','#734F30','260B01',
'#CCB8A3','#FF8FB1','#FFF5EA','#4E382F','B29882',
'#B70000','#FFFFFF','#FFCA3D','#94C4F4','0092B3',
'#053B44','#06736C','#A53539','#B9543C','EAD075',
'#E8C1B9','#FFB3AB','#FFCAB8','#E8B69C','FFCEAB',
'#E7F2DF','#69043B','#59023B','#231E2D','161726',
'#E82B1E','#E5DEAF','#A0B688','#557A66','453625',
'#F1E6D4','#BA3D49','#791F33','#9F9694','E3E1DC',
'#CED59F','#F1EDC0','#B1BEA4','#647168','282828',
'#2C3E50','#E74C3C','#ECF0F1','#3498DB','646464',
'#DE7047','#FFDE8D','#FFFFFF','#CDDE47','528540',
'#8EAB99','#40232B','#D95829','#D97338','DEC085',
'#E9662C','#EBAF3C','#00AC65','#068894','2B2B2B',
'#46483C','#A0AA8F','#EBE3CB','#FFFFFF','F26101',
'#170F0E','#290418','#505217','#FFD372','FFF1AF',
'#263545','#C4273C','#D7DADB','#6DBCDB','FFFFFF',
'#DCFAC0','#B1E1AE','#85C79C','#56AE8B','00968B',
'#075807','#097609','#70AF1A','#B9D40B','E5EB0B',
'#521000','#712800','#744E1D','#879666','F1D98C',
'#261F26','#3F3B40','#6C7367','#BFBF8A','F2E086',
'#2C3E50','#FC4349','#D7DADB','#6DBCDB','FFFFFF',
'#506D7D','#94CCB9','#FFECA7','#FFB170','F07D65',
'#3F4036','#8DA681','#F2E1C2','#BF2806','8C1D04',
'#990700','#CC542E','#FF964F','#FFCB7C','787730',
'#195073','#7F8C1F','#EE913F','#F2E5BD','9FD7C7',
'#1B3E59','#F2F0F0','#FFAC00','#BF0404','730202',
'#EA6045','#F8CA4D','#F5E5C0','#3F5666','2F3440',
'#F95759','#FDA099','#FFFFFF','#D9F3CB','8AC2B0',
'#265573','#386D73','#81A68A','#9FBF8F','D4D9B0',
'#E1DA36','#FFEA1B','#6FE4DA','#1DB0BC','007BBC',
'#013859','#185E65','#F9CC7F','#F15C25','9E1617',
'#36CC7C','#D6FFBE','#94D794','#228765','77A668',
'#94201F','#D4421F','#478A80','#D9E061','F08835',
'#F16233','#00B5B5','#F0F0F0','#3E4651','5C6D7E',
'#2E806C','#76CC99','#E0FFED','#FF5F3A','D2413C',
'#00393B','#00766C','#44A18E','#E5EDB6','F6695B',
'#734854','#F2F2E9','#D9D7C5','#A69580','736766',
'#03497E','#0596D5','#9DEBFC','#8D7754','FEB228',
'#F0E14C','#FFBB20','#FA7B12','#E85305','59CC0D',
'#FE4365','#FC9D9A','#F9CDAD','#C8C8A9','83AF9B',
'#00557C','#186D94','#3488AD','#81C1DC','BBE5F3',
'#DEE8D7','#918773','#420A1A','#240001','4D493A',
'#FFFFFF','#CAC535','#97AF25','#158471','41342C',
'#041F3D','#0B2E41','#165751','#448C61','9AC16D',
'#FA8C01','#FF6405','#577700','#082400','A0A600',
'#78C0F9','#FFDDCE','#FFFFFF','#FFDBE6','FE86A4',
'#351330','#CC2A41','#E7CAA4','#759A8A','524549',
'#02151A','#043A47','#087891','#C8C8C8','B31D14',
'#F34A53','#FAE3B4','#AAC789','#437356','1E4147',
'#58838C','#DAD7C7','#BF996B','#BF5841','A61C1C',
'#556354','#E68F0D','#8C948A','#495450','42423F',
'#323640','#5B6470','#8C94A1','#BDC7D6','DFE2FF',
'#FF0000','#FF950B','#2FA88C','#DEEB00','4B2C04',
'#0F3D48','#174C5B','#366774','#ECECE7','E96151',
'#3DBB7E','#A3CD39','#FBAC1D','#F96C1E','EE4036',
'#23363B','#A44F3F','#F8983D','#8D9151','BBC946',
'#4B5657','#969481','#D2C9B0','#F4E3C1','B6B835',
'#E8980C','#B1F543','#F2FF00','#FF5E00','59BBAB',
'#849696','#FEFFFB','#232D33','#17384D','FF972C',
'#555555','#7BB38E','#F4F1D7','#F8AB65','F15C4C',
'#1D3C42','#67BFAD','#F2EC99','#F2C48D','F25050',
'#334D5C','#45B29D','#EFC94C','#E27A3F','DF4949',
'#B8E1F2','#249AA7','#ABD25E','#F8C830','F1594A',
'#FDEDD0','#BCF1ED','#FF634D','#FD795B','FFF0AA',
'#FFFFFF','#E5E1D1','#52616D','#2C343B','C44741',
'#FFFFF1','#D5FF9B','#8FB87F','#5A7B6C','374E5A',
'#010340','#0E1E8C','#0003C7','#1510F0','1441F7',
'#002A4A','#17607D','#FFF1CE','#FF9311','E33200',
'#871E31','#CCC097','#9E9D7B','#687061','262626',
'#F16663','#F48D6C','#F2E07B','#8ABE9B','4A6D8B',
'#001F11','#204709','#0C8558','#FFD96A','FF4533',
'#1D1626','#F2E0BD','#BFAA8F','#8C786C','594C4C',
'#685D47','#913420','#1E2729','#C1D9C5','FEEFB1',
'#1D7561','#FC8448','#FF4138','#A8282B','38141B',
'#BF0633','#FF484E','#FF9273','#D1D0B4','E5ECED',
'#8E9E63','#E6DBB0','#F5EED7','#C4BCA0','176573',
'#665446','#809994','#AECCB6','#DEF2C4','E6683F',
'#3D0D26','#660A3E','#891C56','#B0276F','C93482',
'#082136','#00294D','#004B8D','#0068C4','2998FF',
'#3C4631','#9A746F','#F8A2AB','#F1C6B3','EAE9C0',
'#FF534E','#FFD7AC','#BED194','#499989','176785',
'#006D80','#BDA44D','#3C2000','#84CECC','78A419',
'#352C2B','#3C555C','#9E9657','#FFEBCD','CD5510',
'#2C3E50','#FC4349','#6DBCDB','#D7DADB','FFFFFF',
'#523631','#D1BE91','#605E3A','#4D462F','592F39',
'#18293B','#5B5A56','#F2DEA0','#D0B580','FFFBFF',
'#C8DBB6','#ECEBB7','#CCC68A','#B8B165','827A5D ',
'#7DA88C','#EBE9A0','#BED24B','#859132','35323C',
'#E8574C','#F27B29','#E6A51B','#D9CC3C','399977',
'#324032','#B7C22C','#FFFFE1','#22A8B5','2A3F42',
'#B3A589','#FFB896','#FFF9B1','#9AB385','11929E',
'#272433','#343F4F','#3D6066','#77994D','B2D249',
'#250701','#6D4320','#B0925F','#E7DEC0','82ABB8',
'#023550','#028A9E','#04BFBF','#EFEFEF','FF530D',
'#594732','#40342A','#7A422E','#D4CA9A','EDE5AE',
'#013C4D','#BA5B22','#DB913C','#F0B650','FAD46B',
'#143840','#5C6B63','#A69E89','#E0C297','D96523',
'#3FB8AF','#7FC7AF','#DAD8A7','#FFB38B','FF3F34',
'#CA3995','#F58220','#FFDF05','#BED73D','61BC46',
'#FFE1D0','#FFBFB4','#FF837E','#FF4242','BF1616',
'#C4EEFF','#7BA32D','#094201','#A41717','C48726',
'#001325','#187072','#90BD90','#D7D8A2','F2E4C2',
'#1A4F63','#068587','#6FB07F','#FCB03C','FC5B3F',
'#97B350','#333230','#736D61','#BAAB90','FFE5BA',
'#403D33','#807966','#CCC2A3','#8C0000','590000',
'#5F8A42','#86AD59','#F6FAA1','#F28410','D66011',
'#BF355D','#ED8168','#FAB66A','#F2DC86','83BFA1',
'#E1F03E','#FFBA14','#DB3A0F','#A1003D','630024',
'#212226','#45433F','#687067','#BDBB99','F0EAC3',
'#FE4365','#FC9D9A','#F9CDAD','#C8C8A9','83AF9B',
'#293B47','#5F7A87','#FFFFFF','#CBFF48','00ADA9',
'#282A33','#697371','#FFE7A6','#F5BA52','FA8000',
'#0C304A','#2B79A1','#F3F4F1','#85A71E','BFD841',
'#008B83','#4DAE83','#A0AE79','#FFE499','FF665E',
'#5D7359','#E0D697','#D6AA5C','#8C5430','661C0E',
'#324452','#97BDBF','#F2DFBB','#F28705','BF3604',
'#EEEFB9','#6ACFAE','#369C93','#232928','B03831',
'#332F45','#015770','#2A8782','#9FD6AE','FFFED2',
'#2B2830','#5C504F','#ABAB8E','#D9D7A3','C7BE88',
'#DC941B','#EDC266','#B6952C','#E1D3A6','E9A119',
'#00305A','#00448D','#0074D9','#4192D9','7ABAF2',
'#344459','#485F73','#5DA6A6','#A9D9CB','F2EAD0',
'#060719','#4D1B2F','#9E332E','#EB6528','FC9D1C',
'#96CEB4','#FFEEAD','#FF6F69','#FFCC5C','AAD8B0',
'#05F2F2','#04BFBF','#EEF1D9','#A60201','7E100E',
'#E6F1F5','#636769','#AAB3B6','#6E7476','4B4E50',
'#DA0734','#F1A20D','#4AABB1','#FCF3E7','3F1833',
'#202D44','#FC4349','#6DBCDB','#D7DADB','FFFFFF',
'#CC3B37','#398899','#FFFCE8','#FF857F','CCC1A3',
'#5DBEA9','#EFEDDF','#EF7247','#4E3F35','D1CBBA',
'#FFC62D','#E49400','#DD5200','#EFE38A','91B166',
'#B67D14','#F2921F','#F0B23E','#A62409','441208',
'#C71B1B','#D6BA8A','#017467','#E08F23','0B0D0C',
'#474143','#A69E9D','#E7E2DA','#FFFFFF','E7E8E7',
'#435772','#2DA4A8','#FEAA3A','#FD6041','CF2257',
'#6DD19D','#99E89D','#D0E8A1','#FFF9C0','D40049',
'#FAF1D5','#DEC9AC','#CCA18B','#11282D','A5C4BB',
'#000000','#141414','#1C1919','#1A1716','24201F',
'#D5D8DD','#5CA2BE','#135487','#2A4353','989DA4',
'#73161E','#BF0F30','#BFB093','#037F8C','0A2140',
'#195962','#F56F6C','#FFFFFF','#252932','191C21',
'#F8EFB6','#FEBAC5','#6CD1EA','#FACFD7','C2EAE9',
'#91D6BC','#768C6A','#755F31','#B37215','FFBA4B',
'#F2E6BB','#DD4225','#202724','#63BD99','F8FDD8',
'#762B1B','#807227','#CCBF7A','#FFEF98','60B0A1',
'#707864','#C1D74E','#F5FF7C','#DFE6B4','A6B89C',
'#FFF3D2','#97B48F','#E87657','#FF9B6F','E8D495',
'#33262E','#733230','#CC5539','#E6D27F','86A677',
'#122430','#273E45','#FFFCE2','#EBD2B5','E63531',
'#30394F','#FF434C','#6ACEEB','#EDE8DF','FFFBED',
'#0A3A4A','#196A73','#32A6A6','#A1BF36','C8D94A',
'#FFF7CC','#CCC28F','#70995C','#33664D','142933',
'#43464D','#9197A6','#D3DCF2','#7690CF','48577D',
'#DFE0AF','#A4BAA2','#569492','#41505E','383245',
'#B52841','#FFC051','#FF8939','#E85F4D','590051',
'#473C35','#A36D5C','#9C968B','#D9CEAD','8A866A',
'#DB4C39','#2D3638','#109489','#44D487','D0DB86',
'#6F8787','#AEC2AE','#E6DFAE','#B0B57B','888F51',
'#C8385A','#FFCF48','#ECEABE','#1FCECB','1CA9C9',
'#42282E','#75A48B','#D9CFB0','#DC9B74','D6665A',
'#362F2D','#4C4C4C','#94B73E','#B5C0AF','FAFDF2',
'#98293A','#B14A58','#C86C6B','#DE9D76','EFC77F',
'#C1D301','#76AB01','#0E6A00','#083500','042200',
'#453F22','#7A6B26','#CCAD5C','#A1191F','4E1716',
'#541E32','#8E3557','#88A33E','#C2BD86','F7F2B2',
'#2B1B2E','#54344D','#FFFFD6','#B89E95','6E444F',
'#6EC1A5','#9FBEA6','#F5D3A3','#FF9F88','FB7878',
'#2F252C','#D3CCB2','#99AD93','#6E6751','5C3122',
'#BE333F','#F2E9CE','#C8C5B1','#939F88','307360',
'#F0F1F2','#232625','#647362','#B3D929','D2D9B8',
'#FA2B31','#FFBF1F','#FFF146','#ABE319','00C481',
'#09455C','#527E7C','#F5FFCC','#E0EB6E','C4D224',
'#F2DA91','#F2B950','#F29D35','#D96704','BF4904',
'#A2CFA5','#E0E7AB','#F5974E','#E96B56','D24344',
'#150033','#310D42','#5C2445','#AB6946','FFCE4C',
'#23A38F','#B7C11E','#EFF1C2','#F0563D','2E313D',
'#FF2468','#E0D4B1','#FFFFE3','#00A5A6','005B63',
'#65A683','#218777','#3F585F','#47384D','F53357',
'#000623','#28475C','#4A6C74','#8BA693','F0E3C0',
'#E65322','#D19552','#B8BF73','#B6DB83','FFF991',
'#112F41','#068587','#6FB07F','#FCB03C','FC5B3F',
'#C89B41','#A16B2B','#77312B','#1C2331','152C52',
'#C24366','#D9C099','#FFF8D8','#A8E0BA','00ADA7',
'#CC0000','#006600','#FFFFEC','#9C9178','6C644F',
'#3D0319','#720435','#C1140E','#FC5008','32241B',
'#CFC7A4','#5A9E94','#005275','#002344','A38650',
'#FFEBC3','#CC3A00','#FF3600','#FF851B','800C00',
'#EFC164','#F3835D','#F35955','#286275','00434C',
'#E9F29D','#B7C29D','#878E8F','#67617A','51456B',
'#445859','#03A696','#49C4BE','#F1F2E4','FF7746',
'#FA726C','#FFD794','#BAD174','#3BA686','5F6F8C',
'#4D2B1F','#635D61','#7992A2','#97BFD5','BFDCF5',
'#CC4D00','#E6CF73','#668059','#264D4D','00CCB3',
'#4385F5','#DC4437','#FCBE1F','#109D59','FFFFFF',
'#271F2E','#A4A680','#F2EBC9','#D9B166','A66B38',
'#0B2C3C','#FF6666','#DADFE1','#FFFFFF','444444',
'#CFF09E','#A8DBA8','#79BD9A','#3B8686','0B486B',
'#302B26','#A6B827','#EDE9DD','#98D3D4','594E7A',
'#4B0505','#720707','#BFB694','#004659','00292B',
'#B52C38','#EBD1B0','#536682','#D9964B','DE6846',
'#F2F1DF','#F2B705','#F2C84B','#BF820F','734002',
'#26140C','#3D2216','#784E3D','#AB8574','D6BCB1',
'#26221D','#8C2C0F','#E6E5B8','#BFB38D','402D1F',
'#1F8181','#F2BC79','#F28972','#BF1B39','730240',
'#002635','#013440','#AB1A25','#D97925','EFE7BE',
'#8EC447','#FFFFFF','#96D3D4','#636466','2D2D2E',
'#2D1E1E','#4B3C37','#96A576','#CDE196','FFFFBE',
'#F06060','#FA987D','#F7F2CB','#72CCA7','10A296',
'#1D8281','#44BF87','#FBD258','#F29A3F','DB634F',
'#DEDE91','#EF9950','#F34E52','#C91452','492449',
'#6D8EAD','#1F3447','#1A0B07','#362416','CFCDB4',
'#00CD73','#008148','#2D9668','#3ECD8E','004E2C',
'#3D8080','#628282','#858383','#A38282','C28080',
'#475159','#839795','#B2BDB7','#CCC9C0','F2F2F2',
'#0E6870','#C6B599','#C65453','#FFDDB4','EDAA7D',
'#CEF0B7','#A8DBA8','#79BD9A','#3B8686','0B486B',
'#292C44','#FF5349','#F0F0F1','#18CDCA','4F80E1',
'#272A2B','#383737','#473B39','#692B28','940500',
'#D6C274','#DB9E46','#25706B','#3D2423','AB362E',
'#FFA68F','#FF4867','#FFF9C8','#B5EBB9','18B29D',
'#A1A16A','#727D59','#366353','#133C40','03212E',
'#D45354','#A9DC3A','#2FCAD8','#818B85','CDCDC1',
'#F14B6A','#3D3C3E','#22BDAF','#BAD7D4','F4F4F4',
'#FFE2C5','#FFEEDD','#FFDDAA','#FFC484','FFDD99',
'#9FFF4A','#1ABF93','#087363','#004040','2F1933',
'#FFDB97','#B28F4E','#FFFDFB','#466CB2','97BBFF',
'#991C00','#E09A25','#FFFCDB','#008B83','262B30',
'#44281A','#00ACAE','#F5EFD5','#F37606','EE4717',
'#FF5952','#FCEEC9','#96D6D9','#4FAAC9','176075',
'#5C4B51','#8CBEB2','#F2EBBF','#A5C88F','EF847B',
'#105F73','#F7F3B2','#C6CC33','#F28322','CC5404',
'#137072','#56B292','#B7F5AB','#FBFFC0','BF223D',
'#E3F23E','#6C821C','#A6A53F','#E0E0AC','33302E',
'#00215E','#003CAA','#1967F7','#5E4000','AA7400',
'#273A3D','#54695C','#AD9970','#FFBF87','FF8F60',
'#FFAA00','#C2B93E','#808F5D','#576157','302F30',
'#BE1405','#F2DCAC','#AABEAA','#736E41','413C2D',
'#6B1229','#C76A61','#FAB99A','#F7D9B5','CCB1A7',
'#2D9993','#58B3A3','#83BFA3','#B0D9A8','FFFCB6',
'#334D5C','#45B29D','#EFC94C','#E27A3F','DF5A49',
'#F30B55','#010326','#012840','#54717F','F2E6CE',
'#2A3411','#73662C','#BC9847','#FFDFB2','6B0031',
'#637D74','#403D3A','#8C3B3B','#AB6937','D4A960',
'#010A26','#011640','#B6D6F2','#FFFFFF','E83338',
'#924847','#EB986C','#E4C678','#9C7885','372C2C',
'#022440','#3F95AA','#4EC6DE','#EAE2DF','F7572F',
'#2B1D2E','#323657','#076473','#54B087','D6F567',
'#052229','#004043','#BCC373','#E3FF55','D0D90C',
'#4C514A','#907A62','#879796','#755854','B09880',
'#1D2939','#1CAF9A','#FFFFFF','#EE4F4B','D1DC48',
'#004B67','#41CCB4','#FFEA95','#FF7C5D','C70151',
'#C0272D','#FCFBE7','#9FD3DA','#008C9A','05484F',
'#213130','#FF5E3D','#C9C83E','#FDFFF1','559398',
'#B1E4FC','#366D78','#39D5F1','#FFFFFF','D9FF03',
'#DECE6C','#FCF9B6','#BFE3B5','#5D826E','262E2B',
'#520A17','#668F91','#F5E6AC','#AB8E5B','52301C',
'#2D3032','#DD5F18','#FBA922','#F7F7F7','404333',
'#0C2538','#2B434F','#638270','#BCC98E','EDE059',
'#E85066','#F28E76','#E6CEB0','#5A8C81','382837',
'#BF2633','#A6242F','#D9CEAD','#C0B18F','011C26',
'#002A4A','#17607D','#FFF1CE','#FF9311','E33200',
'#0A8B91','#485956','#C4B98F','#FFF9BC','EEDF2E',
'#B89A7B','#9BBAAC','#F2D649','#D95D50','DBDBDB',
'#BD7938','#8D4421','#643001','#532700','3A1C00',
'#E1E6FA','#C4D7ED','#ABC8E2','#375D81','183152',
'#2E4259','#F7483B','#ECF0F1','#03C8FA','737373',
'#364656','#5D6B74','#94A4A5','#F2F5E9','FF8C31',
'#3E5916','#93A605','#F28705','#F25C05','E5EFFA',
'#248077','#74AD8D','#C82754','#F7BB21','F9E2B7',
'#20736A','#8BD9CA','#B1D95B','#93A651','403E34',
'#D74B4B','#DCDDD8','#475F77','#354B5E','FFFFFF',
'#252F33','#415C4F','#869C80','#93C2CC','CEEAEE',
'#012840','#79C7D9','#9BF2EA','#497358','9DBF8E',
'#EE7E94','#F8B4C4','#C7CAC9','#D8505C','41424',
'#282828','#505050','#FFFFFF','#2DCEDB','F20000',
'#004358','#1F8A70','#BEDB39','#FF5347','FD7400',
'#470C3B','#802F56','#C0576F','#E38679','FFBD83',
'#573328','#B05A3A','#FF8548','#29332E','0F1B1C',
'#461F2D','#E1FFBB','#BAD47F','#849C23','52533F',
'#333A40','#4C5E5E','#ADD0E5','#CDE4FF','729EBF',
'#DE5605','#F7A035','#B1DEB5','#EFECCA','65ABA6',
'#76D6D2','#F9E270','#EF6F56','#F4EED8','596B56',
'#403E3F','#F2F2F2','#D9D9D9','#9DAABB','8C8C8C',
'#059E9A','#F4F2ED','#F5A243','#DB3E3B','585857',
'#FFBF41','#EE8943','#C02221','#FFF4D3','249CA9',
'#024E76','#39A6B2','#FCE138','#F5B824','F08106',
'#FF0067','#FF3D6A','#E7FF04','#9CFF00','56FF00',
'#003540','#0D3F40','#487360','#8FA671','F2D795',
'#FF493C','#FFFFFF','#B3ECEF','#31C4F5','ADEB41',
'#244358','#4A8B87','#7CBCAE','#F0D4AF','C5252B',
'#EA5930','#F8AF1E','#F5E5C0','#097380','372560',
'#A1DBB2','#FEE5AD','#FACA66','#F7A541','F45D4C',
'#2C4A47','#6C9A7F','#BB523D','#C89D11','81810B',
'#F0F1F2','#232625','#647362','#FF5629','D2D9B8',
'#7C9B5F','#B8D197','#E3FFF3','#9BDEC7','568F84',
'#E54E45','#DBC390','#F2F2EF','#13A3A5','403833',
'#77A7FB','#E57368','#FBCB43','#34B67A','FFFFFF',
'#001A2E','#8F0000','#FFFFFF','#8A874B','41594F',
'#312F40','#49A69C','#EFEAC5','#E89063','BF5656',
'#047C8C','#018B8D','#F3BF81','#F49B78','F1706D',
'#00303E','#7096AD','#C1D1DE','#FFF9EF','EC4911',
'#2D6891','#70A0BF','#F5EEDC','#DC4C1A','F0986C',
'#040002','#3D1309','#E8B96A','#BC5D15','5C0F00',
'#8B929C','#5E6070','#514454','#3B313D','FF2479',
'#142D58','#447F6E','#E1B65B','#C8782A','9E3E17',
'#22104D','#2D1E5E','#483A85','#7067AB','A49CFA',
'#919C86','#9E373E','#2B2E36','#D1B993','C45A3B',
'#332F45','#015770','#2A8782','#9FD6AE','FFFED2',
'#37C78F','#FEE293','#FF4D38','#CC2249','380C2A',
'#47282C','#8C8468','#C9B37F','#DBDAB7','C4C49C',
'#14191A','#2D2B21','#A69055','#CCB287','FFB88C',
'#F5E3CD','#696158','#B6A898','#877D71','504A43',
'#005151','#009393','#F56200','#454445','969692',
'#D95F47','#FFF2C1','#80A894','#106153','072C36',
'#9E352C','#E6E8A9','#93C28C','#2E5A5C','2B2623',
'#03013A','#334A94','#6B9EDF','#83C3F2','99E6FF',
'#372A26','#4D4D4D','#6DA0A7','#9ED5A8','C7F5FF',
'#03658C','#022E40','#F2B705','#F28705','F25C05',
'#FF3B16','#E87826','#E8BA4A','#80A272','003045',
'#00748E','#E3DFBB','#F4BA4D','#E3753C','DA3B3A',
'#25401E','#56732C','#84A63C','#B8D943','EAF2AC',
'#449BB5','#043D5D','#EB5055','#68C39F','FFFCF5',
'#108F97','#FF8B6B','#FFE39F','#16866D','103636',
'#1A4F63','#068F86','#6FD57F','#FCB03C','FC5B3F',
'#381C19','#472E29','#948658','#F0E99A','362E29',
'#D7E8F7','#BBD0E3','#9CB7CF','#6A8BAB','375D81',
'#0F1C28','#136972','#67BFA7','#F3CF5B','F07444',
'#FFFFFF','#4EA9A0','#969514','#FE9C03','FCDE8E',
'#2F2D30','#656566','#65537A','#51386E','2A2333',
'#4C2916','#F05A28','#FBAF3F','#38B449','FFFFFF',
'#132537','#006C80','#EBCAB8','#FE8315','FA3113',
'#ECEEE1','#A8DACF','#F05B4F','#D8403A','221E1F',
'#00305A','#004B8C','#0074D9','#4192D9','7ABAF2',
'#72CF3F','#85FF00','#23E000','#2FB81B','00FF1C',
'#45CEEF','#FFF5A5','#FFD4DA','#99D2E4','D8CAB4',
'#FF5B00','#A1716C','#728296','#439AAB','00CABD',
'#EB6C2D','#D9C8A2','#939C80','#496158','232F38',
'#D94214','#FFF2C1','#80A894','#52736B','093844',
'#4D1B2F','#9E332E','#EB6528','#FC9D1C','FFCA50',
'#FFEEB0','#9AE8A4','#C7C12D','#F76245','ED1C43',
'#FFFAED','#D4DBFF','#879AC9','#242942','FF8800',
'#022840','#013440','#517360','#9DA67C','F2DC99',
'#331A0F','#519994','#BA4B3C','#EEDDAA','789F63',
'#577867','#EDCE82','#D68644','#AB3229','662845',
'#435A66','#88A6AF','#F5F2EB','#D9CDB8','424342',
'#FF8840','#958D4F','#737B55','#595540','513E38',
'#9D805A','#EBC99D','#FFE6C5','#9DCEEA','4B809E',
'#272D40','#364659','#55736D','#9DBF8E','D0D991',
'#23A38F','#B7C11E','#EFF1C2','#F0563D','2E313D',
'#98C000','#3D4C53','#EA2E49','#FFE11A','0CDBE8',
'#A20E30','#E93C4F','#DCDCD4','#ADBCC3','2D4255',
'#1C2640','#263357','#384C80','#4E6AB3','5979CD',
'#D94214','#FFF2C1','#80A894','#52736B','093844',
'#3B596A','#427676','#3F9A82','#A1CD73','ECDB60',
'#1E1E1F','#424143','#67666A','#807F83','CBC9CF',
'#E04946','#3BA686','#B6D15D','#FFD495','FA847E',
'#FFEBB0','#FFB05A','#F84322','#C33A1A','9F3818',
'#FFA136','#FF814A','#E6635A','#785D6B','534557',
'#CDCF91','#EBEACC','#D6D5B8','#6D7D80','41545E',
'#011526','#011C40','#4E8DA6','#F2EA79','F2B33D',
'#353230','#3F4E51','#7B8F70','#99B2BE','F6F4EA',
'#063559','#0D8C7F','#8FBF4D','#F2D13E','D95929',
'#158000','#199900','#20BF00','#24D900','29FF00',
'#0B0D0E','#137074','#7EB7A3','#F1DDBB','EC6766',
'#02151A','#043A47','#087891','#C8C8C8','B31D14',
'#59361F','#5C992E','#A3CC52','#E6E673','FF5933',
'#FE4365','#FC9D9A','#F9CDAD','#C8C8A9','83AF9B',
'#4B1E18','#F9E5C2','#BBB082','#829993','4F5D4E',
'#032843','#1F595B','#508C6D','#71A670','A6DB89',
'#191724','#4C4547','#8C594E','#D18952','FDB157',
'#191919','#182828','#60702D','#AAB232','E6FA87',
'#212A3F','#434F5B','#F2F2F2','#8AB839','2E2E2E',
'#004158','#026675','#038B8B','#F1EEC9','F09979',
'#023059','#3F7EA6','#F2F2F2','#D99E32','BF5E0A',
'#F21E52','#FFFFFF','#3D3B42','#0C6F73','63CFD4',
'#452743','#E7635E','#F8E9A8','#89E0AD','00928C',
'#FAAD63','#D1714D','#785E48','#39403B','3D1C24',
'#4C0016','#FFF7EB','#DCCEA7','#A17345','104F53',
'#BF2431','#F24150','#2A4557','#3B848C','EFF2E4',
'#3B3013','#8F6031','#E88833','#9C0C0A','FDF3C1',
'#1E2422','#88BEB1','#FF006D','#DAFFFF','718A94',
'#F1F4F7','#AF9F7B','#775E43','#40413C','251C17',
'#00182E','#0C6BA1','#D4D6D4','#FFFDEB','FF7500',
'#FFAB4A','#CCBAAB','#1E2129','#3D5E6E','47A3A3',
'#66B3A7','#C0D4B6','#EEF0BD','#F0563D','2C2F3B',
'#332525','#907465','#EDC5B5','#878C6D','63674A',
'#F04C16','#DBDBD0','#EDBD1F','#4CB09C','313B4A',
'#2B211D','#611C26','#C5003E','#8EB7A8','F1E4B7',
'#1A1F2B','#30395C','#4A6491','#85A5CC','D0E4F2',
'#03497E','#0596D5','#9DEBFC','#999999','FE4B28',
'#2F4159','#465E73','#88A649','#F2ECE4','D98841',
'#323A46','#22282F','#EB4A33','#FFFFFF','E9F0F5',
'#2C3E50','#FC4349','#6DBCDB','#D7DADB','FFFFFF',
'#F29727','#E05723','#B0382F','#982E4B','713045',
'#4D584A','#465943','#428552','#3E754E','4C694B',
'#47191C','#59574B','#829690','#B5B09A','E1E3CB',
'#1D5123','#B1C661','#FFDA68','#FE9257','F64448',
'#59323C','#260126','#F2EEB3','#BFAF80','8C6954',
'#4E0805','#9E0522','#FFF4D4','#B8C591','447622',
'#424862','#FB9A63','#BFC4D5','#F6FBF4','FEBC98',
'#FF2468','#E0D4B1','#FFFFE3','#00A5A6','005B63',
'#1C2F40','#4C6173','#8094A6','#D9D1BA','F2E9D8',
'#DFD7B7','#EB7707','#5C5445','#3B2323','9CBFC7',
'#262E3B','#9C8878','#CFCAAA','#FBF8FF','992435',
'#FFBC67','#DA727E','#AC6C82','#685C79','455C7B',
'#404A69','#516C8A','#8AC0DE','#FFFFFF','FFAC00',
'#485B61','#4B8C74','#74C476','#A4E66D','CFFC83',
'#A31180','#C42795','#DE52B4','#EA88CE','FFBFE5',
'#E64D2E','#FFF5F1','#7893AD','#576B9C','2D2A52',
'#BF0436','#8C0327','#590219','#F2CBA1','8C674C',
'#CF5B6F','#FFF8C8','#CAD9B1','#8FB3A0','648991',
'#341D44','#744D90','#BB8CDD','#3E4417','88904D',
'#00293E','#003D4E','#006269','#00918F','00BAB5',
'#43212E','#D9666F','#F2D57E','#A9A688','516057',
'#2A3B30','#ABFFD1','#EBFFF5','#9DFEFF','273B40',
'#A63343','#E65159','#F5E9DB','#F4F7CF','BAD984',
'#1BA68C','#54BFAC','#F2EDA7','#F2E530','D94625',
'#1A2A40','#3F7369','#F2DEA0','#CE5251','EA895E',
'#1E9382','#70A758','#EFF1C2','#F0563D','2E313D',
'#A991E8','#FFB4BB','#ACF7FF','#A2E891','FFEDAE',
'#225B66','#17A3A5','#8DBF67','#FCCB5F','FC6E59',
'#282624','#BFB7AA','#403D39','#807A71','ABA398',
'#334D5C','#45B29D','#EFC94C','#E27A3F','DF4949',
'#440008','#605521','#988432','#D9A54E','9E3711',
'#649670','#36291E','#69AD6C','#92E67C','C5FF84',
'#42342C','#738076','#B2B39B','#DFE5E1','294359',
'#1A3838','#3F7A51','#82A352','#D1C062','FFBE59',
'#7D8C22','#B3BF67','#F2E49B','#D9DFF4','6791BF',
'#8A7D6D','#2D2D38','#E86E48','#FFFFE8','9CC9C9',
'#CFC949','#FFF5BF','#A9E6C4','#6AB39F','665841',
'#A1172D','#FDFFBA','#A7DB9E','#275C57','1F1B19',
'#FF6C0D','#F29E00','#E6C10F','#44996F','216273',
'#2C3E50','#FA4248','#D7DADB','#6DBCDB','FFFFFF',
'#627369','#99B397','#E2F2C6','#91CCAD','376266',
'#04496E','#66CAFF','#A3FC7E','#70D44A','2C6B0F',
'#1BA68C','#97BF3F','#F2ECD8','#F2B035','F2522E',
'#A2D9B1','#7CBF9E','#F2F1B9','#8C8575','193741',
'#024959','#037E8C','#F2EFDC','#E74C30','363636',
'#212625','#9CA6A2','#D0D9D6','#BF0404','C2C6AF',
'#00FFFF','#00FF00','#FFFF00','#FF5100','FF007C',
'#212629','#CDCF19','#FFF77D','#96C4AB','CF2A56',
'#CFF9FF','#BFC7BB','#787051','#332730','57324F',
'#98CACB','#FDEFBE','#F0542B','#736E5B','ABA68E',
'#F2F1EB','#BFB9A4','#262222','#802A30','8C0303',
'#65356B','#AB434F','#C76347','#FFA24C','519183',
'#78BF82','#A4D17C','#CFD96C','#EBD464','FFD970',
'#806265','#FFA256','#F7DD77','#E0D054','ABA73C',
'#8F323C','#123943','#80BDDB','#4189AB','C98127',
'#683820','#8C9A89','#E7D6A2','#BEAA65','9A8234',
'#021B21','#032C36','#065F73','#E8DFD6','FF2A1D',
'#2D6C73','#3FA693','#B4D9CB','#9ABF49','C6D93B',
'#141F26','#2B4040','#405950','#A69E86','F2D9BB',
'#4A8279','#003330','#610400','#003B06','02730F',
'#69B5E1','#D4E4F5','#EAF2F8','#BEDBED','000000',
'#893660','#EF7261','#68D693','#A0D7E2','299CA8',
'#073A59','#2D9AA6','#F2E2DC','#F23322','A61B1B',
'#2A3A48','#3E6372','#B2D4DC','#FAFAFF','FF6900',
'#F3BD8D','#F1A280','#BE6D6B','#704A5B','3E263C',
'#1C2742','#3C91C7','#5A9ABE','#95C5DE','E0EEFB',
'#426261','#465A59','#577573','#739A97','9AC1C0',
'#002A4A','#17607D','#FFF1CE','#FF9311','D64700',
'#589373','#BFBD99','#F2D6B3','#C2512F','241E1E',
'#1F518B','#1488C8','#F7E041','#E2413E','B5292A',
'#549494','#E85649','#232C2E','#E6E8D2','706558',
'#392133','#FFECBE','#D9D098','#C4AB6D','AB7D3A',
'#F0F0F0','#1C1C1C','#A2FDF5','#1CCDC7','27EDDF',
'#011526','#025959','#027353','#03A678','03A696',
'#004358','#1F8A70','#BEDB39','#FFE11A','FD7400',
'#37465D','#F2F2F2','#9DC02E','#779324','051A37',
'#580022','#AA2C30','#FFBE8D','#487B80','011D24',
'#F9F9F9','#03A678','#E9EDEB','#F44647','00707F',
'#800000','#BF0000','#E2D6C2','#F6EDD8','FFFFFF',
'#F7F6AF','#1B2124','#D62822','#97D6A6','468263',
'#432852','#992255','#FF3D4C','#28656E','00968F',
'#444344','#52BBB2','#2B344D','#EE5555','F8F7EE',
'#45334A','#796B7D','#CCC4B0','#FFF1B5','FFA3A3',
'#5A4B53','#9C3C58','#DE2B5B','#D86A41','D2A825',
'#14151C','#0C242B','#297059','#84D66E','D1FB7A',
'#272D40','#364659','#55736D','#9DBF8E','D0D991',
'#23A38F','#B7C11E','#EFF1C2','#F0563D','2E313D',
'#2E064D','#80176B','#B356A1','#59580B','FFFF00',
'#CC3333','#FF9D33','#F7F7F0','#3EBBA7','00747A',
'#5C4B51','#8CBEB2','#F2EBBF','#F3B562','BD6060',
'#0D3E58','#1C848C','#19C0C2','#F3EDD6','DA6260',
'#022629','#2A5945','#FAFFED','#E6DCC0','B3371C',
'#F4FAC7','#7BAD8D','#FFB159','#F77F45','C2454E',
'#A2C1C6','#86B1B7','#AECBAD','#CFDCB0','D6E1D1',
'#B0DAFF','#325B80','#64B7FF','#586D80','5092CC',
'#0F808C','#6C8C26','#F2A71B','#F26A1B','D91818',
'#FFBC6C','#FE9F6C','#BD716E','#74495F','3B2C4D',
'#FF4D41','#F2931F','#E6CA21','#91B321','1E8C65',
'#302821','#453629','#5C4837','#8A735F','BDA895',
'#415457','#5F7B7F','#9ACCAF','#E6EBC4','F9F7C8',
'#474143','#A69E9D','#E7E2DA','#FFFFFF','E7E8E7',
'#805939','#BD9962','#E6CD7D','#578072','2D4B4D',
'#03588C','#1763A6','#419CA6','#54BF83','8DBF41',
'#00CCFF','#A1FCFF','#040438','#004878','C9FAFF',
'#534C64','#B7DECF','#F0F3D7','#7E858C','D96557',
'#7F7364','#CBB08E','#CBC1B7','#789DCB','646F7F',
'#5C2849','#A73E5C','#EC7263','#FE9551','FFD285',
'#FF0012','#FF7D00','#FFD900','#5BE300','0084B0',
'#F24C32','#F29471','#FCDFA6','#36B898','3D7585',
'#083157','#0A6C87','#459C97','#92CCA5','C9F0B1',
'#DC941B','#EDC266','#B6952C','#E1D3A6','E9A119',
'#323836','#BAD1B5','#DBE8CF','#F0F7E8','FFFEF5',
'#081724','#589494','#8EBBB4','#D0DCD0','F5EED2',
'#50781C','#9CAD1C','#EAF7E6','#40A5DE','0B5191',
'#537F79','#78A68F','#CBD49C','#FED457','CB252A',
'#F23C13','#CBAB78','#FFFFFF','#898373','1F1C17',
'#450003','#5C0002','#94090D','#D40D12','FFED75',
'#0770A2','#82D9F7','#FEFEFE','#AEC844','F36622',
'#30394F','#FF434C','#6ACEEB','#EDE8DF','0E6569',
'#FF6B6B','#556270','#C7F464','#4ECDC4','EDC8BB',
'#D9B500','#FFED9C','#BFCC85','#748F74','454545',
'#452E32','#A34B1B','#B5A187','#EDDF9A','A7CC31',
'#2C2B33','#596664','#909980','#CCC08D','FF8A00',
'#C21F1F','#FFFFFC','#E34446','#FFFFDB','E36D6F',
'#282828','#00AAB5','#C1C923','#F41C54','F5F0F0',
'#3A3F40','#202627','#151B1E','#EFF4FF','41444D',
'#DEBB73','#4D0017','#010000','#4D0F30','9A002F',
'#EB9328','#FFA754','#FFD699','#FFF5DC','4FA6B3',
'#025E73','#037F8C','#D9D59A','#D9BD6A','590202',
'#636266','#E0CEA4','#E8A579','#7D6855','42403E',
'#FF0000','#FF4000','#FF7F00','#FFBF00','FFFF00',
'#FFFFFF','#74ADA6','#1E5E6F','#241B1F','68A81E',
'#5A0532','#FF6745','#FFC861','#9DAE64','27404A',
'#ACCBBC','#467847','#E8E4C1','#A60303','730202',
'#5C4B51','#8CBEB2','#F2EBBF','#F3B562','F06060',
'#0D2557','#93A8C9','#FFFFFF','#F5DED5','558D96',
'#F53C4A','#565157','#10CFC8','#F2EEE7','F5D662',
'#FFD97B','#E65029','#A60027','#660033','191C26',
'#595408','#A6800D','#A66D03','#A63F03','730C02',
'#2E031F','#590424','#8C072B','#BF0A2B','DEEFC5',
'#E0C882','#A6874E','#BFA169','#D9B779','F2D399',
'#D88681','#A67673','#746566','#535A5D','324F54',
'#FC297D','#FB607A','#FDA286','#FDC188','FEE78A',
'#FFECA1','#B3B27F','#4C5E52','#2F3436','FFBE2C',
'#D93312','#B3AB82','#45735F','#394D47','2C3233',
'#324143','#6595A3','#C8E3E8','#FCFFED','B6C28B',
'#477984','#FEF5EB','#C03C44','#EEAA4D','313E4A',
'#334D5C','#45B29D','#EFC94C','#E27A3F','DF4949',
'#630B11','#33322F','#2A2927','#1E1D1C','000000',
'#D94214','#FFF2C1','#80A894','#52736B','093844',
'#051E21','#00302D','#856434','#F28C28','FFAD4E',
'#D7DADD','#DDDEE3','#E1E1E9','#EDEFF4','F2F3F8',
'#BF495E','#41A693','#F2EC9B','#D9CF48','D9583B',
'#067072','#14A589','#DECFA6','#BAAE8C','F94B06',
'#423A38','#47B8C8','#E7EEE2','#BDB9B1','D7503E',
'#730324','#DFE3E6','#B4C4D4','#8BA2BD','456382',
'#537374','#F9BD7F','#EBD7A5','#ADC9A5','5C9E99',
'#88B59E','#B6DEC8','#39464D','#C04229','ABD1AB',
'#11A7FC','#95D127','#F2E415','#FF8638','EE3551',
'#212640','#5D718C','#4B95A6','#60BFBF','EFF2D8',
'#D8A64D','#9B5422','#351411','#5B0D0D','991C11',
'#53324F','#668D6E','#F2E0A0','#F19B7A','F0756E',
'#DFE0AF','#A4BAA2','#569492','#41505E','383245',
'#7BBADE','#93DE7F','#FFED5D','#F29E4A','FF7050',
'#133800','#1B4F1B','#398133','#5C9548','93E036',
'#D9D7AD','#91A685','#FF6A00','#37485C','1C232E',
'#008767','#FFB27A','#FF6145','#AB2141','5E1638',
'#727B7F','#CCEAEA','#7A7556','#2E2125','44CACC',
'#FFFFED','#FF2C38','#FF9A3A','#FFF040','67D9FF',
'#007148','#60A859','#9BDA6A','#C7F774','F9FFEF',
'#092740','#45698B','#90B0CC','#F1FAFF','8FD36F',
'#E2FFA0','#7D8076','#FAFFED','#C2CCBE','8F7D70',
'#00736A','#00BC9F','#F1EEC7','#FEA301','F2561A',
'#26282E','#AD5138','#F7F7F7','#DDDAE0','8594AE',
'#1A191F','#35352F','#484042','#4E5252','E64D38',
'#49454A','#E69B02','#FAF4C6','#B1D631','324052',
'#5F1A2B','#1D2834','#6F8B78','#E4D49E','C96466',
'#012D3D','#38AD9E','#FFEB9E','#FF6867','D0DBED',
'#0D1F36','#104954','#1E9C89','#38CC85','60EB7B',
'#8C4E03','#9FA66A','#F2EC94','#F23005','8B0F03',
'#000001','#20201F','#E2E2E4','#590402','B80000',
'#344059','#465973','#F2D272','#A69460','595139',
'#33454C','#608F85','#B6E5CB','#8BAF95','54584E',
'#FBFEF6','#B7BFA4','#687F70','#1A3841','BF3847',
'#D7E836','#86FFC7','#FFB048','#E8366C','593BFF',
'#34A9FF','#5982DB','#665EB8','#684682','632E62',
'#004056','#2C858D','#74CEB7','#C9FFD5','FFFFCB',
'#BFB978','#84945C','#516967','#4D3130','281B24',
'#103B73','#20638C','#3786A6','#4EABBF','EBEFF2',
'#9FB1BF','#1D2D63','#1C5357','#1F6E56','196331',
'#FFEBBA','#C3BD91','#88947B','#4C3F3F','2A2727',
'#347373','#4EA6A6','#91D9D9','#FFFFFD','F2E205',
'#828948','#EFDFC2','#006971','#DC533E','840000',
'#000137','#29003F','#79003D','#D04D14','F89801',
'#370005','#4B0005','#5F0005','#730005','870005',
'#C3AE8D','#F25260','#2D5F73','#6BADC9','8FCED6',
'#9E1B36','#F7EDBA','#E69B3D','#EB3355','3D241D',
'#1D8281','#44BF87','#FBD258','#F29A3F','DB634F',
'#035C75','#1B808C','#31A6A8','#F3F1BC','F3AD14',
'#FF7500','#665130','#EBB643','#CEDAA8','668E84',
'#384D3A','#3E6653','#728053','#A68357','D97C71',
'#012326','#17455C','#E1CAAB','#FE8333','FA4913',
'#1A2944','#2DA7C7','#56ACBA','#98C4C9','CBD5D2',
'#BF3542','#CDC5BA','#EBE3D6','#3C3C3C','2E2E2E',
'#231921','#695F74','#BEB4CB','#EBEBF0','D2DCEB',
'#34373F','#686C75','#F3E9D0','#BEB7A7','8E867C',
'#661510','#D9351A','#F2C76F','#BF9727','204D3F',
'#3CFFEE','#24AABC','#356781','#2C3D51','1C1F24',
'#DA3537','#FFFCC4','#00585F','#6A6A61','2A2C2B',
'#AE3135','#D1AF87','#8C826B','#3D3C33','F2F0CE',
'#FF0894','#FF5E9F','#FF91A7','#FFB5CA','F5F0BA',
'#99878D','#323232','#646464','#7E4A5C','372129',
'#3FB8AF','#7FC7AF','#DAD8A7','#FFB38B','FF3F34',
'#402B3C','#6AA6A6','#D9CCA7','#F2B263','F26835',
'#6AA690','#F2BC1B','#F2DC99','#F29057','BF1F1F',
'#F4FAC7','#7BAD8D','#FFB158','#F77F45','C2454E',
'#E5533C','#F5E346','#93D06D','#50AC6A','227864',
'#39588A','#A9BDD7','#FFFFFF','#FFEADD','FFD0BB',
'#B0B595','#615F4F','#828567','#91A380','EAFFCD',
'#00427F','#0066BD','#66B5CC','#F0E4C5','D6C28F',
'#FF6313','#F9E4B3','#C29689','#74474B','45232E',
'#00585F','#009393','#FFFCC4','#C7C49B','EB0A00',
'#091840','#44A2FF','#F7F7EA','#B3CC63','4C6620',
'#5CBBE3','#FCF1BC','#5C8182','#383A47','B4F257',
'#9E9E9E','#E5E1D1','#E0393D','#253746','425563',
'#4D9453','#FFFFB1','#ADDE4E','#FF9D27','A62A16',
'#B70046','#FF850B','#FFEBC5','#109679','675A4C',
'#363636','#0599B0','#A4BD0A','#FFA615','FF2E00',
'#7D8077','#BBBFB2','#FAFFED','#E82A33','E3DEBC',
'#FD9F44','#FC5C65','#007269','#03A679','FAF0B9',
'#134B57','#81A489','#F1D8B5','#F2A054','C04D31',
'#946E49','#394042','#EDDBAC','#872A0C','BA8E3A',
'#404040','#024959','#037E8C','#FFFFFF','F24C27',
'#2A3342','#163C6E','#4E5F61','#E6A015','EDE7BE',
'#445060','#829AB5','#849E91','#C14543','D6D5D1',
'#8A9126','#B7BF5E','#FFE9C4','#F5B776','F58E45',
'#9B2D1E','#3C3A28','#78A080','#9BCD9E','FFFFAE',
'#FF6138','#FFFF9D','#BEEB9F','#79BD8F','00A388',
'#990000','#FF6600','#FF9900','#996633','CC9966',
'#DCE6DA','#B8CCBB','#98B3A5','#7A9994','62858C',
'#0B1C29','#3B7C8F','#73A5A3','#98C1B7','F0EBD2',
'#F6CB51','#E25942','#13A89E','#3F4953','F2E7DA',
'#282F36','#FFFEFC','#BDA21D','#BFBC5B','D2E098',
'#8C182D','#DE7140','#FCB95A','#FAE285','6A7349',
'#6B9100','#FFE433','#FF841F','#E03D19','A6001C',
'#FFEAA7','#D9D697','#9FC49F','#718C6A','543122',
'#CFF09E','#A8DBA8','#79BD9A','#3B8686','0B486B',
'#0C2233','#065471','#0A91AB','#FFC045','F2F2F2',
'#BEE8E0','#373C40','#2E2621','#73320B','FF5E00',
'#1B2C35','#A3BFC6','#FF005D','#222A30','293A42',
'#FF8400','#3B4044','#494948','#E6E1D8','F7F2E9',
'#6A482D','#518C86','#F6BF3D','#EF7C27','BF2424',
'#261C2B','#292B39','#226468','#608D80','829D8F',
'#B2AD9A','#110E00','#363226','#A9A695','ECE9D8',
'#1B1B26','#26394D','#286480','#13B3BF','A3FF57',
'#F2C2A7','#F5E5C5','#593D28','#422C21','93DEDB',
'#001028','#033140','#1E5A5B','#7BA78C','EBEDC6',
'#544E6E','#808CB0','#ABD1D9','#D9FFF7','DDF556',
'#323A45','#596677','#758194','#FFFFFF','E74C3C',
'#45291A','#AB926D','#DBD1BC','#4999C3','5FCBEC',
'#6B151D','#2E1615','#A8553A','#DB8F5A','F2C18E',
'#000623','#28475C','#4A6C74','#8BA693','F0E3B1',
'#60807B','#81B37A','#BCCC5F','#FFEE65','E64964',
'#FFFFFA','#A1A194','#5B605F','#464646','FF6600',
'#1E1B17','#577270','#9C9A79','#C7BDA1','580E0C',
'#452F27','#5E504A','#6B6865','#9BBAB2','B0FFED',
'#1B5257','#F7F6C3','#F28159','#CC5850','4F1C2E',
'#FAA51B','#BF511F','#2C445E','#2F6D82','5EE4EB',
'#BF3952','#59364A','#556D73','#D9D1A9','D95F5F',
'#024959','#037E8C','#F2EFDC','#E74C30','363636',
'#221A26','#544759','#A197A6','#F27405','D93D04',
'#C4A44A','#E6D399','#9AB8A9','#7C8A7F','4E4B44',
'#FFFEC8','#B1BF99','#5B604D','#39382B','26181E',
'#4E3C51','#21A68D','#3BBF9A','#F2E8B6','F25749',
'#102144','#1B325E','#254580','#3C63B0','5D8AEA',
'#2A3A48','#3E6372','#B2D4DC','#FAFAFF','FF4B00',
'#FFF1BF','#F20058','#FFAEAC','#000001','7D7A96',
'#FDFFC6','#F2F096','#FF0080','#DE0049','521218',
'#5B0E00','#FBB500','#FBD864','#807D1A','59233C',
'#1E1E1F','#424143','#67666A','#807F83','CBC9CF',
'#3C3658','#3EC8B7','#7CD0B4','#B9D8B1','F7E0AE',
'#FFFFFF','#99B75F','#D5DD98','#EBF4DB','D8D8D8',
'#248A8A','#C9FA58','#F9E555','#FAAC38','F2572A',
'#086B63','#77A490','#E2D8C1','#BFAE95','7C7159',
'#5C4B51','#8CBEB2','#F2EBBF','#A5C88F','EF847B',
'#17162F','#89346D','#C76058','#FFB248','E8C475',
'#6E8F4A','#65D9C5','#F2E7B6','#EDA430','AB3E2C',
'#30394F','#FF434C','#6ACEEB','#EDE8DF','0E6569',
'#8E1B13','#F9E4B3','#849689','#46464A','29232E',
'#686B30','#AB9A52','#E8BA67','#D68F4F','BA512E',
'#E54E45','#DBC390','#F2F2EF','#13A3A5','403833',
'#65BA99','#59A386','#F1DDBB','#D6C4A6','E74C3C',
'#A6FFBC','#4ACFAF','#00A995','#006161','003D4C',
'#33271E','#8B7653','#C8D9A0','#FDEE9D','233331',
'#048789','#503D2E','#D44D27','#E2A72E','EFEBC8',
'#E5FF1E','#A9D943','#75A660','#698070','494D4B',
'#2DEBA2','#91F57F','#EBAA69','#E70049','2B0027',
'#990000','#336699','#DDDDDD','#999999','333333',
'#F13A4B','#3D3C3E','#22BDAF','#F4F4F4','D7D7D7',
'#F53A59','#001D2D','#15A88C','#B7D9C8','F3F5F4',];

outArrayPalette.set(colors);
}
};

CABLES.OPS["a96020ac-0832-478e-bbb7-d6246d0eeedf"]={f:Ops.Array.PaletteLibrary,objName:"Ops.Array.PaletteLibrary"};




// **************************************************************
// 
// Ops.Gl.ImageCompose.LUTMap
// 
// **************************************************************

Ops.Gl.ImageCompose.LUTMap= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={"lut_frag":"IN vec2 texCoord;\nUNI sampler2D tex;\nUNI sampler2D texLut;\nUNI float amount;\n\nvoid main()\n{\n    vec4 textureColor = texture(tex, texCoord);\n    float blueColor = textureColor.b * 63.0;\n    \n    vec2 quad1;\n    quad1.y = floor(floor(blueColor) / 8.0);\n    quad1.x = floor(blueColor) - (quad1.y * 8.0);\n    \n    vec2 quad2;\n    quad2.y = floor(ceil(blueColor) / 8.0);\n    quad2.x = ceil(blueColor) - (quad2.y * 8.0);\n    \n    highp vec2 texPos1;\n    texPos1.x = (quad1.x * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * textureColor.r);\n    texPos1.y = (quad1.y * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * textureColor.g);\n    \n    highp vec2 texPos2;\n    texPos2.x = (quad2.x * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * textureColor.r);\n    texPos2.y = (quad2.y * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * textureColor.g);\n    \n    vec4 newColor1 = texture(texLut, texPos1);\n    vec4 newColor2 = texture(texLut, texPos2);\n    \n    vec4 newColor = mix(newColor1, newColor2, fract(blueColor));\n    outColor= mix(textureColor,vec4(newColor.rgb, textureColor.w),amount);\n}\n",};
let render = op.inTrigger("render");
let trigger = op.outTrigger("trigger");
let inLut = op.inTexture("LUT Image");
let inAmount = op.inValueSlider("Amount", 1.0);

let cgl = op.patch.cgl;
let shader = new CGL.Shader(cgl, op.name, op);

shader.setSource(shader.getDefaultVertexShader(), attachments.lut_frag);
let textureUniform = new CGL.Uniform(shader, "t", "tex", 0);
let textureUniform2 = new CGL.Uniform(shader, "t", "texLut", 1);
let uniPos = new CGL.Uniform(shader, "f", "amount", inAmount);

render.onTriggered = function ()
{
    if (!CGL.TextureEffect.checkOpInEffect(op)) return;
    if (!inLut.get()) return;

    cgl.pushShader(shader);
    cgl.currentTextureEffect.bind();

    cgl.setTexture(0, cgl.currentTextureEffect.getCurrentSourceTexture().tex);

    cgl.setTexture(1, inLut.get().tex);

    cgl.currentTextureEffect.finish();
    cgl.popShader();

    trigger.trigger();
};

}
};

CABLES.OPS["baba13d7-1cc2-4ba8-b66d-05425b0e5a75"]={f:Ops.Gl.ImageCompose.LUTMap,objName:"Ops.Gl.ImageCompose.LUTMap"};




// **************************************************************
// 
// Ops.Gl.RenderToTexture_v3
// 
// **************************************************************

Ops.Gl.RenderToTexture_v3= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
const
    render = op.inTrigger("render"),
    inSize = op.inSwitch("Size", ["Canvas", "Manual"], "Canvas"),
    width = op.inValueInt("texture width", 512),
    height = op.inValueInt("texture height", 512),
    aspect = op.inBool("Auto Aspect", true),
    tfilter = op.inSwitch("filter", ["nearest", "linear", "mipmap"], "linear"),
    twrap = op.inSwitch("Wrap", ["Clamp", "Repeat", "Mirror"], "Repeat"),
    msaa = op.inSwitch("MSAA", ["none", "2x", "4x", "8x"], "none"),
    trigger = op.outTrigger("trigger"),
    tex = op.outTexture("texture"),
    texDepth = op.outTexture("textureDepth"),
    inPixelFormat = op.inDropDown("Pixel Format", CGL.Texture.PIXELFORMATS, CGL.Texture.PFORMATSTR_RGBA8UB),
    depth = op.inValueBool("Depth", true),
    clear = op.inValueBool("Clear", true);

const cgl = op.patch.cgl;
let fb = null;
let reInitFb = true;

op.setPortGroup("Size", [inSize, width, height, aspect]);

inPixelFormat.onChange =
    depth.onChange =
    clear.onChange =
    tfilter.onChange =
    twrap.onChange =
    msaa.onChange = initFbLater;

inSize.onChange = updateUi;

render.onTriggered =
    op.preRender = doRender;

updateUi();

function updateUi()
{
    width.setUiAttribs({ "greyout": inSize.get() != "Manual" });
    height.setUiAttribs({ "greyout": inSize.get() != "Manual" });
    aspect.setUiAttribs({ "greyout": inSize.get() != "Manual" });
}

function initFbLater()
{
    reInitFb = true;
}

function doRender()
{
    CGL.TextureEffect.checkOpNotInTextureEffect(op);

    if (!fb || reInitFb)
    {
        if (fb) fb.delete();

        let selectedWrap = CGL.Texture.WRAP_REPEAT;
        if (twrap.get() == "Clamp") selectedWrap = CGL.Texture.WRAP_CLAMP_TO_EDGE;
        else if (twrap.get() == "Mirror") selectedWrap = CGL.Texture.WRAP_MIRRORED_REPEAT;

        let selectFilter = CGL.Texture.FILTER_NEAREST;
        if (tfilter.get() == "nearest") selectFilter = CGL.Texture.FILTER_NEAREST;
        else if (tfilter.get() == "linear") selectFilter = CGL.Texture.FILTER_LINEAR;
        else if (tfilter.get() == "mipmap") selectFilter = CGL.Texture.FILTER_MIPMAP;

        if (inPixelFormat.get().indexOf("loat") && tfilter.get() == "mipmap") op.setUiError("fpmipmap", "Can't use mipmap and float texture at the same time");
        else op.setUiError("fpmipmap", null);

        if (cgl.glVersion >= 2)
        {
            let ms = true;
            let msSamples = 4;

            if (msaa.get() == "none")
            {
                msSamples = 0;
                ms = false;
            }
            if (msaa.get() == "2x") msSamples = 2;
            if (msaa.get() == "4x") msSamples = 4;
            if (msaa.get() == "8x") msSamples = 8;

            fb = new CGL.Framebuffer2(cgl, 8, 8,
                {
                    "name": "render2texture " + op.id,
                    "pixelFormat": inPixelFormat.get(),
                    "multisampling": ms,
                    "multisamplingSamples": msSamples,
                    "wrap": selectedWrap,
                    "filter": selectFilter,
                    "depth": depth.get(),
                    "clear": clear.get()
                });
        }
        else
        {
            fb = new CGL.Framebuffer(cgl, 8, 8, { "isFloatingPointTexture": false, "clear": clear.get() });
        }

        if (fb && fb.valid)
        {
            texDepth.setRef(fb.getTextureDepth());
            reInitFb = false;
        }
        else
        {
            fb = null;
            reInitFb = true;
        }
    }

    let setAspect = aspect.get();

    if (inSize.get() == "Canvas")
    {
        setAspect = true;
        width.set(op.patch.cgl.checkTextureSize(cgl.canvasWidth));
        height.set(op.patch.cgl.checkTextureSize(cgl.canvasHeight));
    }

    if (fb.getWidth() != op.patch.cgl.checkTextureSize(width.get()) || fb.getHeight() != op.patch.cgl.checkTextureSize(height.get()))
    {
        fb.setSize(
            op.patch.cgl.checkTextureSize(width.get()),
            op.patch.cgl.checkTextureSize(height.get()));
    }

    fb.renderStart(cgl);

    cgl.pushViewPort(0, 0, width.get(), height.get());

    if (setAspect) mat4.perspective(cgl.pMatrix, 45, width.get() / height.get(), 0.1, 1000.0);

    trigger.trigger();
    fb.renderEnd(cgl);

    cgl.popViewPort();

    texDepth.setRef(fb.getTextureDepth());
    tex.setRef(fb.getTextureColor());
}

//

}
};

CABLES.OPS["41eec5c7-c480-477a-be81-04c3efac8357"]={f:Ops.Gl.RenderToTexture_v3,objName:"Ops.Gl.RenderToTexture_v3"};




// **************************************************************
// 
// Ops.Math.Multiply3Numbers
// 
// **************************************************************

Ops.Math.Multiply3Numbers= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
const
    inR = op.inFloat("R", 0),
    inG = op.inFloat("G", 0),
    inB = op.inFloat("B", 0),

    inMul = op.inFloat("Multiply", 1),

    outR = op.outNumber("ResultR", 0),
    outG = op.outNumber("ResultG", 0),
    outB = op.outNumber("ResultB", 0);

inR.onChange =
inG.onChange =
inB.onChange =
inMul.onChange = () =>
{
    const m = inMul.get();
    outR.set(inR.get() * m);
    outG.set(inG.get() * m);
    outB.set(inB.get() * m);
};

}
};

CABLES.OPS["b058255d-2193-4399-bf40-793558362d6f"]={f:Ops.Math.Multiply3Numbers,objName:"Ops.Math.Multiply3Numbers"};




// **************************************************************
// 
// Ops.Gl.ClearColor
// 
// **************************************************************

Ops.Gl.ClearColor= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
const
    render = op.inTrigger("render"),
    trigger = op.outTrigger("trigger"),
    r = op.inFloatSlider("r", 0.1),
    g = op.inFloatSlider("g", 0.1),
    b = op.inFloatSlider("b", 0.1),
    a = op.inFloatSlider("a", 1);

r.setUiAttribs({ "colorPick": true });

const cgl = op.patch.cgl;

render.onTriggered = function ()
{
    cgl.gl.clearColor(r.get(), g.get(), b.get(), a.get());
    cgl.gl.clear(cgl.gl.COLOR_BUFFER_BIT | cgl.gl.DEPTH_BUFFER_BIT);
    trigger.trigger();
};

}
};

CABLES.OPS["19b441eb-9f63-4f35-ba08-b87841517c4d"]={f:Ops.Gl.ClearColor,objName:"Ops.Gl.ClearColor"};




// **************************************************************
// 
// Ops.Gl.Orthogonal_v2
// 
// **************************************************************

Ops.Gl.Orthogonal_v2= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
const
    render = op.inTrigger("render"),
    bounds = op.inValue("bounds", 2),
    fixAxis = op.inSwitch("Axis", ["X", "Y", "None"], "X"),
    zNear = op.inValue("frustum near", -100),
    zFar = op.inValue("frustum far", 100),
    trigger = op.outTrigger("trigger"),
    outRatio = op.outNumber("Ratio"),
    outWidth = op.outNumber("Width"),
    outHeight = op.outNumber("Height");
const cgl = op.patch.cgl;

render.onTriggered = function ()
{
    const vp = cgl.getViewPort();

    if (fixAxis.get() == "X")
    {
        const ratio = vp[3] / vp[2];

        cgl.pushPMatrix();
        mat4.ortho(
            cgl.pMatrix,
            -bounds.get(),
            bounds.get(),
            -bounds.get() * ratio,
            bounds.get() * ratio,
            parseFloat(zNear.get()),
            parseFloat(zFar.get())
        );

        outWidth.set(bounds.get() * 2);
        outHeight.set(bounds.get() * ratio * 2);
        outRatio.set(ratio);
    }
    else if (fixAxis.get() == "Y")
    {
        const ratio = vp[2] / vp[3];

        cgl.pushPMatrix();
        mat4.ortho(
            cgl.pMatrix,
            -bounds.get() * ratio,
            bounds.get() * ratio,
            -bounds.get(),
            bounds.get(),
            parseFloat(zNear.get()),
            parseFloat(zFar.get())
        );

        outWidth.set(bounds.get() * ratio * 2);
        outHeight.set(bounds.get() * 2);
        outRatio.set(ratio);
    }
    else
    {
        cgl.pushPMatrix();
        mat4.ortho(
            cgl.pMatrix,
            -bounds.get(),
            bounds.get(),
            -bounds.get(),
            bounds.get(),
            parseFloat(zNear.get()),
            parseFloat(zFar.get())
        );

        outWidth.set(bounds.get() * 2);
        outHeight.set(bounds.get() * 2);
        outRatio.set(1);
    }

    trigger.trigger();
    cgl.popPMatrix();
};

}
};

CABLES.OPS["b9235490-eaf2-4960-b1be-4279a4051ec6"]={f:Ops.Gl.Orthogonal_v2,objName:"Ops.Gl.Orthogonal_v2"};




// **************************************************************
// 
// Ops.Gl.ImageCompose.LumaKey_v3
// 
// **************************************************************

Ops.Gl.ImageCompose.LumaKey_v3= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={"lumakeyV2_frag":"IN vec2 texCoord;\nUNI float threshholdLow;\nUNI float threshholdHigh;\nUNI sampler2D text;\n\n\nfloat invLerp(float from, float to, float value) {\n  return (value - from) / (to - from);\n}\n\n\n\n\nfloat remap(float origFrom, float origTo, float targetFrom, float targetTo, float value){\n  float rel = invLerp(origFrom, origTo, value);\n  return mix(targetFrom, targetTo, rel);\n}\n\nvoid main()\n{\n   vec4 col = texture(text, texCoord );\n\n   float gray = dot(vec3(0.2126,0.7152,0.0722), col.rgb );\n\n    #ifdef INVERT\n        gray=1.0-gray;\n    #endif\n\n\n    if(gray < threshholdLow || gray > threshholdHigh) col.r=col.g=col.b=col.a=0.0;\n        #ifdef BLACKWHITE\n        else col.r=col.g=col.b=col.a=1.0;\n        #endif\n\n    #ifdef REMAP\n        col.rgb=vec3(remap(threshholdLow,threshholdHigh,0.0,1.0,gray));\n    #endif\n\n\n    #ifdef REMOVEALPHA\n        col.a=1.0;\n    #endif\n\n\n\n\n   outColor= col;\n}",};
const
    render = op.inTrigger("render"),
    trigger = op.outTrigger("trigger"),
    inInvert = op.inValueBool("Invert"),
    inBlackWhite = op.inValueBool("Black White"),
    inRemoveAlpha = op.inBool("Remove Alpha", true),
    inRemap = op.inBool("Remap", true),
    thresholdLow = op.inValueSlider("Threshold low ", 0.5),
    thresholdHigh = op.inValueSlider("Threshold high", 1.0);

const cgl = op.patch.cgl;
const shader = new CGL.Shader(cgl, "lumakey");

shader.setSource(shader.getDefaultVertexShader(), attachments.lumakeyV2_frag);
const textureUniform = new CGL.Uniform(shader, "t", "tex", 0);
const uniThresholdLow = new CGL.Uniform(shader, "f", "threshholdLow", thresholdLow);
const uniThresholdHigh = new CGL.Uniform(shader, "f", "threshholdHigh", thresholdHigh);

inRemap.onChange =
    inInvert.onChange =
    inBlackWhite.onChange =
    inRemoveAlpha.onChange = updateUi;

updateUi();

function updateUi()
{
    shader.toggleDefine("BLACKWHITE", inBlackWhite.get());
    shader.toggleDefine("INVERT", inInvert.get());
    shader.toggleDefine("REMOVEALPHA", inRemoveAlpha.get());
    shader.toggleDefine("REMAP", inRemap.get());
}

render.onTriggered = function ()
{
    if (!CGL.TextureEffect.checkOpInEffect(op)) return;

    cgl.pushShader(shader);

    cgl.currentTextureEffect.bind();
    cgl.setTexture(0, cgl.currentTextureEffect.getCurrentSourceTexture().tex);

    cgl.currentTextureEffect.finish();

    cgl.popShader();
    trigger.trigger();
};

}
};

CABLES.OPS["3305b74b-d48a-4671-b456-fd9a64e8d0f3"]={f:Ops.Gl.ImageCompose.LumaKey_v3,objName:"Ops.Gl.ImageCompose.LumaKey_v3"};




// **************************************************************
// 
// Ops.Gl.ImageCompose.AlphaMask_v2
// 
// **************************************************************

Ops.Gl.ImageCompose.AlphaMask_v2= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={"alphamask_frag":"IN vec2 texCoord;\nUNI sampler2D tex;\nUNI sampler2D image;\nUNI float amount;\n\nvoid main()\n{\n    vec4 col=vec4(0.0,0.0,0.0,1.0);\n    col=texture(tex,texCoord);\n\n#ifdef USE_TEXTURE\n    float newAlpha=0.0;\n\n    #ifdef FROM_RED\n       newAlpha=texture(image,texCoord).r;\n    #endif\n\n    #ifdef FROM_GREEN\n       newAlpha=texture(image,texCoord).g;\n    #endif\n\n    #ifdef FROM_BLUE\n       newAlpha=texture(image,texCoord).b;\n    #endif\n\n    #ifdef FROM_ALPHA\n       newAlpha=texture(image,texCoord).a;\n    #endif\n\n    #ifdef FROM_LUMINANCE\n       float gray = dot(vec3(0.2126,0.7152,0.0722), texture(image,texCoord).rgb );\n       newAlpha=gray;\n    #endif\n\n\n    newAlpha*=amount;\n\n    #ifdef INVERT\n        newAlpha=1.0-newAlpha;\n    #endif\n\n    #ifdef METH_OVERRIDE\n        col.a=newAlpha;\n    #endif\n    #ifdef METH_ADD\n        col.a+=newAlpha;\n    #endif\n    #ifdef METH_MUL\n        col.a*=newAlpha;\n    #endif\n\n#endif\n#ifndef USE_TEXTURE\n    col.a*=amount;\n    // col.g=1.0;\n#endif\n\n    outColor= col;\n}",};
const
    render = op.inTrigger("render"),
    inAmount = op.inFloatSlider("Amount", 1),
    inMethod = op.inSwitch("Method", ["Override", "Mul", "Add"], "Override"),
    inInvert = op.inBool("Invert", false),
    image = op.inTexture("image"),
    next = op.outTrigger("trigger");

const cgl = this.patch.cgl;
const shader = new CGL.Shader(cgl, op.name, op);
shader.setSource(shader.getDefaultVertexShader(), attachments.alphamask_frag);

const textureUniform = new CGL.Uniform(shader, "t", "tex", 0);
const textureDisplaceUniform = new CGL.Uniform(shader, "t", "image", 1);
const amountUniform = new CGL.Uniform(shader, "f", "amount", inAmount);

// const method = this.addInPort(new CABLES.Port(this, "method", CABLES.OP_PORT_TYPE_VALUE, { "display": "dropdown", "values": ["luminance", "image alpha", "red", "green", "blue"] }));
const method = op.inDropDown("method", ["luminance", "image alpha", "red", "green", "blue"], "luminance");

image.onChange =
inMethod.onChange =
inInvert.onChange =
method.onChange = function ()
{
    shader.toggleDefine("FROM_LUMINANCE", method.get() == "luminance");
    shader.toggleDefine("FROM_ALPHA", method.get() == "image alpha");
    shader.toggleDefine("FROM_RED", method.get() == "red");
    shader.toggleDefine("FROM_GREEN", method.get() == "green");
    shader.toggleDefine("FROM_BLUR", method.get() == "blue");
    shader.toggleDefine("USE_TEXTURE", image.get());

    shader.toggleDefine("INVERT", inInvert.get());
    shader.toggleDefine("METH_MUL", inMethod.get() == "Mul");
    shader.toggleDefine("METH_ADD", inMethod.get() == "Add");
    shader.toggleDefine("METH_OVERRIDE", inMethod.get() == "Override");
};

render.onTriggered = function ()
{
    if (!CGL.TextureEffect.checkOpInEffect(op, 3)) return;
    // if (!image.get()) return next.trigger();

    cgl.pushShader(shader);
    cgl.currentTextureEffect.bind();

    cgl.setTexture(0, cgl.currentTextureEffect.getCurrentSourceTexture().tex);

    if (image.get() && image.get().tex) cgl.setTexture(1, image.get().tex);

    cgl.currentTextureEffect.finish();
    cgl.popShader();

    next.trigger();
};

}
};

CABLES.OPS["a971aaa4-565f-47cf-8a4f-61a3a4378183"]={f:Ops.Gl.ImageCompose.AlphaMask_v2,objName:"Ops.Gl.ImageCompose.AlphaMask_v2"};




// **************************************************************
// 
// Ops.Patch.PLH3vXR.IsLayerVisible1
// 
// **************************************************************

Ops.Patch.PLH3vXR.IsLayerVisible1= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={"inc_gen_ports_js":"const port_mqmfkaq8t=op.inFloat(\"mqmfkaq8t\",0);\nport_mqmfkaq8t.setUiAttribs({title:\"LayerIndex\",increment:\"integer\",});\nport_mqmfkaq8t.setUiAttribs({\"values\":[\"\"]});\n\nconst port_vfunjpwkx=op.outNumber(\"vfunjpwkx\");\nport_vfunjpwkx.setUiAttribs({title:\"Visible\",increment:\"integer\",});\nport_vfunjpwkx.setUiAttribs({\"values\":[\"\"]});\n\nop.initInnerPorts=function(addedOps)\n{\n  for(let i=0;i<addedOps.length;i++)\n  {\n    if(addedOps[i].innerInput)\n    {\nconst innerOut_mqmfkaq8t = addedOps[i].outNumber(\"innerOut_mqmfkaq8t\");\ninnerOut_mqmfkaq8t.set(port_mqmfkaq8t.get() );\ninnerOut_mqmfkaq8t.setUiAttribs({title:\"LayerIndex\"});\nport_mqmfkaq8t.on(\"change\", (a,v) => { innerOut_mqmfkaq8t.set(a); });\n\n    }\nif(addedOps[i].innerOutput)\n{\nconst innerIn_vfunjpwkx = addedOps[i].inFloat(\"innerIn_vfunjpwkx\");\ninnerIn_vfunjpwkx.setUiAttribs({title:\"Visible\"});\ninnerIn_vfunjpwkx.on(\"change\", (a,v) => { port_vfunjpwkx.set(a); });\n\n}\n}\n};\n","subpatch_json":"{\"ops\":[{\"id\":\"sp3-0\",\"uiAttribs\":{\"subPatch\":\"1gb8io0qj\"},\"storage\":{\"blueprintVer\":2},\"portsOut\":[{\"name\":\"Result\",\"links\":[{\"portIn\":\"innerIn_vfunjpwkx\",\"portOut\":\"Result\",\"objIn\":\"sp3-7\",\"objOut\":\"sp3-0\"}]}],\"objName\":\"Ops.Ui.VizNumber\"},{\"id\":\"sp3-1\",\"uiAttribs\":{\"subPatch\":\"1gb8io0qj\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"Variable\",\"value\":\"LayerIndex\"}],\"portsOut\":[{\"name\":\"Value\",\"links\":[{\"portIn\":\"number1\",\"portOut\":\"Value\",\"objIn\":\"sp3-3\",\"objOut\":\"sp3-1\"},{\"portIn\":\"number1\",\"portOut\":\"Value\",\"objIn\":\"sp3-4\",\"objOut\":\"sp3-1\"}]}],\"objName\":\"Ops.Vars.VarGetNumber_v2\"},{\"id\":\"sp3-2\",\"uiAttribs\":{\"subPatch\":\"1gb8io0qj\"},\"storage\":{\"blueprintVer\":2},\"portsOut\":[{\"name\":\"result\",\"links\":[{\"portIn\":\"bool 2\",\"portOut\":\"result\",\"objIn\":\"sp3-5\",\"objOut\":\"sp3-2\"}]}],\"objName\":\"Ops.Math.Compare.Equals\"},{\"id\":\"sp3-3\",\"uiAttribs\":{\"subPatch\":\"1gb8io0qj\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"number2\",\"value\":1}],\"portsOut\":[{\"name\":\"result\",\"links\":[{\"portIn\":\"number1\",\"portOut\":\"result\",\"objIn\":\"sp3-2\",\"objOut\":\"sp3-3\"}]}],\"objName\":\"Ops.Math.Subtract\"},{\"id\":\"sp3-4\",\"uiAttribs\":{\"subPatch\":\"1gb8io0qj\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"number2\",\"value\":0}],\"portsOut\":[{\"name\":\"result\",\"links\":[{\"portIn\":\"bool 1\",\"portOut\":\"result\",\"objIn\":\"sp3-5\",\"objOut\":\"sp3-4\"}]}],\"objName\":\"Ops.Math.Compare.Equals\"},{\"id\":\"sp3-5\",\"uiAttribs\":{\"subPatch\":\"1gb8io0qj\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"bool 3\",\"value\":0},{\"name\":\"bool 4\",\"value\":0},{\"name\":\"bool 5\",\"value\":0},{\"name\":\"bool 6\",\"value\":0},{\"name\":\"bool 7\",\"value\":0},{\"name\":\"bool 8\",\"value\":0},{\"name\":\"bool 9\",\"value\":0},{\"name\":\"bool 10\",\"value\":0}],\"portsOut\":[{\"name\":\"result\",\"links\":[{\"portIn\":\"Number\",\"portOut\":\"result\",\"objIn\":\"sp3-0\",\"objOut\":\"sp3-5\"}]}],\"objName\":\"Ops.Boolean.Or\"},{\"id\":\"sp3-6\",\"uiAttribs\":{\"subPatch\":\"1gb8io0qj\"},\"storage\":{\"blueprintVer\":2},\"portsOut\":[{\"name\":\"innerOut_mqmfkaq8t\",\"title\":\"LayerIndex\",\"links\":[{\"portIn\":\"number2\",\"portOut\":\"innerOut_mqmfkaq8t\",\"objIn\":\"sp3-2\",\"objOut\":\"sp3-6\"}]}],\"objName\":\"Ops.Ui.SubPatchInput\"},{\"id\":\"sp3-7\",\"uiAttribs\":{\"subPatch\":\"1gb8io0qj\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"innerIn_vfunjpwkx\",\"title\":\"Visible\"}],\"objName\":\"Ops.Ui.SubPatchOutput\"}]}",};
const port_mqmfkaq8t=op.inFloat("mqmfkaq8t",0);
port_mqmfkaq8t.setUiAttribs({title:"LayerIndex",increment:"integer",});
port_mqmfkaq8t.setUiAttribs({"values":[""]});

const port_vfunjpwkx=op.outNumber("vfunjpwkx");
port_vfunjpwkx.setUiAttribs({title:"Visible",increment:"integer",});
port_vfunjpwkx.setUiAttribs({"values":[""]});

op.initInnerPorts=function(addedOps)
{
  for(let i=0;i<addedOps.length;i++)
  {
    if(addedOps[i].innerInput)
    {
const innerOut_mqmfkaq8t = addedOps[i].outNumber("innerOut_mqmfkaq8t");
innerOut_mqmfkaq8t.set(port_mqmfkaq8t.get() );
innerOut_mqmfkaq8t.setUiAttribs({title:"LayerIndex"});
port_mqmfkaq8t.on("change", (a,v) => { innerOut_mqmfkaq8t.set(a); });

    }
if(addedOps[i].innerOutput)
{
const innerIn_vfunjpwkx = addedOps[i].inFloat("innerIn_vfunjpwkx");
innerIn_vfunjpwkx.setUiAttribs({title:"Visible"});
innerIn_vfunjpwkx.on("change", (a,v) => { port_vfunjpwkx.set(a); });

}
}
};

const patchId = "bp2sub_" + op.id;

new CABLES.SubPatchOp(op, { "subId": patchId });

initializeSubpatch();

function initializeSubpatch()
{
    const p = JSON.parse(attachments.subpatch_json);

    CABLES.Patch.replaceOpIds(p,
        {
            "parentSubPatchId": patchId,
            "prefixHash": patchId,
            "oldIdAsRef": true,
            "doNotUnlinkLostLinks": true
        });

    for (let i = 0; i < p.ops.length; i++)
    {
        p.ops[i].uiAttribs.blueprintSubpatch2 = true;
    }

    op.loadDependencies(p, () =>
    {
        op.patch.deSerialize(p, { "opsCreated": op.initInnerPorts });
        if (CABLES.UI)gui.savedState.setSaved("blueprintloaded", patchId);
        op.patch.emitEvent("subpatchExpose", patchId);
        op.setStorage({ "blueprintVer": 2 });
        op.patch.emitEvent("subpatchExpose", patchId);
    });
}

}
};

CABLES.OPS["bfa82392-6e0d-4770-abbe-5625e5900d52"]={f:Ops.Patch.PLH3vXR.IsLayerVisible1,objName:"Ops.Patch.PLH3vXR.IsLayerVisible1"};




// **************************************************************
// 
// Ops.Patch.PLH3vXR.DisplayBounds
// 
// **************************************************************

Ops.Patch.PLH3vXR.DisplayBounds= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={"inc_gen_ports_js":"const port_br9ezjywo=op.outNumber(\"br9ezjywo\");\nport_br9ezjywo.setUiAttribs({title:\"xMin\",});\nport_br9ezjywo.setUiAttribs({\"values\":[\"\"]});\n\nconst port_ves8t32bh=op.outNumber(\"ves8t32bh\");\nport_ves8t32bh.setUiAttribs({title:\"xMax\",});\nport_ves8t32bh.setUiAttribs({\"values\":[\"\"]});\n\nconst port_s4x9bwpue=op.outNumber(\"s4x9bwpue\");\nport_s4x9bwpue.setUiAttribs({title:\"yMin\",});\nport_s4x9bwpue.setUiAttribs({\"values\":[\"\"]});\n\nconst port_vvze3lkl2=op.outNumber(\"vvze3lkl2\");\nport_vvze3lkl2.setUiAttribs({title:\"yMax\",});\nport_vvze3lkl2.setUiAttribs({\"values\":[\"\"]});\n\nconst port_fimwluhh4=op.outNumber(\"fimwluhh4\");\nport_fimwluhh4.setUiAttribs({title:\"Width\",});\nport_fimwluhh4.setUiAttribs({\"values\":[\"\"]});\n\nconst port_dzq5f4w23=op.outNumber(\"dzq5f4w23\");\nport_dzq5f4w23.setUiAttribs({title:\"Height\",});\nport_dzq5f4w23.setUiAttribs({\"values\":[\"\"]});\n\nconst port_l666gc2uq=op.outNumber(\"l666gc2uq\");\nport_l666gc2uq.setUiAttribs({title:\"centerX\",});\nport_l666gc2uq.setUiAttribs({\"values\":[\"\"]});\n\nconst port_sfmosbvpy=op.outNumber(\"sfmosbvpy\");\nport_sfmosbvpy.setUiAttribs({title:\"centerY\",});\nport_sfmosbvpy.setUiAttribs({\"values\":[\"\"]});\n\nop.initInnerPorts=function(addedOps)\n{\n  for(let i=0;i<addedOps.length;i++)\n  {\n    if(addedOps[i].innerInput)\n    {\n    }\nif(addedOps[i].innerOutput)\n{\nconst innerIn_br9ezjywo = addedOps[i].inFloat(\"innerIn_br9ezjywo\");\ninnerIn_br9ezjywo.setUiAttribs({title:\"xMin\"});\ninnerIn_br9ezjywo.on(\"change\", (a,v) => { port_br9ezjywo.set(a); });\n\nconst innerIn_ves8t32bh = addedOps[i].inFloat(\"innerIn_ves8t32bh\");\ninnerIn_ves8t32bh.setUiAttribs({title:\"xMax\"});\ninnerIn_ves8t32bh.on(\"change\", (a,v) => { port_ves8t32bh.set(a); });\n\nconst innerIn_s4x9bwpue = addedOps[i].inFloat(\"innerIn_s4x9bwpue\");\ninnerIn_s4x9bwpue.setUiAttribs({title:\"yMin\"});\ninnerIn_s4x9bwpue.on(\"change\", (a,v) => { port_s4x9bwpue.set(a); });\n\nconst innerIn_vvze3lkl2 = addedOps[i].inFloat(\"innerIn_vvze3lkl2\");\ninnerIn_vvze3lkl2.setUiAttribs({title:\"yMax\"});\ninnerIn_vvze3lkl2.on(\"change\", (a,v) => { port_vvze3lkl2.set(a); });\n\nconst innerIn_fimwluhh4 = addedOps[i].inFloat(\"innerIn_fimwluhh4\");\ninnerIn_fimwluhh4.setUiAttribs({title:\"Width\"});\ninnerIn_fimwluhh4.on(\"change\", (a,v) => { port_fimwluhh4.set(a); });\n\nconst innerIn_dzq5f4w23 = addedOps[i].inFloat(\"innerIn_dzq5f4w23\");\ninnerIn_dzq5f4w23.setUiAttribs({title:\"Height\"});\ninnerIn_dzq5f4w23.on(\"change\", (a,v) => { port_dzq5f4w23.set(a); });\n\nconst innerIn_l666gc2uq = addedOps[i].inFloat(\"innerIn_l666gc2uq\");\ninnerIn_l666gc2uq.setUiAttribs({title:\"centerX\"});\ninnerIn_l666gc2uq.on(\"change\", (a,v) => { port_l666gc2uq.set(a); });\n\nconst innerIn_sfmosbvpy = addedOps[i].inFloat(\"innerIn_sfmosbvpy\");\ninnerIn_sfmosbvpy.setUiAttribs({title:\"centerY\"});\ninnerIn_sfmosbvpy.on(\"change\", (a,v) => { port_sfmosbvpy.set(a); });\n\n}\n}\n};\n","subpatch_json":"{\"ops\":[{\"id\":\"sp92-0\",\"uiAttribs\":{\"subPatch\":\"k8410uqu2\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"Variable\",\"value\":\"MarginHorizontal\"}],\"portsOut\":[{\"name\":\"Value\",\"links\":[{\"portIn\":\"number2\",\"portOut\":\"Value\",\"objIn\":\"sp92-2\",\"objOut\":\"sp92-0\"},{\"portIn\":\"number2\",\"portOut\":\"Value\",\"objIn\":\"sp92-3\",\"objOut\":\"sp92-0\"}]}],\"objName\":\"Ops.Vars.VarGetNumber_v2\"},{\"id\":\"sp92-1\",\"uiAttribs\":{\"subPatch\":\"k8410uqu2\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"Variable\",\"value\":\"MarginVertical\"}],\"portsOut\":[{\"name\":\"Value\",\"links\":[{\"portIn\":\"number2\",\"portOut\":\"Value\",\"objIn\":\"sp92-4\",\"objOut\":\"sp92-1\"},{\"portIn\":\"number2\",\"portOut\":\"Value\",\"objIn\":\"sp92-5\",\"objOut\":\"sp92-1\"}]}],\"objName\":\"Ops.Vars.VarGetNumber_v2\"},{\"id\":\"sp92-2\",\"uiAttribs\":{\"subPatch\":\"k8410uqu2\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"number1\",\"value\":-1}],\"portsOut\":[{\"name\":\"result\",\"links\":[{\"portIn\":\"number2\",\"portOut\":\"result\",\"objIn\":\"sp92-7\",\"objOut\":\"sp92-2\"},{\"portIn\":\"innerIn_br9ezjywo\",\"portOut\":\"result\",\"objIn\":\"sp92-9\",\"objOut\":\"sp92-2\"},{\"portIn\":\"Value 1\",\"portOut\":\"result\",\"objIn\":\"sp92-10\",\"objOut\":\"sp92-2\"}]}],\"objName\":\"Ops.Math.Sum\"},{\"id\":\"sp92-3\",\"uiAttribs\":{\"subPatch\":\"k8410uqu2\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"number1\",\"value\":1}],\"portsOut\":[{\"name\":\"result\",\"links\":[{\"portIn\":\"number1\",\"portOut\":\"result\",\"objIn\":\"sp92-7\",\"objOut\":\"sp92-3\"},{\"portIn\":\"innerIn_ves8t32bh\",\"portOut\":\"result\",\"objIn\":\"sp92-9\",\"objOut\":\"sp92-3\"},{\"portIn\":\"Value 2\",\"portOut\":\"result\",\"objIn\":\"sp92-10\",\"objOut\":\"sp92-3\"}]}],\"objName\":\"Ops.Math.Subtract\"},{\"id\":\"sp92-4\",\"uiAttribs\":{\"subPatch\":\"k8410uqu2\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"number1\",\"value\":-1}],\"portsOut\":[{\"name\":\"result\",\"links\":[{\"portIn\":\"number2\",\"portOut\":\"result\",\"objIn\":\"sp92-6\",\"objOut\":\"sp92-4\"},{\"portIn\":\"innerIn_s4x9bwpue\",\"portOut\":\"result\",\"objIn\":\"sp92-9\",\"objOut\":\"sp92-4\"},{\"portIn\":\"Value 1\",\"portOut\":\"result\",\"objIn\":\"sp92-11\",\"objOut\":\"sp92-4\"}]}],\"objName\":\"Ops.Math.Sum\"},{\"id\":\"sp92-5\",\"uiAttribs\":{\"subPatch\":\"k8410uqu2\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"number1\",\"value\":1}],\"portsOut\":[{\"name\":\"result\",\"links\":[{\"portIn\":\"number1\",\"portOut\":\"result\",\"objIn\":\"sp92-6\",\"objOut\":\"sp92-5\"},{\"portIn\":\"innerIn_vvze3lkl2\",\"portOut\":\"result\",\"objIn\":\"sp92-9\",\"objOut\":\"sp92-5\"},{\"portIn\":\"Value 2\",\"portOut\":\"result\",\"objIn\":\"sp92-11\",\"objOut\":\"sp92-5\"}]}],\"objName\":\"Ops.Math.Subtract\"},{\"id\":\"sp92-6\",\"uiAttribs\":{\"subPatch\":\"k8410uqu2\"},\"storage\":{\"blueprintVer\":2},\"portsOut\":[{\"name\":\"result\",\"links\":[{\"portIn\":\"innerIn_dzq5f4w23\",\"portOut\":\"result\",\"objIn\":\"sp92-9\",\"objOut\":\"sp92-6\"}]}],\"objName\":\"Ops.Math.Subtract\"},{\"id\":\"sp92-7\",\"uiAttribs\":{\"subPatch\":\"k8410uqu2\"},\"storage\":{\"blueprintVer\":2},\"portsOut\":[{\"name\":\"result\",\"links\":[{\"portIn\":\"innerIn_fimwluhh4\",\"portOut\":\"result\",\"objIn\":\"sp92-9\",\"objOut\":\"sp92-7\"}]}],\"objName\":\"Ops.Math.Subtract\"},{\"id\":\"sp92-8\",\"uiAttribs\":{\"subPatch\":\"k8410uqu2\"},\"storage\":{\"blueprintVer\":2},\"objName\":\"Ops.Ui.SubPatchInput\"},{\"id\":\"sp92-9\",\"uiAttribs\":{\"subPatch\":\"k8410uqu2\"},\"storage\":{\"blueprintVer\":2},\"portsIn\":[{\"name\":\"innerIn_br9ezjywo\",\"title\":\"xMin\"},{\"name\":\"innerIn_ves8t32bh\",\"title\":\"xMax\"},{\"name\":\"innerIn_s4x9bwpue\",\"title\":\"yMin\"},{\"name\":\"innerIn_vvze3lkl2\",\"title\":\"yMax\"},{\"name\":\"innerIn_fimwluhh4\",\"title\":\"Width\"},{\"name\":\"innerIn_dzq5f4w23\",\"title\":\"Height\"},{\"name\":\"innerIn_l666gc2uq\",\"title\":\"centerX\"},{\"name\":\"innerIn_sfmosbvpy\",\"title\":\"centerY\"}],\"objName\":\"Ops.Ui.SubPatchOutput\"},{\"id\":\"sp92-10\",\"uiAttribs\":{\"subPatch\":\"k8410uqu2\"},\"portsIn\":[{\"name\":\"Percentage\",\"value\":0.5}],\"portsOut\":[{\"name\":\"Result\",\"links\":[{\"portIn\":\"innerIn_l666gc2uq\",\"portOut\":\"Result\",\"objIn\":\"sp92-9\",\"objOut\":\"sp92-10\"}]}],\"storage\":{\"ref\":\"sp92-10\",\"blueprintVer\":2},\"objName\":\"Ops.Math.Interpolate\"},{\"id\":\"sp92-11\",\"uiAttribs\":{\"subPatch\":\"k8410uqu2\"},\"portsIn\":[{\"name\":\"Percentage\",\"value\":0.5}],\"portsOut\":[{\"name\":\"Result\",\"links\":[{\"portIn\":\"innerIn_sfmosbvpy\",\"portOut\":\"Result\",\"objIn\":\"sp92-9\",\"objOut\":\"sp92-11\"}]}],\"storage\":{\"ref\":\"sp92-11\",\"blueprintVer\":2},\"objName\":\"Ops.Math.Interpolate\"}]}",};
const port_br9ezjywo=op.outNumber("br9ezjywo");
port_br9ezjywo.setUiAttribs({title:"xMin",});
port_br9ezjywo.setUiAttribs({"values":[""]});

const port_ves8t32bh=op.outNumber("ves8t32bh");
port_ves8t32bh.setUiAttribs({title:"xMax",});
port_ves8t32bh.setUiAttribs({"values":[""]});

const port_s4x9bwpue=op.outNumber("s4x9bwpue");
port_s4x9bwpue.setUiAttribs({title:"yMin",});
port_s4x9bwpue.setUiAttribs({"values":[""]});

const port_vvze3lkl2=op.outNumber("vvze3lkl2");
port_vvze3lkl2.setUiAttribs({title:"yMax",});
port_vvze3lkl2.setUiAttribs({"values":[""]});

const port_fimwluhh4=op.outNumber("fimwluhh4");
port_fimwluhh4.setUiAttribs({title:"Width",});
port_fimwluhh4.setUiAttribs({"values":[""]});

const port_dzq5f4w23=op.outNumber("dzq5f4w23");
port_dzq5f4w23.setUiAttribs({title:"Height",});
port_dzq5f4w23.setUiAttribs({"values":[""]});

const port_l666gc2uq=op.outNumber("l666gc2uq");
port_l666gc2uq.setUiAttribs({title:"centerX",});
port_l666gc2uq.setUiAttribs({"values":[""]});

const port_sfmosbvpy=op.outNumber("sfmosbvpy");
port_sfmosbvpy.setUiAttribs({title:"centerY",});
port_sfmosbvpy.setUiAttribs({"values":[""]});

op.initInnerPorts=function(addedOps)
{
  for(let i=0;i<addedOps.length;i++)
  {
    if(addedOps[i].innerInput)
    {
    }
if(addedOps[i].innerOutput)
{
const innerIn_br9ezjywo = addedOps[i].inFloat("innerIn_br9ezjywo");
innerIn_br9ezjywo.setUiAttribs({title:"xMin"});
innerIn_br9ezjywo.on("change", (a,v) => { port_br9ezjywo.set(a); });

const innerIn_ves8t32bh = addedOps[i].inFloat("innerIn_ves8t32bh");
innerIn_ves8t32bh.setUiAttribs({title:"xMax"});
innerIn_ves8t32bh.on("change", (a,v) => { port_ves8t32bh.set(a); });

const innerIn_s4x9bwpue = addedOps[i].inFloat("innerIn_s4x9bwpue");
innerIn_s4x9bwpue.setUiAttribs({title:"yMin"});
innerIn_s4x9bwpue.on("change", (a,v) => { port_s4x9bwpue.set(a); });

const innerIn_vvze3lkl2 = addedOps[i].inFloat("innerIn_vvze3lkl2");
innerIn_vvze3lkl2.setUiAttribs({title:"yMax"});
innerIn_vvze3lkl2.on("change", (a,v) => { port_vvze3lkl2.set(a); });

const innerIn_fimwluhh4 = addedOps[i].inFloat("innerIn_fimwluhh4");
innerIn_fimwluhh4.setUiAttribs({title:"Width"});
innerIn_fimwluhh4.on("change", (a,v) => { port_fimwluhh4.set(a); });

const innerIn_dzq5f4w23 = addedOps[i].inFloat("innerIn_dzq5f4w23");
innerIn_dzq5f4w23.setUiAttribs({title:"Height"});
innerIn_dzq5f4w23.on("change", (a,v) => { port_dzq5f4w23.set(a); });

const innerIn_l666gc2uq = addedOps[i].inFloat("innerIn_l666gc2uq");
innerIn_l666gc2uq.setUiAttribs({title:"centerX"});
innerIn_l666gc2uq.on("change", (a,v) => { port_l666gc2uq.set(a); });

const innerIn_sfmosbvpy = addedOps[i].inFloat("innerIn_sfmosbvpy");
innerIn_sfmosbvpy.setUiAttribs({title:"centerY"});
innerIn_sfmosbvpy.on("change", (a,v) => { port_sfmosbvpy.set(a); });

}
}
};

const patchId = "bp2sub_" + op.id;

new CABLES.SubPatchOp(op, { "subId": patchId });

initializeSubpatch();

function initializeSubpatch()
{
    const p = JSON.parse(attachments.subpatch_json);

    CABLES.Patch.replaceOpIds(p,
        {
            "parentSubPatchId": patchId,
            "prefixHash": patchId,
            "oldIdAsRef": true,
            "doNotUnlinkLostLinks": true
        });

    for (let i = 0; i < p.ops.length; i++)
    {
        p.ops[i].uiAttribs.blueprintSubpatch2 = true;
    }

    op.loadDependencies(p, () =>
    {
        op.patch.deSerialize(p, { "opsCreated": op.initInnerPorts });
        if (CABLES.UI)gui.savedState.setSaved("blueprintloaded", patchId);
        op.patch.emitEvent("subpatchExpose", patchId);
        op.setStorage({ "blueprintVer": 2 });
        op.patch.emitEvent("subpatchExpose", patchId);
    });
}

}
};

CABLES.OPS["2bd13c56-6c39-4b3d-8d90-fd71d2194984"]={f:Ops.Patch.PLH3vXR.DisplayBounds,objName:"Ops.Patch.PLH3vXR.DisplayBounds"};




// **************************************************************
// 
// Ops.Ui.VizBool
// 
// **************************************************************

Ops.Ui.VizBool= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
const
    inNum = op.inBool("Boolean", 0),
    outBool = op.outBoolNum("Bool");

op.setUiAttrib({ "height": 100, "width": 100, "resizable": true });

inNum.onChange = () =>
{
    outBool.set(inNum.get());
};

op.renderVizLayer = (ctx, layer) =>
{
    if (layer.width <= 0 || layer.height <= 0) return;

    ctx.fillStyle = "#222";
    ctx.fillRect(layer.x, layer.y, layer.width, layer.height);

    let isTrue = !!inNum.get();

    let circle = new Path2D();
    let radius = Math.min(layer.height, layer.width) / 2.4 * 0.8;
    if (radius < 0)radius = 0;
    circle.arc(layer.x + layer.width / 2, layer.y + layer.height / 2, radius, 0, 2 * Math.PI, false);

    ctx.strokeStyle = "#555";
    ctx.lineWidth = 7 * layer.scale;
    ctx.stroke(circle);

    if (isTrue)
    {
        if (op.uiAttribs.color)ctx.fillStyle = op.uiAttribs.color;
        else ctx.fillStyle = "#ccc";

        let circle = new Path2D();
        circle.arc(layer.x + layer.width / 2, layer.y + layer.height / 2, radius - (ctx.lineWidth / 2), 0, 2 * Math.PI, false);
        ctx.fill(circle);
    }
};

}
};

CABLES.OPS["cf194306-175b-416a-b90e-31ff2192a190"]={f:Ops.Ui.VizBool,objName:"Ops.Ui.VizBool"};




// **************************************************************
// 
// Ops.Gl.Matrix.Billboard
// 
// **************************************************************

Ops.Gl.Matrix.Billboard= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
const exec = op.inTrigger("Exec");
const next = op.outTrigger("Next");

const cgl = op.patch.cgl;

let mm = mat4.create();
let mv = mat4.create();
let m = mat4.create();
let mempty = mat4.create();

exec.onTriggered = function ()
{
    mat4.invert(mm, cgl.mMatrix);
    mat4.invert(mv, cgl.vMatrix);

    mat4.mul(mm, mm, mv);

    mm[12] = 0;
    mm[13] = 0;
    mm[14] = 0;

    cgl.pushModelMatrix();
    cgl.pushViewMatrix();
    mat4.mul(cgl.mMatrix, cgl.mMatrix, mm);
    next.trigger();
    cgl.popViewMatrix();
    cgl.popModelMatrix();
};

}
};

CABLES.OPS["d41e676e-d8a7-4a1e-8abf-f1bddfc982d5"]={f:Ops.Gl.Matrix.Billboard,objName:"Ops.Gl.Matrix.Billboard"};




// **************************************************************
// 
// Ops.Patch.PLH3vXR.AnimationPointsGenerator_SingleLayer
// 
// **************************************************************

Ops.Patch.PLH3vXR.AnimationPointsGenerator_SingleLayer= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
const
    updateDisplayTrigger = op.inTrigger("Update Display Trigger"),
    calculateDataTrigger = op.inTrigger("Calculate Data Trigger"),
    triggerIn = op.inTrigger("Trigger In"),
    layerIndex = op.inValueInt("Layer Index", 0),
    pointCount = op.inValueInt("Point Count", 52),
    barCount = op.inValueInt("Bar Count", 20),
    animation = op.inValueFloat("Animation", 1),
    timelineArray = op.inArray("Timeline Array"),

    apiData = op.inArray("API Data"),
    apiRangeMin = op.inValueFloat("API Range Min", 0),
    apiRangeMax = op.inValueFloat("API Range Max", 1),

    rangeXMin = op.inValueFloat("Dst RangeX Min", -1),
    rangeXMax = op.inValueFloat("Dst RangeX Max", 1),
    rangeYMin = op.inValueFloat("Dst RangeY Min", -1),
    rangeYMax = op.inValueFloat("Dst RangeY Max", 1),

    layerInterval = op.inValueFloat("Layer Interval", 0.5),
    imageIntervalX = op.inValueFloat("Image Interval X", 0.08),
    imageIntervalZ = op.inValueFloat("Image Interval Z", 0.001),

    pointDataOut = op.outArray("Point Data List"),  // mapped API data at each point
    barDataOut = op.outArray("Bar Data List"),      // mapped API data used by each bar

    pointOut = op.outArray("Point List"),           // mapped position list of points
    colorfulPointOut = op.outArray("Colorful Point List"),           // mapped position list of points
    barOut = op.outArray("Bar List"),               // mapped position list of images
    barSizeOut = op.outArray("Bar Size List"),      // mapped size list of images
    barAnimOut = op.outArray("Bar Anim List"),      // animation

    segmentOut = op.outArray("Segment PosXY_SizeXY List"),   // mapped posXY and sizeXY of each segment formatted in vector4

    geomOut = op.outObject("Geometry"),             // geometry

    // pointDataOut2 = op.outArray("Second Layer Point Data List"),
    barDataOut2 = op.outArray("Second Layer Bar Data List"),

    // pointOut2 = op.outArray("Second Layer Point List"),
    barOut2 = op.outArray("Second Layer Bar List"),
    barSizeOut2 = op.outArray("Second Layer Bar Size List"),
    barAnimOut2 = op.outArray("Second Layer Bar Anim List"),

    // aniamtion
    animPointOut = op.outArray("Current Animation Point");

op.setPortGroup("Display Range", [rangeXMin, rangeXMax, rangeYMin, rangeYMax]);
op.setPortGroup("First Layer", [pointDataOut, barDataOut, pointOut, barOut, barSizeOut, barAnimOut, segmentOut, geomOut]);
op.setPortGroup("Second Layer", [ barDataOut2, barOut2, barSizeOut2, barAnimOut2]);
// op.setPortGroup("Output Range", [new_min, new_max]);


// Data
let pointDataArray = Array(1);  // original data array - 1 dimentional
let barDataArray = Array(1);    // original bar data array - 1 dimentional

// UI
let originalPosArray = Array(1);    // full length point posXYZ array
let pointArray = Array(1);      // picked point posXYZ array
let colorfulPointArray = Array(1);
let originalBarArray = Array(1);
let barArray = Array(1);
let barSizeArray = Array(1);
let barAnimArray = Array(1);
let segmentArray = Array(1);

// Geometry
let geom = new CGL.Geometry();
let vertexList = Array(1);
let indexList = Array(1);
let uvList = Array(1);

// Second Layer
let barDataArray2 = Array(1);    // original bar data array - 1 dimentional

let barArray2 = Array(1);
let barSizeArray2 = Array(1);
let barAnimArray2 = Array(1);

//
let currentAnimationPoint = Array(1);

let r = 0;
let x = 0;


triggerIn.onTriggered = exec
function exec()
{
    calculateData();

    updateDisplay();

}

let needCalculateData = false;
function setNeedCalculateData()
{
    needCalculateData = true;
}

pointCount.onChange =
barCount.onChange =
apiData.onChange = setNeedCalculateData

calculateDataTrigger.onTriggered = calculateData;
function calculateData()
{
    if(needCalculateData == false)
        return;
    needCalculateData = false;

    const inArray = apiData.get();
    if (!inArray || inArray.length === 0)
    {
        return;
    }

    let need_update_point_array = false;
    if(pointDataArray.length != pointCount.get())
    {
        need_update_point_array = true;
    }

    // First Layer
    const point_count = pointCount.get();
    const bar_count = barCount.get();
    pointDataArray.length = pointCount.get();
    barDataArray.length = barCount.get();

    let percentage = 0;
    for(let i=0; i<point_count; i++)
    {
        percentage =  parseFloat(i)/parseFloat(point_count-1);

        pointDataArray[i] =  GetInterpolatedValue(inArray, percentage);
    }

    for(let i=0; i<bar_count; i++)
    {
        percentage =  parseFloat(i+0.5)/parseFloat(bar_count);

         // Method 1: Lerp linear
        barDataArray[i] =  GetInterpolatedValue(inArray, percentage);

        // Method 2: Find maximum in segment
        // barDataArray[i] =  GetHighestValueInSegment(inArray, bar_count, i);

        // Method 3: Calculate average in segment
        // barDataArray[i] =  GetAverageHeightInSegment(inArray, bar_count, i);
    }

    pointDataOut.setRef(pointDataArray);
    barDataOut.setRef(barDataArray);

    if(need_update_point_array)
    {
        rebuildGeometry();
    }

    // Second Layer
    /*
    const second_layer_bar_count = Math.max(0, bar_count - 1);
    barDataArray2.length =  second_layer_bar_count;
    for(let i=0; i<second_layer_bar_count; i++)
    {
        // Mean height of adjacent bars
        let average = (barDataArray[i] + barDataArray[i+1]) * 0.5;

        // Higher First Layer buildings have lower possibility to have second Layer
        let probability = MapRange(average, 0.3, 0.8, 1, 0);
        if(Math.random() > probability)
        {
            // If don't have second layer, set it to 0
            barDataArray2[i] = 0;
            continue;
        }

        // Higher First Layer buildings have lower percentage on height of second Layer
        percentage = MapRange(average, 0, 1, 0.9, 0.5);
        barDataArray2[i] = average * percentage * MapRange(Math.random(), 0, 1, 0.8, 1.1);
    }
    barDataOut2.setRef(barDataArray2);
    */

    // Update Display
    setNeedUpdateDisplay();
}

let lineAnim = 0;
let gradientAnim = 0;
let colorfulLineAnim = 0;
let buildingAnim = 0;
function readTimeline()
{
    const anim_list = timelineArray.get();
    if(anim_list == null || anim_list.length === 0)
    {
        return;
    }

    lineAnim = anim_list[0];
    gradientAnim = anim_list[1];
    colorfulLineAnim = anim_list[2];
    buildingAnim = anim_list[3];
}


animation.onChange =
timelineArray.onChange =
apiRangeMin.onChange =
apiRangeMax.onChange =
rangeXMin.onChange =
rangeXMax.onChange =
rangeYMin.onChange =
rangeYMax.onChange =
layerInterval.onChange =
imageIntervalX.onChange =
imageIntervalZ.onChange = setNeedUpdateDisplay;

let needUpdateDisplay = false;
function setNeedUpdateDisplay()
{
    needUpdateDisplay = true;
}
updateDisplayTrigger.onTriggered = updateDisplay;
function updateDisplay()
{
    if(needUpdateDisplay == false)
        return;
    needUpdateDisplay = false;

    const inArray = apiData.get();
    if (!inArray || inArray.length === 0)
    {
        return;
    }

    // Read timeline
    readTimeline();


    // Set array length
    originalPosArray.length = inArray.length * 3;
    pointArray.length = pointCount.get() * 3;
    colorfulPointArray.length = pointCount.get() * 3;
    originalBarArray.length = barCount.get() * 3;
    barArray.length = barCount.get() * 3;
    barSizeArray.length = barCount.get() * 2;
    barAnimArray.length = barCount.get();

    // determine all position
    for(let i=0; i<inArray.length; i++)
    {
        originalPosArray[i * 3 + 0] = MapRange(i, 0, inArray.length-1, rangeXMin.get(), rangeXMax.get());
        originalPosArray[i * 3 + 1] = MapRange(inArray[i], apiRangeMin.get(), apiRangeMax.get(), rangeYMin.get(), rangeYMax.get());
        // adjust overlapping by assigning z value.
        // make first layer the farest. make buildings on the right the nearest
        originalPosArray[i * 3 + 2] = (2-layerIndex.get()) * layerInterval.get() * -1 + i * imageIntervalZ.get();
    }

    //////////////////////
    // Line
    //////////////////////
    // interpolate points while taking animation under consideration
    let percentage = 0;
    for(let i=0; i<pointCount.get(); i++)
    {
        percentage =  Math.min(parseFloat(i)/parseFloat(pointCount.get()-1), animation.get() * lineAnim);
        [ pointArray[i*3 + 0], pointArray[i*3 + 1], pointArray[i*3 + 2]] = GetInterpolatedPoint(originalPosArray, percentage);
    }


    //////////////////////
    // Colourful Line
    //////////////////////
    for(let i=0; i<pointCount.get(); i++)
    {
        percentage =  Math.min(parseFloat(i)/parseFloat(pointCount.get()-1), animation.get() * colorfulLineAnim);
        [ colorfulPointArray[i*3 + 0], colorfulPointArray[i*3 + 1], colorfulPointArray[i*3 + 2]] = GetInterpolatedPoint(originalPosArray, percentage);
    }


    //////////////////////
    // First Layer Buildings
    //////////////////////
    // interpolate bars while taking animation under consideration
    let individual_anim = 0;
    let bar_width = (rangeXMax.get()-rangeXMin.get()) * (1 - Math.min(1, Math.max(0, imageIntervalX.get()))) / barCount.get();
    let cur_anim = animation.get() * buildingAnim;
    let fade_range = 0.2;
    for(let i=0; i<barCount.get(); i++)
    {
        // bar position
        percentage = parseFloat(i+0.5)/parseFloat(barCount.get());
        // Method 1: Lerp linear
        [ originalBarArray[i*3 + 0], originalBarArray[i*3 + 1], originalBarArray[i*3 + 2]] = GetInterpolatedPoint(originalPosArray, percentage);
        // Method 2: Find maximum in segment
        // [ originalBarArray[i*3 + 0], originalBarArray[i*3 + 1], originalBarArray[i*3 + 2]] = GetHighestPointInSegment(originalPosArray, barCount.get(), i);
        // Method 3: Calculate average in segment
        // [ originalBarArray[i*3 + 0], originalBarArray[i*3 + 1], originalBarArray[i*3 + 2]] = GetAveragePointInSegment(originalPosArray, barCount.get(), i);

        // bar size
        barSizeArray[i*2 + 0] = bar_width;
        barSizeArray[i*2 + 1] = MapRange(barDataArray[i], apiRangeMin.get(), apiRangeMax.get(), 0, rangeYMax.get()-rangeYMin.get());

        // bar animation
        // individual_anim = GetIndividualAnimation(animation.get() * buildingAnim, i, barCount.get());
        percentage = percentage * (1-fade_range);
        individual_anim = MapRange(percentage, cur_anim-fade_range, cur_anim, 1, 0);
        individual_anim = easeOutQuad(individual_anim);

        barArray[i*3 + 0] = originalBarArray[i*3 + 0];
        barArray[i*3 + 1] = MapRange(individual_anim, 0, 1, -1 - barSizeArray[i*2 + 1] / 2.0, rangeYMin.get() + barSizeArray[i*2 + 1] / 2.0);
        barArray[i*3 + 2] = originalBarArray[i*3 + 2];

        barAnimArray[i] = individual_anim;
    }


    segmentArray.length = barCount.get() * 4;
    bar_width = (rangeXMax.get()-rangeXMin.get()) / barCount.get();
    let bar_height = (rangeYMax.get()-rangeYMin.get());
    for(let i=0; i<barCount.get(); i++)
    {
        // segment debug info
        // percentage = parseFloat(i+0.5)/parseFloat(barCount.get()-1);
        // [ segmentArray[i*4 + 0], , ] = GetInterpolatedPoint(originalPosArray, percentage);
        segmentArray[i*4 + 0] = rangeXMin.get() + bar_width * (i+0.5);
        segmentArray[i*4 + 1] = rangeYMin.get() + bar_height * 0.5;
        segmentArray[i*4 + 2] = bar_width;
        segmentArray[i*4 + 3] = bar_height;
    }

    pointOut.setRef(pointArray);
    colorfulPointOut.setRef(colorfulPointArray);
    barOut.setRef(barArray);
    barSizeOut.setRef(barSizeArray);
    barAnimOut.setRef(barAnimArray);
    segmentOut.setRef(segmentArray);


    //////////////////////
    // Second Layer Buildings
    //////////////////////
    /*
    barArray2.length = Math.max(0, (barCount.get()-1) * 3);
    barSizeArray2.length = Math.max(0, (barCount.get()-1) * 2);
    barAnimArray2.length = Math.max(0, (barCount.get()-1));
    for(let i=0; i<barCount.get()-1; i++)
    {
        let height = barDataArray2[i];

        // bar size
        barSizeArray2[i*2 + 0] = bar_width;
        barSizeArray2[i*2 + 1] = MapRange(barDataArray2[i], apiRangeMin.get(), apiRangeMax.get(), 0, rangeYMax.get()-rangeYMin.get());

        // shift x by random value
        let shift_x = randomArray2[i] * barSizeArray2[i*2+0] * 0.1;
        barArray2[i*3+0] = (originalBarArray[i*3+0] + originalBarArray[i*3+3]) * 0.5 + shift_x;

        // calculate y taking aniamtion into consideration
        // individual_anim = GetIndividualAnimation(animation.get() * buildingAnim, i, barCount.get()-1);
        percentage = parseFloat(i)/parseFloat(barCount.get()-2);
        percentage = percentage * (1-fade_range);
        individual_anim = MapRange(percentage, cur_anim-fade_range, cur_anim, 1, 0);
        individual_anim = easeOutQuad(individual_anim);
        barArray2[i*3+1] = MapRange(individual_anim, 0, 1, -1 - barSizeArray2[i*2 + 1] / 2.0, rangeYMin.get() + barSizeArray2[i*2 + 1] / 2.0);

        // z
        barArray2[i*3+2] = (originalBarArray[i*3+2] + originalBarArray[i*3+5]) * 0.5;

        barAnimArray2[i] = individual_anim;
    }

    barOut2.setRef(barArray2);
    barSizeOut2.setRef(barSizeArray2);
    barAnimOut2.setRef(barAnimArray2);
    */

    //////////////////////
    // Mesh
    //////////////////////
    updateVertices();


    //////////////////////
    // Animation parameters related to Camera
    //////////////////////
    // output current line animation point
    percentage = animation.get() * lineAnim;
    currentAnimationPoint.length = 3;
    [ currentAnimationPoint[0], currentAnimationPoint[1], currentAnimationPoint[2]] = GetInterpolatedPoint(originalPosArray, percentage);
    animPointOut.setRef(currentAnimationPoint);
}

// Method 1#. Choose point which is at the center position
function GetInterpolatedValue(in_array, per)
{
    let array_length = in_array.length;

    let threshold_index = Math.min(Math.max(0, per), 1) * (array_length - 1);
    let start_index = Math.floor(threshold_index);
    let end_index = Math.min(start_index + 1, array_length - 1)
    let lerp_in_segment = threshold_index - start_index;

    return MapRange(lerp_in_segment, 0, 1, in_array[start_index], in_array[end_index]);
}

function GetInterpolatedPoint(in_array, per)
{
    let array_length = in_array.length / 3;

    let threshold_index = Math.min(Math.max(0, per), 1) * (array_length - 1);
    let start_index = Math.floor(threshold_index);
    let end_index = Math.min(start_index + 1, array_length - 1)
    let lerp_in_segment = threshold_index - start_index;

    return [MapRange(lerp_in_segment, 0, 1, in_array[start_index * 3 + 0], in_array[end_index * 3 + 0]),
    MapRange(lerp_in_segment, 0, 1, in_array[start_index * 3 + 1], in_array[end_index * 3 + 1]),
    MapRange(lerp_in_segment, 0, 1, in_array[start_index * 3 + 2], in_array[end_index * 3 + 2])];
}

// Method 2#. Choose point which is highest
function GetHighestValueInSegment(in_array, segment_count, segment_index)
{
    let array_length = in_array.length;

    let start_index = Math.floor(segment_index / segment_count * array_length);
    let end_index = Math.floor((segment_index+1) / segment_count * array_length);

    let max_value = null;
    for(let i =start_index; i< end_index; i++)
    {
        if(max_value == null || in_array[i] > max_value)
        {
            max_value = in_array[i];
        }
    }
    return max_value;
}


// function GetHighestPointInSegment(in_array, segment_count, per)
// {
//     let array_length = Math.floor(in_array.length / 3);

//     let threshold_index = Math.min(Math.max(0, per), 1) * (array_length - 1);
//     let start_index = Math.floor(threshold_index);
//     let end_index = Math.min(Math.floor(start_index + (array_length/segment_count)), array_length);

//     let max_value = null;
//     let max_value_index = null;
//     for(let i =start_index; i< end_index; i++)
//     {
//         if(max_value == null || in_array[i*3+1] > max_value)
//         {
//             max_value = in_array[i*3+1];
//             max_value_index = i;
//         }
//     }

//     return [in_array[max_value_index*3+0], in_array[max_value_index*3+1], in_array[max_value_index*3+2]];
// }

function GetHighestPointInSegment(in_array, segment_count, segment_index)
{
    let array_length = Math.floor(in_array.length / 3);

    let start_index = Math.floor(segment_index / segment_count * array_length);
    let end_index = Math.floor((segment_index+1) / segment_count * array_length);

    let max_value = null;
    let max_value_index = null;
    for(let i =start_index; i< end_index; i++)
    {
        if(max_value == null || in_array[i*3+1] > max_value)
        {
            max_value = in_array[i*3+1];
            max_value_index = i;
        }
    }

    return [in_array[max_value_index*3+0], in_array[max_value_index*3+1], in_array[max_value_index*3+2]];
}


// Method 3#. Display point at the middle, but use the average height
function GetAverageHeightInSegment(in_array, segment_count, segment_index)
{
    let array_length = in_array.length;

    let start_index = Math.floor(segment_index / segment_count * array_length);
    let end_index = Math.floor((segment_index+1) / segment_count * array_length);

    let accumulated_value = 0;
    for(let i =start_index; i< end_index; i++)
    {
        accumulated_value += in_array[i];
    }
    return accumulated_value / (end_index-start_index);
}

function GetAveragePointInSegment(in_array, segment_count, segment_index)
{
    let array_length = Math.floor(in_array.length / 3);

    let start_index = Math.floor(segment_index / segment_count * array_length);
    let end_index = Math.floor((segment_index+1) / segment_count * array_length);

    let accumulated_point = [0,0,0];
    for(let i =start_index; i< end_index; i++)
    {
        accumulated_point[0] += in_array[i*3+0];
        accumulated_point[1] += in_array[i*3+1];
        accumulated_point[2] += in_array[i*3+2];
    }

    let point_count = (end_index-start_index);
    return [accumulated_point[0]/point_count, accumulated_point[1]/point_count, accumulated_point[2]/point_count];
}

function GetIndividualAnimation(anim, index, array_length)
{
    let threshold_index = Math.min(Math.max(0, anim), 1) * (array_length); // Use array_length instead of (array_length - 1) to complete the animation of last segment
    let start_index = Math.floor(threshold_index);
    let end_index = Math.min(start_index + 1, array_length);
    let lerp_in_segment = threshold_index - start_index;

    return index<start_index ? 1 : (index >= end_index ? 0 : lerp_in_segment);
}

function rebuildGeometry()
{
    let point_count = pointCount.get();
    let vertex_count = point_count * 2;
    let uv_count = point_count * 2;

    let quad_count = point_count-1;
    let index_count = quad_count * 6;


    vertexList.length = vertex_count * 3;
    uvList.length = uv_count * 2;
    indexList.length = index_count;

    let vertex_index_offset = vertexList.length / 2;
    let uv_index_offset = uvList.length / 2;
    let per = 0;
    for(let i =0; i<point_count; i++)
    {
        per = i / (point_count-1);
        vertexList[i*3 + 0] = per;
        vertexList[i*3 + 1] = 1;
        vertexList[i*3 + 2] = 0;

        vertexList[vertex_index_offset + i*3 + 0] = per;
        vertexList[vertex_index_offset + i*3 + 1] = 0;
        vertexList[vertex_index_offset + i*3 + 2] = 0;

        uvList[i*2 + 0] = per;
        uvList[i*2 + 1] = 1;

        uvList[uv_index_offset + i*2 + 0] = per;
        uvList[uv_index_offset + i*2 + 1] = 0;
    }

    let index_offset = point_count;
    for(let i=0; i<quad_count; i++)
    {
        indexList[i*6 + 0] = i;
        indexList[i*6 + 1] = i+index_offset;
        indexList[i*6 + 2] = i+1;

        indexList[i*6 + 3] = i+1;
        indexList[i*6 + 4] = i+index_offset;
        indexList[i*6 + 5] = i+index_offset+1;
    }

    geom.vertices = vertexList;
    geom.texCoords = uvList;
    geom.verticesIndices = indexList;
    geomOut.setRef(geom);

    updateVertices();
}

function updateVertices()
{
    let point_count = pointCount.get();
    let vertex_index_offset = vertexList.length / 2;
    let uv_count = point_count * 2;
    let uv_index_offset = uvList.length / 2;
    // for(let i =0; i<point_count; i++)
    // {

    //     vertexList[i*3 + 0] = pointArray[i*3 + 0];
    //     vertexList[i*3 + 1] = pointArray[i*3 + 1];
    //     vertexList[i*3 + 2] = pointArray[i*3 + 2];

    //     vertexList[vertex_index_offset + i*3 + 0] = pointArray[i*3 + 0];
    //     vertexList[vertex_index_offset + i*3 + 1] = rangeYMin.get();
    //     vertexList[vertex_index_offset + i*3 + 2] = pointArray[i*3 + 2];
    // }
    let percentage = 0;
    let max_percentage = animation.get() * gradientAnim;
    let temp_point = Array(3);
    for(let i=0; i<pointCount.get(); i++)
    {
        percentage =  Math.min(parseFloat(i)/parseFloat(pointCount.get()-1), animation.get() * gradientAnim);
        [ temp_point[0], temp_point[1], temp_point[2]] = GetInterpolatedPoint(originalPosArray, percentage);

        vertexList[i*3 + 0] = temp_point[0];
        vertexList[i*3 + 1] = temp_point[1];
        vertexList[i*3 + 2] = temp_point[2];

        vertexList[vertex_index_offset + i*3 + 0] = temp_point[0];
        vertexList[vertex_index_offset + i*3 + 1] = rangeYMin.get();
        vertexList[vertex_index_offset + i*3 + 2] = temp_point[2];

        uvList[i*2 + 0] = percentage / max_percentage;
        uvList[i*2 + 1] = 1;

        uvList[uv_index_offset + i*2 + 0] = percentage / max_percentage;
        uvList[uv_index_offset + i*2 + 1] = 0;
    }

    geom.texCoords = uvList;
    geom.vertices = vertexList;
    geomOut.setRef(geom);
}

function MapRange(v, oMin, oMax, nMin, nMax, ease = 0)
{

    if (v >= Math.max(oMax, oMin))
    {
        v = nMax;
    }
    else if (v <= Math.min(oMax, oMin))
    {
        v = nMin;
    }
    else
    {
        let reverseInput = false;
        const oldMin = Math.min(oMin, oMax);
        const oldMax = Math.max(oMin, oMax);
        if (oldMin !== oMin) reverseInput = true;

        let reverseOutput = false;
        const newMin = Math.min(nMin, nMax);
        const newMax = Math.max(nMin, nMax);
        if (newMin !== nMin) reverseOutput = true;

        let portion = 0;

        if (reverseInput)
        {
            portion = (oldMax - v) * (newMax - newMin) / (oldMax - oldMin);
        }
        else
        {
            portion = (v - oldMin) * (newMax - newMin) / (oldMax - oldMin);
        }

        if (reverseOutput)
        {
            r = newMax - portion;
        }
        else
        {
            r = portion + newMin;
        }

        if (ease === 0)
        {
            v = r;
        }
        else if (ease === 1)
        {
            x = Math.max(0, Math.min(1, (r - nMin) / (nMax - nMin)));
            v = nMin + x * x * (3 - 2 * x) * (nMax - nMin); // smoothstep
        }
        else if (ease === 2)
        {
            x = Math.max(0, Math.min(1, (r - nMin) / (nMax - nMin)));
            v = nMin + x * x * x * (x * (x * 6 - 15) + 10) * (nMax - nMin); // smootherstep
        }
    }

    return v;
}

function easeOutQuad(x)
{
    return 1 - (1 - x) * (1 - x);
}


let randomArray2 = Array(100);
function prepareRandomArray()
{
    for(let i=0; i<randomArray2.length; i++)
    {
        // Set random value for each bar
        randomArray2[i] = (Math.random() - 0.5) * 2;
    }
}
prepareRandomArray();



calculateData();
updateDisplay();

}
};

CABLES.OPS["35054ddd-9484-4d1b-a535-b2e8c8b1a366"]={f:Ops.Patch.PLH3vXR.AnimationPointsGenerator_SingleLayer,objName:"Ops.Patch.PLH3vXR.AnimationPointsGenerator_SingleLayer"};




// **************************************************************
// 
// Ops.Gl.ImageCompose.Color_v2
// 
// **************************************************************

Ops.Gl.ImageCompose.Color_v2= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={"color_frag":"IN vec2 texCoord;\nUNI sampler2D tex;\nUNI float r;\nUNI float g;\nUNI float b;\nUNI float a;\nUNI float amount;\n\n#ifdef MASK\n    UNI sampler2D mask;\n#endif\n\n{{CGL.BLENDMODES3}}\n\nvoid main()\n{\n    vec4 col=vec4(r,g,b,a);\n    vec4 base=texture(tex,texCoord);\n\n    float am=amount;\n    #ifdef MASK\n        float msk=texture(mask,texCoord).r;\n        #ifdef INVERTMASK\n            msk=1.0-msk;\n        #endif\n        am*=1.0-msk;\n    #endif\n\n    outColor=cgl_blendPixel(base,col,am);\n}\n",};
const
    render = op.inTrigger("render"),
    blendMode = CGL.TextureEffect.AddBlendSelect(op),
    amount = op.inValueSlider("Amount", 1),
    maskAlpha = CGL.TextureEffect.AddBlendAlphaMask(op),

    inMask = op.inTexture("Mask"),
    inMaskInvert = op.inValueBool("Mask Invert"),
    r = op.inValueSlider("r", Math.random()),
    g = op.inValueSlider("g", Math.random()),
    b = op.inValueSlider("b", Math.random()),
    a = op.inValueSlider("A", 1),
    trigger = op.outTrigger("trigger");

r.setUiAttribs({ "colorPick": true });
op.setPortGroup("Color", [r, g, b]);

const TEX_SLOT = 0;
const cgl = op.patch.cgl;
const shader = new CGL.Shader(cgl, "textureeffect color");
const srcFrag = attachments.color_frag || "";
shader.setSource(shader.getDefaultVertexShader(), srcFrag);
CGL.TextureEffect.setupBlending(op, shader, blendMode, amount, maskAlpha);

const
    textureUniform = new CGL.Uniform(shader, "t", "tex", TEX_SLOT),
    makstextureUniform = new CGL.Uniform(shader, "t", "mask", 1),
    uniformR = new CGL.Uniform(shader, "f", "r", r),
    uniformG = new CGL.Uniform(shader, "f", "g", g),
    uniformB = new CGL.Uniform(shader, "f", "b", b),
    uniformA = new CGL.Uniform(shader, "f", "a", a),
    uniformAmount = new CGL.Uniform(shader, "f", "amount", amount);

inMask.onChange = function ()
{
    if (inMask.isLinked())shader.define("MASK");
    else shader.removeDefine("MASK");
};

inMaskInvert.onChange = function ()
{
    if (inMaskInvert.get())shader.define("INVERTMASK");
    else shader.removeDefine("INVERTMASK");
};

render.onTriggered = function ()
{
    if (!CGL.TextureEffect.checkOpInEffect(op, 3)) return;

    cgl.pushShader(shader);
    cgl.currentTextureEffect.bind();

    cgl.setTexture(TEX_SLOT, cgl.currentTextureEffect.getCurrentSourceTexture().tex);
    if (inMask.get()) cgl.setTexture(1, inMask.get().tex);

    cgl.currentTextureEffect.finish();
    cgl.popShader();

    trigger.trigger();
};

}
};

CABLES.OPS["6dada2b7-da7c-47ee-87a9-a12e87055208"]={f:Ops.Gl.ImageCompose.Color_v2,objName:"Ops.Gl.ImageCompose.Color_v2"};




// **************************************************************
// 
// Ops.Gl.ImageCompose.Alpha
// 
// **************************************************************

Ops.Gl.ImageCompose.Alpha= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={"clearAlpha_frag":"\n// void main()\n// {\n//     outColor.a=0.0;\n// }\n\nIN vec2 texCoord;\nUNI sampler2D tex;\nUNI float amount;\n\n\nvoid main()\n{\n    vec4 base=texture(tex,texCoord);\n\n    outColor=base;\n\n    #ifdef METH_NORM\n        outColor.a=amount;\n    #endif\n    #ifdef METH_ADD\n        outColor.a+=amount;\n    #endif\n    #ifdef METH_SUB\n        outColor.a-=amount;\n    #endif\n    #ifdef METH_MUL\n        outColor.a*=amount;\n    #endif\n\n    #ifdef DO_CLAMP\n    outColor.a=clamp(0.0,1.0,outColor.a);\n    #endif\n\n}\n",};
const
    render = op.inTrigger("Render"),
    amount = op.inValueSlider("Amount", 1),
    meth = op.inSwitch("Method", ["Set", "Add", "Sub", "Mul"], "Set"),
    clamp = op.inBool("Clamp", true),
    trigger = op.outTrigger("Next");

const cgl = op.patch.cgl;
const shader = new CGL.Shader(cgl, "Alpha");
const TEX_SLOT = 0;

shader.setSource(shader.getDefaultVertexShader(), attachments.clearAlpha_frag || "");

const uniformAmount = new CGL.Uniform(shader, "f", "amount", amount);
const textureUniform = new CGL.Uniform(shader, "t", "tex", TEX_SLOT);

clamp.onChange =
    meth.onChange = updateDefines;
updateDefines();

function updateDefines()
{
    shader.toggleDefine("METH_NORM", meth.get() == "Set");
    shader.toggleDefine("METH_ADD", meth.get() == "Add");
    shader.toggleDefine("METH_SUB", meth.get() == "Sub");
    shader.toggleDefine("METH_MUL", meth.get() == "Mul");
    shader.toggleDefine("DO_CLAMP", clamp.get());
}

render.onTriggered = function ()
{
    if (!CGL.TextureEffect.checkOpInEffect(op)) return;

    cgl.pushShader(shader);
    cgl.currentTextureEffect.bind();

    cgl.setTexture(TEX_SLOT, cgl.currentTextureEffect.getCurrentSourceTexture().tex);

    cgl.currentTextureEffect.finish();
    cgl.popShader();

    trigger.trigger();
};

}
};

CABLES.OPS["131687e0-77f5-4fd7-be57-864aa6559418"]={f:Ops.Gl.ImageCompose.Alpha,objName:"Ops.Gl.ImageCompose.Alpha"};




// **************************************************************
// 
// Ops.Vars.VarGetString
// 
// **************************************************************

Ops.Vars.VarGetString= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
var val=op.outString("Value");
op.varName=op.inValueSelect("Variable",[],"",true);

new CABLES.VarGetOpWrapper(op,"string",op.varName,val);

}
};

CABLES.OPS["3ad08cfc-bce6-4175-9746-fef2817a3b12"]={f:Ops.Vars.VarGetString,objName:"Ops.Vars.VarGetString"};




// **************************************************************
// 
// Ops.String.StringEditor
// 
// **************************************************************

Ops.String.StringEditor= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
const
    v = op.inStringEditor("value", ""),
    syntax = op.inValueSelect("Syntax", ["text", "glsl", "css", "html", "xml", "json", "javascript", "inline-css", "sql"], "text"),
    result = op.outString("Result");

syntax.onChange = updateSyntax;

function updateSyntax()
{
    let s = syntax.get();
    if (s == "javascript")s = "js";
    v.setUiAttribs({ "editorSyntax": s });
}

v.onChange = function ()
{
    result.set(v.get());
};

}
};

CABLES.OPS["6468b7c1-f63e-4db4-b809-4b203d27ead3"]={f:Ops.String.StringEditor,objName:"Ops.String.StringEditor"};




// **************************************************************
// 
// Ops.Array.ArrayGetString
// 
// **************************************************************

Ops.Array.ArrayGetString= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
const
    array = op.inArray("array"),
    index = op.inValueInt("index"),
    result = op.outString("result");

array.ignoreValueSerialize = true;
op.toWorkPortsNeedToBeLinked(array);

array.onChange =
index.onChange = update;

function update()
{
    const arr = array.get();
    if (arr) result.set(arr[index.get()]);
}

}
};

CABLES.OPS["be8f16c0-0c8a-48a2-a92b-45dbf88c76c1"]={f:Ops.Array.ArrayGetString,objName:"Ops.Array.ArrayGetString"};




// **************************************************************
// 
// Ops.Ui.VizString
// 
// **************************************************************

Ops.Ui.VizString= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
const
    inStr = op.inStringEditor("String"),
    inZoomText = op.inBool("ZoomText", false),
    inLineNums = op.inBool("Line Numbers", true),
    inWhitespace = op.inBool("Whitespace", false),
    inWrap = op.inBool("Wrap lines", false),
    syntax = op.inValueSelect("Syntax", ["text", "glsl", "css", "html", "xml", "json", "javascript", "inline-css", "sql"], "text"),
    inFontSize = op.inFloat("Font Size", 10),
    inPos = op.inFloatSlider("Scroll", 0),
    outStr = op.outString("Passthrough String");

op.setUiAttrib({ "height": 200, "width": 400, "resizable": true, "vizLayerMaxZoom": 2500 });
inStr.ignoreValueSerialize = true;

let lines = [];

inStr.onLinkChanged = () =>
{
    if (!inStr.isLinked())
    {
        lines = [];
        inStr.set(null);

        op.setUiAttrib({ "extendTitle": "" });
    }
    else
    {
        const pp = inStr.links[0].getOtherPort(inStr);
        if (pp) op.setUiAttrib({ "extendTitle": pp.name });
    }
};

inStr.onChange = () =>
{
    outStr.set(inStr.get());
    if (CABLES.UI)
    {
        if (inStr.get()) lines = inStr.get().split("\n");
        else lines = [];
    }
};

op.renderVizLayer = (ctx, layer, viz) =>
{
    viz.clear(ctx, layer);

    if (!inStr.get()) return;

    ctx.save();
    ctx.scale(layer.scale, layer.scale);

    viz.renderText(ctx, layer, lines, {
        "zoomText": inZoomText.get(),
        "showLineNum": inLineNums.get(),
        "fontSize": inFontSize.get(),
        "scroll": inPos.get(),
        "syntax": syntax.get(),
        "showWhitespace": inWhitespace.get(),
        "wrap": inWrap.get()
    });

    ctx.restore();
};

}
};

CABLES.OPS["b4c93fde-85c6-4c7e-9962-a6463a84838b"]={f:Ops.Ui.VizString,objName:"Ops.Ui.VizString"};




// **************************************************************
// 
// Ops.Gl.TextureArrayLoader_v2
// 
// **************************************************************

Ops.Gl.TextureArrayLoader_v2= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
const USE_LEFT_PAD_DEFAULT = false;

const filename = op.inString("Url");
const leftPadFilename = op.inBool("Left Pad", USE_LEFT_PAD_DEFAULT);
const numberLengthPort = op.inInt("Num Digits", 3);
numberLengthPort.setUiAttribs({ "hidePort": !USE_LEFT_PAD_DEFAULT, "greyout": !USE_LEFT_PAD_DEFAULT });

const indexStart = op.inInt("Index Start");
const indexEnd = op.inInt("Index End");

const tfilter = op.inValueSelect("filter", ["nearest", "linear", "mipmap"]);
const wrap = op.inValueSelect("wrap", ["repeat", "mirrored repeat", "clamp to edge"], "clamp to edge");
const flip = op.inBool("Flip", false);
const unpackAlpha = op.inBool("unpackPreMultipliedAlpha", false);

const arrOut = op.outArray("TextureArray");

const width = op.outNumber("Width");
const height = op.outNumber("Height");
const loading = op.outBool("Loading");
const ratio = op.outNumber("Aspect Ratio");

indexEnd.set(10);
flip.set(false);
unpackAlpha.set(false);

const cgl = op.patch.cgl;
let cgl_filter = 0;
let cgl_wrap = 0;

const arr = [];
arrOut.set(arr);

flip.onChange = function () { reload(); };
filename.onChange = reload;

tfilter.onChange = onFilterChange;
wrap.onChange = onWrapChange;
unpackAlpha.onChange = function () { reload(); };

leftPadFilename.onChange = setNumberLengthPortVisibility;

let timedLoader = 0;

function setNumberLengthPortVisibility()
{
    const doLeftPad = leftPadFilename.get();
    numberLengthPort.setUiAttribs({ "hidePort": !doLeftPad, "greyout": !doLeftPad });
}

const setTempTexture = function ()
{
    const t = CGL.Texture.getTempTexture(cgl);
    // textureOut.set(t);
};

function reload(nocache)
{
    clearTimeout(timedLoader);
    timedLoader = setTimeout(function ()
    {
        realReload(nocache);
    }, 30);
}

const REPLACE_CHARACTER = "X";

function pad(value, length)
{
    return (value.toString().length < length) ? pad("0" + value, length) : value;
}

function loadImage(i, nocache)
{
    let url = filename.get();
    if (!url) return;
    const firstXIndex = url.indexOf(REPLACE_CHARACTER);
    const lastXIndex = url.lastIndexOf(REPLACE_CHARACTER);
    if (firstXIndex === -1) { return; }
    const replaceString = url.substring(firstXIndex, lastXIndex + 1);
    let numberString = i;
    if (leftPadFilename.get())
    {
        numberString = pad(i, numberLengthPort.get());
    }
    url = url.replace(replaceString, numberString);
    url = op.patch.getFilePath(url);

    if (nocache)url += "?rnd=" + CABLES.generateUUID();

    if ((filename.get() && filename.get().length > 1))
    {
        loading.set(1);

        var tex = CGL.Texture.load(cgl, url,
            function (err)
            {
                if (err)
                {
                    console.warn("error loading texture", url, err);
                    setTempTexture();
                    return;
                }
                width.set(tex.width);
                height.set(tex.height);
                ratio.set(tex.width / tex.height);

                arr[i - parseInt(indexStart.get())] = tex;

                arrOut.setRef(arr);
            }, {
                "wrap": cgl_wrap,
                "flip": flip.get(),
                "unpackAlpha": unpackAlpha.get(),
                "filter": cgl_filter
            });

        loading.set(0);
    }
    else
    {
        setTempTexture();
    }
}

function realReload(nocache)
{
    for (var i = 0; i < arr.length; i++)
    {
        if (arr[i])
        {
            arr[i].delete();
        }
    }
    arr.length = 0;
    for (var i = Math.floor(indexStart.get()); i <= Math.floor(indexEnd.get()); i++)
    {
        loadImage(i, nocache);
    }
}

function onFilterChange()
{
    if (tfilter.get() == "nearest") cgl_filter = CGL.Texture.FILTER_NEAREST;
    if (tfilter.get() == "linear") cgl_filter = CGL.Texture.FILTER_LINEAR;
    if (tfilter.get() == "mipmap") cgl_filter = CGL.Texture.FILTER_MIPMAP;

    reload();
}

function onWrapChange()
{
    if (wrap.get() == "repeat") cgl_wrap = CGL.Texture.WRAP_REPEAT;
    if (wrap.get() == "mirrored repeat") cgl_wrap = CGL.Texture.WRAP_MIRRORED_REPEAT;
    if (wrap.get() == "clamp to edge") cgl_wrap = CGL.Texture.WRAP_CLAMP_TO_EDGE;

    reload();
}

op.onFileChanged = function (fn)
{
};

tfilter.set("linear");
wrap.set("repeat");

}
};

CABLES.OPS["4bbb57ce-3c7b-49c1-84fd-2b6a27ff3afa"]={f:Ops.Gl.TextureArrayLoader_v2,objName:"Ops.Gl.TextureArrayLoader_v2"};




// **************************************************************
// 
// Ops.Math.Interpolate
// 
// **************************************************************

Ops.Math.Interpolate= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
const
    val1 = op.inFloat("Value 1"),
    val2 = op.inFloat("Value 2"),
    perc = op.inFloatSlider("Percentage"),
    result = op.outNumber("Result");

val1.onChange =
val2.onChange =
perc.onChange = update;

function update()
{
    result.set((val2.get() - val1.get()) * perc.get() + val1.get());
}

}
};

CABLES.OPS["d126e2c8-221e-428f-8ff4-8b8c5f6b8905"]={f:Ops.Math.Interpolate,objName:"Ops.Math.Interpolate"};




// **************************************************************
// 
// Ops.Gl.MainLoop_v2
// 
// **************************************************************

Ops.Gl.MainLoop_v2= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
const
    hdpi = op.inFloat("Max Pixel Density (DPR)", 2),
    fpsLimit = op.inValue("FPS Limit", 0),
    reduceFocusFPS = op.inValueBool("Reduce FPS unfocussed", false),
    clear = op.inValueBool("Transparent", false),
    active = op.inValueBool("Active", 1),
    inFocus = op.inValueBool("Focus canvas", 1),
    trigger = op.outTrigger("trigger"),
    width = op.outNumber("width"),
    height = op.outNumber("height"),
    outPixel = op.outNumber("Pixel Density");

op.onAnimFrame = render;
hdpi.onChange = updateHdpi;

const cgl = op.patch.cg = op.patch.cgl;
let rframes = 0;
let rframeStart = 0;
let timeOutTest = null;
let addedListener = false;
if (!op.patch.cgl) op.uiAttr({ "error": "No webgl cgl context" });

const identTranslate = vec3.create();
vec3.set(identTranslate, 0, 0, 0);
const identTranslateView = vec3.create();
vec3.set(identTranslateView, 0, 0, -2);

let firstTime = true;
let fsElement = null;
let winhasFocus = true;
let winVisible = true;

window.addEventListener("blur", () => { winhasFocus = false; });
window.addEventListener("focus", () => { winhasFocus = true; });
document.addEventListener("visibilitychange", () => { winVisible = !document.hidden; });

testMultiMainloop();

// op.patch.cgl.cgCanvas.forceAspect = 1.7777777;
op.patch.tempData.mainloopOp = this;

function updateHdpi()
{
    setPixelDensity();

    if (CABLES.UI)
    {
        if (hdpi.get() < 1)
            op.patch.cgl.canvas.style.imageRendering = "pixelated";
    }

    op.patch.cgl.updateSize();
    if (CABLES.UI) gui.setLayout();
}

active.onChange = function ()
{
    op.patch.removeOnAnimFrame(op);

    if (active.get())
    {
        op.setUiAttrib({ "extendTitle": "" });
        op.onAnimFrame = render;
        op.patch.addOnAnimFrame(op);
        op.log("adding again!");
    }
    else
    {
        op.setUiAttrib({ "extendTitle": "Inactive" });
    }
};

function getFpsLimit()
{
    if (reduceFocusFPS.get())
    {
        if (!winVisible) return 10;
        if (!winhasFocus) return 30;
    }

    return fpsLimit.get();
}

op.onDelete = function ()
{
    cgl.gl.clearColor(0, 0, 0.0, 0);
    cgl.gl.clear(cgl.gl.COLOR_BUFFER_BIT | cgl.gl.DEPTH_BUFFER_BIT);
};

function setPixelDensity()
{
    if (hdpi.get() != 0) op.patch.cgl.pixelDensity = Math.min(hdpi.get(), window.devicePixelRatio);
    else op.patch.cgl.pixelDensity = window.devicePixelRatio;
}

function render(time)
{
    if (!active.get()) return;
    if (cgl.aborted || cgl.canvas.clientWidth === 0 || cgl.canvas.clientHeight === 0) return;

    op.patch.cg = cgl;

    setPixelDensity();

    // if (hdpi.get())op.patch.cgl.pixelDensity = window.devicePixelRatio;

    const startTime = performance.now();

    op.patch.config.fpsLimit = getFpsLimit();

    if (cgl.canvasWidth == -1)
    {
        cgl.setCanvas(op.patch.config.glCanvasId);
        return;
    }

    if (cgl.canvasWidth != width.get() || cgl.canvasHeight != height.get())
    {
        width.set(cgl.canvasWidth / 1);
        height.set(cgl.canvasHeight / 1);
    }

    if (CABLES.now() - rframeStart > 1000)
    {
        CGL.fpsReport = CGL.fpsReport || [];
        if (op.patch.loading.getProgress() >= 1.0 && rframeStart !== 0)CGL.fpsReport.push(rframes);
        rframes = 0;
        rframeStart = CABLES.now();
    }
    CGL.MESH.lastShader = null;
    CGL.MESH.lastMesh = null;

    cgl.renderStart(cgl, identTranslate, identTranslateView);

    if (!clear.get()) cgl.gl.clearColor(0, 0, 0, 1);
    else cgl.gl.clearColor(0, 0, 0, 0);

    cgl.gl.clear(cgl.gl.COLOR_BUFFER_BIT | cgl.gl.DEPTH_BUFFER_BIT);

    trigger.trigger();

    if (CGL.MESH.lastMesh)CGL.MESH.lastMesh.unBind();

    if (CGL.Texture.previewTexture)
    {
        if (!CGL.Texture.texturePreviewer) CGL.Texture.texturePreviewer = new CGL.Texture.texturePreview(cgl);
        CGL.Texture.texturePreviewer.render(CGL.Texture.previewTexture);
    }
    cgl.renderEnd(cgl);

    op.patch.cg = null;

    if (!clear.get())
    {
        cgl.gl.clearColor(1, 1, 1, 1);
        cgl.gl.colorMask(false, false, false, true);
        cgl.gl.clear(cgl.gl.COLOR_BUFFER_BIT);
        cgl.gl.colorMask(true, true, true, true);
    }

    if (!cgl.tempData.phong)cgl.tempData.phong = {};
    rframes++;
    if (firstTime)
    {
        if (inFocus.get()) cgl.canvas.focus();
        firstTime = false;
    }

    outPixel.set(op.patch.cgl.pixelDensity);
    op.patch.cgl.profileData.profileMainloopMs = performance.now() - startTime;
}

function testMultiMainloop()
{
    clearTimeout(timeOutTest);
    timeOutTest = setTimeout(
        () =>
        {
            if (op.patch.getOpsByObjName(op.name).length > 1)
            {
                op.setUiError("multimainloop", "there should only be one mainloop op!");
                if (!addedListener)addedListener = op.patch.addEventListener("onOpDelete", testMultiMainloop);
            }
            else op.setUiError("multimainloop", null, 1);
        }, 500);
}

}
};

CABLES.OPS["f1029550-d877-42da-9b1e-63a5163a0350"]={f:Ops.Gl.MainLoop_v2,objName:"Ops.Gl.MainLoop_v2"};




// **************************************************************
// 
// Ops.Vars.VarSetNumber_v2
// 
// **************************************************************

Ops.Vars.VarSetNumber_v2= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
const val = op.inValueFloat("Value", 0);
op.varName = op.inDropDown("Variable", [], "", true);

new CABLES.VarSetOpWrapper(op, "number", val, op.varName);

}
};

CABLES.OPS["b5249226-6095-4828-8a1c-080654e192fa"]={f:Ops.Vars.VarSetNumber_v2,objName:"Ops.Vars.VarSetNumber_v2"};




// **************************************************************
// 
// Ops.Devices.Mobile.ScreenOrientation
// 
// **************************************************************

Ops.Devices.Mobile.ScreenOrientation= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
const
    angle = op.outNumber("Angle"),
    str = op.outString("Description");

let count = 0;
window.addEventListener("resize", onOrientationChange, false);
window.addEventListener("orientationchange", onOrientationChange, false);

onOrientationChange();

if (screen && screen.orientation)
{
    screen.orientation.addEventListener("change", onOrientationChange);
}

function onOrientationChange()
{
    count++;
    if (!screen.orientation) return;
    if (screen.orientation.hasOwnProperty("angle"))angle.set(screen.orientation.angle);
    let s = screen.orientation.type + " #" + count + " WINORIENT:" + window.orientation;
    str.set(s);
}

op.onDelete = function ()
{
    window.removeEventListener("resize", onOrientationChange);
    window.removeEventListener("orientationchange", onOrientationChange);
};

}
};

CABLES.OPS["ef8f5f5a-4652-4fad-983b-aca96d9cc13b"]={f:Ops.Devices.Mobile.ScreenOrientation,objName:"Ops.Devices.Mobile.ScreenOrientation"};




// **************************************************************
// 
// Ops.Devices.Mobile.LockOrientation
// 
// **************************************************************

Ops.Devices.Mobile.LockOrientation= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
const inPortrait = op.inValueBool("Portrait");
const inLandscape = op.inValueBool("Landscape");

screen.lockOrientationUniversal = screen.lockOrientation || screen.mozLockOrientation || screen.msLockOrientation;

const support = op.outBoolNum("Supported", screen.lockOrientationUniversal !== undefined);
const locked = op.outBoolNum("Locked");

inPortrait.onChange = setup;
inLandscape.onChange = setup;

function setup()
{
    if (screen.lockOrientationUniversal)
    {
        let orientations = [];
        if (inPortrait.get())orientations.push("portrait");
        if (inLandscape.get())orientations.push("landscape");

        if (screen.lockOrientationUniversal(orientations)) locked.set(true);
        else locked.set(false);
    }
    locked.set(false);
}

}
};

CABLES.OPS["486d5713-5292-47af-bbd3-df81fb7cd3ca"]={f:Ops.Devices.Mobile.LockOrientation,objName:"Ops.Devices.Mobile.LockOrientation"};




// **************************************************************
// 
// Ops.Array.NumbersToArrayMultiPort
// 
// **************************************************************

Ops.Array.NumbersToArrayMultiPort= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
const
    inStrs = op.inMultiPort("Numbers", CABLES.OP_PORT_TYPE_NUMBER),
    outArr = op.outArray("Result"),
    outNum = op.outNumber("Num Values");

inStrs.onChange = () =>
{
    const stringPorts = inStrs.get();
    let arr = [];

    for (let i = 0; i < stringPorts.length; i++)
    {
        arr[i] = stringPorts[i].get() || 0;
    }
    outArr.set(arr);
    outNum.set(stringPorts.length);
};

}
};

CABLES.OPS["d63e564f-55bd-49fc-ae75-d20096f18b01"]={f:Ops.Array.NumbersToArrayMultiPort,objName:"Ops.Array.NumbersToArrayMultiPort"};




// **************************************************************
// 
// Ops.Trigger.TriggerSend
// 
// **************************************************************

Ops.Trigger.TriggerSend= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
const
    trigger = op.inTriggerButton("Trigger"),
    next = op.outTrigger("Next");

op.varName = op.inValueSelect("Named Trigger", [], "", true);

op.varName.onChange = updateName;

trigger.onTriggered = doTrigger;

op.patch.addEventListener("namedTriggersChanged", updateVarNamesDropdown);

updateVarNamesDropdown();

op.varName.setUiAttribs({ "_triggerSelect": true });

function updateVarNamesDropdown()
{
    if (CABLES.UI)
    {
        let varnames = [];
        const vars = op.patch.namedTriggers;
        varnames.push("+ create new one");
        for (const i in vars) varnames.push(i);
        varnames = varnames.sort();
        op.varName.uiAttribs.values = varnames;
    }
}

function updateName()
{
    if (CABLES.UI)
    {
        if (op.varName.get() == "+ create new one")
        {
            new CABLES.UI.ModalDialog({
                "prompt": true,
                "title": "New Trigger",
                "text": "Enter a name for the new trigger",
                "promptValue": "",
                "promptOk": (str) =>
                {
                    op.varName.set(str);
                    op.patch.namedTriggers[str] = op.patch.namedTriggers[str] || [];
                    updateVarNamesDropdown();
                }
            });
            return;
        }

        op.refreshParams();
    }

    if (!op.patch.namedTriggers[op.varName.get()])
    {
        op.patch.namedTriggers[op.varName.get()] = op.patch.namedTriggers[op.varName.get()] || [];
        op.patch.emitEvent("namedTriggersChanged");
    }

    op.setTitle(">" + op.varName.get());

    op.refreshParams();
    op.patch.emitEvent("opTriggerNameChanged", op, op.varName.get());
}

function doTrigger()
{
    const arr = op.patch.namedTriggers[op.varName.get()];
    // fire an event even if noone is receiving this trigger
    // this way TriggerReceiveFilter can still handle it
    op.patch.emitEvent("namedTriggerSent", op.varName.get());

    if (!arr)
    {
        op.setUiError("unknowntrigger", "unknown trigger");
        return;
    }
    else op.setUiError("unknowntrigger", null);

    for (let i = 0; i < arr.length; i++)
    {
        arr[i]();
    }

    next.trigger();
}

}
};

CABLES.OPS["ce1eaf2b-943b-4dc0-ab5e-ee11b63c9ed0"]={f:Ops.Trigger.TriggerSend,objName:"Ops.Trigger.TriggerSend"};




// **************************************************************
// 
// Ops.Gl.TriggerOnCanvasResize
// 
// **************************************************************

Ops.Gl.TriggerOnCanvasResize= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
const onResize = op.outTrigger("Resized");

let listener = op.patch.cgl.on("resize", resize);

function resize()
{
    onResize.trigger();
}

op.onDelete = () =>
{
    op.patch.cgl.off(listener);
};

}
};

CABLES.OPS["856de8cf-b8d1-4668-b8ff-80c68bc73ddd"]={f:Ops.Gl.TriggerOnCanvasResize,objName:"Ops.Gl.TriggerOnCanvasResize"};




// **************************************************************
// 
// Ops.Sidebar.Slider_v3
// 
// **************************************************************

Ops.Sidebar.Slider_v3= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
// constants
const STEP_DEFAULT = 0.00001;

// inputs
const parentPort = op.inObject("link");
const labelPort = op.inString("Text", "Slider");
const minPort = op.inValue("Min", 0);
const maxPort = op.inValue("Max", 1);
const stepPort = op.inValue("Step", STEP_DEFAULT);
const labelSuffix = op.inString("Suffix", "");

const inGreyOut = op.inBool("Grey Out", false);
const inVisible = op.inBool("Visible", true);

const inputValuePort = op.inValue("Input", 0.5);
const setDefaultValueButtonPort = op.inTriggerButton("Set Default");
const reset = op.inTriggerButton("Reset");

let parent = null;

const defaultValuePort = op.inValue("Default", 0.5);
defaultValuePort.setUiAttribs({ "hidePort": true, "greyout": true });

// outputs
const siblingsPort = op.outObject("childs");
const valuePort = op.outNumber("Result", defaultValuePort.get());

op.toWorkNeedsParent("Ops.Sidebar.Sidebar");
op.setPortGroup("Range", [minPort, maxPort, stepPort]);
op.setPortGroup("Display", [inGreyOut, inVisible]);

// vars
const el = document.createElement("div");
el.addEventListener("dblclick", function ()
{
    valuePort.set(parseFloat(defaultValuePort.get()));
    inputValuePort.set(parseFloat(defaultValuePort.get()));
    setValueFieldValue(defaultValuePort.get());
});

el.dataset.op = op.id;
el.classList.add("cablesEle");

el.classList.add("sidebar__item");
el.classList.add("sidebar__slider");
el.classList.add("sidebar__reloadable");

op.patch.on("sidebarStylesChanged", () => { updateActiveTrack(); });

const label = document.createElement("div");
label.classList.add("sidebar__item-label");

const greyOut = document.createElement("div");
greyOut.classList.add("sidebar__greyout");
el.appendChild(greyOut);
greyOut.style.display = "none";

const labelText = document.createTextNode(labelPort.get());
label.appendChild(labelText);
el.appendChild(label);

const value = document.createElement("input");
value.value = defaultValuePort.get();
value.classList.add("sidebar__text-input-input");
value.setAttribute("type", "text");

value.oninput = onTextInputChanged;
el.appendChild(value);

const suffixEle = document.createElement("span");
// setValueFieldValue(defaultValuePort).get();
// value.setAttribute("type", "text");
// value.oninput = onTextInputChanged;

el.appendChild(suffixEle);

labelSuffix.onChange = () =>
{
    suffixEle.innerHTML = labelSuffix.get();
};

const inputWrapper = document.createElement("div");
inputWrapper.classList.add("sidebar__slider-input-wrapper");
el.appendChild(inputWrapper);

const activeTrack = document.createElement("div");
activeTrack.classList.add("sidebar__slider-input-active-track");
inputWrapper.appendChild(activeTrack);
const input = document.createElement("input");
input.classList.add("sidebar__slider-input");
input.setAttribute("min", minPort.get());
input.setAttribute("max", maxPort.get());
input.setAttribute("type", "range");
input.setAttribute("step", stepPort.get());
input.setAttribute("value", defaultValuePort.get());
input.style.display = "block"; /* needed because offsetWidth returns 0 otherwise */
inputWrapper.appendChild(input);

updateActiveTrack();
input.addEventListener("input", onSliderInput);

// events
parentPort.onChange = onParentChanged;
labelPort.onChange = onLabelTextChanged;
inputValuePort.onChange = onInputValuePortChanged;
defaultValuePort.onChange = onDefaultValueChanged;
setDefaultValueButtonPort.onTriggered = onSetDefaultValueButtonPress;
minPort.onChange = onMinPortChange;
maxPort.onChange = onMaxPortChange;
stepPort.onChange = stepPortChanged;
op.onDelete = onDelete;

// op.onLoadedValueSet=function()
op.onLoaded = op.onInit = function ()
{
    if (op.patch.config.sidebar)
    {
        op.patch.config.sidebar[labelPort.get()];
        valuePort.set(op.patch.config.sidebar[labelPort.get()]);
    }
    else
    {
        valuePort.set(parseFloat(defaultValuePort.get()));
        inputValuePort.set(parseFloat(defaultValuePort.get()));
        // onInputValuePortChanged();
    }
};

reset.onTriggered = function ()
{
    const newValue = parseFloat(defaultValuePort.get());
    valuePort.set(newValue);
    setValueFieldValue(newValue);
    setInputFieldValue(newValue);
    inputValuePort.set(newValue);
    updateActiveTrack();
};

inGreyOut.onChange = function ()
{
    greyOut.style.display = inGreyOut.get() ? "block" : "none";
};

inVisible.onChange = function ()
{
    el.style.display = inVisible.get() ? "block" : "none";
};

function onTextInputChanged(ev)
{
    let newValue = parseFloat(ev.target.value);
    if (isNaN(newValue)) newValue = 0;
    const min = minPort.get();
    const max = maxPort.get();
    if (newValue < min) { newValue = min; }
    else if (newValue > max) { newValue = max; }
    // setInputFieldValue(newValue);
    valuePort.set(newValue);
    updateActiveTrack();
    inputValuePort.set(newValue);
    op.refreshParams();
}

function onInputValuePortChanged()
{
    let newValue = parseFloat(inputValuePort.get());
    const minValue = minPort.get();
    const maxValue = maxPort.get();
    if (newValue > maxValue) { newValue = maxValue; }
    else if (newValue < minValue) { newValue = minValue; }
    // setValueFieldValue(newValue);
    setInputFieldValue(newValue);
    valuePort.set(newValue);
    updateActiveTrack();
}

function onSetDefaultValueButtonPress()
{
    let newValue = parseFloat(inputValuePort.get());
    const minValue = minPort.get();
    const maxValue = maxPort.get();
    if (newValue > maxValue) { newValue = maxValue; }
    else if (newValue < minValue) { newValue = minValue; }
    setValueFieldValue(newValue);
    setInputFieldValue(newValue);
    valuePort.set(newValue);
    defaultValuePort.set(newValue);
    op.refreshParams();

    updateActiveTrack();
}

function onSliderInput(ev)
{
    ev.preventDefault();
    ev.stopPropagation();
    setValueFieldValue(ev.target.value);
    const inputFloat = parseFloat(ev.target.value);
    valuePort.set(inputFloat);
    inputValuePort.set(inputFloat);
    op.refreshParams();

    updateActiveTrack();
    return false;
}

function stepPortChanged()
{
    const step = stepPort.get();
    input.setAttribute("step", step);
    updateActiveTrack();
}

function updateActiveTrack(val)
{
    let valueToUse = parseFloat(input.value);
    if (typeof val !== "undefined") valueToUse = val;
    let availableWidth = activeTrack.parentElement.getBoundingClientRect().width || 220;
    if (parent) availableWidth = parseInt(getComputedStyle(parent.parentElement).getPropertyValue("--sidebar-width")) - 20;

    const trackWidth = CABLES.map(
        valueToUse,
        parseFloat(input.min),
        parseFloat(input.max),
        0,
        availableWidth - 16 /* subtract slider thumb width */
    );
    activeTrack.style.width = trackWidth + "px";
}

function onMinPortChange()
{
    const min = minPort.get();
    input.setAttribute("min", min);
    updateActiveTrack();
}

function onMaxPortChange()
{
    const max = maxPort.get();
    input.setAttribute("max", max);
    updateActiveTrack();
}

function onDefaultValueChanged()
{
    const defaultValue = defaultValuePort.get();
    valuePort.set(parseFloat(defaultValue));
    onMinPortChange();
    onMaxPortChange();
    setInputFieldValue(defaultValue);
    setValueFieldValue(defaultValue);

    updateActiveTrack(defaultValue); // needs to be passed as argument, is this async?
}

function onLabelTextChanged()
{
    const labelText = labelPort.get();
    label.textContent = labelText;
    if (CABLES.UI) op.setUiAttrib({ "extendTitle": labelText });
    value.setAttribute("aria-label", "slider " + labelPort.get());
    input.setAttribute("aria-label", "slider " + labelPort.get());
}

function onParentChanged()
{
    siblingsPort.set(null);
    parent = parentPort.get();
    if (parent && parent.parentElement)
    {
        parent.parentElement.appendChild(el);
        siblingsPort.set(parent);
    }
    else if (el.parentElement) el.parentElement.removeChild(el);

    updateActiveTrack();
}

function setValueFieldValue(v)
{
    value.value = v;
}

function setInputFieldValue(v)
{
    input.value = v;
}

function showElement(el)
{
    if (el)el.style.display = "block";
}

function hideElement(el)
{
    if (el)el.style.display = "none";
}

function onDelete()
{
    removeElementFromDOM(el);
}

function removeElementFromDOM(el)
{
    if (el && el.parentNode && el.parentNode.removeChild) el.parentNode.removeChild(el);
}

}
};

CABLES.OPS["74730122-5cba-4d0d-b610-df334ec6220a"]={f:Ops.Sidebar.Slider_v3,objName:"Ops.Sidebar.Slider_v3"};




// **************************************************************
// 
// Ops.Sidebar.Sidebar
// 
// **************************************************************

Ops.Sidebar.Sidebar= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={"style_css":" /*\n * SIDEBAR\n  http://danielstern.ca/range.css/#/\n  https://developer.mozilla.org/en-US/docs/Web/CSS/::-webkit-progress-value\n */\n\n.sidebar-icon-undo\n{\n    width:10px;\n    height:10px;\n    background-image: url(\"data:image/svg+xml;charset=utf8, %3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' fill='none' stroke='grey' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M3 7v6h6'/%3E%3Cpath d='M21 17a9 9 0 00-9-9 9 9 0 00-6 2.3L3 13'/%3E%3C/svg%3E\");\n    background-size: 19px;\n    background-repeat: no-repeat;\n    top: -19px;\n    margin-top: -7px;\n}\n\n.icon-chevron-down {\n    top: 2px;\n    right: 9px;\n}\n\n.iconsidebar-chevron-up,.sidebar__close-button {\n\tbackground-image: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJub25lIiBzdHJva2U9IiM4ODg4ODgiIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIiBjbGFzcz0iZmVhdGhlciBmZWF0aGVyLWNoZXZyb24tdXAiPjxwb2x5bGluZSBwb2ludHM9IjE4IDE1IDEyIDkgNiAxNSI+PC9wb2x5bGluZT48L3N2Zz4=);\n}\n\n.iconsidebar-minimizebutton {\n    background-position: 98% center;\n    background-repeat: no-repeat;\n}\n\n.sidebar-cables-right\n{\n    right: 15px;\n    left: initial !important;\n}\n\n.sidebar-cables *\n{\n    color: #BBBBBB !important;\n    font-family: Arial;\n}\n\n.sidebar-cables {\n    --sidebar-color: #07f78c;\n    --sidebar-width: 220px;\n    --sidebar-border-radius: 10px;\n    --sidebar-monospace-font-stack: \"SFMono-Regular\", Consolas, \"Liberation Mono\", Menlo, Courier, monospace;\n    --sidebar-hover-transition-time: .2s;\n\n    position: absolute;\n    top: 15px;\n    left: 15px;\n    border-radius: var(--sidebar-border-radius);\n    z-index: 100000;\n    width: var(--sidebar-width);\n    max-height: 100%;\n    box-sizing: border-box;\n    overflow-y: auto;\n    overflow-x: hidden;\n    font-size: 13px;\n    line-height: 1em; /* prevent emojis from breaking height of the title */\n}\n\n.sidebar-cables::selection {\n    background-color: var(--sidebar-color);\n    color: #EEEEEE;\n}\n\n.sidebar-cables::-webkit-scrollbar {\n    background-color: transparent;\n    --cables-scrollbar-width: 8px;\n    width: var(--cables-scrollbar-width);\n}\n\n.sidebar-cables::-webkit-scrollbar-track {\n    background-color: transparent;\n    width: var(--cables-scrollbar-width);\n}\n\n.sidebar-cables::-webkit-scrollbar-thumb {\n    background-color: #333333;\n    border-radius: 4px;\n    width: var(--cables-scrollbar-width);\n}\n\n.sidebar-cables--closed {\n    width: auto;\n}\n\n.sidebar__close-button {\n    background-color: #222;\n    /*-webkit-user-select: none;  */\n    /*-moz-user-select: none;     */\n    /*-ms-user-select: none;      */\n    /*user-select: none;          */\n    /*transition: background-color var(--sidebar-hover-transition-time);*/\n    /*color: #CCCCCC;*/\n    height: 2px;\n    /*border-bottom:20px solid #222;*/\n\n    /*box-sizing: border-box;*/\n    /*padding-top: 2px;*/\n    /*text-align: center;*/\n    /*cursor: pointer;*/\n    /*border-radius: 0 0 var(--sidebar-border-radius) var(--sidebar-border-radius);*/\n    /*opacity: 1.0;*/\n    /*transition: opacity 0.3s;*/\n    /*overflow: hidden;*/\n}\n\n.sidebar__close-button-icon {\n    display: inline-block;\n    /*opacity: 0;*/\n    width: 20px;\n    height: 20px;\n    /*position: relative;*/\n    /*top: -1px;*/\n\n\n}\n\n.sidebar--closed {\n    width: auto;\n    margin-right: 20px;\n}\n\n.sidebar--closed .sidebar__close-button {\n    margin-top: 8px;\n    margin-left: 8px;\n    padding:10px;\n\n    height: 25px;\n    width:25px;\n    border-radius: 50%;\n    cursor: pointer;\n    opacity: 0.3;\n    background-repeat: no-repeat;\n    background-position: center center;\n    transform:rotate(180deg);\n}\n\n.sidebar--closed .sidebar__group\n{\n    display:none;\n\n}\n.sidebar--closed .sidebar__close-button-icon {\n    background-position: 0px 0px;\n}\n\n.sidebar__close-button:hover {\n    background-color: #111111;\n    opacity: 1.0 !important;\n}\n\n/*\n * SIDEBAR ITEMS\n */\n\n.sidebar__items {\n    /* max-height: 1000px; */\n    /* transition: max-height 0.5;*/\n    background-color: #222;\n    padding-bottom: 20px;\n}\n\n.sidebar--closed .sidebar__items {\n    /* max-height: 0; */\n    height: 0;\n    display: none;\n    pointer-interactions: none;\n}\n\n.sidebar__item__right {\n    float: right;\n}\n\n/*\n * SIDEBAR GROUP\n */\n\n.sidebar__group {\n    /*background-color: #1A1A1A;*/\n    overflow: hidden;\n    box-sizing: border-box;\n    animate: height;\n    /*background-color: #151515;*/\n    /* max-height: 1000px; */\n    /* transition: max-height 0.5s; */\n--sidebar-group-header-height: 33px;\n}\n\n.sidebar__group-items\n{\n    padding-top: 15px;\n    padding-bottom: 15px;\n}\n\n.sidebar__group--closed {\n    /* max-height: 13px; */\n    height: var(--sidebar-group-header-height);\n}\n\n.sidebar__group-header {\n    box-sizing: border-box;\n    color: #EEEEEE;\n    background-color: #151515;\n    -webkit-user-select: none;  /* Chrome all / Safari all */\n    -moz-user-select: none;     /* Firefox all */\n    -ms-user-select: none;      /* IE 10+ */\n    user-select: none;          /* Likely future */\n\n    /*height: 100%;//var(--sidebar-group-header-height);*/\n\n    padding-top: 7px;\n    text-transform: uppercase;\n    letter-spacing: 0.08em;\n    cursor: pointer;\n    /*transition: background-color var(--sidebar-hover-transition-time);*/\n    position: relative;\n}\n\n.sidebar__group-header:hover {\n  background-color: #111111;\n}\n\n.sidebar__group-header-title {\n  /*float: left;*/\n  overflow: hidden;\n  padding: 0 15px;\n  padding-top:5px;\n  padding-bottom:10px;\n  font-weight:bold;\n}\n\n.sidebar__group-header-undo {\n    float: right;\n    overflow: hidden;\n    padding-right: 15px;\n    padding-top:5px;\n    font-weight:bold;\n  }\n\n.sidebar__group-header-icon {\n    width: 17px;\n    height: 14px;\n    background-repeat: no-repeat;\n    display: inline-block;\n    position: absolute;\n    background-size: cover;\n\n    /* icon open */\n    /* feather icon: chevron up */\n    background-image: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJub25lIiBzdHJva2U9IiM4ODg4ODgiIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIiBjbGFzcz0iZmVhdGhlciBmZWF0aGVyLWNoZXZyb24tdXAiPjxwb2x5bGluZSBwb2ludHM9IjE4IDE1IDEyIDkgNiAxNSI+PC9wb2x5bGluZT48L3N2Zz4=);\n    top: 4px;\n    right: 5px;\n    opacity: 0.0;\n    transition: opacity 0.3;\n}\n\n.sidebar__group-header:hover .sidebar__group-header-icon {\n    opacity: 1.0;\n}\n\n/* icon closed */\n.sidebar__group--closed .sidebar__group-header-icon {\n    /* feather icon: chevron down */\n    background-image: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJub25lIiBzdHJva2U9IiM4ODg4ODgiIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIiBjbGFzcz0iZmVhdGhlciBmZWF0aGVyLWNoZXZyb24tZG93biI+PHBvbHlsaW5lIHBvaW50cz0iNiA5IDEyIDE1IDE4IDkiPjwvcG9seWxpbmU+PC9zdmc+);\n    top: 4px;\n    right: 5px;\n}\n\n/*\n * SIDEBAR ITEM\n */\n\n.sidebar__item\n{\n    box-sizing: border-box;\n    padding: 7px;\n    padding-left:15px;\n    padding-right:15px;\n\n    overflow: hidden;\n    position: relative;\n}\n\n.sidebar__item-label {\n    display: inline-block;\n    -webkit-user-select: none;  /* Chrome all / Safari all */\n    -moz-user-select: none;     /* Firefox all */\n    -ms-user-select: none;      /* IE 10+ */\n    user-select: none;          /* Likely future */\n    width: calc(50% - 7px);\n    margin-right: 7px;\n    margin-top: 2px;\n    text-overflow: ellipsis;\n    /* overflow: hidden; */\n}\n\n.sidebar__item-value-label {\n    font-family: var(--sidebar-monospace-font-stack);\n    display: inline-block;\n    text-overflow: ellipsis;\n    overflow: hidden;\n    white-space: nowrap;\n    max-width: 60%;\n}\n\n.sidebar__item-value-label::selection {\n    background-color: var(--sidebar-color);\n    color: #EEEEEE;\n}\n\n.sidebar__item + .sidebar__item,\n.sidebar__item + .sidebar__group,\n.sidebar__group + .sidebar__item,\n.sidebar__group + .sidebar__group {\n    /*border-top: 1px solid #272727;*/\n}\n\n/*\n * SIDEBAR ITEM TOGGLE\n */\n\n/*.sidebar__toggle */\n.icon_toggle{\n    cursor: pointer;\n}\n\n.sidebar__toggle-input {\n    --sidebar-toggle-input-color: #CCCCCC;\n    --sidebar-toggle-input-color-hover: #EEEEEE;\n    --sidebar-toggle-input-border-size: 2px;\n    display: inline;\n    float: right;\n    box-sizing: border-box;\n    border-radius: 50%;\n    /*outline-style: solid;*/\n    /*outline-color:red;*/\n    cursor: pointer;\n    --toggle-size: 11px;\n    margin-top: 2px;\n    background-color: transparent !important;\n    border: var(--sidebar-toggle-input-border-size) solid var(--sidebar-toggle-input-color);\n    width: var(--toggle-size);\n    height: var(--toggle-size);\n    transition: background-color var(--sidebar-hover-transition-time);\n    transition: border-color var(--sidebar-hover-transition-time);\n}\n.sidebar__toggle:hover .sidebar__toggle-input {\n    border-color: var(--sidebar-toggle-input-color-hover);\n}\n\n.sidebar__toggle .sidebar__item-value-label {\n    -webkit-user-select: none;  /* Chrome all / Safari all */\n    -moz-user-select: none;     /* Firefox all */\n    -ms-user-select: none;      /* IE 10+ */\n    user-select: none;          /* Likely future */\n    max-width: calc(50% - 12px);\n}\n.sidebar__toggle-input::after { clear: both; }\n\n.sidebar__toggle--active .icon_toggle\n{\n\n    background-image: url(data:image/svg+xml;base64,PHN2ZyBoZWlnaHQ9IjE1cHgiIHdpZHRoPSIzMHB4IiBmaWxsPSIjMDZmNzhiIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB2ZXJzaW9uPSIxLjEiIHg9IjBweCIgeT0iMHB4IiB2aWV3Qm94PSIwIDAgMTAwIDEwMCIgZW5hYmxlLWJhY2tncm91bmQ9Im5ldyAwIDAgMTAwIDEwMCIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+PGcgZGlzcGxheT0ibm9uZSI+PGcgZGlzcGxheT0iaW5saW5lIj48Zz48cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZmlsbD0iIzA2Zjc4YiIgZD0iTTMwLDI3QzE3LjM1LDI3LDcsMzcuMzUsNyw1MGwwLDBjMCwxMi42NSwxMC4zNSwyMywyMywyM2g0MCBjMTIuNjUsMCwyMy0xMC4zNSwyMy0yM2wwLDBjMC0xMi42NS0xMC4zNS0yMy0yMy0yM0gzMHogTTcwLDY3Yy05LjM4OSwwLTE3LTcuNjEtMTctMTdzNy42MTEtMTcsMTctMTdzMTcsNy42MSwxNywxNyAgICAgUzc5LjM4OSw2Nyw3MCw2N3oiPjwvcGF0aD48L2c+PC9nPjwvZz48Zz48cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTMwLDI3QzE3LjM1LDI3LDcsMzcuMzUsNyw1MGwwLDBjMCwxMi42NSwxMC4zNSwyMywyMywyM2g0MCAgIGMxMi42NSwwLDIzLTEwLjM1LDIzLTIzbDAsMGMwLTEyLjY1LTEwLjM1LTIzLTIzLTIzSDMweiBNNzAsNjdjLTkuMzg5LDAtMTctNy42MS0xNy0xN3M3LjYxMS0xNywxNy0xN3MxNyw3LjYxLDE3LDE3ICAgUzc5LjM4OSw2Nyw3MCw2N3oiPjwvcGF0aD48L2c+PGcgZGlzcGxheT0ibm9uZSI+PGcgZGlzcGxheT0iaW5saW5lIj48cGF0aCBmaWxsPSIjMDZmNzhiIiBzdHJva2U9IiMwNmY3OGIiIHN0cm9rZS13aWR0aD0iNCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBkPSJNNyw1MGMwLDEyLjY1LDEwLjM1LDIzLDIzLDIzaDQwICAgIGMxMi42NSwwLDIzLTEwLjM1LDIzLTIzbDAsMGMwLTEyLjY1LTEwLjM1LTIzLTIzLTIzSDMwQzE3LjM1LDI3LDcsMzcuMzUsNyw1MEw3LDUweiI+PC9wYXRoPjwvZz48Y2lyY2xlIGRpc3BsYXk9ImlubGluZSIgZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGZpbGw9IiMwNmY3OGIiIHN0cm9rZT0iIzA2Zjc4YiIgc3Ryb2tlLXdpZHRoPSI0IiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIGN4PSI3MCIgY3k9IjUwIiByPSIxNyI+PC9jaXJjbGU+PC9nPjxnIGRpc3BsYXk9Im5vbmUiPjxwYXRoIGRpc3BsYXk9ImlubGluZSIgZD0iTTcwLDI1SDMwQzE2LjIxNSwyNSw1LDM2LjIxNSw1LDUwczExLjIxNSwyNSwyNSwyNWg0MGMxMy43ODUsMCwyNS0xMS4yMTUsMjUtMjVTODMuNzg1LDI1LDcwLDI1eiBNNzAsNzEgICBIMzBDMTguNDIxLDcxLDksNjEuNTc5LDksNTBzOS40MjEtMjEsMjEtMjFoNDBjMTEuNTc5LDAsMjEsOS40MjEsMjEsMjFTODEuNTc5LDcxLDcwLDcxeiBNNzAsMzFjLTEwLjQ3NywwLTE5LDguNTIzLTE5LDE5ICAgczguNTIzLDE5LDE5LDE5czE5LTguNTIzLDE5LTE5UzgwLjQ3NywzMSw3MCwzMXogTTcwLDY1Yy04LjI3MSwwLTE1LTYuNzI5LTE1LTE1czYuNzI5LTE1LDE1LTE1czE1LDYuNzI5LDE1LDE1Uzc4LjI3MSw2NSw3MCw2NXoiPjwvcGF0aD48L2c+PC9zdmc+);\n    opacity: 1;\n    transform: rotate(0deg);\n    background-position: -4px -9px;\n}\n\n\n.icon_toggle\n{\n    float: right;\n    width:40px;\n    height:18px;\n    background-image: url(data:image/svg+xml;base64,PHN2ZyBoZWlnaHQ9IjE1cHgiIHdpZHRoPSIzMHB4IiBmaWxsPSIjYWFhYWFhIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB2ZXJzaW9uPSIxLjEiIHg9IjBweCIgeT0iMHB4IiB2aWV3Qm94PSIwIDAgMTAwIDEwMCIgZW5hYmxlLWJhY2tncm91bmQ9Im5ldyAwIDAgMTAwIDEwMCIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+PGcgZGlzcGxheT0ibm9uZSI+PGcgZGlzcGxheT0iaW5saW5lIj48Zz48cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZmlsbD0iI2FhYWFhYSIgZD0iTTMwLDI3QzE3LjM1LDI3LDcsMzcuMzUsNyw1MGwwLDBjMCwxMi42NSwxMC4zNSwyMywyMywyM2g0MCBjMTIuNjUsMCwyMy0xMC4zNSwyMy0yM2wwLDBjMC0xMi42NS0xMC4zNS0yMy0yMy0yM0gzMHogTTcwLDY3Yy05LjM4OSwwLTE3LTcuNjEtMTctMTdzNy42MTEtMTcsMTctMTdzMTcsNy42MSwxNywxNyAgICAgUzc5LjM4OSw2Nyw3MCw2N3oiPjwvcGF0aD48L2c+PC9nPjwvZz48Zz48cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTMwLDI3QzE3LjM1LDI3LDcsMzcuMzUsNyw1MGwwLDBjMCwxMi42NSwxMC4zNSwyMywyMywyM2g0MCAgIGMxMi42NSwwLDIzLTEwLjM1LDIzLTIzbDAsMGMwLTEyLjY1LTEwLjM1LTIzLTIzLTIzSDMweiBNNzAsNjdjLTkuMzg5LDAtMTctNy42MS0xNy0xN3M3LjYxMS0xNywxNy0xN3MxNyw3LjYxLDE3LDE3ICAgUzc5LjM4OSw2Nyw3MCw2N3oiPjwvcGF0aD48L2c+PGcgZGlzcGxheT0ibm9uZSI+PGcgZGlzcGxheT0iaW5saW5lIj48cGF0aCBmaWxsPSIjYWFhYWFhIiBzdHJva2U9IiNhYWFhYWEiIHN0cm9rZS13aWR0aD0iNCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBkPSJNNyw1MGMwLDEyLjY1LDEwLjM1LDIzLDIzLDIzaDQwICAgIGMxMi42NSwwLDIzLTEwLjM1LDIzLTIzbDAsMGMwLTEyLjY1LTEwLjM1LTIzLTIzLTIzSDMwQzE3LjM1LDI3LDcsMzcuMzUsNyw1MEw3LDUweiI+PC9wYXRoPjwvZz48Y2lyY2xlIGRpc3BsYXk9ImlubGluZSIgZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGZpbGw9IiNhYWFhYWEiIHN0cm9rZT0iI2FhYWFhYSIgc3Ryb2tlLXdpZHRoPSI0IiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIGN4PSI3MCIgY3k9IjUwIiByPSIxNyI+PC9jaXJjbGU+PC9nPjxnIGRpc3BsYXk9Im5vbmUiPjxwYXRoIGRpc3BsYXk9ImlubGluZSIgZD0iTTcwLDI1SDMwQzE2LjIxNSwyNSw1LDM2LjIxNSw1LDUwczExLjIxNSwyNSwyNSwyNWg0MGMxMy43ODUsMCwyNS0xMS4yMTUsMjUtMjVTODMuNzg1LDI1LDcwLDI1eiBNNzAsNzEgICBIMzBDMTguNDIxLDcxLDksNjEuNTc5LDksNTBzOS40MjEtMjEsMjEtMjFoNDBjMTEuNTc5LDAsMjEsOS40MjEsMjEsMjFTODEuNTc5LDcxLDcwLDcxeiBNNzAsMzFjLTEwLjQ3NywwLTE5LDguNTIzLTE5LDE5ICAgczguNTIzLDE5LDE5LDE5czE5LTguNTIzLDE5LTE5UzgwLjQ3NywzMSw3MCwzMXogTTcwLDY1Yy04LjI3MSwwLTE1LTYuNzI5LTE1LTE1czYuNzI5LTE1LDE1LTE1czE1LDYuNzI5LDE1LDE1Uzc4LjI3MSw2NSw3MCw2NXoiPjwvcGF0aD48L2c+PC9zdmc+);\n    background-size: 50px 37px;\n    background-position: -6px -10px;\n    transform: rotate(180deg);\n    opacity: 0.4;\n}\n\n\n\n/*.sidebar__toggle--active .sidebar__toggle-input {*/\n/*    transition: background-color var(--sidebar-hover-transition-time);*/\n/*    background-color: var(--sidebar-toggle-input-color);*/\n/*}*/\n/*.sidebar__toggle--active .sidebar__toggle-input:hover*/\n/*{*/\n/*    background-color: var(--sidebar-toggle-input-color-hover);*/\n/*    border-color: var(--sidebar-toggle-input-color-hover);*/\n/*    transition: background-color var(--sidebar-hover-transition-time);*/\n/*    transition: border-color var(--sidebar-hover-transition-time);*/\n/*}*/\n\n/*\n * SIDEBAR ITEM BUTTON\n */\n\n.sidebar__button {}\n\n.sidebar__button-input:active\n{\n    background-color: #555 !important;\n}\n\n.sidebar__button-input {\n    -webkit-user-select: none;  /* Chrome all / Safari all */\n    -moz-user-select: none;     /* Firefox all */\n    -ms-user-select: none;      /* IE 10+ */\n    user-select: none;          /* Likely future */\n    min-height: 24px;\n    background-color: transparent;\n    color: #CCCCCC;\n    box-sizing: border-box;\n    padding-top: 3px;\n    text-align: center;\n    border-radius: 125px;\n    border:2px solid #555;\n    cursor: pointer;\n    padding-bottom: 3px;\n    display:block;\n}\n\n.sidebar__button-input.plus, .sidebar__button-input.minus {\n    display: inline-block;\n    min-width: 20px;\n}\n\n.sidebar__button-input:hover {\n  background-color: #333;\n  border:2px solid var(--sidebar-color);\n}\n\n/*\n * VALUE DISPLAY (shows a value)\n */\n\n.sidebar__value-display {}\n\n/*\n * SLIDER\n */\n\n.sidebar__slider {\n    --sidebar-slider-input-height: 3px;\n}\n\n.sidebar__slider-input-wrapper {\n    width: 100%;\n\n    margin-top: 8px;\n    position: relative;\n}\n\n.sidebar__slider-input {\n    -webkit-appearance: none;\n    appearance: none;\n    margin: 0;\n    width: 100%;\n    height: var(--sidebar-slider-input-height);\n    background: #555;\n    cursor: pointer;\n    /*outline: 0;*/\n\n    -webkit-transition: .2s;\n    transition: background-color .2s;\n    border: none;\n}\n\n.sidebar__slider-input:focus, .sidebar__slider-input:hover {\n    border: none;\n}\n\n.sidebar__slider-input-active-track {\n    user-select: none;\n    position: absolute;\n    z-index: 11;\n    top: 0;\n    left: 0;\n    background-color: var(--sidebar-color);\n    pointer-events: none;\n    height: var(--sidebar-slider-input-height);\n    max-width: 100%;\n}\n\n/* Mouse-over effects */\n.sidebar__slider-input:hover {\n    /*background-color: #444444;*/\n}\n\n/*.sidebar__slider-input::-webkit-progress-value {*/\n/*    background-color: green;*/\n/*    color:green;*/\n\n/*    }*/\n\n/* The slider handle (use -webkit- (Chrome, Opera, Safari, Edge) and -moz- (Firefox) to override default look) */\n\n.sidebar__slider-input::-moz-range-thumb\n{\n    position: absolute;\n    height: 15px;\n    width: 15px;\n    z-index: 900 !important;\n    border-radius: 20px !important;\n    cursor: pointer;\n    background: var(--sidebar-color) !important;\n    user-select: none;\n\n}\n\n.sidebar__slider-input::-webkit-slider-thumb\n{\n    position: relative;\n    appearance: none;\n    -webkit-appearance: none;\n    user-select: none;\n    height: 15px;\n    width: 15px;\n    display: block;\n    z-index: 900 !important;\n    border: 0;\n    border-radius: 20px !important;\n    cursor: pointer;\n    background: #777 !important;\n}\n\n.sidebar__slider-input:hover ::-webkit-slider-thumb {\n    background-color: #EEEEEE !important;\n}\n\n/*.sidebar__slider-input::-moz-range-thumb {*/\n\n/*    width: 0 !important;*/\n/*    height: var(--sidebar-slider-input-height);*/\n/*    background: #EEEEEE;*/\n/*    cursor: pointer;*/\n/*    border-radius: 0 !important;*/\n/*    border: none;*/\n/*    outline: 0;*/\n/*    z-index: 100 !important;*/\n/*}*/\n\n.sidebar__slider-input::-moz-range-track {\n    background-color: transparent;\n    z-index: 11;\n}\n\n.sidebar__slider input[type=text],\n.sidebar__slider input[type=paddword]\n{\n    box-sizing: border-box;\n    /*background-color: #333333;*/\n    text-align: right;\n    color: #BBBBBB;\n    display: inline-block;\n    background-color: transparent !important;\n\n    width: 40%;\n    height: 18px;\n    /*outline: none;*/\n    border: none;\n    border-radius: 0;\n    padding: 0 0 0 4px !important;\n    margin: 0;\n}\n\n.sidebar__slider input[type=text]:active,\n.sidebar__slider input[type=text]:focus,\n.sidebar__slider input[type=text]:hover\n.sidebar__slider input[type=password]:active,\n.sidebar__slider input[type=password]:focus,\n.sidebar__slider input[type=password]:hover\n{\n\n    color: #EEEEEE;\n}\n\n/*\n * TEXT / DESCRIPTION\n */\n\n.sidebar__text .sidebar__item-label {\n    width: auto;\n    display: block;\n    max-height: none;\n    margin-right: 0;\n    line-height: 1.1em;\n}\n\n/*\n * SIDEBAR INPUT\n */\n.sidebar__text-input textarea,\n.sidebar__text-input input[type=date],\n.sidebar__text-input input[type=datetime-local],\n.sidebar__text-input input[type=text],\n.sidebar__text-input input[type=password] {\n    box-sizing: border-box;\n    background-color: #333333;\n    color: #BBBBBB;\n    display: inline-block;\n    width: 50%;\n    height: 18px;\n\n\n    border: none;\n    border-radius: 0;\n    border:1px solid #666;\n    padding: 0 0 0 4px !important;\n    margin: 0;\n    color-scheme: dark;\n}\n\n.sidebar__text-input textarea:focus::placeholder {\n  color: transparent;\n}\n\n\n\n\n\n.sidebar__color-picker .sidebar__item-label\n{\n    width:45%;\n}\n\n.sidebar__text-input textarea,\n.sidebar__text-input input[type=text]:active,\n.sidebar__text-input input[type=text]:focus,\n.sidebar__text-input input[type=text]:hover,\n.sidebar__text-input input[type=password]:active,\n.sidebar__text-input input[type=password]:focus,\n.sidebar__text-input input[type=password]:hover {\n    background-color: transparent;\n    color: #EEEEEE;\n\n}\n\n.sidebar__text-input textarea\n{\n    margin-top:10px;\n    height:60px;\n    width:100%;\n}\n\n/*\n * SIDEBAR SELECT\n */\n\n\n\n .sidebar__select {}\n .sidebar__select-select {\n    color: #BBBBBB;\n    /*-webkit-appearance: none;*/\n    /*-moz-appearance: none;*/\n    appearance: none;\n    /*box-sizing: border-box;*/\n    width: 50%;\n    /*height: 20px;*/\n    background-color: #333333;\n    /*background-image: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJub25lIiBzdHJva2U9IiM4ODg4ODgiIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIiBjbGFzcz0iZmVhdGhlciBmZWF0aGVyLWNoZXZyb24tZG93biI+PHBvbHlsaW5lIHBvaW50cz0iNiA5IDEyIDE1IDE4IDkiPjwvcG9seWxpbmU+PC9zdmc+);*/\n    background-repeat: no-repeat;\n    background-position: right center;\n    background-size: 16px 16px;\n    margin: 0;\n    /*padding: 0 2 2 6px;*/\n    border-radius: 5px;\n    border: 1px solid #777;\n    background-color: #444;\n    cursor: pointer;\n    /*outline: none;*/\n    padding-left: 5px;\n\n }\n\n.sidebar__select-select:hover,\n.sidebar__select-select:active,\n.sidebar__select-select:inactive {\n    background-color: #444444;\n    color: #EEEEEE;\n}\n\n/*.sidebar__select-select option*/\n/*{*/\n/*    background-color: #444444;*/\n/*    color: #bbb;*/\n/*}*/\n\n.sidebar__select-select option:checked\n{\n    background-color: #000;\n    color: #FFF;\n}\n\n\n/*\n * COLOR PICKER\n */\n\n\n .sidebar__color-picker input[type=text] {\n    box-sizing: border-box;\n    background-color: #333333;\n    color: #BBBBBB;\n    display: inline-block;\n    width: calc(50% - 21px); /* 50% minus space of picker circle */\n    height: 18px;\n    /*outline: none;*/\n    border: none;\n    border-radius: 0;\n    padding: 0 0 0 4px !important;\n    margin: 0;\n    margin-right: 7px;\n}\n\n.sidebar__color-picker input[type=text]:active,\n.sidebar__color-picker input[type=text]:focus,\n.sidebar__color-picker input[type=text]:hover {\n    background-color: #444444;\n    color: #EEEEEE;\n}\n\ndiv.sidebar__color-picker-color-input,\n.sidebar__color-picker input[type=color],\n.sidebar__palette-picker input[type=color] {\n    display: inline-block;\n    border-radius: 100%;\n    height: 14px;\n    width: 14px;\n\n    padding: 0;\n    border: none;\n    /*border:2px solid red;*/\n    border-color: transparent;\n    outline: none;\n    background: none;\n    appearance: none;\n    -moz-appearance: none;\n    -webkit-appearance: none;\n    cursor: pointer;\n    position: relative;\n    top: 3px;\n}\n.sidebar__color-picker input[type=color]:focus,\n.sidebar__palette-picker input[type=color]:focus {\n    outline: none;\n}\n.sidebar__color-picker input[type=color]::-moz-color-swatch,\n.sidebar__palette-picker input[type=color]::-moz-color-swatch {\n    border: none;\n}\n.sidebar__color-picker input[type=color]::-webkit-color-swatch-wrapper,\n.sidebar__palette-picker input[type=color]::-webkit-color-swatch-wrapper {\n    padding: 0;\n}\n.sidebar__color-picker input[type=color]::-webkit-color-swatch,\n.sidebar__palette-picker input[type=color]::-webkit-color-swatch {\n    border: none;\n    border-radius: 100%;\n}\n\n/*\n * Palette Picker\n */\n.sidebar__palette-picker .sidebar__palette-picker-color-input.first {\n    margin-left: 0;\n}\n.sidebar__palette-picker .sidebar__palette-picker-color-input.last {\n    margin-right: 0;\n}\n.sidebar__palette-picker .sidebar__palette-picker-color-input {\n    margin: 0 4px;\n}\n\n.sidebar__palette-picker .circlebutton {\n    width: 14px;\n    height: 14px;\n    border-radius: 1em;\n    display: inline-block;\n    top: 3px;\n    position: relative;\n}\n\n/*\n * Preset\n */\n.sidebar__item-presets-preset\n{\n    padding:4px;\n    cursor:pointer;\n    padding-left:8px;\n    padding-right:8px;\n    margin-right:4px;\n    background-color:#444;\n}\n\n.sidebar__item-presets-preset:hover\n{\n    background-color:#666;\n}\n\n.sidebar__greyout\n{\n    background: #222;\n    opacity: 0.8;\n    width: 100%;\n    height: 100%;\n    position: absolute;\n    z-index: 1000;\n    right: 0;\n    top: 0;\n}\n\n.sidebar_tabs\n{\n    background-color: #151515;\n    padding-bottom: 0px;\n}\n\n.sidebar_switchs\n{\n    float: right;\n}\n\n.sidebar_tab\n{\n    float:left;\n    background-color: #151515;\n    border-bottom:1px solid transparent;\n    padding-right:7px;\n    padding-left:7px;\n    padding-bottom: 5px;\n    padding-top: 5px;\n    cursor:pointer;\n}\n\n.sidebar_tab_active\n{\n    background-color: #272727;\n    color:white;\n}\n\n.sidebar_tab:hover\n{\n    border-bottom:1px solid #777;\n    color:white;\n}\n\n\n.sidebar_switch\n{\n    float:left;\n    background-color: #444;\n    padding-right:7px;\n    padding-left:7px;\n    padding-bottom: 5px;\n    padding-top: 5px;\n    cursor:pointer;\n}\n\n.sidebar_switch:last-child\n{\n    border-top-right-radius: 7px;\n    border-bottom-right-radius: 7px;\n}\n\n.sidebar_switch:first-child\n{\n    border-top-left-radius: 7px;\n    border-bottom-left-radius: 7px;\n}\n\n\n.sidebar_switch_active\n{\n    background-color: #999;\n    color:white;\n}\n\n.sidebar_switch:hover\n{\n    color:white;\n}\n\n.sidebar__text-input-input::focus-visible,\n/*.sidebar__text-input-input:active,*/\n.sidebar__button-input:focus-visible,\n.sidebar__text-input:focus-visible\n/*.sidebar__text-input:active*/\n{\n    outline-style: solid;\n    outline-color:white;\n    outline-width: 1px;\n\n}\n\n",};
// vars
const CSS_ELEMENT_CLASS = "cables-sidebar-style"; /* class for the style element to be generated */
const CSS_ELEMENT_DYNAMIC_CLASS = "cables-sidebar-dynamic-style"; /* things which can be set via op-port, but not attached to the elements themselves, e.g. minimized opacity */
const SIDEBAR_CLASS = "sidebar-cables";
const SIDEBAR_ID = "sidebar" + CABLES.uuid();
const SIDEBAR_ITEMS_CLASS = "sidebar__items";
const SIDEBAR_OPEN_CLOSE_BTN_CLASS = "sidebar__close-button";

const BTN_TEXT_OPEN = ""; // 'Close';
const BTN_TEXT_CLOSED = ""; // 'Show Controls';

let openCloseBtn = null;
let openCloseBtnIcon = null;
let headerTitleText = null;

// inputs
const visiblePort = op.inValueBool("Visible", true);
const opacityPort = op.inValueSlider("Opacity", 1);
const defaultMinimizedPort = op.inValueBool("Default Minimized");
const minimizedOpacityPort = op.inValueSlider("Minimized Opacity", 0.5);
const undoButtonPort = op.inValueBool("Show undo button", false);
const inMinimize = op.inValueBool("Show Minimize", false);

const inTitle = op.inString("Title", "");
const side = op.inValueBool("Side");
const addCss = op.inValueBool("Default CSS", true);

let doc = op.patch.cgl.canvas.ownerDocument;

// outputs
const childrenPort = op.outObject("childs");
childrenPort.setUiAttribs({ "title": "Children" });

const isOpenOut = op.outBool("Opfened");
isOpenOut.setUiAttribs({ "title": "Opened" });

let sidebarEl = doc.querySelector("." + SIDEBAR_ID);
if (!sidebarEl) sidebarEl = initSidebarElement();

const sidebarItemsEl = sidebarEl.querySelector("." + SIDEBAR_ITEMS_CLASS);
childrenPort.set({
    "parentElement": sidebarItemsEl,
    "parentOp": op,
});
onDefaultMinimizedPortChanged();
initSidebarCss();
updateDynamicStyles();

addCss.onChange = () =>
{
    initSidebarCss();
    updateDynamicStyles();
};
visiblePort.onChange = onVisiblePortChange;
opacityPort.onChange = onOpacityPortChange;
defaultMinimizedPort.onChange = onDefaultMinimizedPortChanged;
minimizedOpacityPort.onChange = onMinimizedOpacityPortChanged;
undoButtonPort.onChange = onUndoButtonChange;
op.onDelete = onDelete;

function onMinimizedOpacityPortChanged()
{
    updateDynamicStyles();
}

inMinimize.onChange = updateMinimize;

function updateMinimize(header)
{
    if (!header || header.uiAttribs) header = doc.querySelector(".sidebar-cables .sidebar__group-header");
    if (!header) return;

    const undoButton = doc.querySelector(".sidebar-cables .sidebar__group-header .sidebar__group-header-undo");

    if (inMinimize.get())
    {
        header.classList.add("iconsidebar-chevron-up");
        header.classList.add("iconsidebar-minimizebutton");

        if (undoButton)undoButton.style.marginRight = "20px";
    }
    else
    {
        header.classList.remove("iconsidebar-chevron-up");
        header.classList.remove("iconsidebar-minimizebutton");

        if (undoButton)undoButton.style.marginRight = "initial";
    }
}

side.onChange = function ()
{
    if (!sidebarEl) return;
    if (side.get()) sidebarEl.classList.add("sidebar-cables-right");
    else sidebarEl.classList.remove("sidebar-cables-right");
};

function onUndoButtonChange()
{
    const header = doc.querySelector(".sidebar-cables .sidebar__group-header");
    if (header)
    {
        initUndoButton(header);
    }
}

function initUndoButton(header)
{
    if (header)
    {
        const undoButton = doc.querySelector(".sidebar-cables .sidebar__group-header .sidebar__group-header-undo");
        if (undoButton)
        {
            if (!undoButtonPort.get())
            {
                // header.removeChild(undoButton);
                undoButton.remove();
            }
        }
        else
        {
            if (undoButtonPort.get())
            {
                const headerUndo = doc.createElement("span");
                headerUndo.classList.add("sidebar__group-header-undo");
                headerUndo.classList.add("sidebar-icon-undo");

                headerUndo.addEventListener("click", function (event)
                {
                    event.stopPropagation();
                    const reloadables = doc.querySelectorAll(".sidebar-cables .sidebar__reloadable");
                    const doubleClickEvent = doc.createEvent("MouseEvents");
                    doubleClickEvent.initEvent("dblclick", true, true);
                    reloadables.forEach((reloadable) =>
                    {
                        reloadable.dispatchEvent(doubleClickEvent);
                    });
                });
                header.appendChild(headerUndo);
            }
        }
    }
    updateMinimize(header);
}

function onDefaultMinimizedPortChanged()
{
    if (!openCloseBtn) { return; }
    if (defaultMinimizedPort.get())
    {
        sidebarEl.classList.add("sidebar--closed");
        if (visiblePort.get()) isOpenOut.set(false);
    }
    else
    {
        sidebarEl.classList.remove("sidebar--closed");
        if (visiblePort.get()) isOpenOut.set(true);
    }
}

function onOpacityPortChange()
{
    const opacity = opacityPort.get();
    sidebarEl.style.opacity = opacity;
}

function onVisiblePortChange()
{
    if (!sidebarEl) return;
    if (visiblePort.get())
    {
        sidebarEl.style.display = "block";
        if (!sidebarEl.classList.contains("sidebar--closed")) isOpenOut.set(true);
    }
    else
    {
        sidebarEl.style.display = "none";
        isOpenOut.set(false);
    }
}

side.onChanged = function ()
{

};

/**
 * Some styles cannot be set directly inline, so a dynamic stylesheet is needed.
 * Here hover states can be set later on e.g.
 */
function updateDynamicStyles()
{
    const dynamicStyles = doc.querySelectorAll("." + CSS_ELEMENT_DYNAMIC_CLASS);
    if (dynamicStyles)
    {
        dynamicStyles.forEach(function (e)
        {
            e.parentNode.removeChild(e);
        });
    }

    if (!addCss.get()) return;

    const newDynamicStyle = doc.createElement("style");
    newDynamicStyle.classList.add("cablesEle");
    newDynamicStyle.classList.add(CSS_ELEMENT_DYNAMIC_CLASS);
    let cssText = ".sidebar--closed .sidebar__close-button { ";
    cssText += "opacity: " + minimizedOpacityPort.get();
    cssText += "}";
    const cssTextEl = doc.createTextNode(cssText);
    newDynamicStyle.appendChild(cssTextEl);
    doc.body.appendChild(newDynamicStyle);
}

function initSidebarElement()
{
    const element = doc.createElement("div");
    element.classList.add(SIDEBAR_CLASS);
    element.classList.add(SIDEBAR_ID);
    const canvasWrapper = op.patch.cgl.canvas.parentElement; /* maybe this is bad outside cables!? */

    // header...
    const headerGroup = doc.createElement("div");
    headerGroup.classList.add("sidebar__group");

    element.appendChild(headerGroup);
    const header = doc.createElement("div");
    header.classList.add("sidebar__group-header");

    element.appendChild(header);
    const headerTitle = doc.createElement("span");
    headerTitle.classList.add("sidebar__group-header-title");
    headerTitleText = doc.createElement("span");
    headerTitleText.classList.add("sidebar__group-header-title-text");
    headerTitleText.innerHTML = inTitle.get();
    headerTitle.appendChild(headerTitleText);
    header.appendChild(headerTitle);

    initUndoButton(header);
    updateMinimize(header);

    headerGroup.appendChild(header);
    element.appendChild(headerGroup);
    headerGroup.addEventListener("click", onOpenCloseBtnClick);

    if (!canvasWrapper)
    {
        op.warn("[sidebar] no canvas parentelement found...");
        return;
    }
    canvasWrapper.appendChild(element);
    const items = doc.createElement("div");
    items.classList.add(SIDEBAR_ITEMS_CLASS);
    element.appendChild(items);
    openCloseBtn = doc.createElement("div");
    openCloseBtn.classList.add(SIDEBAR_OPEN_CLOSE_BTN_CLASS);
    openCloseBtn.addEventListener("click", onOpenCloseBtnClick);
    element.appendChild(openCloseBtn);

    return element;
}

inTitle.onChange = function ()
{
    if (headerTitleText)headerTitleText.innerHTML = inTitle.get();
};

function setClosed(b)
{

}

function onOpenCloseBtnClick(ev)
{
    ev.stopPropagation();
    if (!sidebarEl) { op.logError("Sidebar could not be closed..."); return; }
    sidebarEl.classList.toggle("sidebar--closed");
    const btn = ev.target;
    let btnText = BTN_TEXT_OPEN;
    if (sidebarEl.classList.contains("sidebar--closed"))
    {
        btnText = BTN_TEXT_CLOSED;
        isOpenOut.set(false);
    }
    else
    {
        isOpenOut.set(true);
    }
}

function initSidebarCss()
{
    const cssElements = doc.querySelectorAll("." + CSS_ELEMENT_CLASS);
    // remove old script tag
    if (cssElements)
    {
        cssElements.forEach((e) =>
        {
            e.parentNode.removeChild(e);
        });
    }

    if (!addCss.get()) return;

    const newStyle = doc.createElement("style");

    newStyle.innerHTML = attachments.style_css;
    newStyle.classList.add(CSS_ELEMENT_CLASS);
    newStyle.classList.add("cablesEle");
    doc.body.appendChild(newStyle);
}

function onDelete()
{
    removeElementFromDOM(sidebarEl);
}

function removeElementFromDOM(el)
{
    if (el && el.parentNode && el.parentNode.removeChild) el.parentNode.removeChild(el);
}

}
};

CABLES.OPS["5a681c35-78ce-4cb3-9858-bc79c34c6819"]={f:Ops.Sidebar.Sidebar,objName:"Ops.Sidebar.Sidebar"};




// **************************************************************
// 
// Ops.Math.Floor
// 
// **************************************************************

Ops.Math.Floor= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
const number1 = op.inValue("Number");
const result = op.outNumber("Result");
number1.onChange = exec;

function exec()
{
    result.set(Math.floor(number1.get()));
}

}
};

CABLES.OPS["0c77617c-b688-4b55-addf-2cbcaabf98af"]={f:Ops.Math.Floor,objName:"Ops.Math.Floor"};




// **************************************************************
// 
// Ops.Ui.VizArrayTable
// 
// **************************************************************

Ops.Ui.VizArrayTable= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
const
    inArr = op.inArray("Array"),
    inStride = op.inInt("Stride", 0),
    inOffset = op.inInt("Start Row", 0);

op.setUiAttrib({ "height": 200, "width": 400, "resizable": true, "vizLayerMaxZoom": 2500 });

function getCellValue(v)
{
    let str = "";

    if (typeof v == "string")
    {
        // if (CABLES.isNumeric(v)) str = "\"" + v + "\"";
        // else str = v;
        str = "\"" + v + "\"";
    }
    else if (CABLES.isNumeric(v)) str = String(Math.round(v * 10000) / 10000);
    else if (Array.isArray(v))
    {
        let preview = "...";
        if (v.length == 0) preview = "";
        str = "[" + preview + "] (" + v.length + ")";
    }
    else if (typeof v == "object")
    {
        try
        {
            str = JSON.stringify(v, true, 1);
        }
        catch (e)
        {
            str = "{???}";
        }
    }
    else if (v != v || v === undefined)
    {
        str += String(v);
    }
    else
    {
        str += String(v);
    }

    return str;
}

op.renderVizLayer = (ctx, layer) =>
{
    ctx.fillStyle = "#222";
    ctx.fillRect(layer.x, layer.y, layer.width, layer.height);

    ctx.save();
    ctx.scale(layer.scale, layer.scale);

    ctx.font = "normal 10px sourceCodePro";
    ctx.fillStyle = "#ccc";

    const arr = inArr.get() || [];
    let stride = inStride.get() || 1;

    if (inArr.get() === null) op.setUiAttrib({ "extendTitle": "null" });
    else if (inArr.get() === undefined) op.setUiAttrib({ "extendTitle": "undefined" });
    else op.setUiAttrib({ "extendTitle": "length: " + arr.length });

    if (inArr.links.length > 0 && inArr.links[0].getOtherPort(inArr))
        stride = inArr.links[0].getOtherPort(inArr).uiAttribs.stride || inStride.get() || 1;

    if (arr.length % stride != 0)op.setUiError("stride", "stride does not fit length of array. some values may not be shown", 1);
    else op.setUiError("stride", null);

    let lines = Math.floor(layer.height / layer.scale / 10 - 1);
    let padding = 4;
    let offset = inOffset.get() * stride;
    let columnsWidth = [];

    for (let i = 0; i < stride; i++)columnsWidth[i] = 0;

    for (let i = offset; i < offset + lines * stride; i += stride)
    {
        for (let s = 0; s < stride; s++)
        {
            const v = arr[i + s];

            columnsWidth[s] = Math.max(columnsWidth[s], getCellValue(v).length);
        }
    }

    let columsPos = [];
    let addUpPos = 30;
    for (let i = 0; i < stride; i++)
    {
        columsPos[i] = addUpPos;
        addUpPos += (columnsWidth[i] + 1) * 7;
    }

    for (let i = offset; i < offset + lines * stride; i += stride)
    {
        if (i < 0) continue;
        if (i + stride > arr.length) continue;

        ctx.fillStyle = "#666";

        const lineNum = (i) / stride;

        if (lineNum >= 0)
            ctx.fillText(lineNum,
                layer.x / layer.scale + padding,
                layer.y / layer.scale + 10 + (i - offset) / stride * 10 + padding);

        for (let s = 0; s < stride; s++)
        {
            const v = arr[i + s];
            let str = getCellValue(v);

            ctx.fillStyle = "#ccc";

            if (typeof v == "string")
            {
                str = v;
            }
            else if (CABLES.isNumeric(v)) str = String(Math.round(v * 10000) / 10000);
            else if (Array.isArray(v))
            {
                str = JSON.stringify(v);
            }
            else if (typeof v == "object")
            {
                try
                {
                    str = JSON.stringify(v);
                }
                catch (e)
                {
                    str = "{Object}";
                }
            }
            else if (v != v || v === undefined)
            {
                ctx.fillStyle = "#f00";
                str = "?";
            }

            ctx.fillText(str,
                layer.x / layer.scale + columsPos[s],
                layer.y / layer.scale + 10 + (i - offset) / stride * 10 + padding);
        }
    }

    if (inArr.get() === null) ctx.fillText("null", layer.x / layer.scale + 10, layer.y / layer.scale + 10 + padding);
    else if (inArr.get() === undefined) ctx.fillText("undefined", layer.x / layer.scale + 10, layer.y / layer.scale + 10 + padding);

    const gradHeight = 30;

    if (layer.scale <= 0) return;
    if (offset > 0)
    {
        const radGrad = ctx.createLinearGradient(0, layer.y / layer.scale + 5, 0, layer.y / layer.scale + gradHeight);
        radGrad.addColorStop(0, "#222");
        radGrad.addColorStop(1, "rgba(34,34,34,0.0)");
        ctx.fillStyle = radGrad;
        ctx.fillRect(layer.x / layer.scale, layer.y / layer.scale, 200000, gradHeight);
    }

    if (offset + lines * stride < arr.length)
    {
        const radGrad = ctx.createLinearGradient(0, layer.y / layer.scale + layer.height / layer.scale - gradHeight + 5, 0, layer.y / layer.scale + layer.height / layer.scale - gradHeight + gradHeight);
        radGrad.addColorStop(1, "#222");
        radGrad.addColorStop(0, "rgba(34,34,34,0.0)");
        ctx.fillStyle = radGrad;
        ctx.fillRect(layer.x / layer.scale, layer.y / layer.scale + layer.height / layer.scale - gradHeight, 200000, gradHeight);
    }

    ctx.restore();
};

}
};

CABLES.OPS["af2eeaaf-ff86-4bfb-9a27-42f05160a5d8"]={f:Ops.Ui.VizArrayTable,objName:"Ops.Ui.VizArrayTable"};




// **************************************************************
// 
// Ops.Array.Array4
// 
// **************************************************************

Ops.Array.Array4= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
const
    inNum = op.inValueInt("Num Quadruplets", 100),
    inX = op.inValueFloat("X", 1),
    inY = op.inValueFloat("Y", 1),
    inZ = op.inValueFloat("Z", 1),
    inW = op.inValueFloat("W", 1),
    outArr = op.outArray("Array", null, 4),
    outTotalPoints = op.outNumber("Total Quadruplets"),
    outArrayLength = op.outNumber("Array length");

inNum.onChange =
    inX.onChange =
    inY.onChange =
    inZ.onChange =
    inW.onChange = update;

let arr = [];
update();

function update()
{
    let num = Math.floor(inNum.get() * 4);

    if (num < 0)num = 0;
    if (arr.length != num) arr.length = num;

    const x = inX.get();
    const y = inY.get();
    const z = inZ.get();
    const w = inW.get();

    for (let i = 0; i < num; i += 4)
    {
        arr[i] = x;
        arr[i + 1] = y;
        arr[i + 2] = z;
        arr[i + 3] = w;
    }

    outArr.setRef(arr);
    outTotalPoints.set(num / 4);
    outArrayLength.set(num);
}

}
};

CABLES.OPS["28607c74-fa98-423e-a6b6-14305d159eac"]={f:Ops.Array.Array4,objName:"Ops.Array.Array4"};




// **************************************************************
// 
// Ops.String.String_v2
// 
// **************************************************************

Ops.String.String_v2= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
const
    v = op.inString("value", ""),
    result = op.outString("String");

v.onChange = function ()
{
    if (!v.isLinked())
        op.setUiAttrib({ "extendTitle": v.get() });

    result.set(v.get());
};

}
};

CABLES.OPS["d697ff82-74fd-4f31-8f54-295bc64e713d"]={f:Ops.String.String_v2,objName:"Ops.String.String_v2"};




// **************************************************************
// 
// Ops.Array.Array_v3
// 
// **************************************************************

Ops.Array.Array_v3= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
const
    inLength = op.inValueInt("Array length", 10),
    modeSelect = op.inSwitch("Mode select", ["Number", "1,2,3,4", "0-1"], "Number"),
    inDefaultValue = op.inValueFloat("Default Value"),
    inReverse = op.inBool("Reverse", false),
    outArr = op.outArray("Array"),
    outArrayLength = op.outNumber("Array length out");

let arr = [];
let selectIndex = 0;
const MODE_NUMBER = 0;
const MODE_1_TO_4 = 1;
const MODE_0_TO_1 = 2;

modeSelect.onChange = onFilterChange;

inReverse.onChange =
    inDefaultValue.onChange =
    inLength.onChange = reset;

onFilterChange();
reset();

function onFilterChange()
{
    let selectedMode = modeSelect.get();
    if (selectedMode === "Number") selectIndex = MODE_NUMBER;
    else if (selectedMode === "1,2,3,4") selectIndex = MODE_1_TO_4;
    else if (selectedMode === "0-1") selectIndex = MODE_0_TO_1;

    inDefaultValue.setUiAttribs({ "greyout": selectIndex !== MODE_NUMBER });

    op.setUiAttrib({ "extendTitle": modeSelect.get() });

    reset();
}

function reset()
{
    arr.length = 0;

    let arrLength = inLength.get();
    let valueForArray = inDefaultValue.get();
    let i;

    // mode 0 - fill all array values with one number
    if (selectIndex === MODE_NUMBER)
    {
        for (i = 0; i < arrLength; i++)
        {
            arr[i] = valueForArray;
        }
    }
    // mode 1 Continuous number array - increments up to array length
    else if (selectIndex === MODE_1_TO_4)
    {
        for (i = 0; i < arrLength; i++)
        {
            arr[i] = i;
        }
    }
    // mode 2 Normalized array
    else if (selectIndex === MODE_0_TO_1)
    {
        if (arrLength > 1) { 
            for (i = 0; i < arrLength; i++)
                {
                    arr[i] = i / (arrLength - 1);
                }
        } else 
        {
            //When array length is only 1 
            arr = [0];
        }
    }

    if (inReverse.get())arr = arr.reverse();

    outArr.setRef(arr);
    outArrayLength.set(arr.length);
}

}
};

CABLES.OPS["e4d31a46-bf64-42a8-be34-4cbb2bbc2600"]={f:Ops.Array.Array_v3,objName:"Ops.Array.Array_v3"};




// **************************************************************
// 
// Ops.Number.Integer
// 
// **************************************************************

Ops.Number.Integer= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
const
    input = op.inInt("Integer", 0),
    output = op.outNumber("Number out");

input.onChange = function ()
{
    output.set(Math.floor(input.get()));
};

}
};

CABLES.OPS["17bc01d7-04ad-4aab-b88b-bb09744c4a69"]={f:Ops.Number.Integer,objName:"Ops.Number.Integer"};




// **************************************************************
// 
// Ops.Array.MapRangeArray
// 
// **************************************************************

Ops.Array.MapRangeArray= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
const
    v = op.inArray("array"),
    old_min = op.inValueFloat("old min"),
    old_max = op.inValueFloat("old max"),
    new_min = op.inValueFloat("new min"),
    new_max = op.inValueFloat("new max"),
    easing = op.inValueSelect("Easing", ["Linear", "Smoothstep", "Smootherstep"], "Linear"),
    result = op.outArray("result");

op.setPortGroup("Input Range", [old_min, old_max]);
op.setPortGroup("Output Range", [new_min, new_max]);

let ease = 0;
let r = 0;

easing.onChange = function ()
{
    if (easing.get() === "Smoothstep")
    {
        ease = 1;
    }
    else if (easing.get() === "Smootherstep")
    {
        ease = 2;
    }
    else
    {
        ease = 0;
    }
    exec();
};

let outArray = Array(1);

function exec()
{
    const inArray = v.get();
    if (!inArray || inArray.length === 0)
    {
        result.set([]);
        return;
    }
    // const outArray = Array(inArray.length);
    outArray.length = inArray.length;
    for (let i = 0; i < inArray.length; i++)
    {
        let x = inArray[i];

        if (x >= Math.max(old_max.get(), old_min.get()))
        {
            outArray[i] = new_max.get();
        }
        else if (x <= Math.min(old_max.get(), old_min.get()))
        {
            outArray[i] = new_min.get();
        }
        else
        {
            const nMin = new_min.get();
            const nMax = new_max.get();
            const oMin = old_min.get();
            const oMax = old_max.get();

            let reverseInput = false;
            const oldMin = Math.min(oMin, oMax);
            const oldMax = Math.max(oMin, oMax);
            if (oldMin !== oMin) reverseInput = true;

            let reverseOutput = false;
            const newMin = Math.min(nMin, nMax);
            const newMax = Math.max(nMin, nMax);
            if (newMin !== nMin) reverseOutput = true;

            let portion = 0;

            if (reverseInput)
            {
                portion = (oldMax - x) * (newMax - newMin) / (oldMax - oldMin);
            }
            else
            {
                portion = (x - oldMin) * (newMax - newMin) / (oldMax - oldMin);
            }

            if (reverseOutput)
            {
                r = newMax - portion;
            }
            else
            {
                r = portion + newMin;
            }

            if (ease === 0)
            {
                outArray[i] = r;
            }
            else if (ease === 1)
            {
                x = Math.max(0, Math.min(1, (r - nMin) / (nMax - nMin)));
                outArray[i] = nMin + x * x * (3 - 2 * x) * (nMax - nMin); // smoothstep
            }
            else if (ease === 2)
            {
                x = Math.max(0, Math.min(1, (r - nMin) / (nMax - nMin)));
                outArray[i] = nMin + x * x * x * (x * (x * 6 - 15) + 10) * (nMax - nMin); // smootherstep
            }
        }
    }
    result.setRef(outArray);
}

v.set(null);
old_min.set(0);
old_max.set(1);
new_min.set(-1);
new_max.set(1);

v.onChange = exec;
old_min.onChange = exec;
old_max.onChange = exec;
new_min.onChange = exec;
new_max.onChange = exec;

result.set(null);

exec();

}
};

CABLES.OPS["20f921bf-adc2-45fb-b387-834af4f5e19b"]={f:Ops.Array.MapRangeArray,objName:"Ops.Array.MapRangeArray"};




// **************************************************************
// 
// Ops.Array.ArraySum
// 
// **************************************************************

Ops.Array.ArraySum= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
const
    inArray = op.inArray("In"),
    inValue = op.inValue("Value", 1.0),
    outArray = op.outArray("Result");

let newArr = [];
outArray.set(newArr);

inArray.onLinkChanged = () =>
{
    if (inArray) inArray.copyLinkedUiAttrib("stride", outArray);
};

inValue.onChange =
inArray.onChange = function ()
{
    let arr = inArray.get();
    if (!arr) return;

    let add = inValue.get();

    if (newArr.length != arr.length)newArr.length = arr.length;

    for (let i = 0; i < arr.length; i++)
    {
        newArr[i] = arr[i] + add;
    }

    outArray.setRef(newArr);
};

}
};

CABLES.OPS["c6b5bf63-0be8-4eea-acc0-9d32973e665a"]={f:Ops.Array.ArraySum,objName:"Ops.Array.ArraySum"};




// **************************************************************
// 
// Ops.Array.ArrayPack3Simple
// 
// **************************************************************

Ops.Array.ArrayPack3Simple= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
const
    inArr1 = op.inArray("Array 1"),
    inArr2 = op.inArray("Array 2"),
    inArr3 = op.inArray("Array 3"),

    outArr = op.outArray("Array out", 3),
    outNum = op.outNumber("Num Points"),
    outArrayLength = op.outNumber("Array length");

let showingError = false;

let arr = [];
let emptyArray = [];
let needsCalc = true;

inArr1.onChange = inArr2.onChange = inArr3.onChange = update;

function update()
{
    let array1 = inArr1.get();
    let array2 = inArr2.get();
    let array3 = inArr3.get();

    if (!array1 && !array2 && !array3)
    {
        outArr.set(null);
        outNum.set(0);
        return;
    }
    let arrlen = 0;

    if (!array1 || !array2 || !array3)
    {
        if (array1) arrlen = array1.length;
        else if (array2) arrlen = array2.length;
        else if (array3) arrlen = array3.length;

        if (emptyArray.length != arrlen)
            for (let i = 0; i < arrlen; i++) emptyArray[i] = 0;

        if (!array1)array1 = emptyArray;
        if (!array2)array2 = emptyArray;
        if (!array3)array3 = emptyArray;
    }

    if ((array1.length !== array2.length) || (array2.length !== array3.length))
    {
        //
        op.setUiError("arraylen", "Arrays do not have the same length !");
        return;
    }
    op.setUiError("arraylen", null);

    arr.length = array1.length;
    for (let i = 0; i < array1.length; i++)
    {
        arr[i * 3 + 0] = array1[i];
        arr[i * 3 + 1] = array2[i];
        arr[i * 3 + 2] = array3[i];
    }

    needsCalc = false;
    outArr.setRef(arr);
    outNum.set(arr.length / 3);
    outArrayLength.set(arr.length);
}

}
};

CABLES.OPS["9c48785b-4cac-472c-a70f-dbd3c240b782"]={f:Ops.Array.ArrayPack3Simple,objName:"Ops.Array.ArrayPack3Simple"};




// **************************************************************
// 
// Ops.Array.Array3Iterator
// 
// **************************************************************

Ops.Array.Array3Iterator= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
const
    exe = op.inTrigger("Execute"),
    arr = op.inArray("Array"),
    pStep = op.inValue("Step"),
    trigger = op.outTrigger("Trigger"),
    idx = op.outNumber("Index"),
    valX = op.outNumber("Value 1"),
    valY = op.outNumber("Value 2"),
    valZ = op.outNumber("Value 3");

let ar = arr.get() || [];

let vstep = 1;
pStep.onChange = changeStep;
changeStep();

let i = 0;
let count = 0;

arr.onChange = function ()
{
    ar = arr.get() || [];
};

function changeStep()
{
    vstep = pStep.get() || 1;
    if (vstep < 1.0)vstep = 1.0;
    vstep = 3 * vstep;
}

exe.onTriggered = function ()
{
    count = 0;

    for (let i = 0, len = ar.length; i < len; i += vstep)
    // for (var i = ar.length-1; i >=0; i-=vstep)
    {
        idx.set(count);
        valX.set(ar[i + 0]);
        valY.set(ar[i + 1]);
        valZ.set(ar[i + 2]);
        trigger.trigger();
        count++;
    }
};

}
};

CABLES.OPS["3f7db864-7409-418f-8c03-b2c966c050b3"]={f:Ops.Array.Array3Iterator,objName:"Ops.Array.Array3Iterator"};




// **************************************************************
// 
// Ops.Devices.Mouse.Mouse_v3
// 
// **************************************************************

Ops.Devices.Mouse.Mouse_v3= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
const
    inCoords = op.inSwitch("Coordinates", ["-1 to 1", "Pixel Display", "Pixel", "0 to 1"], "-1 to 1"),
    area = op.inValueSelect("Area", ["Canvas", "Document", "Parent Element", "Canvas Area"], "Canvas"),
    flipY = op.inValueBool("flip y", true),
    rightClickPrevDef = op.inBool("right click prevent default", true),
    touchscreen = op.inValueBool("Touch support", true),
    inPassive = op.inValueBool("Passive Events", false),
    active = op.inValueBool("Active", true),
    outMouseX = op.outNumber("x", 0),
    outMouseY = op.outNumber("y", 0),
    mouseClick = op.outTrigger("click"),
    mouseClickRight = op.outTrigger("click right"),
    mouseDown = op.outBoolNum("Button is down"),
    mouseOver = op.outBoolNum("Mouse is hovering"),
    outMovementX = op.outNumber("Movement X", 0),
    outMovementY = op.outNumber("Movement Y", 0);

const cgl = op.patch.cgl;
let normalize = 1;
let listenerElement = null;
let areaElement = null;

inPassive.onChange =
area.onChange = addListeners;

inCoords.onChange = updateCoordNormalizing;
op.onDelete = removeListeners;

addListeners();

op.on("loadedValueSet", onStart);

function onStart()
{
    if (normalize == 0)
    {
        if (areaElement.clientWidth === 0) setTimeout(onStart, 50);

        outMouseX.set(areaElement.clientWidth / 2);
        outMouseY.set(areaElement.clientHeight / 2);
    }
    else if (normalize == 1)
    {
        outMouseX.set(0);
        outMouseY.set(0);
    }
    else if (normalize == 2)
    {
        outMouseX.set(0.5);
        outMouseY.set(0.5);
    }
    else if (normalize == 3)
    {
        if (areaElement.clientWidth === 0)
        {
            setTimeout(onStart, 50);
        }

        outMouseX.set(areaElement.clientWidth / 2 / cgl.pixelDensity);
        outMouseY.set(areaElement.clientHeight / 2 / cgl.pixelDensity);
    }
    else console.error("unknown normalize mouse", normalize);
}

function setValue(x, y)
{
    x = x || 0;
    y = y || 0;

    if (normalize == 0) // pixel
    {
        outMouseX.set(x);
        outMouseY.set(y);
    }
    else
    if (normalize == 3) // pixel css
    {
        outMouseX.set(x * cgl.pixelDensity);
        outMouseY.set(y * cgl.pixelDensity);
    }
    else
    {
        let w = areaElement.clientWidth / cgl.pixelDensity;
        let h = areaElement.clientHeight / cgl.pixelDensity;

        w = w || 1;
        h = h || 1;

        if (normalize == 1) // -1 to 1
        {
            let xx = (x / w * 2.0 - 1.0);
            let yy = (y / h * 2.0 - 1.0);
            xx = CABLES.clamp(xx, -1, 1);
            yy = CABLES.clamp(yy, -1, 1);

            outMouseX.set(xx);
            outMouseY.set(yy);
        }
        else if (normalize == 2) // 0 to 1
        {
            let xx = x / w;
            let yy = y / h;

            xx = CABLES.clamp(xx, 0, 1);
            yy = CABLES.clamp(yy, 0, 1);

            outMouseX.set(xx);
            outMouseY.set(yy);
        }
    }
}

function checkHovering(e)
{
    if (!areaElement) return;
    const r = areaElement.getBoundingClientRect();

    return (
        e.clientX > r.left &&
        e.clientX < r.left + r.width &&
        e.clientY > r.top &&
        e.clientY < r.top + r.height
    );
}

touchscreen.onChange = function ()
{
    removeListeners();
    addListeners();
};

active.onChange = function ()
{
    if (listenerElement)removeListeners();
    if (active.get())addListeners();
};

function updateCoordNormalizing()
{
    if (inCoords.get() == "Pixel") normalize = 0;
    else if (inCoords.get() == "-1 to 1") normalize = 1;
    else if (inCoords.get() == "0 to 1") normalize = 2;
    else if (inCoords.get() == "Pixel Display") normalize = 3;
}

function onMouseEnter(e)
{
    mouseDown.set(false);
    mouseOver.set(checkHovering(e));
}

function onMouseDown(e)
{
    if (!checkHovering(e)) return;
    mouseDown.set(true);
}

function onMouseUp(e)
{
    mouseDown.set(false);
}

function onClickRight(e)
{
    if (!checkHovering(e)) return;
    mouseClickRight.trigger();
    if (rightClickPrevDef.get()) e.preventDefault();
}

function onmouseclick(e)
{
    if (!checkHovering(e)) return;
    mouseClick.trigger();
}

function onMouseLeave(e)
{
    mouseDown.set(false);
    mouseOver.set(checkHovering(e));
}

function setCoords(e)
{
    let x = e.clientX;
    let y = e.clientY;

    if (area.get() != "Document")
    {
        x = e.offsetX;
        y = e.offsetY;
    }
    if (area.get() === "Canvas Area")
    {
        const r = areaElement.getBoundingClientRect();
        x = e.clientX - r.left;
        y = e.clientY - r.top;

        if (x < 0 || x > r.width || y > r.height || y < 0) return;
        x = CABLES.clamp(x, 0, r.width);
        y = CABLES.clamp(y, 0, r.height);
    }

    if (flipY.get()) y = areaElement.clientHeight - y;

    setValue(x / cgl.pixelDensity, y / cgl.pixelDensity);
}

function onmousemove(e)
{
    mouseOver.set(checkHovering(e));
    if (area.get() === "Canvas Area")
    {
        const r = areaElement.getBoundingClientRect();
        const x = e.clientX - r.left;
        const y = e.clientY - r.top;

        if (x < 0 || x > r.width || y > r.height || y < 0) return;
    }

    setCoords(e);

    outMovementX.set(e.movementX / cgl.pixelDensity);
    outMovementY.set(e.movementY / cgl.pixelDensity);
}

function ontouchmove(e)
{
    if (event.touches && event.touches.length > 0) setCoords(e.touches[0]);
}

function ontouchstart(event)
{
    mouseDown.set(true);

    if (event.touches && event.touches.length > 0) onMouseDown(event.touches[0]);
}

function ontouchend(event)
{
    mouseDown.set(false);
    onMouseUp();
}

function removeListeners()
{
    if (!listenerElement) return;
    listenerElement.removeEventListener("touchend", ontouchend);
    listenerElement.removeEventListener("touchstart", ontouchstart);
    listenerElement.removeEventListener("touchmove", ontouchmove);

    listenerElement.removeEventListener("click", onmouseclick);
    listenerElement.removeEventListener("mousemove", onmousemove);
    listenerElement.removeEventListener("mouseleave", onMouseLeave);
    listenerElement.removeEventListener("mousedown", onMouseDown);
    listenerElement.removeEventListener("mouseup", onMouseUp);
    listenerElement.removeEventListener("mouseenter", onMouseEnter);
    listenerElement.removeEventListener("contextmenu", onClickRight);
    listenerElement = null;
}

function addListeners()
{
    if (listenerElement || !active.get())removeListeners();
    if (!active.get()) return;

    listenerElement = areaElement = cgl.canvas;

    if (area.get() == "Canvas Area")
    {
        areaElement = cgl.canvas.parentElement;
        listenerElement = document.body;
    }
    if (area.get() == "Document") areaElement = listenerElement = document.body;
    if (area.get() == "Parent Element") listenerElement = areaElement = cgl.canvas.parentElement;

    if (!areaElement)
    {
        op.setUiError("noarea", "could not find area element for mouse", 2);
        return;
    }
    op.setUiError("noarea", null);

    let passive = false;
    if (inPassive.get())passive = { "passive": true };

    if (touchscreen.get())
    {
        listenerElement.addEventListener("touchend", ontouchend, passive);
        listenerElement.addEventListener("touchstart", ontouchstart, passive);
        listenerElement.addEventListener("touchmove", ontouchmove, passive);
    }

    listenerElement.addEventListener("mousemove", onmousemove, passive);
    listenerElement.addEventListener("mouseleave", onMouseLeave, passive);
    listenerElement.addEventListener("mousedown", onMouseDown, passive);
    listenerElement.addEventListener("mouseup", onMouseUp, passive);
    listenerElement.addEventListener("mouseenter", onMouseEnter, passive);
    listenerElement.addEventListener("contextmenu", onClickRight, passive);
    listenerElement.addEventListener("click", onmouseclick, passive);
}

//

}
};

CABLES.OPS["6d1edbc0-088a-43d7-9156-918fb3d7f24b"]={f:Ops.Devices.Mouse.Mouse_v3,objName:"Ops.Devices.Mouse.Mouse_v3"};




// **************************************************************
// 
// Ops.Array.SwitchArrayOnTrigger
// 
// **************************************************************

Ops.Array.SwitchArrayOnTrigger= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
let N_PORTS = 8;

// input ports
const
    inTrigger1 = op.inTriggerButton("Trigger 1"),
    inArray1 = op.inArray("Array 1"),
    inTrigger2 = op.inTriggerButton("Trigger 2"),
    inArray2 = op.inArray("Array 2"),
    inTrigger3 = op.inTriggerButton("Trigger 3"),
    inArray3 = op.inArray("Array 3"),
    inTrigger4 = op.inTriggerButton("Trigger 4"),
    inArray4 = op.inArray("Array 4"),
    inTrigger5 = op.inTriggerButton("Trigger 5"),
    inArray5 = op.inArray("Array 5"),
    inTrigger6 = op.inTriggerButton("Trigger 6"),
    inArray6 = op.inArray("Array 6"),
    inTrigger7 = op.inTriggerButton("Trigger 7"),
    inArray7 = op.inArray("Array 7"),
    inTrigger8 = op.inTriggerButton("Trigger 8"),
    inArray8 = op.inArray("Array 8");

// output ports
let outArray = op.outArray("Out Array");

// change listeners
inTrigger1.onTriggered = function ()
{
    outArray.set(inArray1.get());
};
inTrigger2.onTriggered = function ()
{
    outArray.set(inArray2.get());
};
inTrigger3.onTriggered = function ()
{
    outArray.set(inArray3.get());
};
inTrigger4.onTriggered = function ()
{
    outArray.set(inArray4.get());
};
inTrigger5.onTriggered = function ()
{
    outArray.set(inArray5.get());
};
inTrigger6.onTriggered = function ()
{
    outArray.set(inArray6.get());
};
inTrigger7.onTriggered = function ()
{
    outArray.set(inArray7.get());
};
inTrigger8.onTriggered = function ()
{
    outArray.set(inArray8.get());
};

}
};

CABLES.OPS["08e0cc91-8fda-48c1-a98e-2bf7265d6683"]={f:Ops.Array.SwitchArrayOnTrigger,objName:"Ops.Array.SwitchArrayOnTrigger"};




// **************************************************************
// 
// Ops.Trigger.TriggerButton
// 
// **************************************************************

Ops.Trigger.TriggerButton= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
const
    inTrig = op.inTriggerButton("Trigger"),
    outTrig = op.outTrigger("Next");

inTrig.onTriggered = function ()
{
    outTrig.trigger();
};

}
};

CABLES.OPS["21630924-39e4-4df5-9965-b9136510d156"]={f:Ops.Trigger.TriggerButton,objName:"Ops.Trigger.TriggerButton"};




// **************************************************************
// 
// Ops.Array.RandomNumbersArray_v4
// 
// **************************************************************

Ops.Array.RandomNumbersArray_v4= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
const
    numValues = op.inValueInt("Num Values", 100),
    inModeSwitch = op.inSwitch("Mode", ["A", "AB", "ABC", "ABCD"], "A"),
    inSeed = op.inValueFloat("Random Seed ", 0),
    inInteger = op.inBool("Integer", false),
    inClosed = op.inValueBool("Last == First"),
    outValues = op.outArray("Array Out"),
    outTotalPoints = op.outNumber("Chunks Amount"),
    outArrayLength = op.outNumber("Array length");

const letters = ["A", "B", "C", "D"];
const arr = [];

const inArray = letters.map(function (value)
{
    return {
        "min": op.inValueFloat("Min " + value, -1),
        "max": op.inValueFloat("Max " + value, 1),
    };
});

for (let i = 0; i < inArray.length; i += 1)
{
    const portObj = inArray[i];
    const keys = Object.keys(portObj);

    op.setPortGroup("Value Range " + letters[i], keys.map(function (key) { return portObj[key]; }));

    if (i > 0) keys.forEach(function (key) { portObj[key].setUiAttribs({ "greyout": true }); });
}

inModeSwitch.onChange = function ()
{
    const mode = inModeSwitch.get();
    const modes = inModeSwitch.uiAttribs.values;

    outValues.setUiAttribs({ "stride": inModeSwitch.get().length });

    const index = modes.indexOf(mode);

    inArray.forEach(function (portObj, i)
    {
        const keys = Object.keys(portObj);
        keys.forEach(function (key, j)
        {
            if (i <= index) portObj[key].setUiAttribs({ "greyout": false });
            else portObj[key].setUiAttribs({ "greyout": true });
        });
    });
    init();
};

outValues.ignoreValueSerialize = true;

inClosed.onChange =
    numValues.onChange =
    inSeed.onChange =
    inInteger.onChange = init;

const minMaxArray = [];

init();

function init()
{
    const mode = inModeSwitch.get();
    const modes = inModeSwitch.uiAttribs.values;
    const index = modes.indexOf(mode);

    const n = Math.floor(Math.abs(numValues.get()));
    Math.randomSeed = inSeed.get();

    op.setUiAttrib({ "extendTitle": n + "*" + mode.length });

    const dimension = index + 1;
    const length = n * dimension;

    arr.length = length;
    const tupleLength = length / dimension;
    const isInteger = inInteger.get();

    // optimization: we only need to fetch the max min for each component once
    for (let i = 0; i < dimension; i += 1)
    {
        const portObj = inArray[i];
        const max = portObj.max.get();
        const min = portObj.min.get();
        minMaxArray[i] = [min, max];
    }

    for (let j = 0; j < tupleLength; j += 1)
    {
        for (let k = 0; k < dimension; k += 1)
        {
            const min = minMaxArray[k][0];
            const max = minMaxArray[k][1];
            const index = j * dimension + k;

            if (isInteger) arr[index] = Math.floor(Math.seededRandom() * ((max + 1) - min) + min);
            else arr[index] = Math.seededRandom() * (max - min) + min;
        }
    }

    if (inClosed.get() && arr.length > dimension)
    {
        for (let i = 0; i < dimension; i++)
            arr[arr.length - 3 + i] = arr[i];
    }

    outValues.setRef(arr);
    outTotalPoints.set(arr.length / dimension);
    outArrayLength.set(arr.length);
}

// assign change handler
inArray.forEach(function (obj)
{
    Object.keys(obj).forEach(function (key)
    {
        const x = obj[key];
        x.onChange = init;
    });
});

}
};

CABLES.OPS["8a9fa2c6-c229-49a9-9dc8-247001539217"]={f:Ops.Array.RandomNumbersArray_v4,objName:"Ops.Array.RandomNumbersArray_v4"};




// **************************************************************
// 
// Ops.Array.ArrayLength_v2
// 
// **************************************************************

Ops.Array.ArrayLength_v2= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
const
    array = op.inArray("array"),
    outLength = op.outNumber("length");

outLength.ignoreValueSerialize = true;

function update()
{
    let l = 0;
    if (array.get()) l = array.get().length;
    outLength.set(l);
}

array.onChange = update;

}
};

CABLES.OPS["6f665caa-96ed-45d8-8620-e34f0f8e062c"]={f:Ops.Array.ArrayLength_v2,objName:"Ops.Array.ArrayLength_v2"};




// **************************************************************
// 
// Ops.Array.ArrayMathArray
// 
// **************************************************************

Ops.Array.ArrayMathArray= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
const inArray_0 = op.inArray("array 0"),
    inArray_1 = op.inArray("array 1"),
    mathSelect = op.inSwitch("Math function", ["+", "-", "*", "/", "%", "min", "max"], "+"),
    outArray = op.outArray("Array result"),
    outArrayLength = op.outNumber("Array length");

let mathFunc;

let showingError = false;

const mathArray = [];

op.toWorkPortsNeedToBeLinked(inArray_1, inArray_0);

mathSelect.onChange = onFilterChange;

inArray_0.onChange = inArray_1.onChange = update;
onFilterChange();

function onFilterChange()
{
    const mathSelectValue = mathSelect.get();

    if (mathSelectValue === "+") mathFunc = function (a, b) { return a + b; };
    else if (mathSelectValue === "-") mathFunc = function (a, b) { return a - b; };
    else if (mathSelectValue === "*") mathFunc = function (a, b) { return a * b; };
    else if (mathSelectValue === "/") mathFunc = function (a, b) { return a / b; };
    else if (mathSelectValue === "%") mathFunc = function (a, b) { return a % b; };
    else if (mathSelectValue === "min") mathFunc = function (a, b) { return Math.min(a, b); };
    else if (mathSelectValue === "max") mathFunc = function (a, b) { return Math.max(a, b); };
    update();
    op.setUiAttrib({ "extendTitle": mathSelectValue });
}

function update()
{
    const array0 = inArray_0.get();
    const array1 = inArray_1.get();

    if (!array0 || !array1)
    {
        outArray.set(null);
        outArrayLength.set(0);
        return;
    }

    const l = mathArray.length = array0.length;

    for (let i = 0; i < l; i++)
    {
        mathArray[i] = mathFunc(array0[i], array1[i]);
    }

    outArrayLength.set(mathArray.length);
    outArray.setRef(mathArray);
}

}
};

CABLES.OPS["f31a1764-ce14-41de-9b3f-dc2fe249bb52"]={f:Ops.Array.ArrayMathArray,objName:"Ops.Array.ArrayMathArray"};




// **************************************************************
// 
// Ops.Array.ArrayClamp
// 
// **************************************************************

Ops.Array.ArrayClamp= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
const
    inArray = op.inArray("Array In"),
    inMinValue = op.inFloat("Min", 0.0),
    inMaxValue = op.inFloat("Max", 1.0),
    outArray = op.outArray("Array Out");

let newArr = [];
outArray.set(newArr);
inArray.onChange = inMinValue.onChange = inMaxValue.onChange = function ()
{
    const arr = inArray.get();
    if (!arr) return;

    const inMin = inMinValue.get();
    const inMax = inMaxValue.get();

    if (newArr.length != arr.length)newArr.length = arr.length;

    for (let i = 0; i < arr.length; i++)
    {
        newArr[i] = Math.min(Math.max(arr[i], inMin), inMax);
    }

    outArray.setRef(newArr);
};

}
};

CABLES.OPS["29ff1261-5dfb-4628-893d-288bcefddc97"]={f:Ops.Array.ArrayClamp,objName:"Ops.Array.ArrayClamp"};




// **************************************************************
// 
// Ops.Vars.VarSetArray_v2
// 
// **************************************************************

Ops.Vars.VarSetArray_v2= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
const val = op.inArray("Value", null);
op.varName = op.inDropDown("Variable", [], "", true);

new CABLES.VarSetOpWrapper(op, "array", val, op.varName);

}
};

CABLES.OPS["8088290f-45d4-4312-b4ca-184d34ca4667"]={f:Ops.Vars.VarSetArray_v2,objName:"Ops.Vars.VarSetArray_v2"};




// **************************************************************
// 
// Ops.Array.ArrayMultiply
// 
// **************************************************************

Ops.Array.ArrayMultiply= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
const
    inArray = op.inArray("In"),
    inValue = op.inValue("Value", 1.0),
    outArray = op.outArray("Result");

let newArr = [];
outArray.set(newArr);
inArray.onChange =
inValue.onChange = inArray.onChange = function ()
{
    let arr = inArray.get();
    if (!arr) return;

    let mul = inValue.get();

    if (newArr.length != arr.length)newArr.length = arr.length;

    for (let i = 0; i < arr.length; i++) newArr[i] = arr[i] * mul;

    outArray.setRef(newArr);
};

inArray.onLinkChanged = () =>
{
    if (inArray) inArray.copyLinkedUiAttrib("stride", outArray);
};

}
};

CABLES.OPS["a01c344b-4129-4b01-9c8f-36cefe86d7cc"]={f:Ops.Array.ArrayMultiply,objName:"Ops.Array.ArrayMultiply"};




// **************************************************************
// 
// Ops.Cables.LoadingStatus_v2
// 
// **************************************************************

Ops.Cables.LoadingStatus_v2= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
const
    exe = op.inTrigger("exe"),
    startTimeLine = op.inBool("Play Timeline", true),
    next = op.outTrigger("Next"),
    outInitialFinished = op.outBoolNum("Finished Initial Loading", false),
    outLoading = op.outBoolNum("Loading"),
    outProgress = op.outNumber("Progress"),
    outList = op.outArray("Jobs"),
    loadingFinished = op.outTrigger("Trigger Loading Finished ");

const cgl = op.patch.cgl;
const patch = op.patch;

let finishedOnce = false;
const preRenderTimes = [];
let firstTime = true;
let timeout = 0;

document.body.classList.add("cables-loading");

let loadingId = cgl.patch.loading.start("loadingStatusInit", "loadingStatusInit", op);

op.patch.loading.on("finishedTask", updateStatus.bind(this));
op.patch.loading.on("startTask", updateStatus.bind(this));

function updateStatus()
{
    const jobs = op.patch.loading.getListJobs();
    outProgress.set(patch.loading.getProgress());

    let hasFinished = jobs.length === 0;
    const notFinished = !hasFinished;

    if (notFinished)
    {
        outList.set(op.patch.loading.getListJobs());
    }

    if (notFinished)
    {
        if (firstTime)
        {
            // if (preRenderOps.get()) op.patch.preRenderOps();

            op.patch.timer.setTime(0);
            if (startTimeLine.get())
            {
                op.patch.timer.play();
            }
            else
            {
                op.patch.timer.pause();
            }
        }
        firstTime = false;

        document.body.classList.remove("cables-loading");
        document.body.classList.add("cables-loaded");
    }
    else
    {
        finishedOnce = true;
        outList.set(op.patch.loading.getListJobs());
        if (patch.loading.getProgress() < 1.0)
        {
            op.patch.timer.setTime(0);
            op.patch.timer.pause();
        }
    }

    outInitialFinished.set(finishedOnce);

    if (outLoading.get() && hasFinished) loadingFinished.trigger();

    outLoading.set(notFinished);
    // clearTimeout(timeout);
    // if (notFinished) outLoading.set(notFinished);
    // else
    //     timeout = setTimeout(() =>
    //     {
    //         outLoading.set(notFinished);
    //     }, 100);

    op.setUiAttribs({ "loading": notFinished });
}

exe.onTriggered = () =>
{
    updateStatus();

    next.trigger();

    if (loadingId)
    {
        cgl.patch.loading.finished(loadingId);
        loadingId = null;
    }
};

}
};

CABLES.OPS["e62f7f4c-7436-437e-8451-6bc3c28545f7"]={f:Ops.Cables.LoadingStatus_v2,objName:"Ops.Cables.LoadingStatus_v2"};




// **************************************************************
// 
// Ops.Sidebar.Toggle_v4
// 
// **************************************************************

Ops.Sidebar.Toggle_v4= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
const
    parentPort = op.inObject("link"),
    labelPort = op.inString("Text", "Toggle"),
    inputValue = op.inBool("Input", true),
    storeDefaultValueButton = op.inTriggerButton("Set Default"),
    defaultValuePort = op.inBool("Default"),
    inGreyOut = op.inBool("Grey Out", false),
    inVisible = op.inBool("Visible", true),
    siblingsPort = op.outObject("childs"),
    valuePort = op.outBoolNum("Value", defaultValuePort.get()),
    outToggled = op.outTrigger("Toggled");

defaultValuePort.setUiAttribs({ "hidePort": true, "greyout": true });

const classNameActive = "sidebar__toggle--active";

const el = document.createElement("div");
el.dataset.op = op.id;
el.classList.add("cablesEle");
el.classList.add("sidebar__item");
el.classList.add("sidebar__toggle");
el.classList.add("sidebar__reloadable");
el.classList.add(classNameActive);

const labelText = document.createTextNode(labelPort.get());
const label = document.createElement("div");
label.classList.add("sidebar__item-label");
label.appendChild(labelText);

const icon = document.createElement("a");

valuePort.set(defaultValuePort.get());

icon.classList.add("icon_toggle");
icon.addEventListener("click", onInputClick);
icon.addEventListener("keypress", onKeyPress);

icon.setAttribute("tabindex", 0);
icon.setAttribute("aria-label", "toggle " + labelPort.get());

const greyOut = document.createElement("div");
greyOut.classList.add("sidebar__greyout");
greyOut.style.display = "none";

el.appendChild(greyOut);
el.appendChild(icon);
el.appendChild(label);
el.addEventListener("dblclick", reset);

op.init = () =>
{
    reset();
    updateClass();
};
op.onDelete = onDelete;
parentPort.onChange = onParentChanged;
labelPort.onChange = onLabelTextChanged;
inputValue.onChange = onInputValueChanged;
storeDefaultValueButton.onTriggered = storeDefaultValue;

function reset()
{
    valuePort.set(defaultValuePort.get());
    inputValue.set(defaultValuePort.get());
    outToggled.trigger();
}

function storeDefaultValue()
{
    const defaultValue = inputValue.get();

    defaultValuePort.set(defaultValue);
    valuePort.set(defaultValue);
    outToggled.trigger();
    op.refreshParams();
}

function updateClass()
{
    const isActive = valuePort.get();
    if (isActive)
    {
        icon.classList.add("icon_toggle_true");
        icon.classList.remove("icon_toggle_false");
    }
    else
    {
        icon.classList.remove("icon_toggle_true");
        icon.classList.add("icon_toggle_false");
    }
}

function onKeyPress(e)
{
    if (e.code === "Enter") onInputClick();
}

function onInputClick()
{
    el.classList.toggle(classNameActive);

    const isActive = el.classList.contains(classNameActive);
    valuePort.set(isActive);
    inputValue.set(isActive);

    updateClass();
    outToggled.trigger();
    op.refreshParams();
}

function onInputValueChanged()
{
    if (inputValue.get()) el.classList.add(classNameActive);
    else el.classList.remove(classNameActive);

    valuePort.set(inputValue.get());
    outToggled.trigger();
}

function onLabelTextChanged()
{
    const text = labelPort.get();
    label.textContent = text;
    icon.setAttribute("aria-label", "toggle " + labelPort.get());
    if (CABLES.UI) op.setUiAttrib({ "extendTitle": text });
}

function onParentChanged()
{
    siblingsPort.set(null);
    const parent = parentPort.get();
    if (parent && parent.parentElement)
    {
        parent.parentElement.appendChild(el);
        siblingsPort.set(parent);
    }
    else if (el.parentElement) el.parentElement.removeChild(el);
}

function showElement(element)
{
    if (element) element.style.display = "block";
}

function hideElement(element)
{
    if (element) element.style.display = "none";
}

function onDelete()
{
    if (el && el.parentNode && el.parentNode.removeChild) el.parentNode.removeChild(el);
}

inGreyOut.onChange = function ()
{
    greyOut.style.display = inGreyOut.get() ? "block" : "none";
};

inVisible.onChange = function ()
{
    el.style.display = inVisible.get() ? "block" : "none";
};

}
};

CABLES.OPS["247f5aaf-6438-4a37-9649-4c0fe9cc78c9"]={f:Ops.Sidebar.Toggle_v4,objName:"Ops.Sidebar.Toggle_v4"};




// **************************************************************
// 
// Ops.Sidebar.SideBarSwitch
// 
// **************************************************************

Ops.Sidebar.SideBarSwitch= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
const parentPort = op.inObject("link"),
    inArr = op.inArray("Names"),
    inStyle = op.inSwitch("Style", ["Tabs", "Switch"], "Switch"),
    labelPort = op.inString("Text", "Switch"),

    inInput = op.inInt("Input", 0),

    setDefaultValueButtonPort = op.inTriggerButton("Set Default"),
    inGreyOut = op.inBool("Grey Out", false),
    inDefault = op.inValue("Default", 0),

    siblingsPort = op.outObject("childs"),
    outIndex = op.outNumber("Index", -1),
    outStr = op.outString("String");

let elTabActive = null;
const el = document.createElement("div");
el.classList.add("sidebar__item");
el.dataset.op = op.id;
el.classList.add("cablesEle");
inDefault.setUiAttribs({ "greyout": true });

const label = document.createElement("div");
label.classList.add("sidebar__item-label");
const labelText = document.createTextNode(labelPort.get());
label.appendChild(labelText);
el.appendChild(label);

const switchGroup = document.createElement("div");
el.appendChild(switchGroup);

const greyOut = document.createElement("div");
greyOut.classList.add("sidebar__greyout");
el.appendChild(greyOut);
greyOut.style.display = "none";

parentPort.onChange = onParentChanged;
op.onDelete = onDelete;

op.toWorkNeedsParent("Ops.Sidebar.Sidebar");
op.setPortGroup("Default Item", [inDefault, setDefaultValueButtonPort]);
const tabEles = [];

inArr.onChange = rebuildHtml;
inStyle.onChange = updateStyle;
updateStyle();

labelPort.onChange = () =>
{
    label.innerHTML = labelPort.get();
};

inGreyOut.onChange = function ()
{
    greyOut.style.display = inGreyOut.get() ? "block" : "none";
};

function rebuildHtml()
{
    tabEles.length = 0;
    switchGroup.innerHTML = "";
    elTabActive = null;

    const arr = inArr.get();
    if (!arr) return;

    for (let i = 0; i < arr.length; i++)
    {
        const el = addTab(String(arr[i]));
        if (i == inDefault.get())setActiveTab(el);
    }
}

setDefaultValueButtonPort.onTriggered = () =>
{
    inDefault.set(outIndex.get());
    op.refreshParams();
};

function updateStyle()
{
    if (inStyle.get() == "Tabs")
    {
        el.classList.add("sidebar_tabs");
        switchGroup.classList.remove("sidebar_switchs");
        label.style.display = "none";
    }
    else
    {
        el.classList.remove("sidebar_tabs");
        switchGroup.classList.add("sidebar_switchs");
        label.style.display = "inline-block";
    }

    labelPort.setUiAttribs({ "greyout": inStyle.get() == "Tabs" });

    rebuildHtml();
}

function addTab(title)
{
    const tabEle = document.createElement("div");

    if (inStyle.get() == "Tabs") tabEle.classList.add("sidebar_tab");
    else tabEle.classList.add("sidebar_switch");

    tabEle.id = "tabEle" + tabEles.length;
    tabEle.innerHTML = title;
    tabEle.dataset.index = tabEles.length;
    tabEle.dataset.txt = title;

    tabEle.addEventListener("click", tabClicked);

    switchGroup.appendChild(tabEle);

    tabEles.push(tabEle);

    return tabEle;
}

inInput.onChange = () =>
{
    if (tabEles.length > inInput.get())
        tabClicked({ "target": tabEles[inInput.get()] });
    // setActiveTab(tabEles[inInput.get()]);
};

function setActiveTab(el)
{
    if (el)
    {
        elTabActive = el;
        outIndex.set(parseInt(el.dataset.index));
        outStr.set(el.dataset.txt);

        if (inStyle.get() == "Tabs") el.classList.add("sidebar_tab_active");
        else el.classList.add("sidebar_switch_active");
    }
}

function tabClicked(e)
{
    if (elTabActive)
        if (inStyle.get() == "Tabs") elTabActive.classList.remove("sidebar_tab_active");
        else elTabActive.classList.remove("sidebar_switch_active");
    setActiveTab(e.target);
}

function onParentChanged()
{
    siblingsPort.set(null);
    const parent = parentPort.get();
    if (parent && parent.parentElement)
    {
        parent.parentElement.appendChild(el);
        siblingsPort.set(parent);
    }
    else
    {
        if (el.parentElement)
            el.parentElement.removeChild(el);
    }
}

function showElement(el)
{
    if (!el) return;
    el.style.display = "block";
}

function hideElement(el)
{
    if (!el) return;
    el.style.display = "none";
}

function onDelete()
{
    removeElementFromDOM(el);
}

function removeElementFromDOM(el)
{
    if (el && el.parentNode && el.parentNode.removeChild)
    {
        el.parentNode.removeChild(el);
    }
}

}
};

CABLES.OPS["ebc8c92c-5fa6-4598-a9c6-b8e12f22f7c2"]={f:Ops.Sidebar.SideBarSwitch,objName:"Ops.Sidebar.SideBarSwitch"};




// **************************************************************
// 
// Ops.Sidebar.Group
// 
// **************************************************************

Ops.Sidebar.Group= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
// inputs
let parentPort = op.inObject("link");
let labelPort = op.inString("Text", "Group");
const inShowTitle = op.inBool("Show Title", true);
let defaultMinimizedPort = op.inValueBool("Default Minimized");
const inVisible = op.inBool("Visible", true);

// outputs
let nextPort = op.outObject("next");
let childrenPort = op.outObject("childs");

inVisible.onChange = function ()
{
    el.style.display = inVisible.get() ? "block" : "none";
};

// vars
let el = document.createElement("div");
el.dataset.op = op.id;
el.classList.add("sidebar__group");
onDefaultMinimizedPortChanged();
let header = document.createElement("div");
header.classList.add("sidebar__group-header");
header.classList.add("cablesEle");
el.appendChild(header);
header.addEventListener("click", onClick);
let headerTitle = document.createElement("div");
headerTitle.classList.add("sidebar__group-header-title");
// headerTitle.textContent = labelPort.get();
header.appendChild(headerTitle);
let headerTitleText = document.createElement("span");
headerTitleText.textContent = labelPort.get();
headerTitleText.classList.add("sidebar__group-header-title-text");
headerTitle.appendChild(headerTitleText);
let icon = document.createElement("span");
icon.classList.add("sidebar__group-header-icon");
icon.classList.add("iconsidebar-chevron-up");
headerTitle.appendChild(icon);
let groupItems = document.createElement("div");
groupItems.classList.add("sidebar__group-items");
el.appendChild(groupItems);
op.toWorkPortsNeedToBeLinked(parentPort);

// events
parentPort.onChange = onParentChanged;
labelPort.onChange = onLabelTextChanged;
defaultMinimizedPort.onChange = onDefaultMinimizedPortChanged;
op.onDelete = onDelete;

// functions

inShowTitle.onChange = () =>
{
    if (inShowTitle.get())header.style.display = "block";
    else header.style.display = "none";
};

function onDefaultMinimizedPortChanged()
{
    if (defaultMinimizedPort.get())
    {
        el.classList.add("sidebar__group--closed");
    }
    else
    {
        el.classList.remove("sidebar__group--closed");
    }
}

function onClick(ev)
{
    ev.stopPropagation();
    el.classList.toggle("sidebar__group--closed");
}

function onLabelTextChanged()
{
    let labelText = labelPort.get();
    headerTitleText.textContent = labelText;
    if (CABLES.UI) op.setUiAttrib({ "extendTitle": labelText });
}

function onParentChanged()
{
    childrenPort.set(null);
    let parent = parentPort.get();
    if (parent && parent.parentElement)
    {
        parent.parentElement.appendChild(el);
        childrenPort.set({
            "parentElement": groupItems,
            "parentOp": op,
        });
        nextPort.set(parent);
    }
    else
    { // detach
        if (el.parentElement)
        {
            el.parentElement.removeChild(el);
        }
    }
}

function showElement(el)
{
    if (el)
    {
        el.style.display = "block";
    }
}

function hideElement(el)
{
    if (el)
    {
        el.style.display = "none";
    }
}

function onDelete()
{
    removeElementFromDOM(el);
}

function removeElementFromDOM(el)
{
    if (el && el.parentNode && el.parentNode.removeChild)
    {
        el.parentNode.removeChild(el);
    }
}

}
};

CABLES.OPS["86ea2333-b51c-48ed-94c2-8b7b6e9ff34c"]={f:Ops.Sidebar.Group,objName:"Ops.Sidebar.Group"};




// **************************************************************
// 
// Ops.Vars.VarSetObject_v2
// 
// **************************************************************

Ops.Vars.VarSetObject_v2= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
const val = op.inObject("Value", null);
op.varName = op.inDropDown("Variable", [], "", true);

new CABLES.VarSetOpWrapper(op, "object", val, op.varName);

}
};

CABLES.OPS["c7608375-5b45-4bca-87ef-d0c5e970779a"]={f:Ops.Vars.VarSetObject_v2,objName:"Ops.Vars.VarSetObject_v2"};




// **************************************************************
// 
// Ops.Vars.VarGetObject_v2
// 
// **************************************************************

Ops.Vars.VarGetObject_v2= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
const val = op.outObject("Value");
op.varName = op.inValueSelect("Variable", [], "", true);

new CABLES.VarGetOpWrapper(op, "object", op.varName, val);

}
};

CABLES.OPS["321419d9-69c7-4310-a327-93d310bc2b8e"]={f:Ops.Vars.VarGetObject_v2,objName:"Ops.Vars.VarGetObject_v2"};




// **************************************************************
// 
// Ops.Sidebar.Button_v2
// 
// **************************************************************

Ops.Sidebar.Button_v2= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
// inputs
const parentPort = op.inObject("link");
const buttonTextPort = op.inString("Text", "Button");

// outputs
const siblingsPort = op.outObject("childs");
const buttonPressedPort = op.outTrigger("Pressed Trigger");

const inGreyOut = op.inBool("Grey Out", false);
const inVisible = op.inBool("Visible", true);

// vars
const el = document.createElement("div");
el.dataset.op = op.id;
el.classList.add("cablesEle");
el.classList.add("sidebar__item");
el.classList.add("sidebar--button");
const input = document.createElement("button");
input.classList.add("sidebar__button-input");
el.appendChild(input);
input.addEventListener("click", onButtonClick);
input.style.width = "100%";
const inputText = document.createTextNode(buttonTextPort.get());
input.appendChild(inputText);
op.toWorkNeedsParent("Ops.Sidebar.Sidebar");

// events
parentPort.onChange = onParentChanged;
buttonTextPort.onChange = onButtonTextChanged;
op.onDelete = onDelete;

const greyOut = document.createElement("div");
greyOut.classList.add("sidebar__greyout");
el.appendChild(greyOut);
greyOut.style.display = "none";

inGreyOut.onChange = function ()
{
    greyOut.style.display = inGreyOut.get() ? "block" : "none";
};

inVisible.onChange = function ()
{
    el.style.display = inVisible.get() ? "block" : "none";
};

function onButtonClick()
{
    buttonPressedPort.trigger();
}

function onButtonTextChanged()
{
    const buttonText = buttonTextPort.get();
    input.textContent = buttonText;

    input.setAttribute("aria-label", "button " + buttonTextPort.get());

    if (CABLES.UI) op.setUiAttrib({ "extendTitle": buttonText });
}

function onParentChanged()
{
    siblingsPort.set(null);
    const parent = parentPort.get();
    if (parent && parent.parentElement)
    {
        parent.parentElement.appendChild(el);
        siblingsPort.set(parent);
    }
    else
    { // detach
        if (el.parentElement)
        {
            el.parentElement.removeChild(el);
        }
    }
}

function showElement(el)
{
    if (el)
    {
        el.style.display = "block";
    }
}

function hideElement(el)
{
    if (el)
    {
        el.style.display = "none";
    }
}

function onDelete()
{
    removeElementFromDOM(el);
}

function removeElementFromDOM(el)
{
    if (el && el.parentNode && el.parentNode.removeChild)
    {
        el.parentNode.removeChild(el);
    }
}

}
};

CABLES.OPS["5e9c6933-0605-4bf7-8671-a016d917f327"]={f:Ops.Sidebar.Button_v2,objName:"Ops.Sidebar.Button_v2"};




// **************************************************************
// 
// Ops.Sidebar.Incrementor_v2
// 
// **************************************************************

Ops.Sidebar.Incrementor_v2= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
const
    parentPort = op.inObject("link"),
    labelPort = op.inString("Label", "Incrementor"),
    inMin = op.inValue("min", 0),
    inMax = op.inValue("max", 10),
    inStepsize = op.inValue("stepsize", 1),
    inDefault = op.inValue("Default", 0),
    inValues = op.inArray("Values"),
    inGreyOut = op.inBool("Grey Out", false),
    inTriggerInc = op.inTriggerButton("Increment"),
    inTriggerDec = op.inTriggerButton("Decrement"),

    inSetDefault = op.inTriggerButton("Set Default"),
    inReset = op.inTriggerButton("Reset"),

    siblingsPort = op.outObject("childs"),
    outValue = op.outNumber("value"),
    outChanged = op.outTrigger("Changed");

inSetDefault.onTriggered = setDefaultValue;
let currentPosition = 0;

op.setPortGroup("Trigger", [inTriggerDec, inTriggerInc]);

const containerEl = document.createElement("div");
containerEl.dataset.op = op.id;
containerEl.classList.add("cablesEle");
containerEl.classList.add("sidebar__item");
const label = document.createElement("div");
label.classList.add("sidebar__item-label");
label.addEventListener("dblclick", function ()
{
    outValue.set(inDefault.get());
    outChanged.trigger();
});

inTriggerInc.onTriggered = onNext;
inTriggerDec.onTriggered = onPrev;

const labelTextEl = document.createTextNode(labelPort.get());
label.appendChild(labelTextEl);
containerEl.appendChild(label);

const innerContainer = document.createElement("span");
innerContainer.classList.add("sidebar__item__right");

// value
const valueEl = document.createElement("span");
valueEl.style.marginRight = "10px";

let valueText = document.createTextNode(inMin.get());
if (Array.isArray(inValues.get()))
{
    valueText = document.createTextNode(inValues.get()[currentPosition]);
}

valueEl.appendChild(valueText);
innerContainer.appendChild(valueEl);

// previous
const prevEl = document.createElement("span");
prevEl.classList.add("sidebar--button");
prevEl.style.marginRight = "3px";
const prevInput = document.createElement("div");
prevInput.classList.add("sidebar__button-input");
prevInput.classList.add("minus");
prevEl.appendChild(prevInput);
prevInput.addEventListener("click", onPrev);
const prevText = document.createTextNode("-");
prevInput.appendChild(prevText);
innerContainer.appendChild(prevEl);

// next
const nextEl = document.createElement("span");
nextEl.classList.add("sidebar--button");
const nextInput = document.createElement("div");
nextInput.classList.add("sidebar__button-input");
nextInput.classList.add("plus");
nextEl.appendChild(nextInput);
nextInput.addEventListener("click", onNext);
const nextText = document.createTextNode("+");
nextInput.appendChild(nextText);

innerContainer.appendChild(nextEl);
containerEl.appendChild(innerContainer);

const greyOut = document.createElement("div");
greyOut.classList.add("sidebar__greyout");
containerEl.appendChild(greyOut);
greyOut.style.display = "none";

op.toWorkNeedsParent("Ops.Sidebar.Sidebar");

function setDefaultValue()
{
    inDefault.set(outValue.get());
    op.refreshParams();
}

// events
parentPort.onChange = onParentChanged;
inValues.onChange = onValueChange;
labelPort.onChange = onLabelTextChanged;
op.onDelete = onDelete;

inGreyOut.onChange = function ()
{
    greyOut.style.display = inGreyOut.get() ? "block" : "none";
};

op.onLoaded = op.onInit = function ()
{
    if (Array.isArray(inValues.get()))
    {
        inDefault.setUiAttribs({ "greyout": true });
    }
    else
    {
        outValue.set(inDefault.get());
        valueText.textContent = inDefault.get();
        outChanged.trigger();
    }
};

inReset.onTriggered = () =>
{
    outValue.set(inDefault.get());
    outChanged.trigger();
    valueText.textContent = inDefault.get();
};

function onValueChange()
{
    const values = inValues.get();
    let value = inMin.get();
    if (Array.isArray(values))
    {
        value = values[currentPosition];
        inMin.setUiAttribs({ "greyout": true });
        inMax.set(values.length - 1);
        inMax.setUiAttribs({ "greyout": true });
        inStepsize.setUiAttribs({ "greyout": true });
        inStepsize.set(1);
        inDefault.setUiAttribs({ "greyout": true });
        inDefault.set(0);
    }
    else
    {
        inMin.setUiAttribs({ "greyout": false });
        inMax.setUiAttribs({ "greyout": false });
        inStepsize.setUiAttribs({ "greyout": false });
        inDefault.setUiAttribs({ "greyout": false });
    }
    outValue.set(value);
    outChanged.trigger();
    valueText.textContent = value;
}

function onNext()
{
    const values = inValues.get();
    let value = 0;
    if (!Array.isArray(values))
    {
        // no array given, increment/decrement according to params
        const currentValue = outValue.get();
        value = Math.min(currentValue + inStepsize.get(), inMax.get());
    }
    else
    {
        // user inputs an array, iterate fields, ignore min/max/stepsize
        if (currentPosition < values.length - 1)
        {
            currentPosition += Math.ceil(inStepsize.get());
        }
        value = values[currentPosition];
    }
    valueText.textContent = value;
    outValue.set(value);
    outChanged.trigger();
}

function onPrev()
{
    const values = inValues.get();
    let value = 0;
    if (!Array.isArray(values))
    {
        // no array given, increment/decrement according to params
        const currentValue = outValue.get();
        value = Math.max(currentValue - inStepsize.get(), inMin.get());
    }
    else
    {
        // user inputs an array, iterate fields, ignore min/max/stepsize
        if (currentPosition > 0)
        {
            currentPosition -= Math.ceil(inStepsize.get());
        }
        value = values[currentPosition];
    }
    valueText.textContent = value;
    outValue.set(value);
    outChanged.trigger();
}

function onParentChanged()
{
    siblingsPort.set(null);
    const parent = parentPort.get();
    if (parent && parent.parentElement)
    {
        parent.parentElement.appendChild(containerEl);
        siblingsPort.set(parent);
    }
    else if (containerEl.parentElement)
    {
        // detach
        containerEl.parentElement.removeChild(containerEl);
    }
}

function onLabelTextChanged()
{
    const labelText = labelPort.get();
    label.textContent = labelText;

    if (CABLES.UI) op.setUiAttrib({ "extendTitle": labelText });
}

function onDelete()
{
    removeElementFromDOM(containerEl);
}

function removeElementFromDOM(el)
{
    if (el && el.parentNode && el.parentNode.removeChild)
    {
        el.parentNode.removeChild(el);
    }
}

}
};

CABLES.OPS["13932cbc-2bd4-4b2a-b6e0-cda6df4cec54"]={f:Ops.Sidebar.Incrementor_v2,objName:"Ops.Sidebar.Incrementor_v2"};




// **************************************************************
// 
// Ops.Array.ArrayUnpack4
// 
// **************************************************************

Ops.Array.ArrayUnpack4= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
const
    inArray1 = op.inArray("Array in xyzw"),
    outArray1 = op.outArray("Array 1 out"),
    outArray2 = op.outArray("Array 2 out"),
    outArray3 = op.outArray("Array 3 out"),
    outArray4 = op.outArray("Array 4 out"),
    outArrayLength = op.outNumber("Array lengths");

let showingError = false;

const arr1 = [];
const arr2 = [];
const arr3 = [];
const arr4 = [];

inArray1.onChange = update;

function update()
{
    let array1 = inArray1.get();

    if (!array1)
    {
        outArray1.set(null);
        return;
    }

    if (array1.length % 4 !== 0)
    {
        if (!showingError)
        {
            op.uiAttr({ "error": "Arrays length not divisible by 4 !" });
            outArrayLength.set(0);
            showingError = true;
        }
        return;
    }

    if (showingError)
    {
        showingError = false;
        op.uiAttr({ "error": null });
    }

    arr1.length = Math.floor(array1.length / 4);
    arr2.length = Math.floor(array1.length / 4);
    arr3.length = Math.floor(array1.length / 4);
    arr4.length = Math.floor(array1.length / 4);

    for (let i = 0; i < array1.length / 4; i++)
    {
        arr1[i] = array1[i * 4];
        arr2[i] = array1[i * 4 + 1];
        arr3[i] = array1[i * 4 + 2];
        arr4[i] = array1[i * 4 + 3];
    }

    // outArray1.set(null);
    // outArray2.set(null);
    // outArray3.set(null);
    // outArray4.set(null);
    outArray1.setRef(arr1);
    outArray2.setRef(arr2);
    outArray3.setRef(arr3);
    outArray4.setRef(arr4);
    outArrayLength.set(arr1.length);
}

}
};

CABLES.OPS["8d2127d8-f3e4-4036-8cd8-75c6a404b582"]={f:Ops.Array.ArrayUnpack4,objName:"Ops.Array.ArrayUnpack4"};




// **************************************************************
// 
// Ops.Math.RandomNumbers_v3
// 
// **************************************************************

Ops.Math.RandomNumbers_v3= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
const
    inSeed = op.inValueFloat("Seed", 1),
    min = op.inValueFloat("Min", 0),
    max = op.inValueFloat("Max", 1),
    outX = op.outNumber("X"),
    outY = op.outNumber("Y"),
    outZ = op.outNumber("Z"),
    outW = op.outNumber("W");

inSeed.onChange =
    min.onChange =
    max.onChange = update;
update();

function update()
{
    const inMin = min.get();
    const inMax = max.get();
    Math.randomSeed = Math.abs(inSeed.get() || 0) * 571.1 + 1.0;
    outX.set(Math.seededRandom() * (inMax - inMin) + inMin);
    outY.set(Math.seededRandom() * (inMax - inMin) + inMin);
    outZ.set(Math.seededRandom() * (inMax - inMin) + inMin);
    outW.set(Math.seededRandom() * (inMax - inMin) + inMin);
}

}
};

CABLES.OPS["d2b970e1-9406-4459-995c-5a594acd88e3"]={f:Ops.Math.RandomNumbers_v3,objName:"Ops.Math.RandomNumbers_v3"};




// **************************************************************
// 
// Ops.Boolean.Boolean
// 
// **************************************************************

Ops.Boolean.Boolean= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
const
    v = op.inBool("value", false),
    result = op.outBoolNum("result");

result.set(false);
v.onChange = exec;

function exec()
{
    if (result.get() != v.get()) result.set(v.get());
}

}
};

CABLES.OPS["83e2d74c-9741-41aa-a4d7-1bda4ef55fb3"]={f:Ops.Boolean.Boolean,objName:"Ops.Boolean.Boolean"};




// **************************************************************
// 
// Ops.Array.ArrayPack2Simple
// 
// **************************************************************

Ops.Array.ArrayPack2Simple= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
const
    inArr1 = op.inArray("Array 1"),
    inArr2 = op.inArray("Array 2"),

    outArr = op.outArray("Array out", 2),
    outNum = op.outNumber("Num Points"),
    outArrayLength = op.outNumber("Array length");

let showingError = false;

let arr = [];
let emptyArray = [];
let needsCalc = true;

inArr1.onChange = inArr2.onChange = update;

function update()
{
    let array1 = inArr1.get();
    let array2 = inArr2.get();

    if (!array1 && !array2)
    {
        outArr.set(null);
        outNum.set(0);
        return;
    }
    let arrlen = 0;

    if (!array1 || !array2)
    {
        if (array1) arrlen = array1.length;
        else if (array2) arrlen = array2.length;

        if (emptyArray.length != arrlen)
            for (let i = 0; i < arrlen; i++) emptyArray[i] = 0;

        if (!array1)array1 = emptyArray;
        if (!array2)array2 = emptyArray;
    }

    if (array1.length !== array2.length)
    {
        op.setUiError("arraylen", "Arrays do not have the same length !");
        return;
    }
    op.setUiError("arraylen", null);

    arr.length = array1.length;
    for (let i = 0; i < array1.length; i++)
    {
        arr[i * 2 + 0] = array1[i];
        arr[i * 2 + 1] = array2[i];
    }

    needsCalc = false;
    outArr.setRef(arr);
    outNum.set(arr.length / 2);
    outArrayLength.set(arr.length);
}

}
};

CABLES.OPS["6248877c-9509-483f-9e44-0061d0447acf"]={f:Ops.Array.ArrayPack2Simple,objName:"Ops.Array.ArrayPack2Simple"};




// **************************************************************
// 
// Ops.Ui.VizGraph
// 
// **************************************************************

Ops.Ui.VizGraph= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};

const
    inNum1 = op.inFloat("Number 1"),
    inNum2 = op.inFloat("Number 2"),
    inNum3 = op.inFloat("Number 3"),
    inNum4 = op.inFloat("Number 4"),
    inNum5 = op.inFloat("Number 5"),
    inNum6 = op.inFloat("Number 6"),
    inNum7 = op.inFloat("Number 7"),
    inNum8 = op.inFloat("Number 8"),
    inFill = op.inBool("Fill Graph", true),
    inReset = op.inTriggerButton("Reset");

op.setUiAttrib({ "height": 150, "resizable": true, "vizLayerMaxZoom": 2500 });

let buff = [];

let max = -Number.MAX_VALUE;
let min = Number.MAX_VALUE;

inNum1.onLinkChanged =
    inNum2.onLinkChanged =
    inNum3.onLinkChanged =
    inNum4.onLinkChanged =
    inNum5.onLinkChanged =
    inNum6.onLinkChanged =
    inNum7.onLinkChanged =
    inNum8.onLinkChanged =
    inReset.onTriggered = () =>
    {
        max = -Number.MAX_VALUE;
        min = Number.MAX_VALUE;
        buff = [];
    };

op.renderVizLayer = (ctx, layer) =>
{
    const doFill = inFill.get();

    const colors = ["#7AC4E0", "#D183BF", "#9091D6", "#FFC395", "#F0D165", "#63A8E8", "#CF5D9D", "#66C984", "#D66AA6", "#515151"];

    let fontSize = 10 * layer.pixelDensity;
    ctx.font = "bold " + fontSize + "px sourceCodePro";
    ctx.fillStyle = "#222";
    ctx.fillRect(layer.x, layer.y, layer.width, layer.height);

    for (let p = 0; p < op.portsIn.length; p++)
    {
        if (!op.portsIn[p].isLinked()) continue;
        const newVal = op.portsIn[p].get();

        max = Math.max(op.portsIn[p].get(), max);
        min = Math.min(op.portsIn[p].get(), min);

        if (!buff[p]) buff[p] = [];
        buff[p].push(newVal);
        if (buff[p].length > 60) buff[p].shift();

        const texSlot = 6;
        const mulX = layer.width / 60;

        ctx.lineWidth = 3;
        ctx.strokeStyle = "#555555";

        ctx.beginPath();
        ctx.moveTo(layer.x, CABLES.map(0, min, max, layer.height, 0) + layer.y);
        ctx.lineTo(layer.x + layer.width, CABLES.map(0, min, max, layer.height, 0) + layer.y);
        ctx.stroke();

        ctx.beginPath();

        let y;

        for (let i = 0; i < buff[p].length; i++)
        {
            y = buff[p][i];

            y = CABLES.map(y, min, max, layer.height - 3, 3);
            y += layer.y;
            if (i === 0)ctx.moveTo(layer.x, y);
            else ctx.lineTo(layer.x + i * mulX, y);
        }

        if (doFill)
        {
            ctx.lineTo(layer.x + buff[p].length * mulX, layer.y + layer.height);
            ctx.lineTo(layer.x, layer.y + layer.height);
            ctx.fillStyle = colors[p];
            ctx.fill();
        }
        else
        {
            ctx.strokeStyle = colors[p];
            ctx.stroke();
        }
    }

    ctx.fillStyle = "#fff";
    ctx.fillText("max:" + Math.round(max * 100) / 100, layer.x + 10, layer.y + layer.height - 10);
    ctx.fillText("min:" + Math.round(min * 100) / 100, layer.x + 10, layer.y + layer.height - 30);
};

}
};

CABLES.OPS["13c54eb4-60ef-4b9c-8425-d52a431f5c87"]={f:Ops.Ui.VizGraph,objName:"Ops.Ui.VizGraph"};




// **************************************************************
// 
// Ops.Anim.Bang
// 
// **************************************************************

Ops.Anim.Bang= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
const
    inUpdate = op.inTrigger("update"),
    inBang = op.inTriggerButton("Bang"),
    inDuration = op.inValue("Duration", 0.1),
    invert = op.inBool("Invert", false),
    outTrigger = op.outTrigger("Trigger Out"),
    outValue = op.outNumber("Value");

const anim = new CABLES.Anim();
let startTime = CABLES.now();
op.toWorkPortsNeedToBeLinked(inUpdate);

let needsReset = false;

inBang.onTriggered = function ()
{
    needsReset = true;
};

inUpdate.onTriggered = function ()
{
    if (needsReset)
    {
        startTime = CABLES.now();
        anim.clear();
        anim.setValue(0, 1);
        anim.setValue(inDuration.get(), 0);
        needsReset = false;
    }

    const elapsed = (CABLES.now() - startTime) / 1000;
    if (elapsed <= inDuration.get())
    {
        const v = anim.getValue(elapsed);
        if (invert.get()) outValue.set(1.0 - v);
        else outValue.set(v);
    }
    else
    {
        if (invert.get())
        {
            outValue.set(1.0);
        }
        else
        {
            outValue.set(0);
        }
    }

    outTrigger.trigger();
};

}
};

CABLES.OPS["92ca45a7-5b4b-4238-956e-23d79bdc659f"]={f:Ops.Anim.Bang,objName:"Ops.Anim.Bang"};




// **************************************************************
// 
// Ops.Math.OneMinus
// 
// **************************************************************

Ops.Math.OneMinus= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
const
    inValue = op.inValue("Value"),
    result = op.outNumber("Result");

inValue.onChange = update;
update();

function update()
{
    result.set(1 - inValue.get());
}

}
};

CABLES.OPS["f34d019d-59ae-40d6-a55d-a7691bbc40e0"]={f:Ops.Math.OneMinus,objName:"Ops.Math.OneMinus"};




// **************************************************************
// 
// Ops.Array.FreezeArray
// 
// **************************************************************

Ops.Array.FreezeArray= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
const
    inArr = op.inArray("Number"),
    inFreeze = op.inTriggerButton("Button"),
    inHidden = op.inString("storedJson"),
    outArr = op.outArray("Frozen Array");

inFreeze.onTriggered =
inHidden.onTriggered = update;

inHidden.setUiAttribs({ "hideParam": true, "hidePort": true, "ignoreBigPort": true });

let changed = false;

inArr.onChange = () =>
{
    changed = true;
};

function update()
{
    if (changed)
    {
        changed = false;
        if (inArr.get())
            inHidden.set(JSON.stringify(inArr.get()));
        else
            inHidden.set("");
    }
}

outArr.onLinkChanged = () =>
{
    if (inHidden.get())
        outArr.setRef(JSON.parse(inHidden.get()));
};

inHidden.onChange = () =>
{
    inHidden.get();
    try
    {
        outArr.setRef(JSON.parse(inHidden.get()));
    }
    catch (e) {}
};

}
};

CABLES.OPS["340fb9e2-27ab-47f0-b3cc-2ef001f485c5"]={f:Ops.Array.FreezeArray,objName:"Ops.Array.FreezeArray"};




// **************************************************************
// 
// Ops.Array.ArrayChunkDuplicate
// 
// **************************************************************

Ops.Array.ArrayChunkDuplicate= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
const
    inArr = op.inArray("Array"),
    inChunks = op.inInt("Chunk Size", 3),
    inRepeats = op.inInt("Repeats", 10),
    outArr = op.outArray("Result");


inArr.onChange =
inChunks.onChange =
inRepeats.onChange = () =>
{
    let chu = inChunks.get();
    let reps = inRepeats.get();
    let arr = inArr.get();

    if (!arr) return;
    if (chu <= 0) return;
    if (chu <= 0) return;

    let rArr = [];
    let count = 0;

    for (let i = 0; i < arr.length; i += chu)
    {
        for (let r = 0; r < reps; r++)
        {
            for (let c = 0; c < chu; c++)
            {
                rArr[count] = arr[i + c];
                count++;
            }
        }
    }

    outArr.setRef(rArr);
};

}
};

CABLES.OPS["a3425fda-2c3c-42a4-b943-122d0a9b3c7e"]={f:Ops.Array.ArrayChunkDuplicate,objName:"Ops.Array.ArrayChunkDuplicate"};




// **************************************************************
// 
// Ops.Patch.PLH3vXR.ControlPointManager
// 
// **************************************************************

Ops.Patch.PLH3vXR.ControlPointManager= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
const
    lineCount = op.inValueInt("Line Count", 3),
    pointList = op.inArray("Control Point Array"),
    resetPoint = op.inTriggerButton("Reset Point"),
    // storedInfoStr = op.inString("Stored Info Str", ""),
    // loadPoint = op.inTriggerButton("Load Settings"),

    pointRadius = op.inValueFloat("Radius", 0.1),
    mouseX = op.inValueFloat("Mouse X"),
    mouseY = op.inValueFloat("Mouse Y"),
    mousePressed = op.inValueBool("Mouse Pressed"),
    mouseDragging = op.inValueBool("Mouse Dragging"),

    isActive = op.inValueBool("Active", true),

    pointOut = op.outArray("Point Out"),
    pressedOut = op.outArray("Pressed Out"),
    lineIndexOut = op.outArray("Line Index Out");
    // pointInfoStr = op.outString("Point Info Str");

    op.setPortGroup("Mouse Interaction", [pointRadius, mouseX, mouseY, mousePressed, mouseDragging]);
    // op.setPortGroup("Output Range", [new_min, new_max]);



let pointArray = Array(1);
let pressedArray = Array(1);
let pressedIndex = -1;
let lineIndexArray = Array(1);

pointList.onChange =
resetPoint.onTriggered = resetPointList;
function resetPointList()
{
    const line_count = lineCount.get();
    const inArray = pointList.get();

    if (!inArray || inArray.length === 0)
    {
        return;
    }

    pointArray.length = inArray.length;
    for(let i=0; i<pointArray.length; i++)
    {
        pointArray[i] = inArray[i];
    }

    const point_count_per_line = Math.floor(pointArray.length / 3 / line_count);
    pressedArray.length = point_count_per_line * line_count;
    lineIndexArray.length = point_count_per_line * line_count;
    for(let i=0; i<point_count_per_line; i++)
    {
        for(let j=0; j<line_count; j++)
        {
            pressedArray[j * point_count_per_line + i] = 0;
            lineIndexArray[j * point_count_per_line + i] = j;
        }
    }

    pointOut.setRef(pointArray);
    pressedOut.setRef(pressedArray);
    lineIndexOut.setRef(lineIndexArray);

    checkPointState();
}

// loadPoint.onTriggered = loadPointList;
// function loadPointList()
// {
//     const info_str = storedInfoStr.get();
//     // split to point list
// }



function updatePointList(index, x, y)
{
    if(pointArray == null || pointArray.length < 3 || index < 0 || index >= Math.floor(pointArray.length / 3))
        return;

    // pointArray[index * 3 + 0] = x;
    pointArray[index * 3 + 1] = y;
}


pointRadius.onChange =
mouseX.onChange =
mouseY.onChange =
mousePressed.onChange =
mouseDragging.onChange = checkPointState;
function checkPointState()
{
    if(isActive.get() == false)
        return;
    if(pointArray == null || pointArray.length < 3)
        return;

    let need_update = false;
    const line_count = lineCount.get();
    const point_count = Math.floor(pointArray.length / 3);
    const point_radius = pointRadius.get();
    const mouse_x = mouseX.get();
    const mouse_y = mouseY.get();
    const mouse_pressed = mousePressed.get();


    if(mouse_pressed == false)
    {
        if(pressedIndex != -1 && pressedIndex < pressedArray.length)
            pressedArray[pressedIndex] = 0;
        pressedIndex = -1;
    }

    if(mouse_pressed == true)
    {
        if(pressedIndex != -1 && pressedIndex < pressedArray.length)
        {
            updatePointList(pressedIndex, mouse_x, mouse_y);
            need_update = true;
        }
        else
        {
            for(let i=point_count-1; i>=0; i--)
            {
                if(isInsideRect(mouse_x, mouse_y, pointArray[i*3 + 0], pointArray[i*3 + 1], point_radius) == true)
                {
                    updatePointList(i, mouse_x, mouse_y);
                    pressedArray[i] = 1;
                    pressedIndex = i;
                    need_update = true;
                    break;
                }
            }
        }
    }

    if(need_update)
        pointOut.setRef(pointArray);
    pressedOut.setRef(pressedArray);
}

function isInsideRect(x, y, circle_x, circle_y, circle_radius)
{
    const dis_squred = (circle_x - x) * (circle_x - x) + (circle_y - y) * (circle_y - y);
    return dis_squred < circle_radius * circle_radius;
}


//-------------------------- Initialization--------------------------
pointOut.set(null);
pressedOut.set(null);

resetPointList();


//-------------------------- Utilities --------------------------
function MapRange(v, oMin, oMax, nMin, nMax, ease = 0)
{

    if (v >= Math.max(oMax, oMin))
    {
        v = nMax;
    }
    else if (v <= Math.min(oMax, oMin))
    {
        v = nMin;
    }
    else
    {
        let reverseInput = false;
        const oldMin = Math.min(oMin, oMax);
        const oldMax = Math.max(oMin, oMax);
        if (oldMin !== oMin) reverseInput = true;

        let reverseOutput = false;
        const newMin = Math.min(nMin, nMax);
        const newMax = Math.max(nMin, nMax);
        if (newMin !== nMin) reverseOutput = true;

        let portion = 0;

        if (reverseInput)
        {
            portion = (oldMax - v) * (newMax - newMin) / (oldMax - oldMin);
        }
        else
        {
            portion = (v - oldMin) * (newMax - newMin) / (oldMax - oldMin);
        }

        if (reverseOutput)
        {
            r = newMax - portion;
        }
        else
        {
            r = portion + newMin;
        }

        if (ease === 0)
        {
            v = r;
        }
        else if (ease === 1)
        {
            x = Math.max(0, Math.min(1, (r - nMin) / (nMax - nMin)));
            v = nMin + x * x * (3 - 2 * x) * (nMax - nMin); // smoothstep
        }
        else if (ease === 2)
        {
            x = Math.max(0, Math.min(1, (r - nMin) / (nMax - nMin)));
            v = nMin + x * x * x * (x * (x * 6 - 15) + 10) * (nMax - nMin); // smootherstep
        }
    }

    return v;
}

}
};

CABLES.OPS["2b4f4b28-d013-4f69-b695-d701106b2e25"]={f:Ops.Patch.PLH3vXR.ControlPointManager,objName:"Ops.Patch.PLH3vXR.ControlPointManager"};




// **************************************************************
// 
// Ops.Sidebar.DropDown_v2
// 
// **************************************************************

Ops.Sidebar.DropDown_v2= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
// inputs
const parentPort = op.inObject("Link");
const labelPort = op.inString("Text", "Value");
const valuesPort = op.inArray("Values");
const defaultValuePort = op.inString("Default", "");
const inGreyOut = op.inBool("Grey Out", false);
const inVisible = op.inBool("Visible", true);
const inSize = op.inInt("Lines", 1);
const setDefaultValueButtonPort = op.inTriggerButton("Set Default");
setDefaultValueButtonPort.onTriggered = setDefault;

// outputs
const siblingsPort = op.outObject("Children");
const valuePort = op.outString("Result", defaultValuePort.get());
const outIndex = op.outNumber("Index");

defaultValuePort.setUiAttribs({ "title": "Input" });

// vars
const el = document.createElement("div");
el.addEventListener("dblclick", function ()
{
    valuePort.set(defaultValuePort.get());
    const optionElements = input.querySelectorAll("option");
    optionElements.forEach(function (optionElement, index)
    {
        if (optionElement.value.trim() === defaultValuePort.get())
        {
            optionElement.selected = true;
            outIndex.set(index);
        }
        else
        {
            optionElement.removeAttribute("selected");
        }
    });
});

el.dataset.op = op.id;
el.classList.add("cablesEle");
el.classList.add("sidebar__item");
el.classList.add("sidebar__select");
el.classList.add("sidebar__reloadable");

const label = document.createElement("div");
label.classList.add("sidebar__item-label");
const labelText = document.createTextNode(labelPort.get());
label.appendChild(labelText);
el.appendChild(label);
const input = document.createElement("select");

input.classList.add("sidebar__select-select");
el.appendChild(input);
input.addEventListener("input", onInput);

const greyOut = document.createElement("div");
greyOut.classList.add("sidebar__greyout");
el.appendChild(greyOut);
greyOut.style.display = "none";

inGreyOut.onChange = function ()
{
    greyOut.style.display = inGreyOut.get() ? "block" : "none";
};

inVisible.onChange = function ()
{
    el.style.display = inVisible.get() ? "block" : "none";
};

// events
parentPort.onChange = onParentChanged;
labelPort.onChange = onLabelTextChanged;
defaultValuePort.onChange = onDefaultValueChanged;
op.onDelete = onDelete;
valuesPort.onChange = onValuesPortChange;

let options = [];
// functions

inSize.onChange = () =>
{
    input.setAttribute("size", inSize.get());
};

op.onLoaded = function ()
{
    valuePort.set(defaultValuePort.get());
};

function onValuesPortChange()
{
    // remove all children
    while (input.lastChild)
    {
        input.removeChild(input.lastChild);
    }
    options = valuesPort.get();
    const defaultValue = defaultValuePort.get();
    if (options)
    {
        options.forEach(function (option)
        {
            const optionEl = document.createElement("option");

            optionEl.setAttribute("value", option);
            if (option === defaultValue || option === valuePort.get())
            {
                optionEl.setAttribute("selected", "");
            }
            const textEl = document.createTextNode(option);
            optionEl.appendChild(textEl);
            input.appendChild(optionEl);
        });
    }
    else
    {
        valuePort.set("");
    }

    outIndex.set(0);
    setSelectedProperty(); /* set the selected property for the default value */
}

let finalIndex = 0;
function setSelectedProperty(defaultinput)
{
    const optionElements = input.querySelectorAll("option");

    let finalEle = null;

    optionElements.forEach(function (optionElement, index)
    {
        if (optionElement.value.trim() === valuePort.get())
        {
            finalEle = optionElement;
            finalIndex = index;
        }
        optionElement.removeAttribute("selected");
    });

    if (defaultinput)
    {
        const defaultItem = defaultValuePort.get() + "".trim();

        optionElements.forEach(function (optionElement, index)
        {
            if (optionElement.value.trim() === defaultItem)
            {
                finalEle = optionElement;
                finalIndex = index;
            }

            optionElement.removeAttribute("selected");
        });
    }

    if (finalEle) finalEle.setAttribute("selected", "");
    outIndex.set(finalIndex);
}

function onInput(ev)
{
    valuePort.set(ev.target.value);
    outIndex.set(options.indexOf(ev.target.value));
    setSelectedProperty();
}

function onDefaultValueChanged()
{
    const defaultValue = defaultValuePort.get();
    valuePort.set(defaultValue);
    input.value = defaultValue;
    setSelectedProperty();
}

function onLabelTextChanged()
{
    const lblText = labelPort.get();
    label.textContent = lblText;
    if (CABLES.UI) op.setUiAttrib({ "extendTitle": lblText });
}

function onParentChanged()
{
    siblingsPort.set(null);
    const parent = parentPort.get();
    if (parent && parent.parentElement)
    {
        parent.parentElement.appendChild(el);
        siblingsPort.set(parent);
    }
    else
    { // detach
        if (el.parentElement)
        {
            el.parentElement.removeChild(el);
        }
    }
}

function showElement(ele)
{
    if (ele)
    {
        ele.style.display = "block";
    }
    setSelectedProperty();
}

function hideElement(ele)
{
    if (ele)
    {
        ele.style.display = "none";
    }
}

function onDelete()
{
    removeElementFromDOM(el);
}

function removeElementFromDOM(ele)
{
    if (ele && ele.parentNode && ele.parentNode.removeChild)
    {
        ele.parentNode.removeChild(ele);
    }
}

function setDefault()
{
    defaultValuePort.set(input.value);
    op.refreshParams();
}

}
};

CABLES.OPS["7b3f93d6-4de1-41fd-aa26-e74c8285c662"]={f:Ops.Sidebar.DropDown_v2,objName:"Ops.Sidebar.DropDown_v2"};




// **************************************************************
// 
// Ops.Sidebar.SidebarText_v2
// 
// **************************************************************

Ops.Sidebar.SidebarText_v2= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
// inputs
const parentPort = op.inObject("link");
const labelPort = op.inString("Text", "Value");
const inId = op.inValueString("Id", "");

// outputs
const siblingsPort = op.outObject("childs");

// vars
const el = document.createElement("div");
el.dataset.op = op.id;
el.classList.add("cablesEle");
el.classList.add("sidebar__item");
el.classList.add("sidebar__text");
const label = document.createElement("div");
label.classList.add("sidebar__item-label");
const labelText = document.createElement("div");// document.createTextNode(labelPort.get());
label.appendChild(labelText);
el.appendChild(label);

// events
parentPort.onChange = onParentChanged;
labelPort.onChange = onLabelTextChanged;
inId.onChange = onIdChanged;
op.onDelete = onDelete;

op.toWorkNeedsParent("Ops.Sidebar.Sidebar");

// functions

function onIdChanged()
{
    el.id = inId.get();
}

function onLabelTextChanged()
{
    const labelText = labelPort.get();
    label.innerHTML = labelText;
}

function onParentChanged()
{
    siblingsPort.set(null);
    const parent = parentPort.get();
    if (parent && parent.parentElement)
    {
        parent.parentElement.appendChild(el);
        siblingsPort.set(parent);
    }
    else
    { // detach
        if (el.parentElement)
        {
            el.parentElement.removeChild(el);
        }
    }
}

function showElement(el)
{
    if (el)
    {
        el.style.display = "block";
    }
}

function hideElement(el)
{
    if (el)
    {
        el.style.display = "none";
    }
}

function onDelete()
{
    removeElementFromDOM(el);
}

function removeElementFromDOM(el)
{
    if (el && el.parentNode && el.parentNode.removeChild)
    {
        el.parentNode.removeChild(el);
    }
}

}
};

CABLES.OPS["cc591cc3-ff23-4817-907c-e5be7d5c059d"]={f:Ops.Sidebar.SidebarText_v2,objName:"Ops.Sidebar.SidebarText_v2"};




// **************************************************************
// 
// Ops.Vars.VarSetString_v2
// 
// **************************************************************

Ops.Vars.VarSetString_v2= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
const val=op.inString("Value","New String");
op.varName=op.inDropDown("Variable",[],"",true);

new CABLES.VarSetOpWrapper(op,"string",val,op.varName);



}
};

CABLES.OPS["0b4d9229-8024-4a30-9cc0-f6653942c2e4"]={f:Ops.Vars.VarSetString_v2,objName:"Ops.Vars.VarSetString_v2"};




// **************************************************************
// 
// Ops.Devices.Mouse.MouseButtons
// 
// **************************************************************

Ops.Devices.Mouse.MouseButtons= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
const
    mouseClickLeft = op.outTrigger("Click Left"),
    mouseClickRight = op.outTrigger("Click Right"),
    mouseDoubleClick = op.outTrigger("Double Click"),
    mouseDownLeft = op.outBoolNum("Button pressed Left", false),
    mouseDownMiddle = op.outBoolNum("Button pressed Middle", false),
    mouseDownRight = op.outBoolNum("Button pressed Right", false),
    triggerMouseDownLeft = op.outTrigger("Mouse Down Left"),
    triggerMouseDownMiddle = op.outTrigger("Mouse Down Middle"),
    triggerMouseDownRight = op.outTrigger("Mouse Down Right"),
    triggerMouseUpLeft = op.outTrigger("Mouse Up Left"),
    triggerMouseUpMiddle = op.outTrigger("Mouse Up Middle"),
    triggerMouseUpRight = op.outTrigger("Mouse Up Right"),
    area = op.inValueSelect("Area", ["Canvas", "Document"], "Canvas"),
    active = op.inValueBool("Active", true);

const cgl = op.patch.cgl;
let listenerElement = null;
area.onChange = updateListeners;
op.onDelete = removeListeners;
updateListeners();

function onMouseDown(e)
{
    if (e.which == 1)
    {
        mouseDownLeft.set(true);
        triggerMouseDownLeft.trigger();
    }
    else if (e.which == 2)
    {
        mouseDownMiddle.set(true);
        triggerMouseDownMiddle.trigger();
    }
    else if (e.which == 3)
    {
        mouseDownRight.set(true);
        triggerMouseDownRight.trigger();
    }
}

function onMouseUp(e)
{
    if (e.which == 1)
    {
        mouseDownLeft.set(false);
        triggerMouseUpLeft.trigger();
    }
    else if (e.which == 2)
    {
        mouseDownMiddle.set(false);
        triggerMouseUpMiddle.trigger();
    }
    else if (e.which == 3)
    {
        mouseDownRight.set(false);
        triggerMouseUpRight.trigger();
    }
}

function onClickRight(e)
{
    mouseClickRight.trigger();
    e.preventDefault();
}

function onDoubleClick(e)
{
    mouseDoubleClick.trigger();
}

function onmouseclick(e)
{
    mouseClickLeft.trigger();
}

function ontouchstart(event)
{
    if (event.touches && event.touches.length > 0)
    {
        event.touches[0].which = 1;
        onMouseDown(event.touches[0]);
    }
}

function ontouchend(event)
{
    onMouseUp({ "which": 1 });
}

function removeListeners()
{
    if (!listenerElement) return;
    listenerElement.removeEventListener("touchend", ontouchend);
    listenerElement.removeEventListener("touchcancel", ontouchend);
    listenerElement.removeEventListener("touchstart", ontouchstart);
    listenerElement.removeEventListener("dblclick", onDoubleClick);
    listenerElement.removeEventListener("click", onmouseclick);
    listenerElement.removeEventListener("mousedown", onMouseDown);
    listenerElement.removeEventListener("mouseup", onMouseUp);
    listenerElement.removeEventListener("contextmenu", onClickRight);
    listenerElement.removeEventListener("mouseleave", onMouseUp);
    listenerElement = null;
}

function addListeners()
{
    if (listenerElement)removeListeners();

    listenerElement = cgl.canvas;
    if (area.get() == "Document") listenerElement = document.body;

    listenerElement.addEventListener("touchend", ontouchend);
    listenerElement.addEventListener("touchcancel", ontouchend);
    listenerElement.addEventListener("touchstart", ontouchstart);
    listenerElement.addEventListener("dblclick", onDoubleClick);
    listenerElement.addEventListener("click", onmouseclick);
    listenerElement.addEventListener("mousedown", onMouseDown);
    listenerElement.addEventListener("mouseup", onMouseUp);
    listenerElement.addEventListener("contextmenu", onClickRight);
    listenerElement.addEventListener("mouseleave", onMouseUp);
}

op.onLoaded = updateListeners;

active.onChange = updateListeners;

function updateListeners()
{
    removeListeners();
    if (active.get()) addListeners();
}

}
};

CABLES.OPS["c7e5e545-c8a1-4fef-85c2-45422b947f0d"]={f:Ops.Devices.Mouse.MouseButtons,objName:"Ops.Devices.Mouse.MouseButtons"};




// **************************************************************
// 
// Ops.Array.ArrayPack4Simple
// 
// **************************************************************

Ops.Array.ArrayPack4Simple= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
const
    inArr1 = op.inArray("Array 1"),
    inArr2 = op.inArray("Array 2"),
    inArr3 = op.inArray("Array 3"),
    inArr4 = op.inArray("Array 4"),

    outArr = op.outArray("Array out", 4),
    outNum = op.outNumber("Num Points"),
    outArrayLength = op.outNumber("Array length");

let showingError = false;

let arr = [];
let emptyArray = [];
let needsCalc = true;

inArr1.onChange = inArr2.onChange = inArr3.onChange = inArr4.onChange = update;

function update()
{
    let array1 = inArr1.get();
    let array2 = inArr2.get();
    let array3 = inArr3.get();
    let array4 = inArr4.get();

    if (!array1 && !array2 && !array3 && !array4)
    {
        outArr.set(null);
        outNum.set(0);
        return;
    }
    let arrlen = 0;

    if (!array1 || !array2 || !array3 || !array4)
    {
        if (array1) arrlen = array1.length;
        else if (array2) arrlen = array2.length;
        else if (array3) arrlen = array3.length;
        else if (array4) arrlen = array4.length;

        if (emptyArray.length != arrlen)
            for (let i = 0; i < arrlen; i++) emptyArray[i] = 0;

        if (!array1)array1 = emptyArray;
        if (!array2)array2 = emptyArray;
        if (!array3)array3 = emptyArray;
        if (!array4)array4 = emptyArray;
    }

    if (
        (array1.length !== array2.length) ||
        (array2.length !== array3.length) ||
        (array3.length !== array4.length) ||
        (array1.length !== array4.length) ||
        (array1.length !== array3.length)
    )
    {
        op.setUiError("arraylen", "Arrays do not have the same length !", 1);
        return;
    }
    op.setUiError("arraylen", null);

    arr.length = array1.length * 4;
    for (let i = 0; i < array1.length; i++)
    {
        arr[i * 4 + 0] = array1[i];
        arr[i * 4 + 1] = array2[i];
        arr[i * 4 + 2] = array3[i];
        arr[i * 4 + 3] = array4[i];
    }

    needsCalc = false;
    outArr.setRef(arr);
    outNum.set(arr.length / 4);
    outArrayLength.set(arr.length);
}

}
};

CABLES.OPS["6fe2bb0e-4bfc-42c1-8bc1-19fda052e091"]={f:Ops.Array.ArrayPack4Simple,objName:"Ops.Array.ArrayPack4Simple"};




// **************************************************************
// 
// Ops.Array.Array3
// 
// **************************************************************

Ops.Array.Array3= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
const
    inNum = op.inValueInt("Num Triplets", 100),
    inX = op.inValueFloat("X", 0),
    inY = op.inValueFloat("Y", 0),
    inZ = op.inValueFloat("Z", 0),
    outArr = op.outArray("Array", null, 3),
    outTotalPoints = op.outNumber("Total points"),
    outArrayLength = op.outNumber("Array length");

inNum.onChange =
    inX.onChange =
    inY.onChange =
    inZ.onChange = update;

let arr = [];
update();

function update()
{
    let num = Math.floor(inNum.get() * 3);

    if (num < 0)num = 0;
    if (arr.length != num) arr.length = num;

    const x = inX.get();
    const y = inY.get();
    const z = inZ.get();

    for (let i = 0; i < num; i += 3)
    {
        arr[i] = x;
        arr[i + 1] = y;
        arr[i + 2] = z;
    }

    outArr.setRef(arr);
    outTotalPoints.set(num / 3);
    outArrayLength.set(num);
}

}
};

CABLES.OPS["2766606a-3ea0-4204-8613-b8950a124435"]={f:Ops.Array.Array3,objName:"Ops.Array.Array3"};




// **************************************************************
// 
// Ops.Trigger.TriggerOnce
// 
// **************************************************************

Ops.Trigger.TriggerOnce= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
const
    exe = op.inTriggerButton("Exec"),
    reset = op.inTriggerButton("Reset"),
    next = op.outTrigger("Next"),
    outTriggered = op.outBoolNum("Was Triggered");

let triggered = false;

op.toWorkPortsNeedToBeLinked(exe);

reset.onTriggered = function ()
{
    triggered = false;
    outTriggered.set(triggered);
};

exe.onTriggered = function ()
{
    if (triggered) return;

    triggered = true;
    next.trigger();
    outTriggered.set(triggered);
};

}
};

CABLES.OPS["cf3544e4-e392-432b-89fd-fcfb5c974388"]={f:Ops.Trigger.TriggerOnce,objName:"Ops.Trigger.TriggerOnce"};




// **************************************************************
// 
// Ops.Array.SwitchArray
// 
// **************************************************************

Ops.Array.SwitchArray= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
let idx = op.inValueInt("Index");
let valuePorts = [];
let result = op.outArray("Result");

idx.onChange = update;
idx.onLinkChanged = update;
op.on("init", update);

for (let i = 0; i < 10; i++)
{
    let p = op.inArray("Array " + i);
    valuePorts.push(p);
    p.onChange = update;
    p.onLinkChanged = update;
}

function update()
{
    if (idx.get() >= 0 && valuePorts[idx.get()] && valuePorts[idx.get()].isLinked())
    {
        result.setRef(valuePorts[idx.get()].get());
    }
    else
        result.setRef([]);
}

}
};

CABLES.OPS["3fab881c-c2cf-42a0-9c42-2d8edfd93f57"]={f:Ops.Array.SwitchArray,objName:"Ops.Array.SwitchArray"};




// **************************************************************
// 
// Ops.Cables.UIMode
// 
// **************************************************************

Ops.Cables.UIMode= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
const
    outUI = op.outBoolNum("UI", op.patch.isEditorMode()),
    outOverlay = op.outBoolNum("Overlay Mode", false),
    outRemoteViewer = op.outBoolNum("Remote Viewer", window.gui ? window.gui.isRemoteClient : false),
    outStandalone = op.outBoolNum("Is Standalone", (CABLES.platform && CABLES.platform.frontendOptions.isElectron)),
    outCanvasMode = op.outNumber("Canvas Mode"),
    outPatchVisible = op.outBoolNum("Patch Field Visible");

if (CABLES.UI)
{
    outOverlay.set(gui.shouldDrawOverlay);

    gui.on("overlaysChanged", (active) =>
    {
        outOverlay.set(active);
    });

    gui.on("canvasModeChange", () =>
    {
        outCanvasMode.set(gui.canvasManager.mode);
        outPatchVisible.set(gui.patchView.element.classList.contains("hidden"));
    });
}

}
};

CABLES.OPS["7c110d60-829f-4b06-b3e4-0af911550570"]={f:Ops.Cables.UIMode,objName:"Ops.Cables.UIMode"};




// **************************************************************
// 
// Ops.Array.Array3GetAverage
// 
// **************************************************************

Ops.Array.Array3GetAverage= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
const
    inArr = op.inArray("Array", 3),
    avgX = op.outNumber("Average X"),
    avgY = op.outNumber("Average Y"),
    avgZ = op.outNumber("Average Z");
op.toWorkPortsNeedToBeLinked(inArr);

inArr.onChange = function ()
{
    let arr = inArr.get();
    if (!arr)
    {
        avgX.set(0);
        avgY.set(0);
        avgZ.set(0);
        return;
    }
    let x = 0;
    let y = 0;
    let z = 0;

    for (let i = 0; i < arr.length; i += 3)
    {
        x += arr[i + 0];
        y += arr[i + 1];
        z += arr[i + 2];
    }

    x /= arr.length / 3;
    y /= arr.length / 3;
    z /= arr.length / 3;

    avgX.set(x);
    avgY.set(y);
    avgZ.set(z);
};

}
};

CABLES.OPS["9643edc7-e479-4b26-9f7a-343cdcdc81f4"]={f:Ops.Array.Array3GetAverage,objName:"Ops.Array.Array3GetAverage"};




// **************************************************************
// 
// Ops.Array.SmoothArray
// 
// **************************************************************

Ops.Array.SmoothArray= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
// look at http://sol.gfxile.net/interpolation/
const exec = op.inTrigger("Execute"),
    inArray = op.inArray("Array In"),
    inModeBool = op.inBool("Separate inc/dec", false),
    incFactor = op.inValue("Inc factor", 4),
    decFactor = op.inValue("Dec factor", 4),
    next = op.outTrigger("Next"),
    outArray = op.outArray("Array Out");

let goal = [];
let reset = false;
let lastTrigger = 0;

let newArr = [];
outArray.set(newArr);

let divisorUp;
let divisorDown;

let selectedMode = false;

onFilterChange();
getDivisors();
function onFilterChange()
{
    selectedMode = inModeBool.get();

    if (!selectedMode)
    {
        decFactor.setUiAttribs({ "greyout": true });
        incFactor.setUiAttribs({ "title": "Inc/Dec factor" });
    }
    else
    {
        decFactor.setUiAttribs({ "greyout": false });
        incFactor.setUiAttribs({ "title": "Inc factor" });
    }

    getDivisors();
    update();
}

function getDivisors()
{
    divisorUp = incFactor.get();

    if (selectedMode == false) divisorDown = incFactor.get();
    else divisorDown = decFactor.get();

    if (divisorUp <= 0 || divisorUp != divisorUp)divisorUp = 0.0001;
    if (divisorDown <= 0 || divisorDown != divisorDown)divisorDown = 0.0001;
    if (divisorUp <= 1.0) divisorUp = 1.0;
    if (divisorDown <= 1.0) divisorDown = 1.0;
}

inArray.onLinkChanged = () =>
{
    if (inArray) inArray.copyLinkedUiAttrib("stride", outArray);
};

inArray.onChange = function ()
{
    let arr = inArray.get();
    if (!arr) return;

    for (let i = 0; i < arr.length; i++)
    {
        goal[i] = arr[i] || 0;
    }
};

let oldVal = 0;

function update()
{
    let arr = inArray.get();
    if (!arr) return;

    if (newArr.length != arr.length)
    {
        newArr.length = arr.length || 0;
        reset = true;
    }

    let tm = 1;
    if (CABLES.now() - lastTrigger > 500 || lastTrigger === 0)reset = true;
    else tm = (CABLES.now() - lastTrigger) / 17;
    lastTrigger = CABLES.now();

    if (reset)
    {
        for (var i = 0; i < arr.length; i++)
        {
            newArr[i] = arr[i];
        }
        reset = false;
    }

    for (var i = 0; i < arr.length; i++)
    {
        let val = newArr[i];

        let diff = goal[i] - val;

        if (diff >= 0)
            val += (diff) / (divisorDown * tm);
        else
            val += (diff) / (divisorUp * tm);

        if (val > 0 && val < 0.000000001)val = 0;
        if (!val) val = 0;

        if (newArr[i] != val)
        {
            newArr[i] = val;
            oldVal = val;
        }
    }
    // outArray.set(null);
    outArray.setRef(newArr);

    next.trigger();
}

exec.onTriggered = function ()
{
    update();
};

incFactor.onChange = decFactor.onChange = getDivisors;
inModeBool.onChange = onFilterChange;
update();

}
};

CABLES.OPS["8fd2ed9b-02e5-4349-b7bc-6665ca240ffa"]={f:Ops.Array.SmoothArray,objName:"Ops.Array.SmoothArray"};




// **************************************************************
// 
// Ops.Array.ArrayIndexMinMax
// 
// **************************************************************

Ops.Array.ArrayIndexMinMax= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
const
    inArr=op.inArray("Array"),
    outMax=op.outNumber("Max"),
    outIndexMax=op.outNumber("Index Max"),
    outMin=op.outNumber("Min"),
    outIndexMin=op.outNumber("Index Min");

inArr.onChange=
outMax.onChange=
outIndexMax.onChange=
outMin.onChange=
outIndexMin.onChange=()=>
{

    const arr=inArr.get();

    if(!arr)
    {
        outMax.set(0);
        outMin.set(0);
        return;
    }

    let min=Number.MAX_VALUE;
    let max=-Number.MAX_VALUE;
    let minIndex=-1;
    let maxIndex=-1;

    for(let i=0;i<arr.length;i++)
    {

        if(arr[i]<min)
        {
            minIndex=i;
            min=arr[i];
        }
        if(arr[i]>max)
        {
            maxIndex=i;
            max=arr[i];
        }

    }

    outMax.set(max);
    outIndexMax.set(maxIndex);
    outMin.set(min);
    outIndexMin.set(minIndex);


};
}
};

CABLES.OPS["240172a6-7dde-4dcc-b862-bbe764aec3f3"]={f:Ops.Array.ArrayIndexMinMax,objName:"Ops.Array.ArrayIndexMinMax"};




// **************************************************************
// 
// Ops.Anim.Smooth
// 
// **************************************************************

Ops.Anim.Smooth= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
const
    exec = op.inTrigger("Update"),
    inMode = op.inBool("Separate inc/dec", false),
    inVal = op.inValue("Value"),
    next = op.outTrigger("Next"),
    inDivisorUp = op.inValue("Inc factor", 4),
    inDivisorDown = op.inValue("Dec factor", 4),
    result = op.outNumber("Result", 0);

let val = 0;
let goal = 0;
let oldVal = 0;
let lastTrigger = 0;

op.toWorkPortsNeedToBeLinked(exec);

let divisorUp;
let divisorDown;
let divisor = 4;
let finished = true;

let selectIndex = 0;
const MODE_SINGLE = 0;
const MODE_UP_DOWN = 1;

onFilterChange();
getDivisors();

inMode.setUiAttribs({ "hidePort": true });

inDivisorUp.onChange = inDivisorDown.onChange = getDivisors;
inMode.onChange = onFilterChange;
update();

function onFilterChange()
{
    const selectedMode = inMode.get();
    if (!selectedMode) selectIndex = MODE_SINGLE;
    else selectIndex = MODE_UP_DOWN;

    if (selectIndex == MODE_SINGLE)
    {
        inDivisorDown.setUiAttribs({ "greyout": true });
        inDivisorUp.setUiAttribs({ "title": "Inc/Dec factor" });
    }
    else if (selectIndex == MODE_UP_DOWN)
    {
        inDivisorDown.setUiAttribs({ "greyout": false });
        inDivisorUp.setUiAttribs({ "title": "Inc factor" });
    }

    getDivisors();
    update();
}

function getDivisors()
{
    if (selectIndex == MODE_SINGLE)
    {
        divisorUp = inDivisorUp.get();
        divisorDown = inDivisorUp.get();
    }
    else if (selectIndex == MODE_UP_DOWN)
    {
        divisorUp = inDivisorUp.get();
        divisorDown = inDivisorDown.get();
    }

    if (divisorUp <= 0.2 || divisorUp != divisorUp)divisorUp = 0.2;
    if (divisorDown <= 0.2 || divisorDown != divisorDown)divisorDown = 0.2;
}

inVal.onChange = function ()
{
    finished = false;
    let oldGoal = goal;
    goal = inVal.get();
};

inDivisorUp.onChange = function ()
{
    getDivisors();
};

function update()
{
    let tm = 1;
    if (performance.now() - lastTrigger > 500 || lastTrigger === 0) val = inVal.get() || 0;
    else tm = (performance.now() - lastTrigger) / (performance.now() - lastTrigger);
    lastTrigger = performance.now();

    if (val != val)val = 0;

    if (divisor <= 0)divisor = 0.0001;

    const diff = goal - val;

    if (diff >= 0) val += (diff) / (divisorDown * tm);
    else val += (diff) / (divisorUp * tm);

    if (Math.abs(diff) < 0.00001)val = goal;

    if (divisor != divisor)val = 0;
    if (val != val || val == -Infinity || val == Infinity)val = inVal.get();

    if (oldVal != val)
    {
        result.set(val);
        oldVal = val;
    }

    if (val == goal && !finished)
    {
        finished = true;
        result.set(val);
    }
}

exec.onTriggered = function ()
{
    update();
    next.trigger();
};

}
};

CABLES.OPS["5677b5b5-753a-4fbf-9e91-64c81ec68a2f"]={f:Ops.Anim.Smooth,objName:"Ops.Anim.Smooth"};




// **************************************************************
// 
// Ops.Cables.Function_v2
// 
// **************************************************************

Ops.Cables.Function_v2= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
const
    funcName = op.inString("Function Name", "default"),
    triggerButton = op.inTriggerButton("Trigger"),
    inString1 = op.inString("Default Parameter 1"),
    inString2 = op.inString("Default Parameter 2"),
    inString3 = op.inString("Default Parameter 3"),
    outTrigger = op.outTrigger("Next"),
    outString1 = op.outString("Parameter 1"),
    outString2 = op.outString("Parameter 2"),
    outString3 = op.outString("Parameter 3");

triggerButton.onTriggered = triggered;

funcName.onChange = function ()
{
    op.patch.config[funcName.get()] = triggered;
};

function triggered()
{
    const arg1 = arguments.hasOwnProperty(0) && typeof arguments[0] !== "undefined" ? arguments[0] : inString1.get();
    const arg2 = arguments.hasOwnProperty(1) && typeof arguments[1] !== "undefined" ? arguments[1] : inString2.get();
    const arg3 = arguments.hasOwnProperty(2) && typeof arguments[2] !== "undefined" ? arguments[2] : inString3.get();
    outString1.set(arg1);
    outString2.set(arg2);
    outString3.set(arg3);
    outTrigger.trigger();
}

}
};

CABLES.OPS["39043a11-1ae0-4568-93a7-ec1493df2662"]={f:Ops.Cables.Function_v2,objName:"Ops.Cables.Function_v2"};




// **************************************************************
// 
// Ops.Patch.PLH3vXR.CreatePathIndexArray
// 
// **************************************************************

Ops.Patch.PLH3vXR.CreatePathIndexArray= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
const
    rebuildTrigger = op.inTrigger("Rebuild Image DataSet Trigger"),
    imageCountList_Iconic = op.inArray("Iconic Image Count List"),
    imageCountList_Generic = op.inArray("Generic Image Count List"),
    shuffle = op.inTriggerButton("Shuffle Imageset"),

    iconicIndexOut = op.outArray("Iconic Image Index Array"),
    genericIndexOut = op.outArray("Generic Image Index Array");



let iconicArray = Array(1);
let genericArray = Array(1);


imageCountList_Iconic.onChange =
imageCountList_Generic.onChange = setNeedUpdate;

let needUpdate = false;
function setNeedUpdate()
{
    needUpdate = true;
}

rebuildTrigger.onTriggered = rebuildImageDataset;
function rebuildImageDataset()
{
    if(needUpdate == false)
        return;
    needUpdate = false

    if (!imageCountList_Iconic.get() || imageCountList_Iconic.get().length === 0
    || !imageCountList_Generic.get() || imageCountList_Generic.get().length === 0)
    {
        return;
    }

    if(imageCountList_Iconic.get().length != imageCountList_Generic.get().length)
    {
        console.error("The amount of categories doesn't match between Iconic and Generic");
        return;
    }

    const iconic_count_list = imageCountList_Iconic.get();
    const generic_count_list = imageCountList_Generic.get();
    iconicArray = [];
    genericArray = [];

    for( let i=0; i<iconic_count_list.length; i++)
    {
        iconicArray[i] = [];
        for(let j=0; j<iconic_count_list[i]; j++)
        {
            iconicArray[i][j] = j
        }
    }
    for( let i=0; i<generic_count_list.length; i++)
    {
        genericArray[i] = [];
        for(let j=0; j<generic_count_list[i]; j++)
        {
            genericArray[i][j] = j
        }
    }

    iconicIndexOut.setRef(iconicArray);
    genericIndexOut.setRef(genericArray);

    shuffleImageset();
}


shuffle.onTriggered = shuffleImageset;
function shuffleImageset()
{
    if (!imageCountList_Iconic.get() || imageCountList_Iconic.get().length === 0
    || !imageCountList_Generic.get() || imageCountList_Generic.get().length === 0)
    {
        return;
    }

    if(imageCountList_Iconic.get().length != imageCountList_Generic.get().length)
    {
        console.error("The amount of categories doesn't match between Iconic and Generic");
        return;
    }

    for( let i=0; i<iconicArray.length; i++)
    {
        shuffleArray(iconicArray[i]);
        shuffleArray(genericArray[i]);
    }

    iconicIndexOut.setRef(iconicArray);
    genericIndexOut.setRef(genericArray);
}

/* Randomize array in-place using Durstenfeld shuffle algorithm */
function shuffleArray(array) {
    for (var i = array.length - 1; i > 0; i--) {
        var j = Math.floor(Math.random() * (i + 1));
        var temp = array[i];
        array[i] = array[j];
        array[j] = temp;
    }
}


iconicIndexOut.set(null);
genericIndexOut.set(null);

rebuildImageDataset();

}
};

CABLES.OPS["e744b533-5883-40e5-ab5f-6448f731e75e"]={f:Ops.Patch.PLH3vXR.CreatePathIndexArray,objName:"Ops.Patch.PLH3vXR.CreatePathIndexArray"};




// **************************************************************
// 
// Ops.Json.ObjectGetString
// 
// **************************************************************

Ops.Json.ObjectGetString= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
const
    data = op.inObject("data"),
    key = op.inString("Key"),
    result = op.outString("Result");

result.ignoreValueSerialize = true;
data.ignoreValueSerialize = true;

op.toWorkPortsNeedsString(key);
op.toWorkPortsNeedToBeLinked(data);

op.setUiAttrib({ "extendTitlePort": key.name });
key.setUiAttribs({ "stringTrim": true });

key.onChange =
data.onChange = exec;

function exec()
{
    if (data.get())
    {
        const value = data.get()[key.get()];
        const isNull = value === undefined || value === null;

        if (isNull)
        {
            result.setRef(null);
        }
        else
        {
            result.set(String(value));
        }
    }
    else
    {
        result.setRef(null);
    }
}

}
};

CABLES.OPS["7d86cd28-f7d8-44a1-a4da-466c4782aaec"]={f:Ops.Json.ObjectGetString,objName:"Ops.Json.ObjectGetString"};




// **************************************************************
// 
// Ops.String.Concat_v2
// 
// **************************************************************

Ops.String.Concat_v2= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
const
    string1 = op.inString("string1", "ABC"),
    string2 = op.inString("string2", "XYZ"),
    newLine = op.inValueBool("New Line", false),
    active = op.inBool("Active", true),
    result = op.outString("result");

newLine.onChange =
    string2.onChange =
    string1.onChange =
    active.onChange = exec;

op.toWorkPortsNeedsString(string1, string2);
exec();

function exec()
{
    if (!active.get())
    {
        return result.set(string1.get());
    }
    let s1 = string1.get();
    let s2 = string2.get();
    if (!s1 && !s2)
    {
        result.set("");
        return;
    }
    if (!s1)s1 = "";
    if (!s2)s2 = "";

    let nl = "";
    if (s1 && s2 && newLine.get())nl = "\n";
    result.set(String(s1) + nl + String(s2));
}

}
};

CABLES.OPS["a52722aa-0ca9-402c-a844-b7e98a6c6e60"]={f:Ops.String.Concat_v2,objName:"Ops.String.Concat_v2"};




// **************************************************************
// 
// Ops.Json.HttpRequest_v3
// 
// **************************************************************

Ops.Json.HttpRequest_v3= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
const filename = op.inUrl("file"),
    headers = op.inObject("headers", {}),
    inBody = op.inStringEditor("body", ""),
    inMethod = op.inDropDown("HTTP Method", ["GET", "POST", "PUT", "DELETE", "PATCH", "HEAD", "CONNECT", "OPTIONS", "TRACE"], "GET"),
    inContentType = op.inString("Content-Type", "application/json"),
    inContent = op.inSwitch("Content", ["JSON", "String", "Binary", "Binary Base64"], "JSON"),
    inAutoRequest = op.inBool("Auto request", true),
    inSendCredentials = op.inBool("Send Credentials", false),
    reloadTrigger = op.inTriggerButton("reload"),
    outData = op.outObject("Response Json Object"),
    outString = op.outString("Response String"),
    outStringBin = op.outString("Response Data Url"),
    outDuration = op.outNumber("Duration MS", 0),
    outStatus = op.outNumber("Status Code", 0),

    isLoading = op.outBoolNum("Is Loading", false),
    outTrigger = op.outTrigger("Loaded");

inContent.setUiAttribs({ "title": "Response Content" });
filename.setUiAttribs({ "title": "URL" });
reloadTrigger.setUiAttribs({ "buttonTitle": "trigger request" });

outData.ignoreValueSerialize = true;
outString.ignoreValueSerialize = true;

outString.onLinkChanged =
    outStringBin.onLinkChanged =
    outData.onLinkChanged = showEmptyUrlWarning;

inContent.onChange = () =>
{
    const greyOut = (inContent.get() === "Binary");
    inMethod.setUiAttribs({ "greyout": greyOut });
    delayedReload(false);
};

inAutoRequest.onChange =
    filename.onChange =
    headers.onChange =
    inMethod.onChange = () =>
    {
        delayedReload(false);
    };

reloadTrigger.onTriggered = () =>
{
    delayedReload(true);
};

let reloadTimeout = 0;

function delayedReload(force = false)
{
    clearTimeout(reloadTimeout);
    reloadTimeout = setTimeout(() => { reload(null, force); }, 100);
}

op.onFileChanged = (fn) =>
{
    if (filename.get() && filename.get().indexOf(fn) > -1) reload(true);
};

function showEmptyUrlWarning()
{
    if (!filename.get())
        op.setUiError("nourl", "URL is empty", 1);
    else
        op.setUiError("nourl", null);
}

function reload(addCachebuster, force = false)
{
    if (!inAutoRequest.get() && !force) return;

    showEmptyUrlWarning();
    if (!filename.get())
    {
        return;
    }

    const loadingId = op.patch.loading.start(op.objName, "" + filename.get(), op);
    isLoading.set(true);

    op.setUiAttrib({ "extendTitle": CABLES.basename(filename.get()) });
    op.setUiError("jsonerr", null);
    op.setUiError("jsonParse", null);

    let url = op.patch.getFilePath(filename.get());
    if (addCachebuster)url += "?rnd=" + CABLES.generateUUID();

    op.patch.loading.addAssetLoadingTask(() =>
    {
        const body = inBody.get();
        const startTime = performance.now();

        const options = {};
        if (inSendCredentials.get()) options.credentials = "include";
        if (inContent.get().includes("Binary"))
        {
            fetch(url, options).then((res) =>
            {
                outDuration.set(Math.round(performance.now() - startTime));
                outStatus.set(res.status);

                res.blob().then((b) =>
                {
                    outStringBin.set(URL.createObjectURL(b));

                    if (inContent.get().includes("Base64"))
                    {
                        const reader = new FileReader();
                        reader.onloadend = function ()
                        {
                            const base64data = reader.result;
                            outStringBin.set(base64data);
                            isLoading.set(false);
                            outTrigger.trigger();
                            op.patch.loading.finished(loadingId);
                        };
                        reader.readAsDataURL(b);
                    }
                    else
                    {
                        isLoading.set(false);
                        outTrigger.trigger();
                        op.patch.loading.finished(loadingId);
                    }
                }).catch((e) =>
                {
                    op.logError(e);
                    op.setUiError("jsonerr", "Problem while loading data:<br/>" + e, 1);
                    isLoading.set(false);
                    outData.setRef(null);
                    outString.set("");
                    outTrigger.trigger();
                    op.patch.loading.finished(loadingId);
                });
            }).catch((e) =>
            {
                op.logError(e);
                op.setUiError("jsonerr", "Problem while loading data:<br/>" + e, 1);
                isLoading.set(false);
                outData.setRef(null);
                outString.set("");
                outTrigger.trigger();
                op.patch.loading.finished(loadingId);
            });
        }
        else
        {
            CABLES.ajax(
                url,
                (err, _data, xhr) =>
                {
                    outDuration.set(Math.round(performance.now() - startTime));
                    outStatus.set(xhr.status);

                    try
                    {
                        let data = _data;

                        if (typeof data === "string" && inContent.get() === "JSON")
                        {
                            try
                            {
                                data = JSON.parse(_data);
                                outData.setRef(data);
                            }
                            catch (e)
                            {
                                op.setUiError("jsonParse", "could not parse json" + e.message, 1);
                                outData.setRef({});
                            }
                        }

                        outString.set(_data);
                        op.uiAttr({ "error": null });
                        outTrigger.trigger();
                        isLoading.set(false);
                        op.patch.loading.finished(loadingId);
                    }
                    catch (e)
                    {
                        op.logError(e);
                        op.setUiError("jsonerr", "Problem while loading data:<br/>" + e, 1);
                        isLoading.set(false);
                        outData.setRef(null);
                        outString.set("");
                        op.patch.loading.finished(loadingId);
                    }
                },
                inMethod.get(),
                (body && body.length > 0) ? body : null,
                inContentType.get(),
                null,
                headers.get() || {},
                options
            );
        }
    });
}

}
};

CABLES.OPS["ba2131a6-782d-40fe-9710-57a8e57051bb"]={f:Ops.Json.HttpRequest_v3,objName:"Ops.Json.HttpRequest_v3"};




// **************************************************************
// 
// Ops.Data.Compose.Array.CompArray
// 
// **************************************************************

Ops.Data.Compose.Array.CompArray= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
const
    update = op.inTrigger("Update"),
    active = op.inBool("Active", true),
    clear = op.inBool("Clear", true),
    inReset = op.inTriggerButton("Reset"),
    next = op.outTrigger("Next"),
    outArr = op.outArray("Result");

inReset.onTriggered = () =>
{
    arr = [];
    outArr.setRef([]);
};

let arr = [];

update.onTriggered = () =>
{
    if (!active.get()) return next.trigger();

    op.patch.tempData.compArray = op.patch.tempData.compArray || [];

    if (clear.get())
    {
        arr = [];
    }

    op.patch.tempData.compArray.push(arr);
    next.trigger();

    outArr.setRef(op.patch.tempData.compArray.pop());
};

}
};

CABLES.OPS["16f1ce37-9e0d-4632-a9ba-dfd42c4eb254"]={f:Ops.Data.Compose.Array.CompArray,objName:"Ops.Data.Compose.Array.CompArray"};




// **************************************************************
// 
// Ops.Data.Compose.Array.CompArrayPushNumber
// 
// **************************************************************

Ops.Data.Compose.Array.CompArrayPushNumber= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
const
    update = op.inTrigger("Update"),
    inNum1 = op.inFloat("Number", 0),
    next = op.outTrigger("Next");

update.onTriggered = () =>
{
    if (op.patch.tempData.compArray && op.patch.tempData.compArray.length > 0)
    {
        let arr = op.patch.tempData.compArray[op.patch.tempData.compArray.length - 1];
        if (arr) arr.push(inNum1.get());
    }
    next.trigger();
};

}
};

CABLES.OPS["49741334-d249-4f62-96ea-3ff582f38598"]={f:Ops.Data.Compose.Array.CompArrayPushNumber,objName:"Ops.Data.Compose.Array.CompArrayPushNumber"};




// **************************************************************
// 
// Ops.Array.ArrayIteratorStrings
// 
// **************************************************************

Ops.Array.ArrayIteratorStrings= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
const
    exe = op.inTrigger("Exe"),
    arr = op.inArray("Array"),
    trigger = op.outTrigger("Trigger"),
    idx = op.outNumber("Index"),
    val = op.outString("Value");

exe.onTriggered = function ()
{
    if (!arr.get()) return;

    for (let i = 0; i < arr.get().length; i++)
    {
        idx.set(i);
        let value = null;
        if (arr.get()[i])
        {
            value = String(arr.get()[i]);
        }
        val.set(value);
        trigger.trigger();
        // op.patch.instancing.increment();
    }
};

}
};

CABLES.OPS["0f8ee026-e094-484d-8403-547c92293be9"]={f:Ops.Array.ArrayIteratorStrings,objName:"Ops.Array.ArrayIteratorStrings"};




// **************************************************************
// 
// Ops.Array.ArrayIteratorNumbers
// 
// **************************************************************

Ops.Array.ArrayIteratorNumbers= class extends CABLES.Op 
{
constructor()
{
super(...arguments);
const op=this;
const attachments=op.attachments={};
const
    exe = op.inTrigger("exe"),
    arr = op.inArray("array"),
    trigger = op.outTrigger("trigger"),
    idx = op.addOutPort(new CABLES.Port(op, "index")),
    val = op.addOutPort(new CABLES.Port(op, "value"));

val.changeAlways = true;

exe.onTriggered = function ()
{
    if (!arr.get()) return;

    for (let i = 0; i < arr.get().length; i++)
    {
        idx.set(i);
        val.set(arr.get()[i]);
        trigger.trigger();
        // op.patch.instancing.increment();
    }
};

}
};

CABLES.OPS["ec280011-1190-4333-9a68-adb4904fca1a"]={f:Ops.Array.ArrayIteratorNumbers,objName:"Ops.Array.ArrayIteratorNumbers"};



window.addEventListener('load', function(event) {
CABLES.jsLoaded=new Event('CABLES.jsLoaded');
document.dispatchEvent(CABLES.jsLoaded);
});
// start js/vargetset.js
/******/ (() => { // webpackBootstrap
/******/ 	// runtime can't be in strict mode because a global variable is assign and maybe created.
/******/ 	// The require scope
/******/ 	var __webpack_require__ = {};
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  VarGetOpWrapper: () => (/* binding */ VarGetOpWrapper),
  VarSetOpWrapper: () => (/* binding */ VarSetOpWrapper)
});

;// CONCATENATED MODULE: external "CABLES"
const external_CABLES_namespaceObject = CABLES;
;// CONCATENATED MODULE: ./src/corelibs/vargetset/vargetset.js


class VarSetOpWrapper
{
    constructor(op, type, valuePort, varNamePort, triggerPort, nextPort)
    {
        this._valuePort = valuePort;
        this._varNamePort = varNamePort;
        this._op = op;
        this._type = type;
        this._typeId = -1;
        this._triggerPort = triggerPort;
        this._nextPort = nextPort;

        this._var = null;

        this._btnCreate = op.inTriggerButton("Create new variable");
        this._btnCreate.setUiAttribs({ "hidePort": true });
        this._btnCreate.onTriggered = this._createVar.bind(this);

        this._helper = op.inUiTriggerButtons("", ["Rename"]);
        this._helper.setUiAttribs({ "hidePort": true });
        this._helper.onTriggered = (which) => { if (which == "Rename") CABLES.CMD.PATCH.renameVariable(op.varName.get()); };

        this._op.setPortGroup("Variable", [this._helper, this._varNamePort, this._btnCreate]);

        varNamePort.setUiAttribs({ "_variableSelect": true });
        this._op.on("uiParamPanel", this._updateVarNamesDropdown.bind(this));

        // this._op.patch.addEventListener("variableDeleted", this._updateVarNamesDropdown.bind(this));
        this._op.patch.addEventListener("variablesChanged", this._updateName.bind(this));
        this._op.patch.addEventListener("variableRename", this._renameVar.bind(this));

        this._varNamePort.onChange = this._updateName.bind(this);

        this._isTexture = this._valuePort.uiAttribs.objType === "texture";

        this._valuePort.changeAlways = true;

        if (this._triggerPort)
        {
            this._triggerPort.onTriggered = () =>
            {
                this._setVarValue(true);
            };
        }
        else
        {
            this._valuePort.onChange = this._setVarValue.bind(this);
        }

        this._op.init = () =>
        {
            this._updateName();
            if (!this._triggerPort) this._setVarValue();
            this._updateErrorUi();
        };

        if (type == "array") this._typeId = external_CABLES_namespaceObject.Port.TYPE_ARRAY;
        else if (type == "object") this._typeId = external_CABLES_namespaceObject.Port.TYPE_OBJECT;
        else if (type == "string") this._typeId = external_CABLES_namespaceObject.Port.TYPE_STRING;
        else if (type == "texture") this._typeId = external_CABLES_namespaceObject.Port.TYPE_TEXTURE;
        else this._typeId = external_CABLES_namespaceObject.Port.TYPE_VALUE;

    }

    _updateErrorUi()
    {
        if (CABLES.UI)
        {
            if (!this._varNamePort.get()) this._op.setUiError("novarname", "no variable selected");
            else
            {
                if (this._op.hasUiErrors)
                    this._op.setUiError("novarname", null);
            }
        }
    }

    _updateName()
    {
        this._var = null;
        const varname = this._varNamePort.get();
        this._op.setTitle("var set");
        this._op.setUiAttrib({ "extendTitle": "#" + varname });

        this._updateErrorUi();

        const vari = this._op.patch.getVar(varname);
        if (vari && !vari.type) vari.type = this._type;

        if (!this._op.patch.hasVar(varname) && varname != 0 && !this._triggerPort)
        {
            this._setVarValue(); // this should not be done!!!, its kept because of compatibility anxiety
        }
        if (!this._op.patch.hasVar(varname) && varname != 0 && this._triggerPort)
        {
            if (this._type == "string") this._op.patch.setVarValue(varname, "");
            else if (this._type == "number") this._op.patch.setVarValue(varname, "");
            else this._op.patch.setVarValue(varname, null);
        }

        if (this._op.isCurrentUiOp())
        {
            this._updateVarNamesDropdown();
            this._op.refreshParams();
        }
        this._updateDisplay();
        this._op.patch.emitEvent("opVariableNameChanged", this._op, this._varNamePort.get());
    }

    _createVar()
    {
        CABLES.CMD.PATCH.createVariable(this._op, this._type, () => { this._updateName(); });
    }

    _updateDisplay()
    {
        this._valuePort.setUiAttribs({ "greyout": !this._varNamePort.get() });
    }

    _updateVarNamesDropdown()
    {
        if (CABLES.UI && CABLES.UI.loaded && CABLES.UI.loaded)
        {
            const perf = gui.uiProfiler.start("[vars] _updateVarNamesDropdown");

            const varnames = [];
            const vars = this._op.patch.getVars();
            for (const i in vars) if (vars[i].type == this._type && i != "0") varnames.push(i);
            this._varNamePort.uiAttribs.values = varnames;

            perf.finish();
        }
    }

    _renameVar(oldname, newname)
    {
        if (oldname != this._varNamePort.get()) return;
        this._varNamePort.set(newname);
        this._updateName();
    }

    _setVarValue(triggered)
    {
        const v = this._valuePort.get();
        if (!this._var)
        {
            const name = this._varNamePort.get();
            if (!name) return;
            this._op.patch.setVarValue(name, v);
            this._var = this._op.patch.getVar(name);
        }

        if (this._typeId == external_CABLES_namespaceObject.Port.TYPE_VALUE || this._typeId == external_CABLES_namespaceObject.Port.TYPE_STRING)
        {
            this._var.setValue(v);
        }
        else
        if (this._typeId == external_CABLES_namespaceObject.Port.TYPE_ARRAY)
        {
            this._arr = [];
            external_CABLES_namespaceObject.utils.copyArray(v, this._arr);
            this._var.setValue(this._arr);
        }
        else
        {
            if (this._typeId == external_CABLES_namespaceObject.Port.TYPE_OBJECT)
            {
                if (this._isTexture)
                    this._var.setValue(CGL.Texture.getEmptyTexture(this._op.patch.cgl));
                else
                    this._var.setValue(null);

                if (v && v.tex && v._cgl && !this._isTexture) this._op.setUiError("texobj", "Dont use object variables for textures, use varSetTexture");
                else this._op.setUiError("texobj", null);
            }
            this._var.setValue(v);
        }

        if (triggered && this._nextPort) this._nextPort.trigger();
    }
}

class VarGetOpWrapper
{
    constructor(op, type, varnamePort, valueOutPort)
    {
        this._op = op;
        this._type = type;
        this._varnamePort = varnamePort;
        this._variable = null;
        this._valueOutPort = valueOutPort;
        this._listenerId = null;
        this._typeId = 0;

        if (type == "array") this._typeId = external_CABLES_namespaceObject.Port.TYPE_ARRAY;
        else if (type == "object") this._typeId = external_CABLES_namespaceObject.Port.TYPE_OBJECT;
        else if (type == "texture") this._typeId = external_CABLES_namespaceObject.Port.TYPE_TEXTURE;
        else if (type == "string") this._typeId = external_CABLES_namespaceObject.Port.TYPE_STRING;
        else this._typeId = external_CABLES_namespaceObject.Port.TYPE_VALUE;

        if (valueOutPort) this._isTexture = valueOutPort.uiAttribs.objType === "texture";

        this._op.on("uiParamPanel", this._updateVarNamesDropdown.bind(this));
        this._op.on("uiErrorChange", this._updateTitle.bind(this));

        this._op.patch.on("variableRename", this._renameVar.bind(this));
        this._op.patch.on("variableDeleted", (oldname) =>
        {
            if (this._op.isCurrentUiOp()) this._op.refreshParams();
        });

        varnamePort.setUiAttribs({ "_variableSelect": true });
        varnamePort.setUiAttribs({ "_variableSelectGet": true });

        this._varnamePort.onChange = this._changeVar.bind(this);
        this._op.patch.addEventListener("variablesChanged", this._init.bind(this));

        this._op.onDelete = () =>
        {
            if (this._variable && this._listenerId) this._variable.off(this._listenerId);
        };

        this._op.init = () =>
        {
            this._init();
        };
    }

    get variable()
    {
        return this._variable;
    }

    _changeVar()
    {
        if (this._variable && this._listenerId)
        {
            this._variable.off(this._listenerId);
        }
        this._init();
    }

    _renameVar(oldname, newname)
    {
        if (oldname != this._varnamePort.get()) return;
        this._varnamePort.set(newname);
        this._updateVarNamesDropdown();
        this._updateTitle();
        this._listenerId = this._variable.on("change", this._setValueOut.bind(this));
    }

    _updateVarNamesDropdown()
    {
        if (CABLES.UI && CABLES.UI.loaded)
        {
            const varnames = [];
            const vars = this._op.patch.getVars();
            for (const i in vars)
                if (vars[i].type == this._type && i != "0")
                    varnames.push(i);

            this._op.varName.uiAttribs.values = varnames;
        }
    }

    _setValueOut(v)
    {
        if (this._valueOutPort)
            if (this._typeId == external_CABLES_namespaceObject.Port.TYPE_NUMBER || this._typeId == external_CABLES_namespaceObject.Port.TYPE_STRING)
                this._valueOutPort.set(v);
            else
            if (this._typeId == external_CABLES_namespaceObject.Port.TYPE_ARRAY || this._typeId == external_CABLES_namespaceObject.Port.TYPE_OBJECT || this._isTexture)
                this._valueOutPort.setRef(v);
            else
                console.log("unkown type?"); // remove type checks when sure

    }

    _updateTitle()
    {
        if (this._variable)
        {
            this._op.setUiError("unknownvar", null);
            this._op.setTitle("var get");
            this._op.setUiAttrib({ "extendTitle": "#" + this._varnamePort.get() });
            if (this._valueOutPort) this._setValueOut(this._variable.getValue());
        }
        else
        {
            this._op.setUiError("unknownvar", "unknown variable! - there is no setVariable with this name (" + this._varnamePort.get() + ")");
            this._op.setUiAttrib({ "extendTitle": "#invalid" });
            if (this._valueOutPort) this._setValueOut(0);
        }
    }

    _init()
    {
        this._updateVarNamesDropdown();

        if (this._variable && this._listenerId) this._variable.off(this._listenerId);
        this._variable = this._op.patch.getVar(this._op.varName.get());
        if (this._variable) this._listenerId = this._variable.on("change", this._setValueOut.bind(this));

        this._updateTitle();

        this._op.patch.emitEvent("opVariableNameChanged", this._op, this._varnamePort.get());
    }

}

})();

var __webpack_export_target__ = (CABLES = typeof CABLES === "undefined" ? {} : CABLES);
for(var i in __webpack_exports__) __webpack_export_target__[i] = __webpack_exports__[i];
if(__webpack_exports__.__esModule) Object.defineProperty(__webpack_export_target__, "__esModule", { value: true });
/******/ })()
;// end js/vargetset.js
// start js/subpatchop.js
/******/ (() => { // webpackBootstrap
/******/ 	// runtime can't be in strict mode because a global variable is assign and maybe created.
/******/ 	// The require scope
/******/ 	var __webpack_require__ = {};
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  SubPatchOp: () => (/* binding */ SubPatchOp)
});

;// CONCATENATED MODULE: external "CABLES"
const external_CABLES_namespaceObject = CABLES;
;// CONCATENATED MODULE: ./src/corelibs/subpatchop/subpatchop.js


class SubPatchOp
{
    constructor(op, options)
    {
        options = options || {};
        this._op = op;

        op.patchId = op.addInPort(new external_CABLES_namespaceObject.Port(op, "patchId", external_CABLES_namespaceObject.CONSTANTS.OP.OP_PORT_TYPE_STRING, { "display": "readonly", "hidePort": true, "hideParam": true }));

        op.setUiAttribs({ "subPatchOp": { "version": 2 } });

        if (op.uiAttribs.parentOfSubpatch)
        {
            op.patchId.set(op.uiAttribs.parentOfSubpatch);
        }
        else
        {
            if (options.subId) op.patchId.set(options.subId);
            else op.patchId.set(external_CABLES_namespaceObject.utils.generateUUID());
        }

        op.patchId.onChange = () =>
        {
            if (options.subId) op.patchId.value = options.subId;
        };

        op.init = () =>
        {
            op.setStorage({ "subPatchVer": 2 });
        };

        op.loadDependencies = (p, next) =>
        {
            if (CABLES.UI)
            {
                gui.serverOps.loadProjectDependencies(p, () =>
                {
                    if (next)next();
                });
            }
            else
            if (next)next();
        };

        op.on("delete", () =>
        {
            if (op.patch.clearSubPatchCache)op.patch.clearSubPatchCache(this.patchId);
            const ops = op.patch.ops;
            for (let i = ops.length - 1; i >= 0; i--)
                if (ops[i] && ops[i].uiAttribs && ops[i].uiAttribs.subPatch == op.patchId.get())
                    op.patch.deleteOp(ops[i].id);
        });

        this._op.isExposableSubpatchOp = () =>
        {
            return true;
        };
    }

    get patchId()
    {
        return this._op.patchId.get();
    }
}

})();

var __webpack_export_target__ = (CABLES = typeof CABLES === "undefined" ? {} : CABLES);
for(var i in __webpack_exports__) __webpack_export_target__[i] = __webpack_exports__[i];
if(__webpack_exports__.__esModule) Object.defineProperty(__webpack_export_target__, "__esModule", { value: true });
/******/ })()
;// end js/subpatchop.js
// start js/cgl_copytexture.js
/******/ (() => { // webpackBootstrap
/******/ 	// runtime can't be in strict mode because a global variable is assign and maybe created.
/******/ 	// The require scope
/******/ 	var __webpack_require__ = {};
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  CopyTexture: () => (/* binding */ CopyTexture)
});

;// CONCATENATED MODULE: external "CABLES"
const external_CABLES_namespaceObject = CABLES;
;// CONCATENATED MODULE: external "CABLES.SHARED"
const external_CABLES_SHARED_namespaceObject = CABLES.SHARED;
;// CONCATENATED MODULE: ./src/corelibs/cg/cg_texture.js


const DEFAULT_TEXTURE_SIZE = 8;

/**
 * @typedef {Object} CglTextureOptions
 * @property {number} [width]
 * @property {number} [height]
 * @property {string} [pixelformat]
 */
class CgTexture
{

    /**
     * @param {CglTextureOptions} options={}
     */
    constructor(options = {})
    {
        this.id = external_CABLES_namespaceObject.utils.uuid();
        this.width = 0;
        this.height = 0;
        this.name = "unknown";

        options = options || {};
        this.pixelFormat = options.pixelFormat || CgTexture.PFORMATSTR_RGBA8UB;

        this.name = options.name || "unknown";

        if (!options.width) options.width = DEFAULT_TEXTURE_SIZE;
        if (!options.height) options.height = DEFAULT_TEXTURE_SIZE;
    }
}

CgTexture.getDefaultTextureData = (name, size, options = {}) =>
{
    if (name == "empty")
    {
        return new Uint8Array(size * size * 4).fill(0);
    }
    else
    if (name == "color")
    {
        const data = new Uint8Array(size * size * 4);
        let r = options.r || 1;
        let g = options.g || 1;
        let b = options.b || 1;

        for (let x = 0; x < size * size; x++)
        {
            data[x * 4 + 0] = r;
            data[x * 4 + 1] = g;
            data[x * 4 + 2] = b;
            data[x * 4 + 3] = 255;
        }
        return data;
    }
    else
    if (name == "randomUInt")
    {
        const data = new Uint8Array(size * size * 4);

        for (let x = 0; x < size * size; x++)
        {
            data[x * 4 + 0] = Math.random() * 255;
            data[x * 4 + 1] = Math.random() * 255;
            data[x * 4 + 2] = Math.random() * 255;
            data[x * 4 + 3] = 255;
        }
        return data;
    }
    else
    if (name == "random" || name == "randomFloat")
    {
        const data = new Float32Array(size * size * 4);

        for (let x = 0; x < size * size; x++)
        {
            data[x * 4 + 0] = (Math.random() - 0.5) * 2.0;
            data[x * 4 + 1] = (Math.random() - 0.5) * 2.0;
            data[x * 4 + 2] = (Math.random() - 0.5) * 2.0;
            data[x * 4 + 3] = 1;
        }
        return data;
    }
    else
    if (name == "stripes")
    {
        const arr = [];

        let r = options.r;
        let g = options.g;
        let b = options.b;

        if (r === undefined)r = 1;
        if (g === undefined)g = 1;
        if (b === undefined)b = 1;

        for (let y = 0; y < size; y++)
        {
            for (let x = 0; x < size; x++)
            {
                if ((x + y) % 64 < 32)
                {
                    arr.push((200 + (y / size) * 25 + (x / size) * 25) * r);
                    arr.push((200 + (y / size) * 25 + (x / size) * 25) * g);
                    arr.push((200 + (y / size) * 25 + (x / size) * 25) * b);
                }
                else
                {
                    arr.push((40 + (y / size) * 25 + (x / size) * 25) * r);
                    arr.push((40 + (y / size) * 25 + (x / size) * 25) * g);
                    arr.push((40 + (y / size) * 25 + (x / size) * 25) * b);
                }
                arr.push(255);
            }
        }

        return new Uint8Array(arr);
    }
    else
    {
        console.warn("unknown default texture", name);
        return CgTexture.getDefaultTextureData("stripes", size, { "r": 1, "g": 0, "b": 0 });
    }
};

CgTexture.FILTER_NEAREST = 0;
CgTexture.FILTER_LINEAR = 1;
CgTexture.FILTER_MIPMAP = 2;

CgTexture.WRAP_REPEAT = 0;
CgTexture.WRAP_MIRRORED_REPEAT = 1;
CgTexture.WRAP_CLAMP_TO_EDGE = 2;

CgTexture.TYPE_DEFAULT = 0;
CgTexture.TYPE_DEPTH = 1;
CgTexture.TYPE_FLOAT = 2;

CgTexture.PFORMATSTR_RGB565 = "RGB 5/6/5bit ubyte";

CgTexture.PFORMATSTR_R8UB = "R 8bit ubyte";
CgTexture.PFORMATSTR_RG8UB = "RG 8bit ubyte";
CgTexture.PFORMATSTR_RGB8UB = "RGB 8bit ubyte";
CgTexture.PFORMATSTR_RGBA8UB = "RGBA 8bit ubyte";

CgTexture.PFORMATSTR_SRGBA8 = "SRGBA 8bit ubyte";

CgTexture.PFORMATSTR_R11FG11FB10F = "RGB 11/11/10bit float";

CgTexture.PFORMATSTR_R16F = "R 16bit float";
CgTexture.PFORMATSTR_RG16F = "RG 16bit float";
CgTexture.PFORMATSTR_RGB16F = "RGB 16bit float";
CgTexture.PFORMATSTR_RGBA16F = "RGBA 16bit float";

CgTexture.PFORMATSTR_R32F = "R 32bit float";
CgTexture.PFORMATSTR_RG32F = "RG 32bit float";
CgTexture.PFORMATSTR_RGB32F = "RGB 32bit float";
CgTexture.PFORMATSTR_RGBA32F = "RGBA 32bit float";

CgTexture.PFORMATSTR_DEPTH = "DEPTH";

CgTexture.PIXELFORMATS = [

    CgTexture.PFORMATSTR_RGB565,

    CgTexture.PFORMATSTR_R8UB,
    CgTexture.PFORMATSTR_RG8UB,
    CgTexture.PFORMATSTR_RGB8UB,
    CgTexture.PFORMATSTR_RGBA8UB,

    CgTexture.PFORMATSTR_SRGBA8,

    CgTexture.PFORMATSTR_R11FG11FB10F,
    CgTexture.PFORMATSTR_R16F,
    CgTexture.PFORMATSTR_RG16F,
    CgTexture.PFORMATSTR_RGBA16F,

    CgTexture.PFORMATSTR_R32F,
    CgTexture.PFORMATSTR_RGBA32F

];

;// CONCATENATED MODULE: ./src/corelibs/cgl/cgl_texture.js





const cgl_texture_DEFAULT_TEXTURE_SIZE = 8;

const log = new external_CABLES_SHARED_namespaceObject.Logger("cgl_texture");

/**
 * A Texture
 * @namespace external:CGL
 * @class
 * @param {CglContext} __cgl cgl
 * @param {Object} options
 * @hideconstructor
 * @example
 * // generate a 256x256 pixel texture of random colors
 * const size=256;
 * const data = new Uint8Array(size*size*4);
 *
 * for(var x=0;x<size*size*4;x++) data[ x*4+3]=255;
 *
 * const tex=new CGL.Texture(cgl);
 * tex.initFromData(data,size,size,CGL.Texture.FILTER_NEAREST,CGL.Texture.WRAP_REPEAT);
 */
class Texture extends CgTexture
{

    /**
     * @param {CglContext} __cgl
     */
    constructor(__cgl, options = {})
    {
        super(options);
        if (!__cgl) throw new Error("no cgl");

        this._cgl = __cgl;
        this._log = new external_CABLES_SHARED_namespaceObject.Logger("tex");
        this.tex = this._cgl.gl.createTexture();
        this.loading = false;
        this.flip = true;
        this.flipped = false;
        this.shadowMap = false;
        this.deleted = false;
        this.image = null;
        this.anisotropic = 0;
        this.filter = Texture.FILTER_NEAREST;
        this.wrap = Texture.WRAP_CLAMP_TO_EDGE;
        this.texTarget = this._cgl.gl.TEXTURE_2D;
        if (options && options.type) this.texTarget = options.type;
        this.textureType = Texture.TYPE_DEFAULT;
        this.unpackAlpha = true;
        this._fromData = true;

        this._glDataType = -1;
        this._glInternalFormat = -1;
        this._glDataFormat = -1;

        if (options)
        {
            if (options.isDepthTexture) this.textureType = Texture.TYPE_DEPTH;
            if (options.isFloatingPointTexture === true) this.textureType = Texture.TYPE_FLOAT;

            if ("textureType" in options) this.textureType = options.textureType;
            if ("filter" in options) this.filter = options.filter;
            if ("wrap" in options) this.wrap = options.wrap;
            if ("unpackAlpha" in options) this.unpackAlpha = options.unpackAlpha;
            if ("flip" in options) this.flip = options.flip;
            if ("shadowMap" in options) this.shadowMap = options.shadowMap;
            if ("anisotropic" in options) this.anisotropic = options.anisotropic;
        }
        else
        {
            options = {};
        }

        if (!options.pixelFormat && options.isFloatingPointTexture) this.pixelFormat = Texture.PFORMATSTR_RGBA32F;

        if (this.textureType == Texture.TYPE_DEPTH) this.pixelFormat = Texture.PFORMATSTR_DEPTH;

        this._cgl.profileData.profileTextureNew++;

        this.setFormat(Texture.setUpGlPixelFormat(this._cgl, this.pixelFormat));
        this._cgl.profileData.addHeavyEvent("texture created", this.name, options.width + "x" + options.height);

        this.setSize(options.width, options.height);
        this.getInfoOneLine();
    }

    isFloatingPoint()
    {
        return Texture.isPixelFormatFloat(this.pixelFormat);
    }

    /**
     * returns true if otherTexture has same options (width/height/filter/wrap etc)
     * @function compareSettings
     * @memberof Texture
     * @instance
     * @param {Texture} tex otherTexture
     * @returns {Boolean}
     */
    compareSettings(tex)
    {
    // if (!tex) { this._log.warn("compare: no tex"); return false; }
    // if (tex.width != this.width) this._log.warn("tex.width not equal", tex.width, this.width);
    // if (tex.height != this.height) this._log.warn("tex.height not equal", tex.height, this.height);
    // if (tex.filter != this.filter) this._log.warn("tex.filter not equal");
    // if (tex.wrap != this.wrap) this._log.warn("tex.wrap not equal");
    // if (tex.textureType != this.textureType) this._log.warn("tex.textureType not equal");
    // if (tex.unpackAlpha != this.unpackAlpha) this._log.warn("tex.unpackAlpha not equal");
    // if (tex.anisotropic != this.anisotropic) this._log.warn("tex.anisotropic not equal");
    // if (tex.shadowMap != this.shadowMap) this._log.warn("tex.shadowMap not equal");
    // if (tex.texTarget != this.texTarget) this._log.warn("tex.texTarget not equal");
    // if (tex.flip != this.flip) this._log.warn("tex.flip not equal");

        if (!tex) return false;
        return (
            tex.width == this.width &&
            tex.height == this.height &&
            tex.filter == this.filter &&
            tex.wrap == this.wrap &&
            tex.textureType == this.textureType &&
            tex.unpackAlpha == this.unpackAlpha &&
            tex.anisotropic == this.anisotropic &&
            tex.shadowMap == this.shadowMap &&
            tex.texTarget == this.texTarget &&
            tex.flip == this.flip
        );
    }

    /**
     * returns a new texture with the same settings (does not copy texture itself)
     * @function clone
     * @memberof Texture
     * @instance
     * @returns {Texture}
     */
    clone()
    {
        const newTex = new Texture(this._cgl, {
            "name": this.name,
            "filter": this.filter,
            "anisotropic": this.anisotropic,
            "wrap": this.wrap,
            "textureType": this.textureType,
            "pixelFormat": this.pixelFormat,
            "unpackAlpha": this.unpackAlpha,
            "flip": this.flip,
            "width": this.width,
            "height": this.height,
        });

        this._cgl.profileData.addHeavyEvent("texture created", this.name, this.width + "x" + this.height);

        if (!this.compareSettings(newTex))
        {
            this._log.error("Cloned texture settings do not compare!");
            this._log.error(this);
            this._log.error(newTex);
        }

        return newTex;
    }

    /**
     * @param {object} o
     */
    setFormat(o)
    {
        this.pixelFormat = o.pixelFormat;
        this._glDataFormat = o.glDataFormat;
        this._glInternalFormat = o.glInternalFormat;
        this._glDataType = o.glDataType;
    }

    /**
     * set pixel size of texture
     * @function setSize
     * @memberof Texture
     * @instance
     * @param {Number} w width
     * @param {Number} h height
     */
    setSize(w, h)
    {
        if (this._cgl.aborted) return;
        if (w != w || w <= 0 || !w) w = cgl_texture_DEFAULT_TEXTURE_SIZE;
        if (h != h || h <= 0 || !h) h = cgl_texture_DEFAULT_TEXTURE_SIZE;

        if (w > this._cgl.maxTexSize || h > this._cgl.maxTexSize) this._log.error("texture size too big! " + w + "x" + h + " / max: " + this._cgl.maxTexSize);

        w = Math.min(w, this._cgl.maxTexSize);
        h = Math.min(h, this._cgl.maxTexSize);

        w = Math.floor(w);
        h = Math.floor(h);
        if (this.width == w && this.height == h) return;

        w = this._cgl.checkTextureSize(w);
        h = this._cgl.checkTextureSize(h);

        this.width = w;
        this.height = h;
        this.deleted = false;

        this.setFormat(Texture.setUpGlPixelFormat(this._cgl, this.pixelFormat));

        this.shortInfoString = this.getInfoOneLine();// w + "x" + h + "";

        this._cgl.gl.bindTexture(this.texTarget, this.tex);
        this._cgl.profileData.profileTextureResize++;

        const uarr = null;

        this._cgl.gl.texImage2D(this.texTarget, 0, this._glInternalFormat, w, h, 0, this._glDataFormat, this._glDataType, uarr);

        this._setFilter();

        this.updateMipMap();

        this._cgl.gl.bindTexture(this.texTarget, null);
    }

    /**
     * @function initFromData
     * @memberof Texture
     * @instance
     * @description create texturem from rgb data
     * @param {Array<Number>} data rgb color array [r,g,b,a,r,g,b,a,...]
     * @param {Number} w width
     * @param {Number} h height
     * @param {Number} filter
     * @param {Number} wrap
     */
    initFromData(data, w, h, filter, wrap)
    {
        this.filter = filter;
        this.wrap = wrap;
        if (filter == undefined) this.filter = Texture.FILTER_LINEAR;
        if (wrap == undefined) this.wrap = Texture.WRAP_CLAMP_TO_EDGE;
        this.width = w;
        this.height = h;
        this._fromData = true;
        this.deleted = false;

        if (this.height > this._cgl.maxTexSize || this.width > this._cgl.maxTexSize)
        {
            const t = CGL.Texture.getTempTexture(this._cgl);
            this.width = t.width;
            this.height = t.height;
            this.tex = t.tex;
            this._log.warn("[cgl_texture] texture size too big!", this.width, this.height, this._cgl.maxTexSize);
            return;
        }

        if (this.flip) this._cgl.gl.pixelStorei(this._cgl.gl.UNPACK_FLIP_Y_WEBGL, this.flip);

        this._cgl.gl.bindTexture(this.texTarget, this.tex);

        this.setFormat(Texture.setUpGlPixelFormat(this._cgl, this.pixelFormat));

        this._cgl.gl.texImage2D(this.texTarget, 0, this._glInternalFormat, w, h, 0, this._glDataFormat, this._glDataType, data);

        this._setFilter();
        this.updateMipMap();

        if (this.flip) this._cgl.gl.pixelStorei(this._cgl.gl.UNPACK_FLIP_Y_WEBGL, false);
        this._cgl.gl.bindTexture(this.texTarget, null);
    }

    updateMipMap()
    {
        if ((this._cgl.glVersion == 2 || this.isPowerOfTwo()) && this.filter == Texture.FILTER_MIPMAP)
        {
            this._cgl.gl.generateMipmap(this.texTarget);
            this._cgl.profileData.profileGenMipMap++;
        }
    }

    /**
     * set texture data from an image/canvas object
     * @function initTexture
     * @memberof Texture
     * @instance
     * @param {Object} img image
     * @param {Number} filter
     */
    initTexture(img, filter = null)
    {
        this._cgl.printError("before initTexture");
        this._cgl.checkFrameStarted("texture inittexture");
        this._fromData = false;

        this._cgl.gl.pixelStorei(this._cgl.gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, this.unpackAlpha);
        if (img.width || img.videoWidth) this.width = img.videoWidth || img.width;
        if (img.height || img.videoHeight) this.height = img.videoHeight || img.height;

        if (filter !== null) this.filter = filter; // todo: can we remove this filter param?

        if (img.height > this._cgl.maxTexSize || img.width > this._cgl.maxTexSize)
        {
            const t = CGL.Texture.getTempTexture(this._cgl);
            this.width = t.width;
            this.height = t.height;
            this.tex = t.tex;
            this._log.warn("[cgl_texture] texture size too big!", img.width, img.height, this._cgl.maxTexSize);
            return;
        }

        this._cgl.gl.bindTexture(this.texTarget, this.tex);

        this.deleted = false;
        this.flipped = !this.flip;
        if (this.flipped) this._cgl.gl.pixelStorei(this._cgl.gl.UNPACK_FLIP_Y_WEBGL, this.flipped);

        this.setFormat(Texture.setUpGlPixelFormat(this._cgl, this.pixelFormat));

        this._cgl.gl.texImage2D(this.texTarget, 0, this._glInternalFormat, this._glDataFormat, this._glDataType, img);

        this._setFilter();
        this.updateMipMap();

        this._cgl.gl.bindTexture(this.texTarget, null);
        this._cgl.gl.pixelStorei(this._cgl.gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
        if (this.flipped) this._cgl.gl.pixelStorei(this._cgl.gl.UNPACK_FLIP_Y_WEBGL, false);

        this.getInfoOneLine();
        this._cgl.printError("initTexture");
    }

    /**
     * delete texture. use this when texture is no longer needed
     * @function delete
     * @memberof Texture
     * @instance
     */
    dispose()
    {
        this.delete();
    }

    delete()
    {
        if (this.loading)
        {
            // cant delete texture when still loading
            // setTimeout(this.delete.bind(this), 50);
            return;
        }

        this.deleted = true;
        this.width = 0;
        this.height = 0;
        this._cgl.profileData.profileTextureDelete++;
        this._cgl.gl.deleteTexture(this.tex);
        this.image = null;

        this.tex = null;
    }

    /**
     * @function isPowerOfTwo
     * @memberof Texture
     * @instance
     * @description return true if texture width and height are both power of two
     * @return {Boolean}
     */
    isPowerOfTwo()
    {
        return Texture.isPowerOfTwo(this.width) && Texture.isPowerOfTwo(this.height);
    }

    printInfo()
    {
        log.log(this.getInfo());
    }

    getInfoReadable()
    {
        const info = this.getInfo();
        let html = "";

        info.name = info.name.substr(0, info.name.indexOf("?rnd="));

        for (const i in info)
        {
            html += "* " + i + ":  **" + info[i] + "**\n";
        }

        return html;
    }

    getInfoOneLine()
    {
        let txt = "" + this.width + "x" + this.height;
        txt += " ";
        // if (this.textureType === CGL.Texture.TYPE_FLOAT) txt += " 32bit"; else txt += " 8bit";
        // if (this.textureType === CGL.Texture.TYPE_FLOAT) txt += " 32bit"; else txt += " 8bit";
        txt += this.pixelFormat;

        if (this.filter === Texture.FILTER_NEAREST) txt += " nearest";
        if (this.filter === Texture.FILTER_LINEAR) txt += " linear";
        if (this.filter === Texture.FILTER_MIPMAP) txt += " mipmap";

        if (this.wrap === Texture.WRAP_CLAMP_TO_EDGE) txt += " clamp";
        if (this.wrap === Texture.WRAP_REPEAT) txt += " repeat";
        if (this.wrap === Texture.WRAP_MIRRORED_REPEAT) txt += " repeatmir";

        this.shortInfoString = txt;

        return txt;
    }

    getInfoOneLineShort()
    {
        let txt = "" + this.width + "x" + this.height;
        // if (this.textureType === CGL.Texture.TYPE_FLOAT) txt += " 32bit"; else txt += " 8bit";
        txt += " ";
        txt += this.pixelFormat;

        this.shortInfoString = txt;

        return txt;
    }

    getInfo()
    {
        return Texture.getTexInfo(this);
    }

    _setFilter()
    {
        this._cgl.printError("before _setFilter");

        if (!this._fromData)
        {
            this._cgl.gl.pixelStorei(this._cgl.gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, this.unpackAlpha);
        }

        if (this.shadowMap)
        {
            this._cgl.gl.texParameteri(this._cgl.gl.TEXTURE_2D, this._cgl.gl.TEXTURE_COMPARE_MODE, this._cgl.gl.COMPARE_REF_TO_TEXTURE);
            this._cgl.gl.texParameteri(this._cgl.gl.TEXTURE_2D, this._cgl.gl.TEXTURE_COMPARE_FUNC, this._cgl.gl.LEQUAL);
        }

        if (this.textureType == Texture.TYPE_FLOAT && this.filter == Texture.FILTER_MIPMAP)
        {
            this.filter = Texture.FILTER_LINEAR;
            this._log.stack("texture: HDR and mipmap filtering at the same time is not possible");
        }

        if (this._cgl.glVersion == 1 && !this.isPowerOfTwo())
        {
            this._cgl.gl.texParameteri(this.texTarget, this._cgl.gl.TEXTURE_MAG_FILTER, this._cgl.gl.NEAREST);
            this._cgl.gl.texParameteri(this.texTarget, this._cgl.gl.TEXTURE_MIN_FILTER, this._cgl.gl.NEAREST);

            this._cgl.gl.texParameteri(this.texTarget, this._cgl.gl.TEXTURE_WRAP_S, this._cgl.gl.CLAMP_TO_EDGE);
            this._cgl.gl.texParameteri(this.texTarget, this._cgl.gl.TEXTURE_WRAP_T, this._cgl.gl.CLAMP_TO_EDGE);

            this.filter = Texture.FILTER_NEAREST;
            this.wrap = Texture.WRAP_CLAMP_TO_EDGE;
        }
        else
        {
            if (this.wrap == Texture.WRAP_CLAMP_TO_EDGE)
            {
                this._cgl.gl.texParameteri(this.texTarget, this._cgl.gl.TEXTURE_WRAP_S, this._cgl.gl.CLAMP_TO_EDGE);
                this._cgl.gl.texParameteri(this.texTarget, this._cgl.gl.TEXTURE_WRAP_T, this._cgl.gl.CLAMP_TO_EDGE);
            }
            else if (this.wrap == Texture.WRAP_REPEAT)
            {
                this._cgl.gl.texParameteri(this.texTarget, this._cgl.gl.TEXTURE_WRAP_S, this._cgl.gl.REPEAT);
                this._cgl.gl.texParameteri(this.texTarget, this._cgl.gl.TEXTURE_WRAP_T, this._cgl.gl.REPEAT);
            }
            else if (this.wrap == Texture.WRAP_MIRRORED_REPEAT)
            {
                this._cgl.gl.texParameteri(this.texTarget, this._cgl.gl.TEXTURE_WRAP_S, this._cgl.gl.MIRRORED_REPEAT);
                this._cgl.gl.texParameteri(this.texTarget, this._cgl.gl.TEXTURE_WRAP_T, this._cgl.gl.MIRRORED_REPEAT);
            }

            if (this.filter == Texture.FILTER_NEAREST)
            {
                this._cgl.gl.texParameteri(this.texTarget, this._cgl.gl.TEXTURE_MAG_FILTER, this._cgl.gl.NEAREST);
                this._cgl.gl.texParameteri(this.texTarget, this._cgl.gl.TEXTURE_MIN_FILTER, this._cgl.gl.NEAREST);
            }
            else if (this.filter == Texture.FILTER_LINEAR)
            {
                this._cgl.gl.texParameteri(this.texTarget, this._cgl.gl.TEXTURE_MIN_FILTER, this._cgl.gl.LINEAR);
                this._cgl.gl.texParameteri(this.texTarget, this._cgl.gl.TEXTURE_MAG_FILTER, this._cgl.gl.LINEAR);
            }
            else if (this.filter == Texture.FILTER_MIPMAP)
            {
                this._cgl.gl.texParameteri(this.texTarget, this._cgl.gl.TEXTURE_MAG_FILTER, this._cgl.gl.LINEAR);
                this._cgl.gl.texParameteri(this.texTarget, this._cgl.gl.TEXTURE_MIN_FILTER, this._cgl.gl.LINEAR_MIPMAP_LINEAR);
            }
            else
            {
                this._log.log("unknown texture filter!", this.filter);
                throw new Error("unknown texture filter!" + this.filter);
            }

            if (this.anisotropic)
            {
                const ext = this._cgl.enableExtension("EXT_texture_filter_anisotropic");

                if (this._cgl.maxAnisotropic)
                {
                    const aniso = Math.min(this._cgl.maxAnisotropic, this.anisotropic);
                    this._cgl.gl.texParameterf(this._cgl.gl.TEXTURE_2D, ext.TEXTURE_MAX_ANISOTROPY_EXT, aniso);
                }
            }
        }
        this.getInfoOneLine();
        this._cgl.printError("_setFilter");
    }
}

/**
 * @function load
 * @static
 * @memberof Texture
 * @description load an image from an url
 * @param {CglContext} cgl
 * @param {String} url
 * @param {Function} finishedCallback
 * @param {Object} settings
 * @return {Texture}
 */
Texture.load = function (cgl, url, finishedCallback, settings)
{
    if (!url) return finishedCallback({ "error": true });
    let loadingId = null;
    if (!cgl.patch.loading.existByName(url)) loadingId = cgl.patch.loading.start("cgl.texture", url);

    const texture = new Texture(cgl);
    texture.name = url;

    texture.image = new Image();
    texture.image.crossOrigin = "anonymous";
    texture.loading = true;

    if (settings && settings.hasOwnProperty("filter")) texture.filter = settings.filter;
    if (settings && settings.hasOwnProperty("flip")) texture.flip = settings.flip;
    if (settings && settings.hasOwnProperty("wrap")) texture.wrap = settings.wrap;
    if (settings && settings.hasOwnProperty("anisotropic")) texture.anisotropic = settings.anisotropic;
    if (settings && settings.hasOwnProperty("unpackAlpha")) texture.unpackAlpha = settings.unpackAlpha;
    if (settings && settings.hasOwnProperty("pixelFormat")) texture.pixelFormat = settings.pixelFormat;

    texture.image.onabort = texture.image.onerror = (e) =>
    {
        console.warn("[cgl.texture.load] error loading texture", url, e);
        texture.loading = false;
        if (loadingId) cgl.patch.loading.finished(loadingId);
        const error = { "error": true };
        if (finishedCallback) finishedCallback(error, texture);
    };

    texture.image.onload = function (e)
    {
        cgl.addNextFrameOnceCallback(() =>
        {
            texture.initTexture(texture.image);
            if (loadingId) cgl.patch.loading.finished(loadingId);
            texture.loading = false;

            if (finishedCallback) finishedCallback(null, texture);
        });
    };
    texture.image.src = url;

    return texture;
};

/**
 * @static
 * @function getTempTexture
 * @memberof Texture
 * @description returns the default temporary texture (grey diagonal stipes)
 // * @param {CglContext} cgl
 * @return {Texture}
 */
Texture.getTempTexture = function (cgl)
{
    if (!cgl) console.error("[getTempTexture] no cgl!");
    if (!cgl.tempTexture) cgl.tempTexture = Texture.getTemporaryTexture(cgl, 256, Texture.FILTER_LINEAR, Texture.REPEAT);
    return cgl.tempTexture;
};

/**
 * @static
 * @function getErrorTexture
 * @memberof Texture
 * @description returns the default temporary texture (grey diagonal stipes)
 * @param {CglContext} cgl
 * @return {Texture}
 */
Texture.getErrorTexture = function (cgl)
{
    if (!cgl) console.error("[getTempTexture] no cgl!");
    if (!cgl.errorTexture) cgl.errorTexture = Texture.getTemporaryTexture(cgl, 256, Texture.FILTER_LINEAR, Texture.REPEAT, 1, 0.2, 0.2);
    return cgl.errorTexture;
};

/**
 * @function getEmptyTexture
 * @memberof Texture
 * @instance
 * @param cgl
 * @param fp
 * @description returns a reference to a small empty (transparent) texture
 * @return {Texture}
 */
Texture.getEmptyTexture = function (cgl, fp)
{
    if (fp) return Texture.getEmptyTextureFloat(cgl);
    if (!cgl) console.error("[getEmptyTexture] no cgl!");
    if (cgl.tempTextureEmpty) return cgl.tempTextureEmpty;

    let size = 8;

    cgl.tempTextureEmpty = new Texture(cgl, { "name": "emptyTexture" });
    const data = Texture.getDefaultTextureData("empty", size);

    cgl.tempTextureEmpty.initFromData(data, size, size, Texture.FILTER_NEAREST, Texture.WRAP_REPEAT);

    return cgl.tempTextureEmpty;
};

/**
 * @function getEmptyTextureFloat
 * @memberof Texture
 * @instance
 * @param cgl
 * @description returns a reference to a small empty (transparent) 32bit texture
 * @return {Texture}
 */
Texture.getEmptyTextureFloat = function (cgl)
{
    if (!cgl) console.error("[getEmptyTextureFloat] no cgl!");
    if (cgl.tempTextureEmptyFloat) return cgl.tempTextureEmptyFloat;

    cgl.tempTextureEmptyFloat = new Texture(cgl, { "name": "emptyTexture", "isFloatingPointTexture": true });
    const data = new Float32Array(8 * 8 * 4).fill(1);
    for (let i = 0; i < 8 * 8 * 4; i += 4) data[i + 3] = 0;

    cgl.tempTextureEmptyFloat.initFromData(data, 8, 8, Texture.FILTER_NEAREST, Texture.WRAP_REPEAT);

    return cgl.tempTextureEmptyFloat;
};

/**
 * @function getRandomTexture
 * @memberof Texture
 * @static
 * @param cgl
 * @description returns a reference to a random texture
 * @return {Texture}
 */
Texture.getRandomTexture = function (cgl)
{
    if (!cgl) console.error("[getRandomTexture] no cgl!");
    if (cgl.randomTexture) return cgl.randomTexture;

    const size = 256;
    const data = Texture.getDefaultTextureData("randomUInt", size);

    cgl.randomTexture = new Texture(cgl);
    cgl.randomTexture.initFromData(data, size, size, Texture.FILTER_NEAREST, Texture.WRAP_REPEAT);

    return cgl.randomTexture;
};

/**
 * @function getRandomFloatTexture
 * @memberof Texture
 * @static
 * @param cgl
 * @description returns a reference to a texture containing random numbers between -1 and 1
 * @return {Texture}
 */
Texture.getRandomFloatTexture = function (cgl)
{
    if (!cgl) console.error("[getRandomTexture] no cgl!");
    if (cgl.getRandomFloatTexture) return cgl.getRandomFloatTexture;

    const size = 256;
    const data = Texture.getDefaultTextureData("randomFloat", size);

    cgl.getRandomFloatTexture = new Texture(cgl, { "isFloatingPointTexture": true });
    cgl.getRandomFloatTexture.initFromData(data, size, size, Texture.FILTER_NEAREST, Texture.WRAP_REPEAT);

    return cgl.getRandomFloatTexture;
};

/**
 * @function getBlackTexture
 * @memberof Texture
 * @static
 * @param {CglContext} cgl
 * @description returns a reference to a black texture
 * @return {Texture}
 */
Texture.getBlackTexture = function (cgl)
{
    if (cgl.blackTexture) return cgl.blackTexture;

    const size = 8;
    const data = Texture.getDefaultTextureData("color", size, { "r": 0, "g": 0, "b": 0 });

    cgl.blackTexture = new Texture(cgl);
    cgl.blackTexture.initFromData(data, size, size, Texture.FILTER_NEAREST, Texture.WRAP_REPEAT);

    return cgl.blackTexture;
};

/**
 * @function getEmptyCubemapTexture
 * @memberof Texture
 * @static
 * @param cgl
 * @description returns an empty cubemap texture with rgba = [0, 0, 0, 0]
 * @return {Texture}
 */
Texture.getEmptyCubemapTexture = function (cgl)
{
    const faces = [
        cgl.gl.TEXTURE_CUBE_MAP_POSITIVE_X,
        cgl.gl.TEXTURE_CUBE_MAP_NEGATIVE_X,
        cgl.gl.TEXTURE_CUBE_MAP_POSITIVE_Y,
        cgl.gl.TEXTURE_CUBE_MAP_NEGATIVE_Y,
        cgl.gl.TEXTURE_CUBE_MAP_POSITIVE_Z,
        cgl.gl.TEXTURE_CUBE_MAP_NEGATIVE_Z
    ];

    const tex = cgl.gl.createTexture();
    const target = cgl.gl.TEXTURE_CUBE_MAP;
    const filter = Texture.FILTER_NEAREST;
    const wrap = Texture.WRAP_CLAMP_TO_EDGE;
    const width = 8;
    const height = 8;

    cgl.profileData.profileTextureNew++;

    cgl.gl.bindTexture(target, tex);
    cgl.profileData.profileTextureResize++;

    for (let i = 0; i < 6; i += 1)
    {
        const data = new Uint8Array(8 * 8 * 4);

        cgl.gl.texImage2D(faces[i], 0, cgl.gl.RGBA, 8, 8, 0, cgl.gl.RGBA, cgl.gl.UNSIGNED_BYTE, data);
        cgl.gl.texParameteri(target, cgl.gl.TEXTURE_MAG_FILTER, cgl.gl.NEAREST);
        cgl.gl.texParameteri(target, cgl.gl.TEXTURE_MIN_FILTER, cgl.gl.NEAREST);

        cgl.gl.texParameteri(target, cgl.gl.TEXTURE_WRAP_S, cgl.gl.CLAMP_TO_EDGE);
        cgl.gl.texParameteri(target, cgl.gl.TEXTURE_WRAP_T, cgl.gl.CLAMP_TO_EDGE);
    }

    cgl.gl.bindTexture(target, null);

    return {
        "id": external_CABLES_namespaceObject.utils.uuid(),
        "tex": tex,
        "cubemap": tex,
        "width": width,
        "height": height,
        "filter": filter,
        "wrap": wrap,
        "unpackAlpha": true,
        "flip": true,
        "_fromData": true,
        "name": "emptyCubemapTexture",
        "anisotropic": 0,
    };
};

Texture.getTempGradientTexture = function (cgl) // deprecated...
{
    if (!cgl) console.error("[getTempGradientTexture] no cgl!");
    return Texture.getTempTexture(cgl);
};

Texture.getTemporaryTexture = function (cgl, size, filter, wrap, r, g, b)
{
    const data = Texture.getDefaultTextureData("stripes", 256, { "r": r, "g": g, "b": b });
    const temptex = new Texture(cgl);
    temptex.initFromData(data, size, size, filter, wrap);
    return temptex;
};

/**
 * @static
 * @function createFromImage
 * @memberof Texture
 * @description create texturem from image data (e.g. image or canvas)
 * @param {CglContext} cgl
 * @param {Object} img image
 * @param {Object} options
 */
Texture.createFromImage = function (cgl, img, options)
{
    options = options || {};
    const texture = new Texture(cgl, options);
    texture.flip = false;
    texture.image = img;
    texture.width = img.videoWidth || img.width || 8;
    texture.height = img.videoHeight || img.height || 8;
    if (options.hasOwnProperty("wrap"))texture.wrap = options.wrap;

    texture.initTexture(img, options.filter);

    return texture;
};

// deprecated!
Texture.fromImage = function (cgl, img, filter, wrap)
{
    console.error("deprecated texture from image...");

    const texture = new Texture(cgl);
    texture.flip = false;
    if (filter) texture.filter = filter;
    if (wrap) texture.wrap = wrap;
    texture.image = img;
    texture.initTexture(img);
    return texture;
};

/**
 * @static
 * @function isPowerOfTwo
 * @memberof Texture
 * @description returns true if x is power of two
 * @param {Number} x
 * @return {Boolean}
 */
Texture.isPowerOfTwo = function (x)
{
    return x == 1 || x == 2 || x == 4 || x == 8 || x == 16 || x == 32 || x == 64 || x == 128 || x == 256 || x == 512 || x == 1024 || x == 2048 || x == 4096 || x == 8192 || x == 16384;
};

Texture.getTexInfo = function (tex)
{
    const obj = {};

    obj.name = tex.name;
    obj["power of two"] = tex.isPowerOfTwo();
    obj.size = tex.width + " x " + tex.height;

    let targetString = tex.texTarget;
    if (tex.texTarget == tex._cgl.gl.TEXTURE_2D) targetString = "TEXTURE_2D";
    obj.target = targetString;

    obj.unpackAlpha = tex.unpackAlpha;

    if (tex.cubemap)obj.cubemap = true;

    if (tex.textureType == Texture.TYPE_FLOAT) obj.textureType = "TYPE_FLOAT";
    if (tex.textureType == Texture.TYPE_HALF_FLOAT) obj.textureType = "TYPE_HALF_FLOAT";
    else if (tex.textureType == Texture.TYPE_DEPTH) obj.textureType = "TYPE_DEPTH";
    else if (tex.textureType == Texture.TYPE_DEFAULT) obj.textureType = "TYPE_DEFAULT";
    else obj.textureType = "UNKNOWN " + this.textureType;

    if (tex.wrap == Texture.WRAP_CLAMP_TO_EDGE) obj.wrap = "CLAMP_TO_EDGE";
    else if (tex.wrap == Texture.WRAP_REPEAT) obj.wrap = "WRAP_REPEAT";
    else if (tex.wrap == Texture.WRAP_MIRRORED_REPEAT) obj.wrap = "WRAP_MIRRORED_REPEAT";
    else obj.wrap = "UNKNOWN";

    if (tex.filter == Texture.FILTER_NEAREST) obj.filter = "FILTER_NEAREST";
    else if (tex.filter == Texture.FILTER_LINEAR) obj.filter = "FILTER_LINEAR";
    else if (tex.filter == Texture.FILTER_MIPMAP) obj.filter = "FILTER_MIPMAP";
    else obj.filter = "UNKNOWN";

    obj.pixelFormat = tex.pixelFormat || "unknown";

    return obj;
};

Texture.setUpGlPixelFormat = function (cgl, pixelFormatStr)
{
    const o = {};

    if (!pixelFormatStr)
    {
        cgl._log.error("no pixelformatstr!");
        cgl._log.log(new Error());
        pixelFormatStr = Texture.PFORMATSTR_RGBA8UB;
    }

    o.pixelFormatBase = pixelFormatStr;
    o.pixelFormat = pixelFormatStr;
    o.glDataType = cgl.gl.UNSIGNED_BYTE;
    o.glInternalFormat = cgl.gl.RGBA8;
    o.glDataFormat = cgl.gl.RGBA;

    let floatDatatype = cgl.gl.FLOAT;

    if (cgl.glUseHalfFloatTex)
    {
        if (pixelFormatStr == Texture.PFORMATSTR_RGBA32F) pixelFormatStr = Texture.PFORMATSTR_RGBA16F;
        if (pixelFormatStr == Texture.PFORMATSTR_RG32F) pixelFormatStr = Texture.PFORMATSTR_RG16F;
        if (pixelFormatStr == Texture.PFORMATSTR_R32F) pixelFormatStr = Texture.PFORMATSTR_R16F;
    }

    if (pixelFormatStr.includes("16bit"))
    {
        if (cgl.glVersion == 2)
        {
            // cgl.enableExtension("OES_texture_half_float");
            const hasExt = cgl.enableExtension("EXT_color_buffer_half_float");

            if (!hasExt)
            {
                console.warn("no 16bit extension, fallback to 32bit", pixelFormatStr);
                // fallback to 32 bit?
                if (pixelFormatStr == Texture.PFORMATSTR_RGBA16F) pixelFormatStr = Texture.PFORMATSTR_RGBA32F;
                if (pixelFormatStr == Texture.PFORMATSTR_RGB16F) pixelFormatStr = Texture.PFORMATSTR_RGB32F;
                if (pixelFormatStr == Texture.PFORMATSTR_RG16F) pixelFormatStr = Texture.PFORMATSTR_RG32F;
                if (pixelFormatStr == Texture.PFORMATSTR_R16F) pixelFormatStr = Texture.PFORMATSTR_R32F;
            }
            else
            {
                floatDatatype = cgl.gl.HALF_FLOAT;
            }
        }
    }

    if (cgl.glVersion == 1)
    {
        o.glInternalFormat = cgl.gl.RGBA;

        if (pixelFormatStr == Texture.PFORMATSTR_RGBA16F || pixelFormatStr == Texture.PFORMATSTR_RG16F || pixelFormatStr == Texture.PFORMATSTR_R16F)
        {
            const ext = cgl.enableExtension("OES_texture_half_float");
            if (!ext) throw new Error("no half float texture extension");

            floatDatatype = ext.HALF_FLOAT_OES;
        }
    }

    if (pixelFormatStr == Texture.PFORMATSTR_RGBA8UB)
    {
    }
    else if (pixelFormatStr == Texture.PFORMATSTR_RGB565)
    {
        o.glInternalFormat = cgl.gl.RGB565;
        o.glDataFormat = cgl.gl.RGB;
    }
    else if (pixelFormatStr == Texture.PFORMATSTR_R8UB)
    {
        o.glInternalFormat = cgl.gl.R8;
        o.glDataFormat = cgl.gl.RED;
    }
    else if (pixelFormatStr == Texture.PFORMATSTR_RG8UB)
    {
        o.glInternalFormat = cgl.gl.RG8;
        o.glDataFormat = cgl.gl.RG;
    }
    else if (pixelFormatStr == Texture.PFORMATSTR_RGB8UB)
    {
        o.glInternalFormat = cgl.gl.RGB8;
        o.glDataFormat = cgl.gl.RGB;
    }
    else if (pixelFormatStr == Texture.PFORMATSTR_SRGBA8)
    {
        o.glInternalFormat = cgl.gl.SRGB8_ALPHA8;
    }

    else if (pixelFormatStr == Texture.PFORMATSTR_R32F)
    {
        o.glInternalFormat = cgl.gl.R32F;
        o.glDataFormat = cgl.gl.RED;
        o.glDataType = floatDatatype;
    }
    else if (pixelFormatStr == Texture.PFORMATSTR_R16F)
    {
        o.glInternalFormat = cgl.gl.R16F;
        o.glDataType = floatDatatype;
        o.glDataFormat = cgl.gl.RED;
    }
    else if (pixelFormatStr == Texture.PFORMATSTR_RG16F)
    {
        o.glInternalFormat = cgl.gl.RG16F;
        o.glDataType = floatDatatype;
        o.glDataFormat = cgl.gl.RG;
    }
    else if (pixelFormatStr == Texture.PFORMATSTR_RGBA16F)
    {
        if (cgl.glVersion == 1) o.glInternalFormat = cgl.gl.RGBA;
        else o.glInternalFormat = cgl.gl.RGBA16F;
        o.glDataType = floatDatatype;
    }
    else if (pixelFormatStr == Texture.PFORMATSTR_R11FG11FB10F)
    {
        o.glInternalFormat = cgl.gl.R11F_G11F_B10F;
        o.glDataType = floatDatatype;
        o.glDataFormat = cgl.gl.RGB;
    }
    else if (pixelFormatStr == Texture.PFORMATSTR_RGBA32F)
    {
        if (cgl.glVersion == 1) o.glInternalFormat = cgl.gl.RGBA;
        else o.glInternalFormat = cgl.gl.RGBA32F;
        o.glDataType = floatDatatype;
    }
    else if (pixelFormatStr == Texture.PFORMATSTR_DEPTH)
    {
        if (cgl.glVersion == 1)
        {
            o.glInternalFormat = cgl.gl.DEPTH_COMPONENT;
            o.glDataType = cgl.gl.UNSIGNED_SHORT;
            o.glDataFormat = cgl.gl.DEPTH_COMPONENT;
        }
        else
        {
            o.glInternalFormat = cgl.gl.DEPTH_COMPONENT32F;
            o.glDataType = cgl.gl.FLOAT;
            o.glDataFormat = cgl.gl.DEPTH_COMPONENT;
        }
    }
    else
    {
        log.log("unknown pixelformat ", pixelFormatStr);
    }

    /// //////

    if (pixelFormatStr.includes("32bit") || pixelFormatStr == Texture.PFORMATSTR_R11FG11FB10F)
    {
        if (cgl.glVersion == 2) cgl.enableExtension("EXT_color_buffer_float");
        if (cgl.glVersion == 2) cgl.enableExtension("EXT_float_blend");

        cgl.enableExtension("OES_texture_float_linear"); // yes, i am sure, this is a webgl 1 and 2 ext
    }

    o.numColorChannels = Texture.getPixelFormatNumChannels(pixelFormatStr);

    if (!o.glDataType || !o.glInternalFormat || !o.glDataFormat) log.log("pixelformat wrong ?!", pixelFormatStr, o.glDataType, o.glInternalFormat, o.glDataFormat, this);

    return o;
};

Texture.getPixelFormatNumChannels =
    (pxlFrmtStr) =>
    {
        if (pxlFrmtStr.startsWith("RGBA")) return 4;
        if (pxlFrmtStr.startsWith("RGB")) return 3;
        if (pxlFrmtStr.startsWith("RG")) return 2;
        return 1;
    };

Texture.isPixelFormatFloat =
    (pxlFrmtStr) =>
    {
        return (pxlFrmtStr || "").includes("float");
    };

Texture.isPixelFormatHalfFloat =
    (pxlFrmtStr) =>
    {
        return (pxlFrmtStr || "").includes("float") && (pxlFrmtStr || "").includes("16bit");
    };

;// CONCATENATED MODULE: ./src/corelibs/cgl/cgl_framebuffer2.js




class Framebuffer2
{

    /**
     * @param {CglContext} cgl
     * @param {number} w
     * @param {number} h
     * @param {object} options
     */
    constructor(cgl, w, h, options)
    {
        this._log = new external_CABLES_SHARED_namespaceObject.Logger("cgl_framebuffer2");
        if (cgl.glVersion == 1) this._log.error("framebuffer2 used on webgl1");
        this.Framebuffer2DrawTargetsDefault = null;
        this.Framebuffer2BlittingFramebuffer = null;
        this.Framebuffer2FinalFramebuffer = null;
        this._cgl = cgl;

        this._cgl.printError("before framebuffer2 constructor");

        this._width = 0;
        this._height = 0;
        this.valid = true;

        this._depthRenderbuffer = null;
        this._frameBuffer = null;
        this._textureFrameBuffer = null;
        this._colorRenderbuffers = [];
        this._drawTargetArray = [];
        this._disposed = false;

        if (!this.Framebuffer2BlittingFramebuffer) this.Framebuffer2BlittingFramebuffer = cgl.gl.createFramebuffer();
        if (!this.Framebuffer2FinalFramebuffer) this.Framebuffer2FinalFramebuffer = cgl.gl.createFramebuffer();

        if (!this.Framebuffer2DrawTargetsDefault) this.Framebuffer2DrawTargetsDefault = [cgl.gl.COLOR_ATTACHMENT0];

        this._options = options || {
            "isFloatingPointTexture": false,
        };

        this.name = this._options.name || "unknown";

        this._cgl.profileData.addHeavyEvent("framebuffer create", this.name);

        if (!this._options.hasOwnProperty("numRenderBuffers")) this._options.numRenderBuffers = 1;
        if (!this._options.hasOwnProperty("depth")) this._options.depth = true;
        if (!this._options.hasOwnProperty("clear")) this._options.clear = true;
        if (!this._options.hasOwnProperty("multisampling"))
        {
            this._options.multisampling = false;
            this._options.multisamplingSamples = 0;
        }

        if (this._options.multisamplingSamples)
        {
            if (this._cgl.glSlowRenderer) this._options.multisamplingSamples = 0;
            if (!this._cgl.gl.MAX_SAMPLES) this._options.multisamplingSamples = 0;
            else this._options.multisamplingSamples = Math.min(this._cgl.maxSamples, this._options.multisamplingSamples);
        }

        if (!this._options.hasOwnProperty("filter")) this._options.filter = Texture.FILTER_LINEAR;
        if (!this._options.hasOwnProperty("wrap")) this._options.wrap = Texture.WRAP_REPEAT;

        this._numRenderBuffers = this._options.numRenderBuffers;
        this._colorTextures = [];

        this.clearColors = [];
        for (let i = 0; i < this._numRenderBuffers; i++) this.clearColors.push([0, 0, 0, 1]);

        if (!options.pixelFormat)
        {
            if (options.isFloatingPointTexture) this._options.pixelFormat = Texture.PFORMATSTR_RGBA32F;
            else this._options.pixelFormat = Texture.PFORMATSTR_RGBA8UB;
        }

        for (let i = 0; i < this._numRenderBuffers; i++)
        {
            this._colorTextures[i] = new Texture(cgl, {
                "name": "fb2 " + this.name + " " + i,
                "isFloatingPointTexture": this._options.isFloatingPointTexture,
                "anisotropic": this._options.anisotropic || 0,
                "pixelFormat": this._options.pixelFormat,
                "filter": this._options.filter,
                "wrap": this._options.wrap,
            });
        }

        let fil = Texture.FILTER_NEAREST;
        if (this._options.shadowMap) fil = Texture.FILTER_LINEAR;

        const defaultTexSize = 512;

        if (this._options.depth)
        {
            this._textureDepth = new Texture(cgl,
                {
                    "name": "fb2 depth " + this.name,
                    "isDepthTexture": true,
                    "filter": fil,
                    "shadowMap": this._options.shadowMap || false,
                    "width": w || defaultTexSize,
                    "height": h || defaultTexSize,
                });
        }

        if (cgl.aborted) return;

        this.setSize(w || defaultTexSize, h || defaultTexSize);

        this._cgl.printError("framebuffer2 constructor");
    }

    getWidth()
    {
        return this._width;
    }

    getHeight()
    {
        return this._height;
    }

    getGlFrameBuffer()
    {
        return this._frameBuffer;
    }

    getDepthRenderBuffer()
    {
        return this._depthRenderbuffer;
    }

    getTextureColor()
    {
        return this._colorTextures[0];
    }

    getTextureColorNum(i)
    {
        return this._colorTextures[i];
    }

    getTextureDepth()
    {
        return this._textureDepth;
    }

    setFilter(f)
    {
        for (let i = 0; i < this._numRenderBuffers; i++)
        {
            this._colorTextures[i].filter = f;
            this._colorTextures[i].setSize(this._width, this._height);
        }
    }

    delete()
    {
        this.dispose();
    }

    dispose()
    {
        this._disposed = true;
        let i = 0;
        for (i = 0; i < this._numRenderBuffers; i++) this._colorTextures[i].delete();
        // this._texture.delete();
        if (this._textureDepth) this._textureDepth.delete();
        for (i = 0; i < this._numRenderBuffers; i++) this._cgl.gl.deleteRenderbuffer(this._colorRenderbuffers[i]);
        this._cgl.gl.deleteRenderbuffer(this._depthRenderbuffer);
        this._cgl.gl.deleteFramebuffer(this._frameBuffer);
        this._cgl.gl.deleteFramebuffer(this._textureFrameBuffer);
    }

    /**
     * @param {number} w
     * @param {number} h
     */
    setSize(w, h)
    {
        if (this._disposed) return this._log.warn("disposed framebuffer setsize...");
        this._cgl.profileData.addHeavyEvent("framebuffer resize", this.name);

        let i = 0;

        this._width = this._cgl.checkTextureSize(w);
        this._height = this._cgl.checkTextureSize(h);

        this._cgl.profileData.profileFrameBuffercreate++;

        if (this._frameBuffer)
        {
            for (i = 0; i < this._numRenderBuffers; i++) this._cgl.gl.deleteRenderbuffer(this._colorRenderbuffers[i]);
            // this._cgl.gl.deleteRenderbuffer(this._colorRenderbuffer);
            this._cgl.gl.deleteRenderbuffer(this._depthRenderbuffer);
            this._cgl.gl.deleteFramebuffer(this._frameBuffer);
            this._cgl.gl.deleteFramebuffer(this._textureFrameBuffer);
        }

        this._frameBuffer = this._cgl.gl.createFramebuffer();
        this._textureFrameBuffer = this._cgl.gl.createFramebuffer();

        const depth = this._options.depth;

        for (i = 0; i < this._numRenderBuffers; i++)
        {
            this._colorTextures[i].setSize(this._width, this._height);
        }

        for (i = 0; i < this._numRenderBuffers; i++)
        {
            const renderBuffer = this._cgl.gl.createRenderbuffer();

            // color renderbuffer

            this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, this._frameBuffer);
            this._cgl.gl.bindRenderbuffer(this._cgl.gl.RENDERBUFFER, renderBuffer);

            const info = Texture.setUpGlPixelFormat(this._cgl, this._options.pixelFormat);
            let internFormat = info.glInternalFormat;

            // if (this._options.isFloatingPointTexture)
            // {
            if (CGL.Texture.isPixelFormatHalfFloat(info.pixelFormat))
            {
                if (!this._cgl.enableExtension("OES_texture_float_linear"))
                {
                    this._options.filter = Texture.FILTER_NEAREST;
                    this.setFilter(this._options.filter);
                }
            }
            else if (CGL.Texture.isPixelFormatFloat(info.pixelFormat))
            {
                if (!this._cgl.enableExtension("OES_texture_float_linear"))
                {
                    this._log.warn("no linear pixelformat,using nearest");
                    this._options.filter = Texture.FILTER_NEAREST;
                    this.setFilter(this._options.filter);
                }
            }
            // else if (info.pixelFormat == Texture.PFORMATSTR_RGBA32F || info.pixelFormat == Texture.PFORMATSTR_R11FG11FB10F
            // else if (info.pixelFormat == Texture.PFORMATSTR_RGBA32F || info.pixelFormat == Texture.PFORMATSTR_R11FG11FB10F
            // else if (info.pixelFormat == Texture.PFORMATSTR_RG16F)
            // {
            //     const extcb = this._cgl.enableExtension("EXT_color_buffer_float");

            //     if (!this._cgl.enableExtension("OES_texture_float_linear"))
            //     {
            //         console.log("no linear pixelformat,switching to nearest");
            //         this._options.filter = Texture.FILTER_NEAREST;
            //         this.setFilter(this._options.filter);
            //     }
            // }
            // }

            if (this._options.multisampling && this._options.multisamplingSamples)
            {
                this._cgl.gl.renderbufferStorageMultisample(this._cgl.gl.RENDERBUFFER, this._options.multisamplingSamples, internFormat, this._width, this._height);
            }
            else
            {
                this._cgl.gl.renderbufferStorage(this._cgl.gl.RENDERBUFFER, internFormat, this._width, this._height);
            }

            this._cgl.gl.framebufferRenderbuffer(this._cgl.gl.FRAMEBUFFER, this._cgl.gl.COLOR_ATTACHMENT0 + i, this._cgl.gl.RENDERBUFFER, renderBuffer);
            this._colorRenderbuffers[i] = renderBuffer;
        }

        // this._cgl.gl.bindFramebuffer(this._cgl.gl.DRAW_FRAMEBUFFER, this._textureFrameBuffer);
        this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, this._textureFrameBuffer);

        for (i = 0; i < this._numRenderBuffers; i++)
        {
            this._cgl.gl.framebufferTexture2D(this._cgl.gl.FRAMEBUFFER, this._cgl.gl.COLOR_ATTACHMENT0 + i, this._cgl.gl.TEXTURE_2D, this._colorTextures[i].tex, 0);
        }

        if (this._options.depth)
        {
            this._cgl.gl.framebufferTexture2D(this._cgl.gl.FRAMEBUFFER, this._cgl.gl.DEPTH_ATTACHMENT, this._cgl.gl.TEXTURE_2D, this._textureDepth.tex, 0);
        }

        // depth renderbuffer

        this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, this._frameBuffer);

        let depthType = this._cgl.gl.DEPTH_COMPONENT32F;

        if (this._cgl.glSlowRenderer) depthType = this._cgl.gl.DEPTH_COMPONENT16;
        if (depth)
        {
            this._textureDepth.setSize(this._width, this._height);
            this._depthRenderbuffer = this._cgl.gl.createRenderbuffer();

            this._cgl.gl.bindRenderbuffer(this._cgl.gl.RENDERBUFFER, this._depthRenderbuffer);
            if (this._options.isFloatingPointTexture)
            {
                if (this._options.multisampling) this._cgl.gl.renderbufferStorageMultisample(this._cgl.gl.RENDERBUFFER, this._options.multisamplingSamples, depthType, this._width, this._height);
                else this._cgl.gl.renderbufferStorage(this._cgl.gl.RENDERBUFFER, depthType, this._width, this._height);
            }
            else if (this._options.multisampling)
            {
                this._cgl.gl.renderbufferStorageMultisample(this._cgl.gl.RENDERBUFFER, this._options.multisamplingSamples, depthType, this._width, this._height);
            // this._cgl.gl.renderbufferStorage(this._cgl.gl.RENDERBUFFER,depthType, this._width, this._height);
            }
            else
            {
                this._cgl.gl.renderbufferStorage(this._cgl.gl.RENDERBUFFER, depthType, this._width, this._height);
            }

            this._cgl.gl.framebufferRenderbuffer(this._cgl.gl.FRAMEBUFFER, this._cgl.gl.DEPTH_ATTACHMENT, this._cgl.gl.RENDERBUFFER, this._depthRenderbuffer);
        }

        // this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, null);
        // this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, this._textureFrameBuffer);

        this._drawTargetArray.length = 0;
        for (i = 0; i < this._numRenderBuffers; i++) this._drawTargetArray.push(this._cgl.gl.COLOR_ATTACHMENT0 + i);

        // this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, null);

        if (!this._cgl.gl.isFramebuffer(this._textureFrameBuffer)) this._log.warn("invalid framebuffer");// throw new Error("Invalid framebuffer");
        const status = this._cgl.gl.checkFramebufferStatus(this._cgl.gl.FRAMEBUFFER);

        if (status != this._cgl.gl.FRAMEBUFFER_COMPLETE)
        {
            this._log.error("framebuffer incomplete: " + this.name, this);
            this._log.log("options", this._options);
            this._log.log("options pixelformat", this._options.pixelFormat);

            switch (status)
            {
            case this._cgl.gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
                this._log.warn("FRAMEBUFFER_INCOMPLETE_ATTACHMENT...", this);
                throw new Error("Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_ATTACHMENT");
            case this._cgl.gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
                this._log.warn("FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT");
                throw new Error("Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT");
            case this._cgl.gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
                this._log.warn("FRAMEBUFFER_INCOMPLETE_DIMENSIONS");
                throw new Error("Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_DIMENSIONS");
            case this._cgl.gl.FRAMEBUFFER_UNSUPPORTED:
                this._log.warn("FRAMEBUFFER_UNSUPPORTED");
                throw new Error("Incomplete framebuffer: FRAMEBUFFER_UNSUPPORTED");
            default:
                this.valid = false;
                this._log.error("incomplete framebuffer", status, this._frameBuffer);
                this._cgl.printError();

                this._frameBuffer = null;
                // debugger;
                throw new Error("Incomplete framebuffer: " + status);

        // throw("Incomplete framebuffer: " + status);
            }
        }

        this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, null);
        this._cgl.gl.bindRenderbuffer(this._cgl.gl.RENDERBUFFER, null);

    // this._cgl.printError("fb setsize");
    }

    renderStart()
    {
        if (this._disposed) return this._log.warn("disposed framebuffer renderStart...");
        this._cgl.checkFrameStarted("fb2 renderstart");
        this._cgl.pushModelMatrix(); // needed ??

        this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, this._frameBuffer);
        this._cgl.pushGlFrameBuffer(this._frameBuffer);
        this._cgl.pushFrameBuffer(this);

        this._cgl.pushPMatrix();
        this._cgl.pushViewPort(0, 0, this._width, this._height);

        this._cgl.gl.drawBuffers(this._drawTargetArray);

        if (this._options.clear)
        {
            this._cgl.gl.clearColor(0, 0, 0, 0);
            this._cgl.gl.clear(this._cgl.gl.COLOR_BUFFER_BIT | this._cgl.gl.DEPTH_BUFFER_BIT);
        }
    }

    clear()
    {
        if (this._numRenderBuffers <= 1)
        {
            this._cgl.gl.bindFramebuffer(this._cgl.gl.READ_FRAMEBUFFER, this._frameBuffer);
            this._cgl.gl.bindFramebuffer(this._cgl.gl.DRAW_FRAMEBUFFER, this._textureFrameBuffer);
        }
        else this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, this._frameBuffer);

        this._cgl.gl.drawBuffers(this._drawTargetArray);

        for (let i = 0; i < this._numRenderBuffers; i++)
        {
            this._cgl.gl.framebufferTexture2D(this._cgl.gl.FRAMEBUFFER, this._cgl.gl.COLOR_ATTACHMENT0 + i, this._cgl.gl.TEXTURE_2D, this._colorTextures[i].tex, 0);
            this._cgl.gl.clearBufferfv(this._cgl.gl.COLOR, i, this.clearColors[i]);
        }
        this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, null);
    }

    renderEnd()
    {
        if (this._disposed) return this._log.warn("disposed framebuffer renderEnd...");
        this._cgl.popPMatrix();

        this._cgl.profileData.profileFramebuffer++;

        if (this._numRenderBuffers <= 1)
        {
            this._cgl.gl.bindFramebuffer(this._cgl.gl.READ_FRAMEBUFFER, this._frameBuffer);
            this._cgl.gl.bindFramebuffer(this._cgl.gl.DRAW_FRAMEBUFFER, this._textureFrameBuffer);

            this._cgl.gl.clearBufferfv(this._cgl.gl.COLOR, 0, [0.0, 0.0, 0.0, 1.0]);
            this._cgl.gl.blitFramebuffer(0, 0, this._width, this._height, 0, 0, this._width, this._height, this._cgl.gl.COLOR_BUFFER_BIT | this._cgl.gl.DEPTH_BUFFER_BIT, this._cgl.gl.NEAREST);
        }
        else
        {
            this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, this.Framebuffer2BlittingFramebuffer);
            this._cgl.gl.framebufferRenderbuffer(this._cgl.gl.FRAMEBUFFER, this._cgl.gl.DEPTH_ATTACHMENT, this._cgl.gl.RENDERBUFFER, this._depthRenderbuffer);

            this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, this.Framebuffer2FinalFramebuffer);
            this._cgl.gl.framebufferTexture2D(this._cgl.gl.FRAMEBUFFER, this._cgl.gl.DEPTH_ATTACHMENT, this._cgl.gl.TEXTURE_2D, this._textureDepth.tex, 0);

            for (let i = 0; i < this._numRenderBuffers; i++)
            {
                this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, this.Framebuffer2BlittingFramebuffer);
                this._cgl.gl.framebufferRenderbuffer(this._cgl.gl.FRAMEBUFFER, this._cgl.gl.COLOR_ATTACHMENT0, this._cgl.gl.RENDERBUFFER, this._colorRenderbuffers[i]);

                this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, this.Framebuffer2FinalFramebuffer);
                this._cgl.gl.framebufferTexture2D(this._cgl.gl.FRAMEBUFFER, this._cgl.gl.COLOR_ATTACHMENT0, this._cgl.gl.TEXTURE_2D, this._colorTextures[i].tex, 0);

                this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, null);

                this._cgl.gl.bindFramebuffer(this._cgl.gl.READ_FRAMEBUFFER, this.Framebuffer2BlittingFramebuffer);
                this._cgl.gl.bindFramebuffer(this._cgl.gl.DRAW_FRAMEBUFFER, this.Framebuffer2FinalFramebuffer);

                // this._cgl.gl.clearBufferfv(this._cgl.gl.COLOR, i, [0.0, 0.0, 0.0, 1.0]);

                let flags = this._cgl.gl.COLOR_BUFFER_BIT;
                if (i == 0) flags |= this._cgl.gl.DEPTH_BUFFER_BIT;

                this._cgl.gl.blitFramebuffer(0, 0, this._width, this._height, 0, 0, this._width, this._height, flags, this._cgl.gl.NEAREST);
            }
        }

        this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, this._cgl.popGlFrameBuffer());
        this._cgl.popFrameBuffer();

        this._cgl.popModelMatrix();
        this._cgl.popViewPort();

        if (this._colorTextures[0].filter == Texture.FILTER_MIPMAP)
        {
            for (let i = 0; i < this._numRenderBuffers; i++)
            {
                this._cgl.gl.bindTexture(this._cgl.gl.TEXTURE_2D, this._colorTextures[i].tex);
                this._colorTextures[i].updateMipMap();
                this._cgl.gl.bindTexture(this._cgl.gl.TEXTURE_2D, null);
            }
        }
    }
}

;// CONCATENATED MODULE: ./src/corelibs/cgl/cgl_marker.js
/** @type {function}
 * @deprecated
*/
const Marker = function (_cgl) // deprecated...
{
    this.draw = function (cgl, _size, depthTest) {};
};

/** @type {function}
 * @deprecated
*/
const WirePoint = function (cgl) // deprecated...
{
    this.render = function (_cgl, _size) {};
};

/** @type {function}
 * @deprecated
*/
const WireCube = function (cgl) // deprecated...
{
    this.render = function (_cgl, sizeX, sizeY, sizeZ) {};
};

;// CONCATENATED MODULE: ./src/corelibs/cg/cg_uniform.js




class CgUniform
{

    /**
     * Description
     * @param {CgShader|CgpShader|Shader} __shader
     * @param {string} __type
     * @param {string} __name
     * @param {Number|Port} _value
     * @param {Port} _port2
     * @param {Port} _port3
     * @param {Port} _port4
     */
    constructor(__shader, __type, __name, _value, _port2, _port3, _port4, _structUniformName, _structName, _propertyName)
    {
        this._log = new external_CABLES_SHARED_namespaceObject.Logger("cg_uniform");
        this._type = __type;
        this._name = __name;

        /** @type {CgShader} */
        this._shader = __shader;
        this._value = 0.00001;
        this._oldValue = null;
        this._port = null;

        this._structName = _structName;
        this._structUniformName = _structUniformName;
        this._propertyName = _propertyName;

        if (this._shader._addUniform) this._shader._addUniform(this);
        this.needsUpdate = true;
        this.shaderType = null;
        this.comment = null;

        if (__type == "f")
        {
            this.set = this.setValue = this.setValueF.bind(this);
            this.updateValue = this.updateValueF.bind(this);
        }
        else if (__type == "f[]")
        {
            this.set = this.setValue = this.setValueArrayF.bind(this);
            this.updateValue = this.updateValueArrayF.bind(this);
        }
        else if (__type == "2f[]")
        {
            this.set = this.setValue = this.setValueArray2F.bind(this);
            this.updateValue = this.updateValueArray2F.bind(this);
        }
        else if (__type == "3f[]")
        {
            this.set = this.setValue = this.setValueArray3F.bind(this);
            this.updateValue = this.updateValueArray3F.bind(this);
        }
        else if (__type == "4f[]")
        {
            this.set = this.setValue = this.setValueArray4F.bind(this);
            this.updateValue = this.updateValueArray4F.bind(this);
        }
        else if (__type == "i")
        {
            this.set = this.setValue = this.setValueI.bind(this);
            this.updateValue = this.updateValueI.bind(this);
        }
        else if (__type == "2i")
        {
            this.set = this.setValue = this.setValue2I.bind(this);
            this.updateValue = this.updateValue2I.bind(this);
        }
        else if (__type == "3i")
        {
            this.set = this.setValue = this.setValue3I.bind(this);
            this.updateValue = this.updateValue3I.bind(this);
        }
        else if (__type == "4i")
        {
            this.set = this.setValue = this.setValue4I.bind(this);
            this.updateValue = this.updateValue4I.bind(this);
        }
        else if (__type == "b")
        {
            this.set = this.setValue = this.setValueBool.bind(this);
            this.updateValue = this.updateValueBool.bind(this);
        }
        else if (__type == "4f")
        {
            this.set = this.setValue = this.setValue4F.bind(this);
            this.updateValue = this.updateValue4F.bind(this);
        }
        else if (__type == "3f")
        {
            this.set = this.setValue = this.setValue3F.bind(this);
            this.updateValue = this.updateValue3F.bind(this);
        }
        else if (__type == "2f")
        {
            this.set = this.setValue = this.setValue2F.bind(this);
            this.updateValue = this.updateValue2F.bind(this);
        }
        else if (__type == "t")
        {
            this.set = this.setValue = this.setValueT.bind(this);
            this.updateValue = this.updateValueT.bind(this);
        }
        else if (__type == "sampler")
        {
            if (this.setValueAny)
            {
                this.set = this.setValue = this.setValueAny.bind(this);
                this.updateValue = this.updateValueAny.bind(this);
            }
        }
        else if (__type == "tc")
        {
            this.set = this.setValue = this.setValueT.bind(this);
            this.updateValue = this.updateValueT.bind(this);
        }
        else if (__type == "t[]")
        {
            this.set = this.setValue = this.setValueArrayT.bind(this);
            this.updateValue = this.updateValueArrayT.bind(this);
        }
        else if (__type == "m4" || __type == "m4[]")
        {
            this.set = this.setValue = this.setValueM4.bind(this);
            this.updateValue = this.updateValueM4.bind(this);
        }
        else
        {
            // console.error("unknown");
            this._log.error("Unknown uniform type " + __type, __name, typeof this._shader);
        }

        if (typeof _value == "object" && _value instanceof external_CABLES_namespaceObject.Port)
        {
            this._port = _value;
            this._value = this._port.get();

            if (_port2 && _port3 && _port4)
            {
                if (!(_port2 instanceof external_CABLES_namespaceObject.Port) || !(_port3 instanceof external_CABLES_namespaceObject.Port) || !(_port4 instanceof external_CABLES_namespaceObject.Port))
                {
                    this._log.error("[cgl_uniform] mixed port/value parameter for vec4 ", this._name);
                }

                this._value = [0, 0, 0, 0];
                this._port2 = _port2;
                this._port3 = _port3;
                this._port4 = _port4;

                this._port.on("change", this.updateFromPort4f.bind(this));
                this._port2.on("change", this.updateFromPort4f.bind(this));
                this._port3.on("change", this.updateFromPort4f.bind(this));
                this._port4.on("change", this.updateFromPort4f.bind(this));

                // this._port.onChange = this._port2.onChange = this._port3.onChange = this._port4.onChange = this.updateFromPort4f.bind(this);
                this.updateFromPort4f();
            }
            else if (_port2 && _port3)
            {
                if (!(_port2 instanceof external_CABLES_namespaceObject.Port) || !(_port3 instanceof external_CABLES_namespaceObject.Port))
                {
                    this._log.error("[cgl_uniform] mixed port/value parameter for vec4 ", this._name);
                }

                this._value = [0, 0, 0];
                this._port2 = _port2;
                this._port3 = _port3;
                // this._port.onChange = this._port2.onChange = this._port3.onChange = this.updateFromPort3f.bind(this);
                this._port.on("change", this.updateFromPort3f.bind(this));
                this._port2.on("change", this.updateFromPort3f.bind(this));
                this._port3.on("change", this.updateFromPort3f.bind(this));

                this.updateFromPort3f();
            }
            else if (_port2)
            {
                if (!(_port2 instanceof external_CABLES_namespaceObject.Port))
                {
                    this._log.error("[cgl_uniform] mixed port/value parameter for vec4 ", this._name);
                }

                this._value = [0, 0];
                this._port2 = _port2;
                // this._port.onChange = this._port2.onChange = this.updateFromPort2f.bind(this);
                this._port.on("change", this.updateFromPort2f.bind(this));
                this._port2.on("change", this.updateFromPort2f.bind(this));

                this.updateFromPort2f();
            }
            else
            {
                // this._port.on = this.updateFromPort.bind(this);
                this._port.on("change", this.updateFromPort.bind(this));
            }
        }
        else this._value = _value;

        if (this._value == undefined)
        {
            this._value = 0;
        }

        this.setValue(this._value);

        this.needsUpdate = true;
    }

    getType()
    {
        return this._type;
    }

    get type()
    {
        return this._type;
    }

    get name()
    {
        return this._name;
    }

    getName()
    {
        return this._name;
    }

    getValue()
    {
        return this._value;
    }

    getShaderType()
    {
        return this.shaderType;
    }

    isStructMember()
    {
        return !!this._structName;
    }

    updateFromPort4f()
    {
        this._value[0] = this._port.get();
        this._value[1] = this._port2.get();
        this._value[2] = this._port3.get();
        this._value[3] = this._port4.get();
        this.setValue(this._value);
    }

    updateFromPort3f()
    {
        this._value[0] = this._port.get();
        this._value[1] = this._port2.get();
        this._value[2] = this._port3.get();
        this.setValue(this._value);
    }

    updateFromPort2f()
    {
        this._value[0] = this._port.get();
        this._value[1] = this._port2.get();
        this.setValue(this._value);
    }

    updateFromPort()
    {
        this.setValue(this._port.get());
    }

    get port()
    {
        return this._port;
    }
}

;// CONCATENATED MODULE: ./src/corelibs/cgl/cgl_shader_uniform.js




/**
 * Shader uniforms
 *
 * types:
 * <pre>
 * f    - float
 * 2f   - vec2
 * 3f   - vec3
 * 4f   - vec4
 * i    - integer
 * t    - texture
 * m4   - mat4, 4x4 float matrix
 * f[]  - array of floats
 * 2f[] - array of float vec2
 * 3f[] - array of float vec3
 * 4f[] - array of float vec4
 * </pre>
 *
 * @namespace external:CGL
 * @class
 * @param {CgShader} shader
 * @param {String} [type=f]
 * @param {String} name
 * @param {Number|Port} value  can be a Number,Matrix or Port
 * @example
 * // bind float uniform called myfloat and initialize with value 1.0
 * const unir=new CGL.Uniform(shader,'f','myfloat',1.0);
 * unir.setValue(1.0);
 *
 * // bind float uniform called myfloat and automatically set it to input port value
 * const myPort=op.inFloat("input");
 * const pv=new CGL.Uniform(shader,'f','myfloat',myPort);
 *
 */

// export const Uniform(__shader, __type, __name, _value, _port2, _port3, _port4, _structUniformName, _structName, _propertyName)

class Uniform extends CgUniform
{
    constructor(__shader, __type, __name, _value, _port2, _port3, _port4, _structUniformName, _structName, _propertyName)
    {
        super(__shader, __type, __name, _value, _port2, _port3, _port4, _structUniformName, _structName, _propertyName);
        this._loc = -1;
        this._cgl = __shader._cgl;
    }

    get name()
    {
        return this._name;
    }

    copy(newShader)
    {
        const uni = new Uniform(newShader, this._type, this._name, this._value, this._port2, this._port3, this._port4, this._structUniformName, this._structName, this._propertyName);
        uni.shaderType = this.shaderType;
        return uni;
    }

    /**
     * returns type as glsl type string. e.g. 'f' returns 'float'
     * @function getGlslTypeString
     * @memberof Uniform
     * @instance
     * @return {string} type as string
     */
    getGlslTypeString()
    {
        return Uniform.glslTypeString(this._type);
    }

    _isValidLoc()
    {
        return this._loc != -1;// && this._loc != null;
    }

    resetLoc()
    {
        this._loc = -1;
        this.needsUpdate = true;
    }

    bindTextures() {}

    getLoc()
    {
        return this._loc;
    }

    updateFromPort4f()
    {
        this._value[0] = this._port.get();
        this._value[1] = this._port2.get();
        this._value[2] = this._port3.get();
        this._value[3] = this._port4.get();
        this.setValue(this._value);
    }

    updateFromPort3f()
    {
        this._value[0] = this._port.get();
        this._value[1] = this._port2.get();
        this._value[2] = this._port3.get();
        this.setValue(this._value);
    }

    updateFromPort2f()
    {
        this._value[0] = this._port.get();
        this._value[1] = this._port2.get();
        this.setValue(this._value);
    }

    updateFromPort()
    {
        this.setValue(this._port.get());
    }

    updateValueF()
    {
        if (!this._isValidLoc()) this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name);
        else this.needsUpdate = false;

        this._shader.getCgl().gl.uniform1f(this._loc, this._value);
        this._cgl.profileData.profileUniformCount++;
    }

    setValueF(v)
    {
        if (v != this._value)
        {
            this.needsUpdate = true;
            this._value = v;
        }
    }

    updateValueI()
    {
        if (!this._isValidLoc()) this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name);
        else this.needsUpdate = false;

        this._shader.getCgl().gl.uniform1i(this._loc, this._value);
        this._cgl.profileData.profileUniformCount++;
    }

    updateValue2I()
    {
        if (!this._value) return;

        if (!this._isValidLoc())
        {
            this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name);
            this._cgl.profileData.profileShaderGetUniform++;
            this._cgl.profileData.profileShaderGetUniformName = this._name;
        }

        this._shader.getCgl().gl.uniform2i(this._loc, this._value[0], this._value[1]);

        this.needsUpdate = false;
        this._cgl.profileData.profileUniformCount++;
    }

    updateValue3I()
    {
        if (!this._value) return;
        if (!this._isValidLoc())
        {
            this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name);
            this._cgl.profileData.profileShaderGetUniform++;
            this._cgl.profileData.profileShaderGetUniformName = this._name;
        }

        this._shader.getCgl().gl.uniform3i(this._loc, this._value[0], this._value[1], this._value[2]);
        this.needsUpdate = false;
        this._cgl.profileData.profileUniformCount++;
    }

    updateValue4I()
    {
        if (!this._isValidLoc())
        {
            this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name);
            this._cgl.profileData.profileShaderGetUniform++;
            this._cgl.profileData.profileShaderGetUniformName = this._name;
        }
        this._shader.getCgl().gl.uniform4i(this._loc, this._value[0], this._value[1], this._value[2], this._value[3]);
        this._cgl.profileData.profileUniformCount++;
    }

    setValueI(v)
    {
        if (v != this._value)
        {
            this.needsUpdate = true;
            this._value = v;
        }
    }

    setValue2I(v)
    {
        if (!v) return;
        if (!this._oldValue)
        {
            this._oldValue = [v[0] - 1, 1];
            this.needsUpdate = true;
        }
        else if (v[0] != this._oldValue[0] || v[1] != this._oldValue[1])
        {
            this._oldValue[0] = v[0];
            this._oldValue[1] = v[1];
            this.needsUpdate = true;
        }

        this._value = v;
    }

    setValue3I(v)
    {
        if (!v) return;
        if (!this._oldValue)
        {
            this._oldValue = [v[0] - 1, 1, 2];
            this.needsUpdate = true;
        }
        else if (v[0] != this._oldValue[0] || v[1] != this._oldValue[1] || v[2] != this._oldValue[2])
        {
            this._oldValue[0] = v[0];
            this._oldValue[1] = v[1];
            this._oldValue[2] = v[2];
            this.needsUpdate = true;
        }

        this._value = v;
    }

    setValue4I(v)
    {
        this.needsUpdate = true;
        this._value = v || vec4.create();
    }

    updateValueBool()
    {
        if (!this._isValidLoc()) this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name);
        else this.needsUpdate = false;
        this._shader.getCgl().gl.uniform1i(this._loc, this._value ? 1 : 0);

        this._cgl.profileData.profileUniformCount++;
    }

    setValueBool(v)
    {
        if (v != this._value)
        {
            this.needsUpdate = true;
            this._value = v;
        }
    }

    setValueArray4F(v)
    {
        this.needsUpdate = true;
        this._value = v;
    }

    updateValueArray4F()
    {
        if (!this._isValidLoc()) this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name);
        else this.needsUpdate = false;

        if (!this._value) return;
        this._shader.getCgl().gl.uniform4fv(this._loc, this._value);
        this._cgl.profileData.profileUniformCount++;
    }

    setValueArray3F(v)
    {
        this.needsUpdate = true;
        this._value = v;
    }

    updateValueArray3F()
    {
        if (!this._isValidLoc()) this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name);
        else this.needsUpdate = false;

        if (!this._value) return;
        this._shader.getCgl().gl.uniform3fv(this._loc, this._value);
        this._cgl.profileData.profileUniformCount++;
    }

    setValueArray2F(v)
    {
        this.needsUpdate = true;
        this._value = v;
    }

    updateValueArray2F()
    {
        if (!this._isValidLoc()) this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name);
        else this.needsUpdate = false;

        if (!this._value) return;
        this._shader.getCgl().gl.uniform2fv(this._loc, this._value);
        this._cgl.profileData.profileUniformCount++;
    }

    setValueArrayF(v)
    {
        this.needsUpdate = true;
        this._value = v;
    }

    updateValueArrayF()
    {
        if (!this._isValidLoc()) this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name);
        else this.needsUpdate = false;

        if (!this._value) return;
        this._shader.getCgl().gl.uniform1fv(this._loc, this._value);
        this._cgl.profileData.profileUniformCount++;
    }

    setValueArrayT(v)
    {
        this.needsUpdate = true;
        this._value = v;
    }

    updateValue3F()
    {
        if (!this._value) return;
        if (!this._isValidLoc())
        {
            this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name);
            this._cgl.profileData.profileShaderGetUniform++;
            this._cgl.profileData.profileShaderGetUniformName = this._name;
        }

        this._shader.getCgl().gl.uniform3f(this._loc, this._value[0], this._value[1], this._value[2]);
        this.needsUpdate = false;
        this._cgl.profileData.profileUniformCount++;
    }

    setValue3F(v)
    {
        if (!v) return;
        if (!this._oldValue)
        {
            this._oldValue = [v[0] - 1, 1, 2];
            this.needsUpdate = true;
        }
        else if (v[0] != this._oldValue[0] || v[1] != this._oldValue[1] || v[2] != this._oldValue[2])
        {
            this._oldValue[0] = v[0];
            this._oldValue[1] = v[1];
            this._oldValue[2] = v[2];
            this.needsUpdate = true;
        }

        this._value = v;
    }

    updateValue2F()
    {
        if (!this._value) return;

        if (!this._isValidLoc())
        {
            this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name);
            this._cgl.profileData.profileShaderGetUniform++;
            this._cgl.profileData.profileShaderGetUniformName = this._name;
        }

        this._shader.getCgl().gl.uniform2f(this._loc, this._value[0], this._value[1]);
        this.needsUpdate = false;
        this._cgl.profileData.profileUniformCount++;
    }

    setValue2F(v)
    {
        if (!v) return;
        if (!this._oldValue)
        {
            this._oldValue = [v[0] - 1, 1];
            this.needsUpdate = true;
        }
        else if (v[0] != this._oldValue[0] || v[1] != this._oldValue[1])
        {
            this._oldValue[0] = v[0];
            this._oldValue[1] = v[1];
            this.needsUpdate = true;
        }
        this._value = v;
    }

    updateValue4F()
    {
        if (!this._isValidLoc())
        {
            this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name);
            this._cgl.profileData.profileShaderGetUniform++;
            this._cgl.profileData.profileShaderGetUniformName = this._name;
        }

        if (!this._value)
        {
            this._log.warn("no value for uniform", this._name, this);
            this._value = [0, 0, 0, 0];
        }

        this.needsUpdate = false;
        this._shader.getCgl().gl.uniform4f(this._loc, this._value[0], this._value[1], this._value[2], this._value[3]);
        this._cgl.profileData.profileUniformCount++;
    }

    setValue4F(v)
    {
        if (typeof this.value == "number") this.value = vec4.create(); // this should not be needed, but somehow it crashes with some shadermods

        if (!v) return;
        if (!this._oldValue)
        {
            this._oldValue = [v[0] - 1, 1, 2, 3];
            this.needsUpdate = true;
        }
        else if (v[0] != this._oldValue[0] || v[1] != this._oldValue[1] || v[2] != this._oldValue[2] || v[3] != this._oldValue[3])
        {
            this._oldValue[0] = v[0];
            this._oldValue[1] = v[1];
            this._oldValue[2] = v[2];
            this.needsUpdate = true;
        }

        this._value = v;
    }

    updateValueM4()
    {
        if (!this._isValidLoc())
        {
            this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name);
            this._cgl.profileData.profileShaderGetUniform++;
            this._cgl.profileData.profileShaderGetUniformName = this._name;
        }
        if (!this._value || this._value.length % 16 != 0) return console.log("this.name", this._name, this._value);

        this._shader.getCgl().gl.uniformMatrix4fv(this._loc, false, this._value);
        this._cgl.profileData.profileUniformCount++;
    }

    setValueM4(v)
    {
        this.needsUpdate = true;
        this._value = v || mat4.create();
    }

    updateValueArrayT()
    {
        if (!this._isValidLoc()) this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name);
        else this.needsUpdate = false;

        if (!this._value) return;
        this._shader.getCgl().gl.uniform1iv(this._loc, this._value);
        this._cgl.profileData.profileUniformCount++;
    }

    updateValueT()
    {
        if (!this._isValidLoc())
        {
            this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name);
            this._cgl.profileData.profileShaderGetUniform++;
            this._cgl.profileData.profileShaderGetUniformName = this._name;
        }

        this._cgl.profileData.profileUniformCount++;
        this._shader.getCgl().gl.uniform1i(this._loc, this._value);
        this.needsUpdate = false;
    }

    setValueT(v)
    {
        this.needsUpdate = true;
        this._value = v;
    }
}

Uniform.glslTypeString = (t) =>
{
    if (t == "f") return "float";
    if (t == "b") return "bool";
    if (t == "i") return "int";
    if (t == "2i") return "ivec2";
    if (t == "2f") return "vec2";
    if (t == "3f") return "vec3";
    if (t == "4f") return "vec4";
    if (t == "m4") return "mat4";

    if (t == "t") return "sampler2D";
    if (t == "tc") return "samplerCube";

    if (t == "3f[]") return null; // ignore this for now...
    if (t == "m4[]") return null; // ignore this for now...
    if (t == "f[]") return null; // ignore this for now...

    console.warn("[CGL UNIFORM] unknown glsl type string ", t);
};

/**
 * @function setValue
 * @memberof Uniform
 * @instance
 * @param {Number|Array|Matrix|Texture} value
 */

;// CONCATENATED MODULE: ./src/corelibs/cgl/constants.js
const SHADER = {
    // default attributes
    "SHADERVAR_VERTEX_POSITION": "vPosition",
    "SHADERVAR_VERTEX_NUMBER": "attrVertIndex",
    "SHADERVAR_VERTEX_NORMAL": "attrVertNormal",
    "SHADERVAR_VERTEX_TEXCOORD": "attrTexCoord",
    "SHADERVAR_INSTANCE_MMATRIX": "instMat",
    "SHADERVAR_VERTEX_COLOR": "attrVertColor",

    "SHADERVAR_INSTANCE_INDEX": "instanceIndex",

    // default uniforms
    "SHADERVAR_UNI_PROJMAT": "projMatrix",
    "SHADERVAR_UNI_VIEWMAT": "viewMatrix",
    "SHADERVAR_UNI_MODELMAT": "modelMatrix",
    "SHADERVAR_UNI_NORMALMAT": "normalMatrix",
    "SHADERVAR_UNI_INVVIEWMAT": "inverseViewMatrix",
    "SHADERVAR_UNI_INVPROJMAT": "invProjMatrix",
    "SHADERVAR_UNI_MATERIALID": "materialId",
    "SHADERVAR_UNI_OBJECTID": "objectId",

    "SHADERVAR_UNI_VIEWPOS": "camPos",
};

const BLEND_MODES = {
    "BLEND_NONE": 0,
    "BLEND_NORMAL": 1,
    "BLEND_ADD": 2,
    "BLEND_SUB": 3,
    "BLEND_MUL": 4,
};

const RAD2DEG = 180.0 / Math.PI;
const DEG2RAD = Math.PI / 180.0;

const CONSTANTS = {
    "MATH": {
        "DEG2RAD": DEG2RAD,
        "RAD2DEG": RAD2DEG,
    },
    "SHADER": SHADER,
    "BLEND_MODES": BLEND_MODES,
};
const nl = "\n";// newline


;// CONCATENATED MODULE: ./src/corelibs/cg/cg_mesh.js
class CgMesh
{
    _name = "unknown";

    constructor()
    {
    }

}

;// CONCATENATED MODULE: ./src/corelibs/cgl/cgl_mesh.js










const MESH = {};
MESH.lastMesh = null;

/**
 * @typedef {Object} CglMeshAttributeOptions
 * @property {boolean} [instanced]
 * @property {Function} [cb]
 * @property {Function} [type]
 */

/**
 * @type Object
 * @typedef CglMeshOptions
 * @property {Number} [glPrimitive]
 * @property {String} [opId]
 */

/**
 * webgl renderable 3d object
 * @class
 * @namespace external:CGL
 * @hideconstructor
 * @example
 * const cgl=this._cgl
 * const mesh=new CGL.Mesh(cgl, geometry);
 *
 * function render()
 * {
 *   mesh.render(cgl.getShader());
 * }
 *
 */
class Mesh extends CgMesh
{

    /** @type {CglContext} */
    #cgl = null;

    /** @type {Geometry} */
    #geom = null;

    /** @type {WebGLBuffer} */
    #bufVerticesIndizes = null;

    /**
     * @param {CglContext} _cgl cgl
     * @param {Geometry} __geom geometry
     * @param {CglMeshOptions} _options
     */
    constructor(_cgl, __geom, _options = {})
    {
        super();
        this.#cgl = _cgl;

        let options = _options || {};
        if (external_CABLES_namespaceObject.utils.isNumeric(options))options = { "glPrimitive": _options }; // old constructor fallback...
        this._log = new external_CABLES_SHARED_namespaceObject.Logger("cgl_mesh");
        this._bufVertexAttrib = null;
        this.#bufVerticesIndizes = this.#cgl.gl.createBuffer();
        this._indexType = this.#cgl.gl.UNSIGNED_SHORT;
        this._attributes = [];
        this._attribLocs = {};

        this._lastShader = null;
        this._numInstances = 0;
        this._glPrimitive = options.glPrimitive;

        this.opId = options.opId || "";
        this._preWireframeGeom = null;
        this.addVertexNumbers = false;

        this.feedBackAttributes = [];
        this.setGeom(__geom);

        this._feedBacks = [];
        this._feedBacksChanged = false;
        this._transformFeedBackLoc = -1;
        this._lastAttrUpdate = 0;

        this.memFreed = false;

        this.#cgl.profileData.addHeavyEvent("mesh constructed", this._name);

        this._queryExt = null;
    }

    get geom()
    {
        return this.#geom;
    }

    get numInstances()
    {
        return this._numInstances;
    }

    set numInstances(v)
    {
        this.setNumInstances(v);
    }

    freeMem()
    {
        this.memFreed = true;

        for (let i = 0; i < this._attributes.length; i++)
            this._attributes[i].floatArray = null;
    }

    /**
     * @function updateVertices
     * @memberof Mesh
     * @instance
     * @description update vertices only from a geometry
     * @param {Geometry} geom
     */
    updateVertices(geom)
    {
        this.setAttribute(CONSTANTS.SHADER.SHADERVAR_VERTEX_POSITION, geom.vertices, 3);
        this._numVerts = geom.vertices.length / 3;
    }

    /**
     * @param {String} attrName
     * @param {String} name
     * @param {Number} stride
     * @param {Number} offset
      */
    setAttributePointer(attrName, name, stride, offset)
    {
        for (let i = 0; i < this._attributes.length; i++)
        {
            if (this._attributes[i].name == attrName)
            {
                if (!this._attributes[i].pointer) this._attributes[i].pointer = [];

                this._attributes[i].pointer.push(
                    {
                        "loc": -1,
                        "name": name,
                        "stride": stride,
                        "offset": offset,
                        "instanced": attrName == CONSTANTS.SHADER.SHADERVAR_INSTANCE_MMATRIX,
                    }
                );
            }
        }
    }

    /**
     * @param {String} name
     * @returns {AttributeObject}
     */
    getAttribute(name)
    {
        for (let i = 0; i < this._attributes.length; i++) if (this._attributes[i].name == name) return this._attributes[i];
    }

    setAttributeRange(attr, array, start, end)
    {
        if (!attr) return;
        if (!start && !end) return;

        if (!attr.name)
            this._log.stack("no attrname?!");

        const gl = this.#cgl.gl;

        gl.bindBuffer(gl.ARRAY_BUFFER, attr.buffer);
        this.#cgl.profileData.profileMeshAttributes += (end - start) || 0;

        this.#cgl.profileData.profileSingleMeshAttribute[this._name] = this.#cgl.profileData.profileSingleMeshAttribute[this._name] || 0;
        this.#cgl.profileData.profileSingleMeshAttribute[this._name] += (end - start) || 0;

        if (attr.numItems < array.length / attr.itemSize)
        {
            this._resizeAttr(array, attr);
        }

        if (end > array.length && !this.warned)
        {
            this.warned = true;
            this._log.warn(this.#cgl.canvas.id + " " + attr.name + " buffersubdata out of bounds ?", array.length, end, start, attr);
            return;
        }

        // if (glVersion == 1) gl.bufferSubData(gl.ARRAY_BUFFER, 0, array); // probably slow/ maybe create and array with only changed size ??
        // else
        gl.bufferSubData(gl.ARRAY_BUFFER, start * 4, array, start, (end - start));
    }

    _resizeAttr(array, attr)
    {
        const gl = this.#cgl.gl;

        if (attr.buffer)
            gl.deleteBuffer(attr.buffer);

        attr.buffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, attr.buffer);
        this._bufferArray(array, attr);
        attr.numItems = array.length / attr.itemSize;// numItems;
    }

    _bufferArray(array, attr)
    {
        let floatArray = attr.floatArray || null;
        if (!array) return;

        if (this.#cgl.debugOneFrame)
        {
        console.log("_bufferArray", array.length, attr.name); // eslint-disable-line
        }

        if (!(array instanceof Float32Array))
        {
            if (attr && floatArray && floatArray.length == array.length)
            {
                floatArray.set(array);
            }
            else
            {
                floatArray = new Float32Array(array);

                if (this.#cgl.debugOneFrame)
                {
                console.log("_bufferArray create new float32array", array.length, attr.name); // eslint-disable-line
                }

                if (array.length > 10000)
                {
                    this.#cgl.profileData.profileNonTypedAttrib++;
                    this.#cgl.profileData.profileNonTypedAttribNames = "(" + this._name + ":" + attr.name + ")";
                }
            }
        }
        else floatArray = array;

        attr.arrayLength = floatArray.length;
        attr.floatArray = null;// floatArray;

        this.#cgl.gl.bufferData(this.#cgl.gl.ARRAY_BUFFER, floatArray, this.#cgl.gl.DYNAMIC_DRAW);
    }

    /**
     * @function setAttribute
     * @description update attribute
     * @memberof Mesh
     * @instance
     * @param {String} name
     * @param {Array} array
     * @param {Number} itemSize
     * @param {Object} options
     */
    addAttribute(name, array, itemSize, options)
    {
        this.setAttribute(name, array, itemSize, options);
    }

    /**
     * @param {String} name
     * @param {Array|Float32Array} array
     * @param {Number} itemSize Integer
     * @param {CglMeshAttributeOptions} options
     */
    setAttribute(name, array, itemSize, options = {})
    {
        if (!array)
        {
            this._log.error("mesh addAttribute - no array given! " + name);
            throw new Error();
        }
        let cb = null;
        let instanced = false;
        let i = 0;
        const numItems = array.length / itemSize;

        this.#cgl.profileData.profileMeshAttributes += numItems || 0;

        if (typeof options == "function")
        {
            cb = options;
        }

        if (typeof options == "object")
        {
            if (options.cb) cb = options.cb;
            if (options.instanced) instanced = options.instanced;
        }

        if (name == CONSTANTS.SHADER.SHADERVAR_INSTANCE_MMATRIX) instanced = true;

        for (i = 0; i < this._attributes.length; i++)
        {
            const attr = this._attributes[i];
            if (attr.name == name)
            {
                if (attr.numItems === numItems)
                {
                }
                else
                {
                    this._resizeAttr(array, attr);
                }

                this.#cgl.gl.bindBuffer(this.#cgl.gl.ARRAY_BUFFER, attr.buffer);
                this._bufferArray(array, attr);

                return attr;
            }
        }

        // create new buffer...

        const buffer = this.#cgl.gl.createBuffer();

        this.#cgl.gl.bindBuffer(this.#cgl.gl.ARRAY_BUFFER, buffer);
        // this._cgl.gl.bufferData(this._cgl.gl.ARRAY_BUFFER, floatArray, this._cgl.gl.DYNAMIC_DRAW);

        let type = this.#cgl.gl.FLOAT;
        if (options && options.type) type = options.type;
        const attr = {
            "buffer": buffer,
            "name": name,
            "cb": cb,
            "itemSize": itemSize,
            "numItems": numItems,
            "startItem": 0,
            "instanced": instanced,
            "type": type
        };

        this._bufferArray(array, attr);

        if (name == CONSTANTS.SHADER.SHADERVAR_VERTEX_POSITION) this._bufVertexAttrib = attr;
        this._attributes.push(attr);
        this._attribLocs = {};

        return attr;
    }

    getAttributes()
    {
        return this._attributes;
    }

    /**
     * @function updateTexCoords
     * @description update texture coordinates only from a geometry
     * @memberof Mesh
     * @instance
     * @param {Geometry} geom
     */
    updateTexCoords(geom)
    {
        if (geom.texCoords && geom.texCoords.length > 0)
        {
            this.setAttribute(CONSTANTS.SHADER.SHADERVAR_VERTEX_TEXCOORD, geom.texCoords, 2);
        }
        else
        {
            const tcBuff = new Float32Array(Math.round((geom.vertices.length / 3) * 2));
            this.setAttribute(CONSTANTS.SHADER.SHADERVAR_VERTEX_TEXCOORD, tcBuff, 2);
        }
    }

    /**
     * @function updateNormals
     * @description update normals only from a geometry
     * @memberof Mesh
     * @instance
     * @param {Geometry} geom
     */
    updateNormals(geom)
    {
        if (geom.vertexNormals && geom.vertexNormals.length > 0)
        {
            this.setAttribute(CONSTANTS.SHADER.SHADERVAR_VERTEX_NORMAL, geom.vertexNormals, 3);
        }
        else
        {
            const tcBuff = new Float32Array(Math.round((geom.vertices.length)));
            this.setAttribute(CONSTANTS.SHADER.SHADERVAR_VERTEX_NORMAL, tcBuff, 3);
        }
    }

    /**
     * @param {Array} [arr]
     */
    _setVertexNumbers(arr = null)
    {
        if (!this._verticesNumbers || this._verticesNumbers.length != this._numVerts || arr)
        {
            if (arr) this._verticesNumbers = arr;
            else
            {
                this._verticesNumbers = new Float32Array(this._numVerts);
                for (let i = 0; i < this._numVerts; i++) this._verticesNumbers[i] = i;
            }

            this.setAttribute(CONSTANTS.SHADER.SHADERVAR_VERTEX_NUMBER, this._verticesNumbers, 1, (_attr, _geom, shader) =>
            {
                if (!shader.uniformNumVertices) shader.uniformNumVertices = new Uniform(shader, "f", "numVertices", this._numVerts);
                shader.uniformNumVertices.setValue(this._numVerts);
            });
        }
    }

    /**
     * @function setVertexIndices
     * @description update vertex indices / faces
     * @memberof Mesh
     * @instance
     * @param {array} vertIndices
     */
    setVertexIndices(vertIndices)
    {
        if (!this.#bufVerticesIndizes)
        {
            this._log.warn("no bufVerticesIndizes: " + this._name);
            return;
        }
        if (vertIndices.length > 0)
        {
            if (vertIndices instanceof Float32Array) this._log.warn("vertIndices float32Array: " + this._name);

            for (let i = 0; i < vertIndices.length; i++)
            {
                if (vertIndices[i] >= this._numVerts)
                {
                    this._log.warn("invalid index in " + this._name, i, vertIndices[i]);
                    return;
                }
            }

            this.#cgl.gl.bindBuffer(this.#cgl.gl.ELEMENT_ARRAY_BUFFER, this.#bufVerticesIndizes);

            /*
             * todo cache this ?
             * if(!this.vertIndicesTyped || this.vertIndicesTyped.length!=this._geom.verticesIndices.length)
             */

            if (vertIndices.length > 65535)
            {
                this.vertIndicesTyped = new Uint32Array(vertIndices);
                this._indexType = this.#cgl.gl.UNSIGNED_INT;
            }
            else
            if (vertIndices instanceof Uint32Array)
            {
                this.vertIndicesTyped = vertIndices;
                this._indexType = this.#cgl.gl.UNSIGNED_INT;
            }
            else
            if (!(vertIndices instanceof Uint16Array))
            {
                this.vertIndicesTyped = new Uint16Array(vertIndices);
                this._indexType = this.#cgl.gl.UNSIGNED_SHORT;
            }
            else this.vertIndicesTyped = vertIndices;

            this.#cgl.gl.bufferData(this.#cgl.gl.ELEMENT_ARRAY_BUFFER, this.vertIndicesTyped, this.#cgl.gl.DYNAMIC_DRAW);
            this.#bufVerticesIndizes.itemSize = 1;
            this.#bufVerticesIndizes.numItems = vertIndices.length;
        }
        else this.#bufVerticesIndizes.numItems = 0;
    }

    /**
     * @function setGeom
     * @memberof Mesh
     * @instance
     * @description set geometry for mesh
     * @param {Geometry} geom
     * @param {boolean} removeRef
     */
    setGeom(geom, removeRef = false)
    {
        this.#geom = geom;
        if (geom.glPrimitive != null) this._glPrimitive = geom.glPrimitive;
        if (this.#geom && this.#geom.name) this._name = "mesh " + this.#geom.name;

        MESH.lastMesh = null;
        this.#cgl.profileData.profileMeshSetGeom++;

        this._disposeAttributes();

        this.updateVertices(this.#geom);
        this.setVertexIndices(this.#geom.verticesIndices);

        if (this.addVertexNumbers) this._setVertexNumbers();

        const geomAttribs = this.#geom.getAttributes();

        const attribAssoc = {
            "texCoords": CONSTANTS.SHADER.SHADERVAR_VERTEX_TEXCOORD,
            "vertexNormals": CONSTANTS.SHADER.SHADERVAR_VERTEX_NORMAL,
            "vertexColors": CONSTANTS.SHADER.SHADERVAR_VERTEX_COLOR,
            "tangents": "attrTangent",
            "biTangents": "attrBiTangent",
        };

        for (const index in geomAttribs)
            if (geomAttribs[index].data && geomAttribs[index].data.length)
                this.setAttribute(attribAssoc[index] || index, geomAttribs[index].data, geomAttribs[index].itemSize);

        if (removeRef)
        {
            this.#geom = null;
        }
    }

    _preBind(shader)
    {
        for (let i = 0; i < this._attributes.length; i++)
            if (this._attributes[i].cb)
                this._attributes[i].cb(this._attributes[i], this.#geom, shader);
    }

    _checkAttrLengths()
    {
        if (this.memFreed) return;
        // check length
        for (let i = 0; i < this._attributes.length; i++)
        {
            if (this._attributes[i].arrayLength / this._attributes[i].itemSize < this._attributes[0].arrayLength / this._attributes[0].itemSize)
            {
                let name = "unknown";
                if (this.#geom)name = this.#geom.name;

            /*
             * this._log.warn(
             *     name + ": " + this._attributes[i].name +
             *     " wrong attr length. is:", this._attributes[i].arrayLength / this._attributes[i].itemSize,
             *     " should be:", this._attributes[0].arrayLength / this._attributes[0].itemSize,
             * );
             */
            }
        }
    }

    _bind(shader)
    {
        if (!shader) return;
        if (!shader.isValid()) return;

        let attrLocs = [];
        if (this._attribLocs[shader.id]) attrLocs = this._attribLocs[shader.id];
        else this._attribLocs[shader.id] = attrLocs;

        this._lastShader = shader;
        if (shader.lastCompile > this._lastAttrUpdate || attrLocs.length != this._attributes.length)
        {
            this._lastAttrUpdate = shader.lastCompile;
            for (let i = 0; i < this._attributes.length; i++) attrLocs[i] = -1;
        }

        for (let i = 0; i < this._attributes.length; i++)
        {
            const attribute = this._attributes[i];
            if (attrLocs[i] == -1)
            {
                if (attribute._attrLocationLastShaderTime != shader.lastCompile)
                {
                    attribute._attrLocationLastShaderTime = shader.lastCompile;
                    attrLocs[i] = this.#cgl.glGetAttribLocation(shader.getProgram(), attribute.name);
                    // this._log.log('attribloc',attribute.name,attrLocs[i]);
                    this.#cgl.profileData.profileAttrLoc++;
                }
            }

            if (attrLocs[i] != -1)
            {
                this.#cgl.gl.enableVertexAttribArray(attrLocs[i]);
                this.#cgl.gl.bindBuffer(this.#cgl.gl.ARRAY_BUFFER, attribute.buffer);

                if (attribute.instanced)
                {
                // todo: easier way to fill mat4 attribs...
                    if (attribute.itemSize <= 4)
                    {
                        if (!attribute.itemSize || attribute.itemSize == 0) this._log.warn("instanced attrib itemsize error", this.#geom.name, attribute);

                        this.#cgl.gl.vertexAttribPointer(attrLocs[i], attribute.itemSize, attribute.type, false, attribute.itemSize * 4, 0);
                        this.#cgl.gl.vertexAttribDivisor(attrLocs[i], 1);
                    }
                    else if (attribute.itemSize == 16)
                    {
                        const stride = 16 * 4;

                        this.#cgl.gl.vertexAttribPointer(attrLocs[i], 4, attribute.type, false, stride, 0);
                        this.#cgl.gl.enableVertexAttribArray(attrLocs[i] + 1);
                        this.#cgl.gl.vertexAttribPointer(attrLocs[i] + 1, 4, attribute.type, false, stride, 4 * 4 * 1);
                        this.#cgl.gl.enableVertexAttribArray(attrLocs[i] + 2);
                        this.#cgl.gl.vertexAttribPointer(attrLocs[i] + 2, 4, attribute.type, false, stride, 4 * 4 * 2);
                        this.#cgl.gl.enableVertexAttribArray(attrLocs[i] + 3);
                        this.#cgl.gl.vertexAttribPointer(attrLocs[i] + 3, 4, attribute.type, false, stride, 4 * 4 * 3);

                        this.#cgl.gl.vertexAttribDivisor(attrLocs[i], 1);
                        this.#cgl.gl.vertexAttribDivisor(attrLocs[i] + 1, 1);
                        this.#cgl.gl.vertexAttribDivisor(attrLocs[i] + 2, 1);
                        this.#cgl.gl.vertexAttribDivisor(attrLocs[i] + 3, 1);
                    }
                    else
                    {
                        this._log.warn("unknown instance attrib size", attribute.name);
                    }
                }
                else
                {
                    if (!attribute.itemSize || attribute.itemSize == 0) this._log.warn("attrib itemsize error", this._name, attribute);
                    this.#cgl.gl.vertexAttribPointer(attrLocs[i], attribute.itemSize, attribute.type, false, attribute.itemSize * 4, 0);

                    if (attribute.pointer)
                    {
                        for (let ip = 0; ip < attribute.pointer.length; ip++)
                        {
                            const pointer = attribute.pointer[ip];

                            if (pointer.loc == -1)
                                pointer.loc = this.#cgl.glGetAttribLocation(shader.getProgram(), pointer.name);

                            this.#cgl.profileData.profileAttrLoc++;

                            this.#cgl.gl.enableVertexAttribArray(pointer.loc);
                            this.#cgl.gl.vertexAttribPointer(pointer.loc, attribute.itemSize, attribute.type, false, pointer.stride, pointer.offset);
                        }
                    }
                    if (this.bindFeedback) this.bindFeedback(attribute);
                }
            }
        }

        if (this.#bufVerticesIndizes && this.#bufVerticesIndizes.numItems !== 0) this.#cgl.gl.bindBuffer(this.#cgl.gl.ELEMENT_ARRAY_BUFFER, this.#bufVerticesIndizes);
    }

    unBind()
    {
        const shader = this._lastShader;
        this._lastShader = null;
        if (!shader) return;

        let attrLocs = [];
        if (this._attribLocs[shader.id]) attrLocs = this._attribLocs[shader.id];
        else this._attribLocs[shader.id] = attrLocs;

        MESH.lastMesh = null;

        for (let i = 0; i < this._attributes.length; i++)
        {
            if (this._attributes[i].instanced)
            {
            // todo: easier way to fill mat4 attribs...
                if (this._attributes[i].itemSize <= 4)
                {
                    if (attrLocs[i] != -1) this.#cgl.gl.vertexAttribDivisor(attrLocs[i], 0);
                    if (attrLocs[i] >= 0) this.#cgl.gl.disableVertexAttribArray(attrLocs[i]);
                }
                else
                {
                    this.#cgl.gl.vertexAttribDivisor(attrLocs[i], 0);
                    this.#cgl.gl.vertexAttribDivisor(attrLocs[i] + 1, 0);
                    this.#cgl.gl.vertexAttribDivisor(attrLocs[i] + 2, 0);
                    this.#cgl.gl.vertexAttribDivisor(attrLocs[i] + 3, 0);
                    this.#cgl.gl.disableVertexAttribArray(attrLocs[i] + 1);
                    this.#cgl.gl.disableVertexAttribArray(attrLocs[i] + 2);
                    this.#cgl.gl.disableVertexAttribArray(attrLocs[i] + 3);
                }
            }

            if (attrLocs[i] != -1) this.#cgl.gl.disableVertexAttribArray(attrLocs[i]);

        }
    }

    meshChanged()
    {
        return this.#cgl.lastMesh && this.#cgl.lastMesh != this;
    }

    printDebug()
    {
        console.log("--attributes");
        for (let i = 0; i < this._attributes.length; i++)
        {
            console.log("attribute " + i + " " + this._attributes[i].name);
        }
    }

    /**
     * @param {Number} num
     */
    setNumVertices(num)
    {
        // this._bufVerticesIndizes.numItems = num;
        this._bufVertexAttrib.numItems = num;
    }

    /**
     * @returns {Number}
     */
    getNumVertices()
    {
        // return this._bufVerticesIndizes.numItems;
        return this._bufVertexAttrib.numItems;
    }

    /**
     * @param {Number} num
     */
    setNumIndices(num)
    {
        this.#bufVerticesIndizes.numItems = num;
    }

    /**
     * @returns {Number}
     */
    getNumIndices()
    {
        return this.#bufVerticesIndizes.numItems;
    }

    /**
     * @function render
     * @memberof Mesh
     * @instance
     * @description draw mesh to screen
     * @param {CgShader} shader
     */
    render(shader)
    {
        // TODO: enable/disablevertex only if the mesh has changed... think drawing 10000x the same mesh

        if (this.#cgl.aborted) return;
        shader = shader || this.#cgl.getShader();

        if (!shader)
        {
            return console.log("shadern not valid");
        }

        if (!shader.isValid())
        {
            shader = this.#cgl.getErrorShader();
        }

        this._checkAttrLengths();

        if (this.#geom)
        {
            if (this._preWireframeGeom && !shader.wireframe && !this.#geom.isIndexed())
            {
                this.setGeom(this._preWireframeGeom);
                this._preWireframeGeom = null;
            }

            if (shader.wireframe)
            {
                let changed = false;

                if (this.#geom.isIndexed())
                {
                    if (!this._preWireframeGeom)
                    {
                        this._preWireframeGeom = this.#geom;
                        this.#geom = this.#geom.copy();
                    }

                    this.#geom.unIndex();
                    changed = true;
                }

                if (!this.#geom.getAttribute("attrBarycentric"))
                {
                    if (!this._preWireframeGeom)
                    {
                        this._preWireframeGeom = this.#geom;
                        this.#geom = this.#geom.copy();
                    }
                    changed = true;

                    this.#geom.calcBarycentric();
                }
                if (changed) this.setGeom(this.#geom);
            }
        }

        let needsBind = false;
        if (MESH.lastMesh != this)
        {
            if (MESH.lastMesh) MESH.lastMesh.unBind();
            needsBind = true;
        }

        if (needsBind) this._preBind(shader);

        if (!shader.bind()) return;

        this._bind(shader);
        if (this.addVertexNumbers) this._setVertexNumbers();

        MESH.lastMesh = this;

        let prim = this.#cgl.gl.TRIANGLES;
        if (this._glPrimitive !== undefined) prim = this._glPrimitive;
        if (shader.glPrimitive !== null) prim = shader.glPrimitive;

        let elementDiv = 1;
        let doQuery = this.#cgl.profileData.doProfileGlQuery;
        let queryStarted = false;
        if (doQuery)
        {
            let id = this._name + " - " + shader.getName() + " #" + shader.id;
            if (this._numInstances) id += " instanced " + this._numInstances + "x";

            let queryProfilerData = this.#cgl.profileData.glQueryData[id];

            if (!queryProfilerData) queryProfilerData = { "id": id, "num": 0 };

            if (shader.opId)queryProfilerData.shaderOp = shader.opId;
            if (this.opId)queryProfilerData.meshOp = this.opId;

            this.#cgl.profileData.glQueryData[id] = queryProfilerData;

            if (!this._queryExt && this._queryExt !== false) this._queryExt = this.#cgl.enableExtension("EXT_disjoint_timer_query_webgl2") || false;
            if (this._queryExt)
            {
                if (queryProfilerData._drawQuery)
                {
                    const available = this.#cgl.gl.getQueryParameter(queryProfilerData._drawQuery, this.#cgl.gl.QUERY_RESULT_AVAILABLE);
                    if (available)
                    {
                        const elapsedNanos = this.#cgl.gl.getQueryParameter(queryProfilerData._drawQuery, this.#cgl.gl.QUERY_RESULT);
                        const currentTimeGPU = elapsedNanos / 1000000;

                        queryProfilerData._times = queryProfilerData._times || 0;
                        queryProfilerData._times += currentTimeGPU;
                        queryProfilerData._numcount++;
                        queryProfilerData.when = performance.now();
                        queryProfilerData._drawQuery = null;
                        queryProfilerData.queryStarted = false;
                    }
                }

                if (!queryProfilerData.queryStarted)
                {
                    queryProfilerData._drawQuery = this.#cgl.gl.createQuery();
                    this.#cgl.gl.beginQuery(this._queryExt.TIME_ELAPSED_EXT, queryProfilerData._drawQuery);
                    queryStarted = queryProfilerData.queryStarted = true;
                }
            }
        }

        if (this.hasFeedbacks && this.hasFeedbacks()) this.drawFeedbacks(shader, prim);
        else if (!this.#bufVerticesIndizes || this.#bufVerticesIndizes.numItems === 0)
        {

            /*
             * for (let i = 0; i < this._attributes.length; i++)
             * {
             *     if (this._attributes[i].arrayLength / this._attributes[i].itemSize != this._bufVertexAttrib.floatArray.length / 3)
             *     {
             *         this._log.warn("attrib buffer length wrong! ", this._attributes[i].name, this._attributes[i].arrayLength / this._attributes[i].itemSize, this._bufVertexAttrib.floatArray.length / 3, this._attributes[i].itemSize);
             *         // this._log.log(this);
             *         // debugger;
             *         return;
             *     }
             * }
             */

            if (prim == this.#cgl.gl.TRIANGLES)elementDiv = 3;

            if (this._numInstances === 0) this.#cgl.gl.drawArrays(prim, this._bufVertexAttrib.startItem, this._bufVertexAttrib.numItems - this._bufVertexAttrib.startItem);
            else this.#cgl.gl.drawArraysInstanced(prim, this._bufVertexAttrib.startItem, this._bufVertexAttrib.numItems, this._numInstances);
        }
        else
        {
            if (prim == this.#cgl.gl.TRIANGLES)elementDiv = 3;
            if (this._numInstances === 0)
            {
                this.#cgl.gl.drawElements(prim, this.#bufVerticesIndizes.numItems, this._indexType, 0);
            }
            else
            {
                this.#cgl.gl.drawElementsInstanced(prim, this.#bufVerticesIndizes.numItems, this._indexType, 0, this._numInstances);
            }
        }

        if (this.#cgl.debugOneFrame && this.#cgl.gl.getError() != this.#cgl.gl.NO_ERROR)
        {
            this._log.error("mesh draw gl error");
            this._log.error("mesh", this);
            this._log.error("shader", shader);

            const attribNames = [];
            for (let i = 0; i < this.#cgl.gl.getProgramParameter(shader.getProgram(), this.#cgl.gl.ACTIVE_ATTRIBUTES); i++)
            {
                const name = this.#cgl.gl.getActiveAttrib(shader.getProgram(), i).name;
                this._log.error("attrib ", name);
            }
        }

        this.#cgl.profileData.profileMeshNumElements += (this._bufVertexAttrib.numItems / elementDiv) * (this._numInstances || 1);
        this.#cgl.profileData.profileMeshDraw++;

        if (doQuery && queryStarted)
        {
            this.#cgl.gl.endQuery(this._queryExt.TIME_ELAPSED_EXT);
        }

        this.#cgl.printError("mesh render " + this._name);

        this.unBind();
    }

    setNumInstances(n)
    {
        n = Math.max(0, n);
        if (this._numInstances != n)
        {
            this._numInstances = n;
            const indexArr = new Float32Array(n);
            for (let i = 0; i < n; i++) indexArr[i] = i;
            this.setAttribute(CONSTANTS.SHADER.SHADERVAR_INSTANCE_INDEX, indexArr, 1, { "instanced": true });
        }
    }

    _disposeAttributes()
    {
        if (!this._attributes) return;

        for (let i = 0; i < this._attributes.length; i++)
        {
            if (this._attributes[i].buffer)
            {
                this.#cgl.gl.deleteBuffer(this._attributes[i].buffer);
                this._attributes[i].buffer = null;
            }
        }
        this._attributes.length = 0;
    }

    dispose()
    {
        if (this.#cgl.aborted) return;
        if (this._bufVertexAttrib && this._bufVertexAttrib.buffer) this.#cgl.gl.deleteBuffer(this._bufVertexAttrib.buffer);
        if (this.#bufVerticesIndizes) this.#cgl.gl.deleteBuffer(this.#bufVerticesIndizes);
        this.#bufVerticesIndizes = null;

        this._disposeAttributes();
    }
}



;// CONCATENATED MODULE: external "CABLES.GLMatrix"
const external_CABLES_GLMatrix_namespaceObject = CABLES.GLMatrix;
;// CONCATENATED MODULE: ./src/corelibs/cg/cg_boundingbox.js





/**
 * bounding box
 *
 * @namespace external:CGL
 * @param {Geometry} geometry or bounding box
 */
class BoundingBox
{

    /**
     * @param {Geometry} [geom]
     */
    constructor(geom)
    {
        this._init();
        this._first = true;
        this._wireMesh = null;

        if (geom) this.applyGeom(geom);
    }

    _init()
    {
        this._max = [-0, -0, -0];
        this._min = [0, 0, 0];
        this._center = [0, 0, 0];
        this._size = [0, 0, 0];
        this._maxAxis = 0.0;
        this._first = true;
    }

    /**
     * get biggest number of maxX,maxY,maxZ
     * @type {Number}
     */
    get maxAxis() { return this._maxAxis || 1; }

    /**
     * size of bounding box
     * @type {vec3}
     */
    get size() { return this._size; }

    /**
     * center of bounding box
     * @type {vec3}
     */
    get center() { return this._center; }

    /**
     * center x
     * @type {Number}
     */
    get x() { return this._center[0]; }

    /**
     * center y
     * @type {Number}
     */
    get y() { return this._center[1]; }

    /**
     * center z
     * @type {Number}
     */
    get z() { return this._center[2]; }

    /**
     * minimum x
     * @type {Number}
     */
    get minX() { return this._min[0]; }

    /**
     * minimum y
     * @type {Number}
     */
    get minY() { return this._min[1]; }

    /**
     * minimum z
     * @type {Number}
     */
    get minZ() { return this._min[2]; }

    /**
     * maximum x
     * @type {Number}
     */
    get maxX() { return this._max[0]; }

    /**
     * maximum y
     * @type {Number}
     */
    get maxY() { return this._max[1]; }

    /**
     * maximum z
     * @type {Number}
     */
    get maxZ() { return this._max[2]; }

    /**
     * @deprecated
     * @param {Geometry} geom
     */
    apply(geom)
    {
        return this.applyGeom(geom);
    }

    /**
     * @param {Geometry} geom
     */
    applyGeom(geom)
    {
        if (!geom) return;

        if (geom instanceof BoundingBox)
        {
            const bb = geom;

            this.applyPos(bb.maxX, bb.maxY, bb.maxZ);
            this.applyPos(bb.minX, bb.minY, bb.minZ);
        }
        else
        {
            if (geom.isGeometry)
                for (let i = 0; i < geom.vertices.length; i += 3)
                    this.applyPos(geom.vertices[i], geom.vertices[i + 1], geom.vertices[i + 2]);
        }
        this.calcCenterSize();
    }

    /**
     * returns a copy of the bounding box
     * @function copy
     * @memberof BoundingBox
     * @instance
     */
    copy()
    {
        return new BoundingBox(this);
    }

    get changed()
    {
        return !(this._max[0] == -Number.MAX_VALUE && this._max[1] == -Number.MAX_VALUE && this._max[2] == -Number.MAX_VALUE);
    }

    /**
     * @param {number} x
     * @param {number} y
     * @param {number} z
     */
    applyPos(x, y, z)
    {
        if (x == Number.MAX_VALUE || x == -Number.MAX_VALUE ||
            y == Number.MAX_VALUE || y == -Number.MAX_VALUE ||
            z == Number.MAX_VALUE || z == -Number.MAX_VALUE) return;

        if (!external_CABLES_namespaceObject.utils.isNumeric(x) || !external_CABLES_namespaceObject.utils.isNumeric(y) || !external_CABLES_namespaceObject.utils.isNumeric(z)) return;

        if (this._first)
        {
            this._max[0] = x;
            this._max[1] = y;
            this._max[2] = z;

            this._min[0] = x;
            this._min[1] = y;
            this._min[2] = z;
            this._first = false;
            return;
        }

        this._max[0] = Math.max(this._max[0], x);
        this._max[1] = Math.max(this._max[1], y);
        this._max[2] = Math.max(this._max[2], z);

        this._min[0] = Math.min(this._min[0], x);
        this._min[1] = Math.min(this._min[1], y);
        this._min[2] = Math.min(this._min[2], z);
    }

    calcCenterSize()
    {
        if (this._first) return;

        this._size[0] = this._max[0] - this._min[0];
        this._size[1] = this._max[1] - this._min[1];
        this._size[2] = this._max[2] - this._min[2];

        this._center[0] = (this._min[0] + this._max[0]) / 2;
        this._center[1] = (this._min[1] + this._max[1]) / 2;
        this._center[2] = (this._min[2] + this._max[2]) / 2;

        this._maxAxis = Math.max(this._size[2], Math.max(this._size[0], this._size[1]));
    }

    /**
     * @param {mat4} m
     */
    mulMat4(m)
    {
        if (this._first)
        {
            this._max[0] = 0;
            this._max[1] = 0;
            this._max[2] = 0;

            this._min[0] = 0;
            this._min[1] = 0;
            this._min[2] = 0;
            this._first = false;
        }
        external_CABLES_GLMatrix_namespaceObject.vec3.transformMat4(this._max, this._max, m);
        external_CABLES_GLMatrix_namespaceObject.vec3.transformMat4(this._min, this._min, m);
        this.calcCenterSize();
    }

    /**
     * @param {CglContext} cgl
     * @param {Shader} _shader
     * @param {Op} op
     */
    render(cgl, _shader, op)
    {
        if (!this._wireMesh) this._wireMesh = new CGL.WireCube(cgl);

        cgl.pushModelMatrix();
        external_CABLES_GLMatrix_namespaceObject.mat4.translate(cgl.mMatrix, cgl.mMatrix, this._center);

        if (CABLES.UI && op)
        {
            CABLES.UI.OverlayMeshes.drawCube(op, this._size[0] / 2, this._size[1] / 2, this._size[2] / 2);
        }

        cgl.popModelMatrix();
    }
}

;// CONCATENATED MODULE: ./src/corelibs/cg/cg_geom.js





/**
 * a geometry contains all information about a mesh, vertices, texturecoordinates etc. etc.
 * @param {String} name
 * @example
 * // create a triangle with all attributes
 * const geom=new Geometry("triangle"),
 *
 * geom.vertices = [
 *      0.0,           sizeH.get(),  0.0,
 *     -sizeW.get(),  -sizeH.get(),  0.0,
 *      sizeW.get(),  -sizeH.get(),  0.0 ];
 *
 * geom.vertexNormals = [
 *      0.0,  0.0,  1.0,
 *      0.0,  0.0,  1.0,
 *      0.0,  0.0,  1.0 ];
 *
 * geom.tangents = [
 *     1,0,0,
 *     1,0,0,
 *     1,0,0 ];
 *
 * geom.biTangents = [
 *     0,1,0,
 *     0,1,0,
 *     0,1,0 ];
 *
 * geom.texCoords = [
 *      0.5,  0.0,
 *      1.0,  1.0,
 *      0.0,  1.0, ];
 *
 * geom.verticesIndices = [
 *     0, 1, 2 ];
 *
 */

class Geometry
{
    isGeometry = true;

    /**
     * @param {String} name
    */
    constructor(name)
    {
        this.name = name || "unknown";
        this._log = new external_CABLES_SHARED_namespaceObject.Logger("cgl_geometry");

        this.faceVertCount = 3;
        this.glPrimitive = null;
        this._attributes = {};

        /** @type {Array|Float32Array} */
        this._vertices = [];

        /** @type {Array} */
        this.verticesIndices = [];

        this.morphTargets = [];
    }

    get vertices()
    {
        return this._vertices;
    }

    set vertices(v)
    {
        this.setVertices(v);
    }

    get texCoords()
    {
        const att = this.getAttribute("texCoords");
        if (!att) return [];
        return att.data;
    }

    set texCoords(v)
    {
        this.setAttribute("texCoords", v, 2);
    }

    get vertexNormals()
    {
        const att = this.getAttribute("vertexNormals");
        if (!att) return [];
        return att.data;
    }

    set vertexNormals(v)
    {
        this.setAttribute("vertexNormals", v, 3);
    }

    get tangents()
    {
        const att = this.getAttribute("tangents");
        if (!att) return [];
        return att.data;
    }

    set tangents(v)
    {
        this.setAttribute("tangents", v, 3);
    }

    get biTangents()
    {
        const att = this.getAttribute("biTangents");
        if (!att) return [];
        return att.data;
    }

    set biTangents(v)
    {
        this.setAttribute("biTangents", v, 3);
    }

    get vertexColors()
    {
        const att = this.getAttribute("vertexColors");
        if (!att) return [];
        return att.data;
    }

    set vertexColors(v)
    {
        this.setAttribute("vertexColors", v, 4);
    }

    /**
     * @description clear all buffers/set them to length 0
     */
    clear()
    {
        this._vertices = new Float32Array([]);
        this.verticesIndices = [];
        this.texCoords = new Float32Array([]);
        this.vertexNormals = new Float32Array([]);
        this.tangents = [];
        this.biTangents = [];
        this._attributes = {};
    }

    /**
    * @return {Object} returns array of attribute objects
    */
    getAttributes()
    {
        return this._attributes;
    }

    /**
     * @function getAttribute
     * @memberof Geometry
     * @instance
     * @param {String} name
     * @return {Object}
     */
    getAttribute(name)
    {
        for (const i in this._attributes)
        {
            if (this._attributes[i].name == name) return this._attributes[i];
        }
        return null;
    }

    /**
     * @function setAttribute
     * @description create an attribute
     * @memberof Geometry
     * @instance
     * @param {String} name
     * @param {Array} arr
     * @param {Number} itemSize
     */
    setAttribute(name, arr, itemSize)
    {
        let attrType = "";
        if (!itemSize || itemSize > 4)
        {
            this._log.warn("itemsize wrong?", itemSize, name);
            this._log.stack("itemsize");

            itemSize = 3;
        }

        if (itemSize == 1) attrType = "float";
        else if (itemSize == 2) attrType = "vec2";
        else if (itemSize == 3) attrType = "vec3";
        else if (itemSize == 4) attrType = "vec4";

        const attr = {
            "name": name,
            "data": arr,
            "itemSize": itemSize,
            "type": attrType,
        };

        this._attributes[name] = attr;
    }

    /**
     * @param {string} name
     * @param {Geometry} newgeom
     */
    copyAttribute(name, newgeom)
    {
        const attr = this.getAttribute(name);
        newgeom.setAttribute(name, new Float32Array(attr.data), attr.itemSize);
    }

    /**
     * @function setVertices
     * @memberof Geometry
     * @instance
     * @description set vertices
     * @param {Array|Float32Array} arr [x,y,z,x,y,z,...]
     */
    setVertices(arr)
    {
        if (arr instanceof Float32Array) this._vertices = arr;
        else this._vertices = new Float32Array(arr);
    }

    /**
     * set texcoords
     * @param {Array|Float32Array} arr [u,v,u,v,...]
     */
    setTexCoords(arr)
    {
        if (arr instanceof Float32Array) this.texCoords = arr;
        else this.texCoords = new Float32Array(arr);
    }

    // deprecated
    calcNormals(smooth)
    {
        const options = { "smooth": smooth };
        this.calculateNormals(options);
    }

    /**
     * @param {number} x
     * @param {number} y
     * @param {number} z
     */
    flipNormals(x, y, z)
    {
        let vec = external_CABLES_GLMatrix_namespaceObject.vec3.create();

        if (x == undefined)x = 1;
        if (y == undefined)y = 1;
        if (z == undefined)z = 1;

        for (let i = 0; i < this.vertexNormals.length; i += 3)
        {
            external_CABLES_GLMatrix_namespaceObject.vec3.set(vec,
                this.vertexNormals[i + 0],
                this.vertexNormals[i + 1],
                this.vertexNormals[i + 2]);

            vec[0] *= -x;
            vec[1] *= -y;
            vec[2] *= -z;

            external_CABLES_GLMatrix_namespaceObject.vec3.normalize(vec, vec);

            this.vertexNormals[i + 0] = vec[0];
            this.vertexNormals[i + 1] = vec[1];
            this.vertexNormals[i + 2] = vec[2];
        }
    }

    getNumTriangles()
    {
        if (this.verticesIndices && this.verticesIndices.length) return this.verticesIndices.length / 3;
        return this.vertices.length / 3;
    }

    /**
     * flip order of vertices in geom faces
     */
    flipVertDir()
    {
        const newInd = [];
        newInd.length = this.verticesIndices.length;
        for (let i = 0; i < this.verticesIndices.length; i += 3)
        {
            newInd[i] = this.verticesIndices[i + 2];
            newInd[i + 1] = this.verticesIndices[i + 1];
            newInd[i + 2] = this.verticesIndices[i];
        }
        this.verticesIndices = newInd;
    }

    /**
     * @param {Array} verts
     */
    setPointVertices(verts)
    {
        if (verts.length % 3 !== 0)
        {
            this._log.error("SetPointVertices: Array must be multiple of three.");
            return;
        }

        if (!(verts instanceof Float32Array)) this.vertices = new Float32Array(verts);
        else this.vertices = verts;

        if (!(this.texCoords instanceof Float32Array)) this.texCoords = new Float32Array((verts.length / 3) * 2);

        // this.texCoords.length=verts.length/3*2;
        this.verticesIndices.length = verts.length / 3;
        // this.verticesIndices=[];

        for (let i = 0; i < verts.length / 3; i++)
        {
            this.verticesIndices[i] = i;
            this.texCoords[i * 2] = 0;
            this.texCoords[i * 2 + 1] = 0;
        }
    }

    /**
     * merge a different geometry into the this geometry
     * @param {Geometry} geom
     */
    merge(geom)
    {
        if (!geom) return;

        if (this.isIndexed() != geom.isIndexed())
        {
            if (this.isIndexed())
            {
                this.unIndex(false, true);
            }
            if (geom.isIndexed())
            {
                const g = geom.copy();
                g.unIndex(false, true);
                geom = g;
            }
        }

        const oldIndizesLength = this.verticesIndices.length;
        const vertLength = this._vertices.length / 3;

        this.verticesIndices.length += geom.verticesIndices.length;
        for (let i = 0; i < geom.verticesIndices.length; i++)
            this.verticesIndices[oldIndizesLength + i] = geom.verticesIndices[i] + vertLength;

        this.vertices = external_CABLES_namespaceObject.utils.float32Concat(this._vertices, geom.vertices);
        this.texCoords = external_CABLES_namespaceObject.utils.float32Concat(this.texCoords, geom.texCoords);
        this.vertexNormals = external_CABLES_namespaceObject.utils.float32Concat(this.vertexNormals, geom.vertexNormals);
        this.tangents = external_CABLES_namespaceObject.utils.float32Concat(this.tangents, geom.tangents);
        this.biTangents = external_CABLES_namespaceObject.utils.float32Concat(this.biTangents, geom.biTangents);
    }

    /**
     *   a copy of the geometry
     * @function copy
     * @memberof Geometry
     * @instance
     */
    copy()
    {
        const geom = new Geometry(this.name + " copy");
        geom.faceVertCount = this.faceVertCount;
        geom.glPrimitive = this.glPrimitive;

        geom.setVertices(this._vertices.slice(0));

        if (this.verticesIndices)
        {
            geom.verticesIndices.length = this.verticesIndices.length;
            for (let i = 0; i < this.verticesIndices.length; i++) geom.verticesIndices[i] = this.verticesIndices[i];
        }

        for (let i in this._attributes) this.copyAttribute(i, geom);

        geom.morphTargets.length = this.morphTargets.length;
        for (let i = 0; i < this.morphTargets.length; i++) geom.morphTargets[i] = this.morphTargets[i];

        return geom;
    }

    /**
     * Calculaten normals
     * @function calculateNormals
     * @param {{ smooth?: any; forceZUp?: any; }} options
     */
    calculateNormals(options = null)
    {
        // todo: should check angle of normals to get edges    https://community.khronos.org/t/calculating-accurate-vertex-normals/28152
        options = options || {};
        if (options.smooth === false) this.unIndex();

        const u = external_CABLES_GLMatrix_namespaceObject.vec3.create();
        const v = external_CABLES_GLMatrix_namespaceObject.vec3.create();
        const n = external_CABLES_GLMatrix_namespaceObject.vec3.create();

        function calcNormal(triangle)
        {
            external_CABLES_GLMatrix_namespaceObject.vec3.subtract(u, triangle[0], triangle[1]);
            external_CABLES_GLMatrix_namespaceObject.vec3.subtract(v, triangle[0], triangle[2]);
            external_CABLES_GLMatrix_namespaceObject.vec3.cross(n, u, v);
            external_CABLES_GLMatrix_namespaceObject.vec3.normalize(n, n);

            if (options && options.forceZUp)
            {
                if (n[2] < 0)
                {
                    n[0] *= -1;
                    n[1] *= -1;
                    n[2] *= -1;
                }
            }
            return n;
        }

        this.getVertexVec = function (which)
        {
            const vec = [0, 0, 0];
            vec[0] = this.vertices[which * 3 + 0];
            vec[1] = this.vertices[which * 3 + 1];
            vec[2] = this.vertices[which * 3 + 2];
            return vec;
        };

        if (!(this.vertexNormals instanceof Float32Array) || this.vertexNormals.length != this.vertices.length) this.vertexNormals = new Float32Array(this.vertices.length);

        for (let i = 0; i < this.vertices.length; i++)
        {
            this.vertexNormals[i] = 0;
        }

        if (!this.isIndexed())
        {
            const norms = [];
            for (let i = 0; i < this.vertices.length; i += 9)
            {
                const triangle = [[this.vertices[i + 0], this.vertices[i + 1], this.vertices[i + 2]], [this.vertices[i + 3], this.vertices[i + 4], this.vertices[i + 5]], [this.vertices[i + 6], this.vertices[i + 7], this.vertices[i + 8]]];
                const nn = calcNormal(triangle);
                norms.push(nn[0], nn[1], nn[2], nn[0], nn[1], nn[2], nn[0], nn[1], nn[2]);
            }
            this.vertexNormals = norms;
        }
        else
        {
            const faceNormals = [];

            faceNormals.length = Math.floor(this.verticesIndices.length / 3);

            for (let i = 0; i < this.verticesIndices.length; i += 3)
            {
                const triangle = [this.getVertexVec(this.verticesIndices[i + 0]), this.getVertexVec(this.verticesIndices[i + 1]), this.getVertexVec(this.verticesIndices[i + 2])];

                faceNormals[i / 3] = calcNormal(triangle);

                this.vertexNormals[this.verticesIndices[i + 0] * 3 + 0] += faceNormals[i / 3][0];
                this.vertexNormals[this.verticesIndices[i + 0] * 3 + 1] += faceNormals[i / 3][1];
                this.vertexNormals[this.verticesIndices[i + 0] * 3 + 2] += faceNormals[i / 3][2];

                this.vertexNormals[this.verticesIndices[i + 1] * 3 + 0] += faceNormals[i / 3][0];
                this.vertexNormals[this.verticesIndices[i + 1] * 3 + 1] += faceNormals[i / 3][1];
                this.vertexNormals[this.verticesIndices[i + 1] * 3 + 2] += faceNormals[i / 3][2];

                this.vertexNormals[this.verticesIndices[i + 2] * 3 + 0] += faceNormals[i / 3][0];
                this.vertexNormals[this.verticesIndices[i + 2] * 3 + 1] += faceNormals[i / 3][1];
                this.vertexNormals[this.verticesIndices[i + 2] * 3 + 2] += faceNormals[i / 3][2];
            }

            for (let i = 0; i < this.verticesIndices.length; i += 3) // faces
            {
                for (let k = 0; k < 3; k++) // triangles
                {
                    const vv = [this.vertexNormals[this.verticesIndices[i + k] * 3 + 0], this.vertexNormals[this.verticesIndices[i + k] * 3 + 1], this.vertexNormals[this.verticesIndices[i + k] * 3 + 2]];
                    external_CABLES_GLMatrix_namespaceObject.vec3.normalize(vv, vv);
                    this.vertexNormals[this.verticesIndices[i + k] * 3 + 0] = vv[0];
                    this.vertexNormals[this.verticesIndices[i + k] * 3 + 1] = vv[1];
                    this.vertexNormals[this.verticesIndices[i + k] * 3 + 2] = vv[2];
                }
            }
        }
    }

    /**
     * Calculates tangents & bitangents with the help of uv-coordinates. Adapted from
     * Lengyel, Eric. “Computing Tangent Space Basis Vectors for an Arbitrary Mesh”.
     * Terathon Software 3D Graphics Library.
     * https://fenix.tecnico.ulisboa.pt/downloadFile/845043405449073/Tangent%20Space%20Calculation.pdf
     *
     * @function calcTangentsBitangents
     */
    calcTangentsBitangents()
    {
        if (!this.vertices.length)
        {
            // this._log.error("Cannot calculate tangents/bitangents without vertices.");
            return;
        }
        if (!this.vertexNormals.length)
        {
            // this._log.error("Cannot calculate tangents/bitangents without normals.");
            return;
        }
        if (!this.texCoords.length)
        {
            const texCoordLength = (this.vertices.length / 3) * 2;
            this.texCoords = new Float32Array(texCoordLength);
            for (let i = 0; i < texCoordLength; i += 1) this.texCoords[i] = 0;
        }
        if (!this.verticesIndices || !this.verticesIndices.length)
        {
            // this._log.error("Cannot calculate tangents/bitangents without vertex indices.");
            return;
        }
        // this code assumes that we have three indices per triangle
        if (this.verticesIndices.length % 3 !== 0)
        {
            this._log.error("Vertex indices mismatch!");
            return;
        }

        const triangleCount = this.verticesIndices.length / 3;
        const vertexCount = this.vertices.length / 3;

        this.tangents = new Float32Array(this.vertexNormals.length);
        this.biTangents = new Float32Array(this.vertexNormals.length);

        // temporary buffers
        const tempVertices = [];
        tempVertices.length = vertexCount * 2;
        const v1 = external_CABLES_GLMatrix_namespaceObject.vec3.create();
        const v2 = external_CABLES_GLMatrix_namespaceObject.vec3.create();
        const v3 = external_CABLES_GLMatrix_namespaceObject.vec3.create();

        const w1 = external_CABLES_GLMatrix_namespaceObject.vec2.create();
        const w2 = external_CABLES_GLMatrix_namespaceObject.vec2.create();
        const w3 = external_CABLES_GLMatrix_namespaceObject.vec2.create();

        const sdir = external_CABLES_GLMatrix_namespaceObject.vec3.create();
        const tdir = external_CABLES_GLMatrix_namespaceObject.vec3.create();

        // for details on calculation, see article referenced above
        for (let tri = 0; tri < triangleCount; tri += 1)
        {
            // indices of the three vertices for a triangle
            const i1 = this.verticesIndices[tri * 3];
            const i2 = this.verticesIndices[tri * 3 + 1];
            const i3 = this.verticesIndices[tri * 3 + 2];

            // vertex position as vec3
            external_CABLES_GLMatrix_namespaceObject.vec3.set(v1, this.vertices[i1 * 3], this.vertices[i1 * 3 + 1], this.vertices[i1 * 3 + 2]);
            external_CABLES_GLMatrix_namespaceObject.vec3.set(v2, this.vertices[i2 * 3], this.vertices[i2 * 3 + 1], this.vertices[i2 * 3 + 2]);
            external_CABLES_GLMatrix_namespaceObject.vec3.set(v3, this.vertices[i3 * 3], this.vertices[i3 * 3 + 1], this.vertices[i3 * 3 + 2]);

            // texture coordinate as vec2
            external_CABLES_GLMatrix_namespaceObject.vec2.set(w1, this.texCoords[i1 * 2], this.texCoords[i1 * 2 + 1]);
            external_CABLES_GLMatrix_namespaceObject.vec2.set(w2, this.texCoords[i2 * 2], this.texCoords[i2 * 2 + 1]);
            external_CABLES_GLMatrix_namespaceObject.vec2.set(w3, this.texCoords[i3 * 2], this.texCoords[i3 * 2 + 1]);

            const x1 = v2[0] - v1[0];
            const x2 = v3[0] - v1[0];
            const y1 = v2[1] - v1[1];
            const y2 = v3[1] - v1[1];
            const z1 = v2[2] - v1[2];
            const z2 = v3[2] - v1[2];

            const s1 = w2[0] - w1[0];
            const s2 = w3[0] - w1[0];
            const t1 = w2[1] - w1[1];
            const t2 = w3[1] - w1[1];

            const r = 1.0 / (s1 * t2 - s2 * t1);

            external_CABLES_GLMatrix_namespaceObject.vec3.set(sdir, (t2 * x1 - t1 * x2) * r, (t2 * y1 - t1 * y2) * r, (t2 * z1 - t1 * z2) * r);
            external_CABLES_GLMatrix_namespaceObject.vec3.set(tdir, (s1 * x2 - s2 * x1) * r, (s1 * y2 - s2 * y1) * r, (s1 * z2 - s2 * z1) * r);

            tempVertices[i1] = sdir;
            tempVertices[i2] = sdir;
            tempVertices[i3] = sdir;

            tempVertices[i1 + vertexCount] = tdir;
            tempVertices[i2 + vertexCount] = tdir;
            tempVertices[i3 + vertexCount] = tdir;
        }

        const normal = external_CABLES_GLMatrix_namespaceObject.vec3.create();
        const tempVert = external_CABLES_GLMatrix_namespaceObject.vec3.create();
        const tan = external_CABLES_GLMatrix_namespaceObject.vec3.create();
        const bitan = external_CABLES_GLMatrix_namespaceObject.vec3.create();
        const temp1 = external_CABLES_GLMatrix_namespaceObject.vec3.create();
        const temp2 = external_CABLES_GLMatrix_namespaceObject.vec3.create();
        const crossPd = external_CABLES_GLMatrix_namespaceObject.vec3.create();
        const normalized = external_CABLES_GLMatrix_namespaceObject.vec3.create();

        for (let vert = 0; vert < vertexCount; vert += 1)
        {
            // NOTE: some meshes don't have index 0 - n in their indexbuffer, if this is the case, skip calculation of this vertex
            if (!tempVertices[vert]) continue;

            external_CABLES_GLMatrix_namespaceObject.vec3.set(normal, this.vertexNormals[vert * 3], this.vertexNormals[vert * 3 + 1], this.vertexNormals[vert * 3 + 2]);
            external_CABLES_GLMatrix_namespaceObject.vec3.set(tempVert, tempVertices[vert][0], tempVertices[vert][1], tempVertices[vert][2]);

            // Gram-Schmidt orthagonalize
            const _dp = external_CABLES_GLMatrix_namespaceObject.vec3.dot(normal, tempVert);
            external_CABLES_GLMatrix_namespaceObject.vec3.scale(temp1, normal, _dp);
            external_CABLES_GLMatrix_namespaceObject.vec3.subtract(temp2, tempVert, temp1);

            external_CABLES_GLMatrix_namespaceObject.vec3.normalize(normalized, temp2);
            external_CABLES_GLMatrix_namespaceObject.vec3.cross(crossPd, normal, tempVert);

            // const intermDot = vec3.dot(crossPd, tempVertices[vert + vertexCount]);
            const w = 1.0;// intermDot < 0.0 ? -1.0 : 1.0;

            external_CABLES_GLMatrix_namespaceObject.vec3.scale(tan, normalized, 1 / w);
            external_CABLES_GLMatrix_namespaceObject.vec3.cross(bitan, normal, tan);

            this.tangents[vert * 3 + 0] = tan[0];
            this.tangents[vert * 3 + 1] = tan[1];
            this.tangents[vert * 3 + 2] = tan[2];
            this.biTangents[vert * 3 + 0] = bitan[0];
            this.biTangents[vert * 3 + 1] = bitan[1];
            this.biTangents[vert * 3 + 2] = bitan[2];
        }
    }

    isIndexed()
    {
        if (this._vertices.length == 0) return true;
        return this.verticesIndices.length != 0;
    }

    /**
     * @function unIndex
     * @memberof Geometry
     * @instance
     * @description remove all vertex indizes, vertices array will contain 3*XYZ for every triangle
     * @param {boolean} reIndex
     * @param {boolean} dontCalcNormals
     */
    unIndex(reIndex = false, dontCalcNormals = false)
    {
        const newVerts = [];
        const newIndizes = [];
        let count = 0;

        for (let j in this._attributes)
        {
            const attr = this._attributes[j];
            let na = [];

            for (let i = 0; i < this.verticesIndices.length; i += 3)
            {
                for (let s = 0; s < 3; s++)
                {
                    if (attr.itemSize == 3)
                        na.push(
                            attr.data[this.verticesIndices[i + s] * 3 + 0],
                            attr.data[this.verticesIndices[i + s] * 3 + 1],
                            attr.data[this.verticesIndices[i + s] * 3 + 2]);
                    else if (attr.itemSize == 4)
                        na.push(
                            attr.data[this.verticesIndices[i + s] * 4 + 0],
                            attr.data[this.verticesIndices[i + s] * 4 + 1],
                            attr.data[this.verticesIndices[i + s] * 4 + 2],
                            attr.data[this.verticesIndices[i + s] * 4 + 3]);
                    else if (attr.itemSize == 2)
                        na.push(
                            attr.data[this.verticesIndices[i + s] * 2 + 0],
                            attr.data[this.verticesIndices[i + s] * 2 + 1]);
                    else if (attr.itemSize == 1)
                        na.push(
                            attr.data[this.verticesIndices[i + s]]);
                    else this._log.warn("unknown attr", attr);
                }
            }
            this.setAttribute(attr.name, na, attr.itemSize);
        }

        for (let i = 0; i < this.verticesIndices.length; i += 3)
        {
            newVerts.push(
                this.vertices[this.verticesIndices[i + 0] * 3 + 0],
                this.vertices[this.verticesIndices[i + 0] * 3 + 1],
                this.vertices[this.verticesIndices[i + 0] * 3 + 2]);

            newIndizes.push(count);
            count++;

            newVerts.push(
                this.vertices[this.verticesIndices[i + 1] * 3 + 0],
                this.vertices[this.verticesIndices[i + 1] * 3 + 1],
                this.vertices[this.verticesIndices[i + 1] * 3 + 2]);

            newIndizes.push(count);
            count++;

            newVerts.push(
                this.vertices[this.verticesIndices[i + 2] * 3 + 0],
                this.vertices[this.verticesIndices[i + 2] * 3 + 1],
                this.vertices[this.verticesIndices[i + 2] * 3 + 2]);

            newIndizes.push(count);
            count++;
        }

        this.vertices = newVerts;

        this.verticesIndices = [];
        if (reIndex) this.verticesIndices = newIndizes;

        if (!dontCalcNormals) this.calculateNormals();
    }

    calcBarycentric()
    {
        let barycentrics = [];
        barycentrics.length = this.vertices.length;
        for (let i = 0; i < this.vertices.length; i++) barycentrics[i] = 0;

        let count = 0;
        for (let i = 0; i < this.vertices.length; i += 3)
        {
            barycentrics[i + count] = 1;
            count++;
            if (count == 3) count = 0;
        }

        this.setAttribute("attrBarycentric", barycentrics, 3);
    }

    getBounds()
    {
        return new BoundingBox(this);
    }

    /**
     * @param {boolean} x
     * @param {boolean} y
     * @param {boolean} z
     * @returns {Array} offset
     */
    center(x, y, z)
    {
        if (x === undefined)
        {
            x = true;
            y = true;
            z = true;
        }

        let i = 0;
        const bounds = this.getBounds();
        const offset = [bounds.minX + (bounds.maxX - bounds.minX) / 2, bounds.minY + (bounds.maxY - bounds.minY) / 2, bounds.minZ + (bounds.maxZ - bounds.minZ) / 2];

        for (i = 0; i < this.vertices.length; i += 3)
        {
            if (this.vertices[i + 0] == this.vertices[i + 0])
            {
                if (x) this.vertices[i + 0] -= offset[0];
                if (y) this.vertices[i + 1] -= offset[1];
                if (z) this.vertices[i + 2] -= offset[2];
            }
        }

        return offset;
    }

    mapTexCoords2d()
    {
        const bounds = this.getBounds();
        const num = this.vertices.length / 3;

        this.texCoords = new Float32Array(num * 2);

        for (let i = 0; i < num; i++)
        {
            const vertX = this.vertices[i * 3 + 0];
            const vertY = this.vertices[i * 3 + 1];
            this.texCoords[i * 2 + 0] = vertX / (bounds.maxX - bounds.minX) + 0.5;
            this.texCoords[i * 2 + 1] = 1.0 - vertY / (bounds.maxY - bounds.minY) + 0.5;
        }
    }

    getInfoOneLine()
    {
        let txt = "";
        if (this.faceVertCount == 3 && this.verticesIndices)txt += this.verticesIndices.length / 3;
        else txt += 0;

        txt += " tris ";

        if (this.vertices)txt += this.vertices.length / 3;
        else txt += 0;

        txt += " verts";

        return txt;
    }

    getInfo()
    {
        const info = {};

        info.name = this.name;
        info.class = this.constructor.name;

        if (this.faceVertCount == 3 && this.verticesIndices)info.numFaces = this.verticesIndices.length / 3;
        else info.numFaces = 0;

        if (this.verticesIndices && this.verticesIndices.length)info.indices = this.verticesIndices.length;

        if (this.vertices)info.numVerts = this.vertices.length / 3;
        else info.numVerts = 0;

        if (this.vertexNormals) info.numNormals = this.vertexNormals.length / 3;
        else info.numNormals = 0;

        if (this.texCoords) info.numTexCoords = this.texCoords.length / 2;
        else info.numTexCoords = 0;

        if (this.tangents) info.numTangents = this.tangents.length / 3;
        else info.numTangents = 0;

        if (this.biTangents) info.numBiTangents = this.biTangents.length / 3;
        else info.numBiTangents = 0;

        if (this.biTangents) info.numBiTangents = this.biTangents.length / 3;
        else info.numBiTangents = 0;

        if (this.vertexColors) info.numVertexColors = this.vertexColors.length / 4;
        else info.numVertexColors = 0;

        if (this.getAttributes()) info.numAttribs = Object.keys(this.getAttributes()).length;
        else info.numAttribs = 0;

        info.isIndexed = this.isIndexed();

        return info;
    }

    // -----------------
}

// TODO : rewritwe circle op 1
/** @deprecated */
Geometry.buildFromFaces = function (arr, name, optimize)
{
    const vertices = [];
    const verticesIndices = [];

    for (let i = 0; i < arr.length; i += 3)
    {
        const a = arr[i + 0];
        const b = arr[i + 1];
        const c = arr[i + 2];
        const face = [-1, -1, -1];

        if (optimize)
            for (let iv = 0; iv < vertices.length; iv += 3)
            {
                if (vertices[iv + 0] == a[0] && vertices[iv + 1] == a[1] && vertices[iv + 2] == a[2]) face[0] = iv / 3;
                if (vertices[iv + 0] == b[0] && vertices[iv + 1] == b[1] && vertices[iv + 2] == b[2]) face[1] = iv / 3;
                if (vertices[iv + 0] == c[0] && vertices[iv + 1] == c[1] && vertices[iv + 2] == c[2]) face[2] = iv / 3;
            }

        if (face[0] == -1)
        {
            vertices.push(a[0], a[1], a[2]);
            face[0] = (vertices.length - 1) / 3;
        }

        if (face[1] == -1)
        {
            vertices.push(b[0], b[1], b[2]);
            face[1] = (vertices.length - 1) / 3;
        }

        if (face[2] == -1)
        {
            vertices.push(c[0], c[1], c[2]);
            face[2] = (vertices.length - 1) / 3;
        }

        verticesIndices.push(face[0]);
        verticesIndices.push(face[1]);
        verticesIndices.push(face[2]);
    }

    const geom = new Geometry(name);
    geom.name = name;
    geom.vertices = vertices;
    geom.verticesIndices = verticesIndices;

    return geom;
};

;// CONCATENATED MODULE: ./src/corelibs/cgl/cgl_simplerect.js



const MESHES = {};

MESHES.getSimpleRect = function (cgl, name, size = 1.0)
{
    const geom = new Geometry(name);

    geom.vertices = [1.0 * size, 1.0 * size, 0.0, -1.0 * size, 1.0 * size, 0.0, 1.0 * size, -1.0 * size, 0.0, -1.0 * size, -1.0 * size, 0.0];
    geom.texCoords = [1.0, 1.0, 0.0, 1.0, 1.0, 0.0, 0.0, 0.0];
    geom.verticesIndices = [0, 1, 2, 2, 1, 3];
    geom.vertexNormals = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0];

    return cgl.createMesh(geom);
};

MESHES.getSimpleCube = function (cgl, name)
{
    const geom = new Geometry(name);
    geom.vertices = [-1, -1, 1, 1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, -1, 1, -1, -1, 1, 1, -1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1, 1, -1, 1, 1, -1, -1, -1, 1, -1, -1, 1, -1, 1, -1, -1, 1, 1, -1, -1, 1, -1, 1, 1, 1, 1, 1, 1, -1, -1, -1, -1, -1, -1, 1, -1, 1, 1, -1, 1, -1];
    geom.setTexCoords([0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0,]);
    geom.verticesIndices = [0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13, 14, 12, 14, 15, 16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23];
    geom.vertexNormals = new Float32Array([0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0]);
    geom.tangents = new Float32Array([0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1]);
    geom.biTangents = new Float32Array([-1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1]);

    return new Mesh(cgl, geom);
};



;// CONCATENATED MODULE: ./src/corelibs/cgl/cgl_textureeffect.js




class TextureEffect
{
    constructor(cgl, options)
    {
        this._cgl = cgl;
        this._log = new external_CABLES_SHARED_namespaceObject.Logger("cgl_TextureEffect");

        if (!cgl.TextureEffectMesh) this.createMesh();

        this._textureSource = null;
        this._options = options;
        this.name = options.name || "unknown";

        this.imgCompVer = 0;
        this.aspectRatio = 1;
        this._textureTarget = null; // new CGL.Texture(this._cgl,opts);
        this._frameBuf = this._cgl.gl.createFramebuffer();
        this._frameBuf2 = this._cgl.gl.createFramebuffer();
        this._renderbuffer = this._cgl.gl.createRenderbuffer();
        this._renderbuffer2 = this._cgl.gl.createRenderbuffer();
        this.switched = false;
        this.depth = false;
    }

    dispose()
    {
        if (this._renderbuffer) this._cgl.gl.deleteRenderbuffer(this._renderbuffer);
        if (this._frameBuf) this._cgl.gl.deleteFramebuffer(this._frameBuf);
        if (this._renderbuffer2) this._cgl.gl.deleteRenderbuffer(this._renderbuffer2);
        if (this._frameBuf2) this._cgl.gl.deleteFramebuffer(this._frameBuf2);
    }

    getWidth()
    {
        return this._textureSource.width;
    }

    getHeight()
    {
        return this._textureSource.height;
    }

    setSourceTexture(tex)
    {
        if (tex === null)
        {
            this._textureSource = new Texture(this._cgl);
            this._textureSource.setSize(16, 16);
        }
        else
        {
            this._textureSource = tex;
        }

        if (!this._textureSource.compareSettings(this._textureTarget))
        {
            if (this._textureTarget) this._textureTarget.delete();

            this._textureTarget = this._textureSource.clone();

            this._cgl.profileData.profileEffectBuffercreate++;

            this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, this._frameBuf);

            this._cgl.gl.bindRenderbuffer(this._cgl.gl.RENDERBUFFER, this._renderbuffer);

            // if(tex.textureType==CGL.Texture.TYPE_FLOAT) this._cgl.gl.renderbufferStorage(this._cgl.gl.RENDERBUFFER,this._cgl.gl.RGBA32F, this._textureSource.width,this._textureSource.height);
            // else this._cgl.gl.renderbufferStorage(this._cgl.gl.RENDERBUFFER,this._cgl.gl.RGBA8, this._textureSource.width,this._textureSource.height);

            if (this.depth) this._cgl.gl.renderbufferStorage(this._cgl.gl.RENDERBUFFER, this._cgl.gl.DEPTH_COMPONENT16, this._textureSource.width, this._textureSource.height);
            this._cgl.gl.framebufferTexture2D(this._cgl.gl.FRAMEBUFFER, this._cgl.gl.COLOR_ATTACHMENT0, this._cgl.gl.TEXTURE_2D, this._textureTarget.tex, 0);
            if (this.depth) this._cgl.gl.framebufferRenderbuffer(this._cgl.gl.FRAMEBUFFER, this._cgl.gl.DEPTH_ATTACHMENT, this._cgl.gl.RENDERBUFFER, this._renderbuffer);

            // this._cgl.gl.framebufferTexture2D(this._cgl.gl.FRAMEBUFFER, this._cgl.gl.COLOR_ATTACHMENT0, this._cgl.gl.TEXTURE_2D, this._textureTarget.tex, 0);

            this._cgl.gl.bindTexture(this._cgl.gl.TEXTURE_2D, null);
            this._cgl.gl.bindRenderbuffer(this._cgl.gl.RENDERBUFFER, null);
            this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, null);

            this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, this._frameBuf2);

            this._cgl.gl.bindRenderbuffer(this._cgl.gl.RENDERBUFFER, this._renderbuffer2);

            // if(tex.textureType==CGL.Texture.TYPE_FLOAT) this._cgl.gl.renderbufferStorage(this._cgl.gl.RENDERBUFFER,this._cgl.gl.RGBA32F, this._textureSource.width,this._textureSource.height);
            // else this._cgl.gl.renderbufferStorage(this._cgl.gl.RENDERBUFFER,this._cgl.gl.RGBA8, this._textureSource.width,this._textureSource.height);

            if (this.depth) this._cgl.gl.renderbufferStorage(this._cgl.gl.RENDERBUFFER, this._cgl.gl.DEPTH_COMPONENT16, this._textureSource.width, this._textureSource.height);
            this._cgl.gl.framebufferTexture2D(this._cgl.gl.FRAMEBUFFER, this._cgl.gl.COLOR_ATTACHMENT0, this._cgl.gl.TEXTURE_2D, this._textureSource.tex, 0);

            if (this.depth) this._cgl.gl.framebufferRenderbuffer(this._cgl.gl.FRAMEBUFFER, this._cgl.gl.DEPTH_ATTACHMENT, this._cgl.gl.RENDERBUFFER, this._renderbuffer2);

            // this._cgl.gl.framebufferTexture2D(this._cgl.gl.FRAMEBUFFER, this._cgl.gl.COLOR_ATTACHMENT0, this._cgl.gl.TEXTURE_2D, this._textureSource.tex, 0);

            this._cgl.gl.bindTexture(this._cgl.gl.TEXTURE_2D, null);
            this._cgl.gl.bindRenderbuffer(this._cgl.gl.RENDERBUFFER, null);
            this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, null);
        }

        this.aspectRatio = this._textureSource.width / this._textureSource.height;
    }

    continueEffect()
    {
        this._cgl.pushDepthTest(false);
        this._cgl.pushModelMatrix();
        this._cgl.pushPMatrix();
        // todo why two pushs?

        this._cgl.pushViewPort(0, 0, this.getCurrentTargetTexture().width, this.getCurrentTargetTexture().height);

        mat4.perspective(this._cgl.pMatrix, 45, this.getCurrentTargetTexture().width / this.getCurrentTargetTexture().height, 0.1, 1100.0); // todo: why?

        this._cgl.pushPMatrix();
        mat4.identity(this._cgl.pMatrix);

        this._cgl.pushViewMatrix();
        mat4.identity(this._cgl.vMatrix);

        this._cgl.pushModelMatrix();
        mat4.identity(this._cgl.mMatrix);
    }

    startEffect(bgTex)
    {
        if (!this._textureTarget)
        {
            this._log.warn("effect has no target");
            return;
        }

        this.switched = false;

        this.continueEffect();

        if (bgTex)
        {
            this._bgTex = bgTex;
        }
        this._countEffects = 0;
    }

    endEffect()
    {
        this._cgl.popDepthTest();
        this._cgl.popModelMatrix();

        this._cgl.popPMatrix();
        this._cgl.popModelMatrix();
        this._cgl.popViewMatrix();

        this._cgl.popPMatrix();
        this._cgl.popViewPort();
    }

    bind()
    {
        if (this._textureSource === null)
        {
            this._log.warn("no base texture set!");
            return;
        }

        if (!this.switched)
        {
            this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, this._frameBuf);
            this._cgl.pushGlFrameBuffer(this._frameBuf);
        }
        else
        {
            this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, this._frameBuf2);
            this._cgl.pushGlFrameBuffer(this._frameBuf2);
        }
    }

    finish()
    {
        if (this._textureSource === null)
        {
            this._log.warn("no base texture set!");
            return;
        }

        this._cgl.TextureEffectMesh.render(this._cgl.getShader());

        this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, this._cgl.popGlFrameBuffer());

        this._cgl.profileData.profileTextureEffect++;

        if (this._textureTarget.filter == Texture.FILTER_MIPMAP)
        {
            if (!this.switched)
            {
                this._cgl.gl.bindTexture(this._cgl.gl.TEXTURE_2D, this._textureTarget.tex);
                this._textureTarget.updateMipMap();
            }
            else
            {
                this._cgl.gl.bindTexture(this._cgl.gl.TEXTURE_2D, this._textureSource.tex);
                this._textureSource.updateMipMap();
            }

            this._cgl.gl.bindTexture(this._cgl.gl.TEXTURE_2D, null);
        }

        this.switched = !this.switched;
        this._countEffects++;
    }

    getCurrentTargetTexture()
    {
        if (this.switched) return this._textureSource;
        return this._textureTarget;
    }

    getCurrentSourceTexture()
    {
        if (this._countEffects == 0 && this._bgTex) return this._bgTex;

        if (this.switched) return this._textureTarget;
        return this._textureSource;
    }

    delete()
    {
        if (this._textureTarget) this._textureTarget.delete();
        if (this._textureSource) this._textureSource.delete();
        this._cgl.gl.deleteRenderbuffer(this._renderbuffer);
        this._cgl.gl.deleteFramebuffer(this._frameBuf);
    }

    createMesh()
    {
        this._cgl.TextureEffectMesh = MESHES.getSimpleRect(this._cgl, "texEffectRect");
    }

    // ---------------------------------------------------------------------------------
}

TextureEffect.checkOpNotInTextureEffect = function (op)
{
    if (!op.patch.cgl) return true;
    if (op.uiAttribs.error && !op.patch.cgl.currentTextureEffect)
    {
        op.setUiError("textureeffect", null);
        return true;
    }
    if (!op.patch.cgl.currentTextureEffect) return true;

    if (op.patch.cgl.currentTextureEffect && !op.uiAttribs.error)
    {
        op.setUiError("textureeffect", "This op can not be a child of a ImageCompose/texture effect! imagecompose should only have textureeffect childs.", 0);
        return false;
    }

    if (op.patch.cgl.currentTextureEffect) return false;
    return true;
};

TextureEffect.checkOpInEffect = function (op, minver)
{
    minver = minver || 0;

    if (op.patch.cgl.currentTextureEffect)
    {
        if (op.uiAttribs.uierrors && op.patch.cgl.currentTextureEffect.imgCompVer >= minver)
        {
            op.setUiError("texeffect", null);
            return true;
        }

        if (minver && op.patch.cgl.currentTextureEffect.imgCompVer < minver)
        {
            op.setUiError("texeffect", "This op must be a child of an ImageCompose op with version >=" + minver + " <span class=\"button-small\" onclick=\"gui.patchView.downGradeOp('" + op.id + "','" + op.name + "')\">Downgrade</span> to previous version", 1);
        }
    }

    if (op.patch.cgl.currentTextureEffect) return true;

    if (!op.patch.cgl.currentTextureEffect && (!op.uiAttribs.uierrors || op.uiAttribs.uierrors.length == 0))
    {
        op.setUiError("texeffect", "This op must be a child of an ImageCompose op! More infos <a href=\"https://cables.gl/docs/image_composition/image_composition.html\" target=\"_blank\">here</a>. ", 1);
        return false;
    }

    if (!op.patch.cgl.currentTextureEffect) return false;
    return true;
};

TextureEffect.getBlendCode = function (ver)
{
    let src = "".endl()
        + "vec3 _blend(vec3 base,vec3 blend)".endl()
        + "{".endl()
        + "   vec3 colNew=blend;".endl()
        + "   #ifdef BM_MULTIPLY".endl()
        + "       colNew=base*blend;".endl()
        + "   #endif".endl()
        + "   #ifdef BM_MULTIPLY_INV".endl()
        + "       colNew=base* vec3(1.0)-blend;".endl()
        + "   #endif".endl()
        + "   #ifdef BM_AVERAGE".endl()
        + "       colNew=((base + blend) / 2.0);".endl()
        + "   #endif".endl()
        + "   #ifdef BM_ADD".endl()
        + "       colNew=min(base + blend, vec3(1.0));".endl()
        + "   #endif".endl()
        + "   #ifdef BM_SUBTRACT_ONE".endl()
        + "       colNew=max(base + blend - vec3(1.0), vec3(0.0));".endl()
        + "   #endif".endl()

        + "   #ifdef BM_SUBTRACT".endl()
        + "       colNew=base - blend;".endl()
        + "   #endif".endl()

        + "   #ifdef BM_DIFFERENCE".endl()
        + "       colNew=abs(base - blend);".endl()
        + "   #endif".endl()
        + "   #ifdef BM_NEGATION".endl()
        + "       colNew=(vec3(1.0) - abs(vec3(1.0) - base - blend));".endl()
        + "   #endif".endl()
        + "   #ifdef BM_EXCLUSION".endl()
        + "       colNew=(base + blend - 2.0 * base * blend);".endl()
        + "   #endif".endl()
        + "   #ifdef BM_LIGHTEN".endl()
        + "       colNew=max(blend, base);".endl()
        + "   #endif".endl()
        + "   #ifdef BM_DARKEN".endl()
        + "       colNew=min(blend, base);".endl()
        + "   #endif".endl()
        + "   #ifdef BM_OVERLAY".endl()
        + "      #define BlendOverlayf(base, blend)  (base < 0.5 ? (2.0 * base * blend) : (1.0 - 2.0 * (1.0 - base) * (1.0 - blend)))"
            // .endl()+'       #define BlendOverlay(base, blend)       Blend(base, blend, BlendOverlayf)'
            //    .endl()+'      colNew=Blend(base, blend, BlendOverlayf);'
            .endl()
        + "      colNew=vec3(BlendOverlayf(base.r, blend.r),BlendOverlayf(base.g, blend.g),BlendOverlayf(base.b, blend.b));".endl()
        + "   #endif".endl()
        + "   #ifdef BM_SCREEN".endl()
        + "      #define BlendScreenf(base, blend)       (1.0 - ((1.0 - base) * (1.0 - blend)))"
            // .endl()+'       #define BlendScreen(base, blend)        Blend(base, blend, BlendScreenf)'
            // .endl()+'      colNew=Blend(base, blend, BlendScreenf);'
            .endl()
        + "      colNew=vec3(BlendScreenf(base.r, blend.r),BlendScreenf(base.g, blend.g),BlendScreenf(base.b, blend.b));".endl()
        + "   #endif".endl()
        + "   #ifdef BM_SOFTLIGHT".endl()
        + "      #define BlendSoftLightf(base, blend)    ((blend < 0.5) ? (2.0 * base * blend + base * base * (1.0 - 2.0 * blend)) : (sqrt(base) * (2.0 * blend - 1.0) + 2.0 * base * (1.0 - blend)))"
            // .endl()+'       #define BlendSoftLight(base, blend)     Blend(base, blend, BlendSoftLightf)'
            //    .endl()+'      colNew=Blend(base, blend, BlendSoftLightf);'
            .endl()
        + "      colNew=vec3(BlendSoftLightf(base.r, blend.r),BlendSoftLightf(base.g, blend.g),BlendSoftLightf(base.b, blend.b));".endl()
        + "   #endif".endl()
        + "   #ifdef BM_HARDLIGHT".endl()
        + "      #define BlendOverlayf(base, blend)  (base < 0.5 ? (2.0 * base * blend) : (1.0 - 2.0 * (1.0 - base) * (1.0 - blend)))"
            // .endl()+'       #define BlendOverlay(base, blend)       Blend(base, blend, BlendOverlayf)'
            // .endl()+'      colNew=Blend(blend, base, BlendOverlayf);'
            .endl()
        + "      colNew=vec3(BlendOverlayf(base.r, blend.r),BlendOverlayf(base.g, blend.g),BlendOverlayf(base.b, blend.b));".endl()
        + "   #endif".endl()
        + "   #ifdef BM_COLORDODGE".endl()
        + "      #define BlendColorDodgef(base, blend)   ((blend == 1.0) ? blend : min(base / (1.0 - blend), 1.0))"
            // .endl()+'      colNew=Blend(base, blend, BlendColorDodgef);'
            .endl()
        + "      colNew=vec3(BlendColorDodgef(base.r, blend.r),BlendColorDodgef(base.g, blend.g),BlendColorDodgef(base.b, blend.b));".endl()
        + "   #endif".endl()
        + "   #ifdef BM_COLORBURN".endl()
        + "      #define BlendColorBurnf(base, blend)    ((blend == 0.0) ? blend : max((1.0 - ((1.0 - base) / blend)), 0.0))"
            // .endl()+'      colNew=Blend(base, blend, BlendColorBurnf);'
            .endl()
        + "      colNew=vec3(BlendColorBurnf(base.r, blend.r),BlendColorBurnf(base.g, blend.g),BlendColorBurnf(base.b, blend.b));".endl()
        + "   #endif".endl()

        + "   return colNew;".endl()
        + "}".endl();

    if (!ver)
        src += "vec4 cgl_blend(vec4 oldColor,vec4 newColor,float amount)".endl()
                + "{".endl()
                    + "vec4 col=vec4( _blend(oldColor.rgb,newColor.rgb) ,1.0);".endl()
                    + "col=vec4( mix( col.rgb, oldColor.rgb ,1.0-oldColor.a*amount),1.0);".endl()
                    + "return col;".endl()
                + "}".endl();

    if (ver >= 3)
        src += "vec4 cgl_blendPixel(vec4 base,vec4 col,float amount)".endl() +
                "{".endl() +

                "#ifdef BM_MATH_ADD".endl() +
                "   return vec4(base.rgb+col.rgb*amount,1.0);".endl() +
                "#endif".endl() +

                "#ifdef BM_MATH_SUB".endl() +
                "   return vec4(base.rgb-col.rgb*amount,1.0);".endl() +
                "#endif".endl() +

                "#ifdef BM_MATH_MUL".endl() +
                "   return vec4(base.rgb*col.rgb*amount,1.0);".endl() +
                "#endif".endl() +

                "#ifdef BM_MATH_DIV".endl() +
                "   return vec4(base.rgb/col.rgb*amount,1.0);".endl() +
                "#endif".endl() +

                    "#ifndef BM_MATH".endl() +
                        "vec3 colNew=_blend(base.rgb,col.rgb);".endl() +

                        "float newA=clamp(base.a+(col.a*amount),0.,1.);".endl() +

                        "#ifdef BM_ALPHAMASKED".endl() +
                            "newA=base.a;".endl() +
                        "#endif".endl() +

                        "return vec4(".endl() +
                            "mix(colNew,base.rgb,1.0-(amount*col.a)),".endl() +
                            "newA);".endl() +

                    "#endif".endl() +
    "}".endl();

    return src;
};

TextureEffect.onChangeBlendSelect = function (shader, blendName, maskAlpha = false)
{
    blendName = String(blendName);
    shader.toggleDefine("BM_NORMAL", blendName == "normal");
    shader.toggleDefine("BM_MULTIPLY", blendName == "multiply");
    shader.toggleDefine("BM_MULTIPLY_INV", blendName == "multiply invert");
    shader.toggleDefine("BM_AVERAGE", blendName == "average");
    shader.toggleDefine("BM_ADD", blendName == "add");
    shader.toggleDefine("BM_SUBTRACT_ONE", blendName == "subtract one");
    shader.toggleDefine("BM_SUBTRACT", blendName == "subtract");
    shader.toggleDefine("BM_DIFFERENCE", blendName == "difference");
    shader.toggleDefine("BM_NEGATION", blendName == "negation");
    shader.toggleDefine("BM_EXCLUSION", blendName == "exclusion");
    shader.toggleDefine("BM_LIGHTEN", blendName == "lighten");
    shader.toggleDefine("BM_DARKEN", blendName == "darken");
    shader.toggleDefine("BM_OVERLAY", blendName == "overlay");
    shader.toggleDefine("BM_SCREEN", blendName == "screen");
    shader.toggleDefine("BM_SOFTLIGHT", blendName == "softlight");
    shader.toggleDefine("BM_HARDLIGHT", blendName == "hardlight");
    shader.toggleDefine("BM_COLORDODGE", blendName == "color dodge");
    shader.toggleDefine("BM_COLORBURN", blendName == "color burn");

    shader.toggleDefine("BM_MATH_ADD", blendName == "Math Add");
    shader.toggleDefine("BM_MATH_SUB", blendName == "Math Subtract");
    shader.toggleDefine("BM_MATH_MUL", blendName == "Math Multiply");
    shader.toggleDefine("BM_MATH_DIV", blendName == "Math Divide");

    shader.toggleDefine("BM_MATH", blendName.indexOf("Math ") == 0);

    shader.toggleDefine("BM_ALPHAMASKED", maskAlpha);
};

TextureEffect.AddBlendSelect = function (op, name, defaultMode)
{
    const p = op.inValueSelect(name || "Blend Mode", [
        "normal", "lighten", "darken", "multiply", "multiply invert", "average", "add", "subtract", "difference", "negation", "exclusion", "overlay", "screen", "color dodge", "color burn", "softlight", "hardlight", "subtract one",
        "Math Add",
        "Math Subtract",
        "Math Multiply",
        "Math Divide",

    ], defaultMode || "normal");
    return p;
};

TextureEffect.AddBlendAlphaMask = function (op, name, defaultMode)
{
    const p = op.inSwitch(name || "Alpha Mask", ["Off", "On"], defaultMode || "Off");
    return p;
};

TextureEffect.setupBlending = function (op, shader, blendPort, amountPort, alphaMaskPort)
{
    const onChange = () =>
    {
        let maskAlpha = false;
        if (alphaMaskPort) maskAlpha = alphaMaskPort.get() == "On";
        TextureEffect.onChangeBlendSelect(shader, blendPort.get(), maskAlpha);

        let str = blendPort.get();
        if (str == "normal") str = null;
        else if (str == "multiply") str = "mul";
        else if (str == "multiply invert") str = "mulinv";
        else if (str == "lighten") str = "light";
        else if (str == "darken") str = "darken";
        else if (str == "average") str = "avg";
        else if (str == "subtract one") str = "sub one";
        else if (str == "subtract") str = "sub";
        else if (str == "difference") str = "diff";
        else if (str == "negation") str = "neg";
        else if (str == "exclusion") str = "exc";
        else if (str == "overlay") str = "ovl";
        else if (str == "color dodge") str = "dodge";
        else if (str == "color burn") str = "burn";
        else if (str == "softlight") str = "soft";
        else if (str == "hardlight") str = "hard";
        else if (str == "Math Add") str = "+";
        else if (str == "Math Subtract") str = "-";
        else if (str == "Math Multiply") str = "*";
        else if (str == "Math Divide") str = "/";

        op.setUiAttrib({ "extendTitle": str });
    };
    op.setPortGroup("Blending", [blendPort, amountPort, alphaMaskPort]);

    let maskAlpha = false;

    blendPort.onChange = onChange;
    if (alphaMaskPort)
    {
        alphaMaskPort.onChange = onChange;
        maskAlpha = alphaMaskPort.get() == "On";
    }

    TextureEffect.onChangeBlendSelect(shader, blendPort.get(), maskAlpha);
};

;// CONCATENATED MODULE: ./src/corelibs/cgl/cgl_shader_lib.js




/** @type {Object} */
const ShaderLibMods = {
    "CGL.BLENDMODES": function ()
    {
        this.name = "blendmodes";
        this.srcHeadFrag = TextureEffect.getBlendCode();
    },

    "CGL.BLENDMODES3": function ()
    {
        this.name = "blendmodes3";
        this.srcHeadFrag = TextureEffect.getBlendCode(3);
    },

    "CGL.LUMINANCE": function ()
    {
        this.name = "luminance";
        this.srcHeadFrag = "".endl()
            + "float cgl_luminance(vec3 c)".endl()
            + "{".endl()
            + "    return dot(vec3(0.2126,0.7152,0.0722),c);".endl()
            + "}".endl();
    },

    // quite good random numbers, but somehow don't work in ANGLE
    "CGL.RANDOM_OLD": function ()
    {
        this.name = "randomNumber";
        this.srcHeadFrag = "".endl()
            + "float cgl_random(vec2 co)".endl()
            + "{".endl()
            + "    return fract(sin(dot(co.xy ,vec2(12.9898,4.1414))) * 432758.5453);".endl()
            + "}".endl()
            + "vec3 cgl_random3(vec2 co)".endl()
            + "{".endl()
            + "    return vec3( cgl_random(co),cgl_random(co+0.5711),cgl_random(co+1.5711));".endl()
            + "}";
    },

    // low quality generative ranodm numbers
    "CGL.RANDOM_LOW": function ()
    {
        this.name = "randomNumber";
        this.srcHeadFrag = "".endl()
            + "float cgl_random(vec2 co)".endl()
            + "{".endl()
            + "    return fract(sin(dot(co.xy ,vec2(12.9898,4.1414))) * 358.5453);".endl()
            + "}".endl()
            + "vec3 cgl_random3(vec2 co)".endl()
            + "{".endl()
            + "    return vec3( cgl_random(co),cgl_random(co+0.5711),cgl_random(co+1.5711));".endl()
            + "}";
    },

    "CGL.RANDOM_TEX": function ()
    {
        this.name = "randomNumbertex";

        this.srcHeadFrag = "".endl()
            + "UNI sampler2D CGLRNDTEX;".endl()
            + "float cgl_random(vec2 co)".endl()
            + "{".endl()
            + "    return texture(CGLRNDTEX,co*5711.0).r;".endl()
            + "}".endl()
            + "vec3 cgl_random3(vec2 co)".endl()
            + "{".endl()
            + "    return texture(CGLRNDTEX,co*5711.0).rgb;".endl()
            + "}";

        this.initUniforms = function (shader)
        {
            return [new Uniform(shader, "t", "CGLRNDTEX", 7)];
        };

        this.onBind = function (cgl, shader)
        {
            Texture.getRandomTexture(cgl);
            cgl.setTexture(7, Texture.getRandomTexture(cgl).tex);
        };
    }

};

;// CONCATENATED MODULE: ./src/corelibs/cgl/cgl_unicolorshader.js


class UniColorShader
{
    constructor(_cgl)
    {
        this.shader = new CGL.Shader(_cgl, "markermaterial");

        const frag = ""
            .endl() + "void main()"
            .endl() + "{"
            .endl() + "    outColor = vec4(color.rgb,1.0);"
            .endl() + "}";

        const vert = ""
            .endl() + "IN vec3 vPosition;"
            .endl() + "UNI mat4 projMatrix;"
            .endl() + "UNI mat4 mvMatrix;"

            .endl() + "void main()"
            .endl() + "{"
            .endl() + "   gl_Position = projMatrix * mvMatrix * vec4(vPosition,1.0);"
            .endl() + "}";

        this.shader.setSource(vert, frag);
        this.coloruni = this.shader.addUniformFrag("4f", "color", [1, 0.777, 1, 1]);
    }

    setColor(r, g, b, a)
    {
        this.coloruni.set(r, g, b, a);
    }
}

;// CONCATENATED MODULE: ./src/corelibs/cg/cg_shader.js



/**
 * @typedef ShaderModule
 * @property {String} title
 * @property {String} name
 * @property {Number} id
 * @property {Number} numId
 * @property {String} group
 * @property {String} prefix
 * @property {Number} priority
 * @property {Number} num
 * @property {String} attributes
 * @property {String} srcBodyFrag
 * @property {String} srcBodyVert
 * @property {String} srcHeadFrag
 * @property {String} srcHeadVert
  */

class CgShader extends external_CABLES_SHARED_namespaceObject.Events
{
    id = external_CABLES_namespaceObject.utils.simpleId();
    _isValid = true;

    /** @type {Array<Array<String>>} */
    _defines = [];

    /** @type {Array<String>} */
    _moduleNames = [];

    _moduleNumId = 0;
    _needsRecompile = true;
    _compileReason = "initial";

    /** @type {Array<ShaderModule>} */
    _modules = [];

    _compileCount = 0;

    logError = true;
    num = -1;
    lastCompile = 0;

    constructor()
    {
        super();
    }

    /**
     * @param {string} reason
     */
    setWhyCompile(reason)
    {
        this._compileReason = reason;
        this._needsRecompile = true;
    }

    getWhyCompile()
    {
        return this._compileReason;
    }

    needsRecompile()
    {
        return this._needsRecompile;
    }

    /**
     * @param {string} name
     */
    removeUniform(name)
    {
        for (let i = 0; i < this._uniforms.length; i++)
        {
            if (this._uniforms[i].getName() == name)
            {
                this._uniforms.splice(i, 1);
            }
        }
        this.setWhyCompile("remove uniform " + name);
    }

    /**
     * @param {String} name
     * @param {number} stage
     */
    hasUniformInStage(name, stage)
    {

        let binding = this.defaultUniBindingFrag;
        if (stage == GPUShaderStage.VERTEX) binding = this.defaultUniBindingVert;
        if (stage == GPUShaderStage.COMPUTE) binding = this.defaultUniBindingCompute;

        for (let i = 0; i < this._uniforms.length; i++)
        {

            console.log("hasuniiiiiiiiiiiiiii", this._uniforms[i].getName(), name);
            if (this._uniforms[i].getName() == name) return true;
        }
        return false;
    }

    /**
     * @param {String} name
     */
    hasUniform(name)
    {
    }

    /**
     * easily enable/disable a define without a value
     * @param {String} name
     * @param {Port|boolean} enabled value or port
     */
    toggleDefine(name, enabled)
    {
        if (enabled && typeof (enabled) == "object" && enabled.addEventListener) // port
        {
            if (enabled.changeListener)enabled.off(enabled.changeListener);

            enabled.onToggleDefine = (v) =>
            {
                this.toggleDefine(name, v);
            };

            enabled.changeListener = enabled.on("change", enabled.onToggleDefine);
            enabled = enabled.get();
        }

        if (enabled) this.define(name);
        else this.removeDefine(name);
    }

    /**
     * add a define to a shader, e.g.  #define DO_THIS_THAT 1
     * @param {String} name
     * @param {any} value (can be empty)
     */
    define(name, value = "")
    {
        if (value === null || value === undefined) value = "";

        if (typeof (value) == "object") // port
        {
            value.removeEventListener("change", value.onDefineChange);
            value.onDefineChange = (v) =>
            {
                this.define(name, v);
            };
            value.on("change", value.onDefineChange);

            value = value.get();
        }

        for (let i = 0; i < this._defines.length; i++)
        {
            if (this._defines[i][0] == name && this._defines[i][1] == value) return;
            if (this._defines[i][0] == name)
            {
                this._defines[i][1] = value;
                this.setWhyCompile("define " + name + " " + value);
                return;
            }
        }
        this.setWhyCompile("define " + name + " " + value);

        this._defines.push([name, value]);
    }

    getDefines()
    {
        return this._defines;
    }

    /**
     * @param {string} name
     */
    getDefine(name)
    {
        for (let i = 0; i < this._defines.length; i++)
            if (this._defines[i][0] == name) return this._defines[i][1];
        return null;
    }

    /**
     * return true if shader has define
     * @function hasDefine
     * @memberof Shader
     * @instance
     * @param {String} name
     * @return {Boolean}
     */
    hasDefine(name)
    {
        for (let i = 0; i < this._defines.length; i++)
            if (this._defines[i][0] == name) return true;
    }

    /**
     * remove a define from a shader
     * @param {string} name
     */
    removeDefine(name)
    {
        for (let i = 0; i < this._defines.length; i++)
        {
            if (this._defines[i][0] == name)
            {
                this._defines.splice(i, 1);
                this.setWhyCompile("define removed:" + name);
                return;
            }
        }
    }

    /**
     * @param {any} modId
     */
    hasModule(modId)
    {
        for (let i = 0; i < this._modules.length; i++)
            if (this._modules[i].id == modId) return true;

        return false;
    }

    /**
     *
     * @param {Array<String>} names
     */
    setModules(names)
    {
        this._moduleNames = names;
    }

    /**
     * remove a module from shader
     * @param {ShaderModule} mod the module to be removed
     */
    removeModule(mod)
    {
        for (let i = 0; i < this._modules.length; i++)
        {
            if (mod && mod.id)
            {
                if (this._modules[i].id == mod.id || !this._modules[i])
                {
                    let found = true;
                    while (found)
                    {
                        found = false;
                        for (let j = 0; j < this._uniforms.length; j++)
                        {
                            if (this._uniforms[j].getName().startsWith(mod.prefix))
                            {
                                this._uniforms.splice(j, 1);
                                found = true;
                                continue;
                            }
                        }
                    }

                    this.setWhyCompile("remove module " + mod.title);
                    this._modules.splice(i, 1);
                    break;
                }
            }
        }
    }

    getNumModules()
    {
        return this._modules.length;
    }

    getCurrentModules() { return this._modules; }

    /**
     * add a module
     * @param {ShaderModule} mod the module to be added
     * @param {ShaderModule} [sibling] sibling module, new module will share the same group
     */
    addModule(mod, sibling)
    {
        if (this.hasModule(mod.id)) return;
        if (!mod.id) mod.id = external_CABLES_namespaceObject.utils.simpleId();
        if (!mod.numId) mod.numId = this._moduleNumId;
        if (!mod.num)mod.num = this._modules.length;
        if (sibling && !sibling.group) sibling.group = external_CABLES_namespaceObject.utils.simpleId();

        if (!mod.group)
            if (sibling) mod.group = sibling.group;
            else mod.group = external_CABLES_namespaceObject.utils.simpleId();

        mod.prefix = "mod" + mod.group + "_";
        this._modules.push(mod);

        this.setWhyCompile("add module " + mod.title);
        this._moduleNumId++;

        return mod;
    }

    isValid()
    {
        return this._isValid;
    }

}

;// CONCATENATED MODULE: ./src/corelibs/cgl/cgl_shader.js











// ---------------------------------------------------------------------------

/*

proposal default shader variable names:

attrVertex - currently: vPosition
attrVertexIndex - currently: attrVertIndex
attrTexCoord
attrInstMat - currently: instMat
attrVertColor
attrTangent
attrBiTangent

uProjMatrix - currently: projMatrix
uModelMatrix - currently: modelMatrix
uNormalMatrix - currently: normalMatrix
uCamPosition - currently: camPos

*/

// ---------------------------------------------------------------------------

// eslint-disable-next-line no-restricted-syntax
const defaultShaderSrcVert = `
{{MODULES_HEAD}}
IN vec3 vPosition; //!@
IN vec2 attrTexCoord;
IN vec3 attrVertNormal;
IN vec3 attrTangent,attrBiTangent;

IN float attrVertIndex;

OUT vec2 texCoord;
OUT vec3 norm;
UNI mat4 projMatrix;
UNI mat4 viewMatrix;
UNI mat4 modelMatrix;

void main()
{
    texCoord=attrTexCoord;
    norm=attrVertNormal;
    vec4 pos=vec4(vPosition,  1.0);
    vec3 tangent=attrTangent;
    vec3 bitangent=attrBiTangent;
    mat4 mMatrix=modelMatrix;
    gl_PointSize=10.0;

    {{MODULE_VERTEX_POSITION}}

    mat4 modelViewMatrix=viewMatrix*mMatrix;
    {{MODULE_VERTEX_MODELVIEW}}

    gl_Position = projMatrix * modelViewMatrix * pos;
}
`;
let materialIdCounter = 0;

function getDefaultVertexShader()
{
    return defaultShaderSrcVert;
}

/**
 * @param {number} [r]
 * @param {number} [g]
 * @param {number} [b]
 */
function getDefaultFragmentShader(r, g, b)
{
    if (r == undefined)
    {
        r = 0.5;
        g = 0.5;
        b = 0.5;
    }
    return ""
        + nl + "IN vec2 texCoord;"
        + nl + "{{MODULES_HEAD}}"
        + nl + "void main()"
        + nl + "{"

        + nl + "    vec4 col=vec4(" + r + "," + g + "," + b + ",1.0);"
        + nl + "    {{MODULE_COLOR}}"
        + nl + "    outColor = col;"
        + nl + "}";
}

/**
 * @class
 * @namespace external:CGL
 * @hideconstructor
 * @param _cgl
 * @param _name
 * @param _op
 * @example
 * var shader=new CGL.Shader(cgl,'MinimalMaterial');
 * shader.setSource(attachments.shader_vert,attachments.shader_frag);
 */
class CglShader extends CgShader
{

    /** @type {Uniform[]} */
    _uniforms = [];

    /**
     * @param {CglContext} _cgl
     * @param {string} _name
     * @param {Op} [_op]
     */
    constructor(_cgl, _name, _op)
    {
        super();
        if (!_cgl) throw new Error("shader constructed without cgl " + _name);

        this._log = new external_CABLES_SHARED_namespaceObject.Logger("cgl_shader");
        this._cgl = _cgl;

        if (!_name) this._log.stack("no shader name given");
        this._name = _name || "unknown";

        if (_op) this.opId = _op.id;
        this.glslVersion = 0;
        if (_cgl.glVersion > 1) this.glslVersion = 300;

        this._materialId = ++materialIdCounter;

        this._program = null;
        this._drawBuffers = [true];
        this.error = null;

        this.ignoreMissingUniforms = false;
        this._projMatrixUniform = null;
        this._mvMatrixUniform = null;
        this._mMatrixUniform = null;
        this._vMatrixUniform = null;
        this._camPosUniform = null;
        this._normalMatrixUniform = null;
        this._inverseViewMatrixUniform = null;
        this._fromUserInteraction = false;

        this._attrVertexPos = -1;
        this.precision = _cgl.patch.config.glslPrecision || "highp";

        this._pMatrixState = -1;
        this._vMatrixState = -1;

        this._countMissingUniforms = 0;
        this._modGroupCount = 0; // not needed anymore...
        this._feedBackNames = [];
        this._attributes = [];

        this.glPrimitive = null;
        this.offScreenPass = false;
        this._extensions = [];
        this.srcVert = getDefaultVertexShader();
        this.srcFrag = getDefaultFragmentShader();
        this.lastCompile = 0;

        this._libs = [];
        this._structNames = [];
        this._structUniformNames = [];
        this._textureStackUni = [];
        this._textureStackTex = [];
        this._textureStackType = [];
        this._textureStackTexCgl = [];

        this._tempNormalMatrix = external_CABLES_GLMatrix_namespaceObject.mat4.create();
        this._tempCamPosMatrix = external_CABLES_GLMatrix_namespaceObject.mat4.create();
        this._tempInverseViewMatrix = external_CABLES_GLMatrix_namespaceObject.mat4.create();
        this._tempInverseProjMatrix = external_CABLES_GLMatrix_namespaceObject.mat4.create();

        this.setModules(["MODULE_VERTEX_POSITION", "MODULE_COLOR", "MODULE_NORMAL", "MODULE_BEGIN_FRAG", "MODULE_VERTEX_MODELVIEW"]);
    }

    isValid()
    {
        return this._isValid;
    }

    getCgl()
    {
        return this._cgl;
    }

    getName()
    {
        return this._name;
    }

    /**
     * @param {string} name
     */
    enableExtension(name)
    {
        this.setWhyCompile("enable extension " + name);

        this._extensions.push(name);
    }

    getAttrVertexPos()
    {
        return this._attrVertexPos;
    }

    hasTextureUniforms()
    {
        for (let i = 0; i < this._uniforms.length; i++)
            if (this._uniforms[i].getType() == "t") return true;
        return false;
    }

    /**
     * copy all uniform values from another shader
     * @param {CglShader} origShader uniform values will be copied from this shader
     */
    copyUniformValues(origShader)
    {
        for (let i = 0; i < origShader._uniforms.length; i++)
        {
            if (!this._uniforms[i])
            {
                this._log.log("unknown uniform?!");
                continue;
            }

            this.getUniform(origShader._uniforms[i].getName()).set(origShader._uniforms[i].getValue());
        }

        this.popTextures();
        for (let i = 0; i < origShader._textureStackUni.length; i++)
        {
            this._textureStackUni[i] = origShader._textureStackUni[i];
            this._textureStackTex[i] = origShader._textureStackTex[i];
            this._textureStackType[i] = origShader._textureStackType[i];
            this._textureStackTexCgl[i] = origShader._textureStackTexCgl[i];
        }

    }

    /**
     * copy current shader
     * @returns {CglShader} newShader
     */
    copy()
    {
        const shader = new CglShader(this._cgl, this._name + " copy");
        shader.setSource(this.srcVert, this.srcFrag);

        shader._modules = JSON.parse(JSON.stringify(this._modules));
        shader._defines = JSON.parse(JSON.stringify(this._defines));

        shader._modGroupCount = this._modGroupCount;
        shader._moduleNames = this._moduleNames;
        shader.glPrimitive = this.glPrimitive;
        shader.offScreenPass = this.offScreenPass;
        shader._extensions = this._extensions;
        shader.wireframe = this.wireframe;
        shader._attributes = this._attributes;

        for (let i = 0; i < this._uniforms.length; i++)
        {
            const u = this._uniforms[i].copy(shader);
            u.resetLoc();
        }

        shader.setWhyCompile("copy");
        return shader;
    }

    /**
     * set shader source code
     * @param {String} srcVert
     * @param {String} srcFrag
     * @param {Boolean} fromUserInteraction
     */
    setSource(srcVert, srcFrag, fromUserInteraction = false)
    {
        this._fromUserInteraction = fromUserInteraction;
        this.srcVert = srcVert;
        this.srcFrag = srcFrag;
        this.setWhyCompile("Source changed");
        this._isValid = true;
    }

    _addLibs(src)
    {
        for (const id in ShaderLibMods)
        {
            if (src.includes(id))
            {
                const lib = new ShaderLibMods[id]();
                src = src.replace("{{" + id + "}}", lib.srcHeadFrag);
                this._libs.push(lib);
                if (lib.initUniforms)lib.initUniforms(this);
            }
        }

        return src;
    }

    createStructUniforms()
    {
        // * create structs
        let structStrFrag = "";
        let structStrVert = ""; // TODO: not used yet

        this._structNames = [];
        // * reset the arrays holding the value each recompile so we don't skip structs
        // * key value mapping so the same struct can be added twice (two times the same modifier)
        this._injectedStringsFrag = {};
        this._injectedStringsVert = {};

        this._structUniformNamesIndicesFrag = [];
        this._structUniformNamesIndicesVert = [];

        for (let i = 0; i < this._uniforms.length; i++)
        {
            // * only add uniforms to struct that are a member of a struct
            if (this._uniforms[i].isStructMember())
            {
                const injectionString = "{{INJECTION_POINT_STRUCT_" + this._uniforms[i]._structName + "}}";

                // * check if struct is not already part of shader
                if (!this._structNames.includes(this._uniforms[i]._structName))
                {
                    // * create struct definition with placeholder string to inject
                    const structDefinition = "struct "
                        + this._uniforms[i]._structName + " {" + nl
                        + injectionString
                        + "};" + nl + nl;

                    if (this._uniforms[i].getShaderType() === "both" || this._uniforms[i].getShaderType() === "frag")
                        structStrFrag = structStrFrag.concat(structDefinition);

                    if (this._uniforms[i].getShaderType() === "both" || this._uniforms[i].getShaderType() === "vert")
                        structStrVert = structStrVert.concat(structDefinition);

                    this._structNames.push(this._uniforms[i]._structName);
                    this._injectedStringsFrag[this._uniforms[i]._structName] = [];
                    this._injectedStringsVert[this._uniforms[i]._structName] = [];
                }

                // * create member & comment
                let comment = "";
                if (this._uniforms[i].comment) comment = " // " + this._uniforms[i].comment;

                let stringToInsert = "";
                if (this._uniforms[i].getGlslTypeString() == undefined)stringToInsert += "//";
                stringToInsert += "  " + this._uniforms[i].getGlslTypeString()
                        + " " + this._uniforms[i]._propertyName + ";"
                        + comment;

                if (this._uniforms[i].getShaderType() === "both")
                {
                    // * inject member before {injectionString}
                    if (
                        !this._injectedStringsFrag[this._uniforms[i]._structName].includes(stringToInsert)
                    && !this._injectedStringsVert[this._uniforms[i]._structName].includes(stringToInsert))
                    {
                        const insertionIndexFrag = structStrFrag.lastIndexOf(injectionString);
                        const insertionIndexVert = structStrVert.lastIndexOf(injectionString);

                        structStrFrag =
                            structStrFrag.slice(0, insertionIndexFrag)
                            + stringToInsert + structStrFrag.slice(insertionIndexFrag - 1);

                        structStrVert =
                            structStrVert.slice(0, insertionIndexVert)
                            + stringToInsert + structStrVert.slice(insertionIndexVert - 1);

                        this._injectedStringsFrag[this._uniforms[i]._structName].push(stringToInsert);
                        this._injectedStringsVert[this._uniforms[i]._structName].push(stringToInsert);
                    }

                    if (!this._structUniformNamesIndicesFrag.includes(i)) this._structUniformNamesIndicesFrag.push(i);
                    if (!this._structUniformNamesIndicesVert.includes(i)) this._structUniformNamesIndicesVert.push(i);
                }
                else if (this._uniforms[i].getShaderType() === "frag")
                {
                    // * inject member before {injectionString}
                    if (!this._injectedStringsFrag[this._uniforms[i]._structName].includes(stringToInsert)) //
                    {
                        const insertionIndexFrag = structStrFrag.lastIndexOf(injectionString);

                        structStrFrag =
                            structStrFrag.slice(0, insertionIndexFrag)
                            + stringToInsert + structStrFrag.slice(insertionIndexFrag - 1);

                        this._injectedStringsFrag[this._uniforms[i]._structName].push(stringToInsert);
                    }

                    if (!this._structUniformNamesIndicesFrag.includes(i)) this._structUniformNamesIndicesFrag.push(i);
                }
                else if (this._uniforms[i].getShaderType() === "vert")
                {
                    // * inject member before {injectionString}
                    if (!this._injectedStringsVert[this._uniforms[i]._structName].includes(stringToInsert))
                    {
                        const insertionIndexVert = structStrVert.lastIndexOf(injectionString);

                        structStrVert =
                            structStrVert.slice(0, insertionIndexVert)
                            + stringToInsert + structStrVert.slice(insertionIndexVert - 1);

                        this._injectedStringsVert[this._uniforms[i]._structName].push(stringToInsert);
                    }

                    if (!this._structUniformNamesIndicesVert.includes(i)) this._structUniformNamesIndicesVert.push(i);
                }
            }
        }

        // * dedupe injected uni declarations
        this._uniDeclarationsFrag = [];
        this._uniDeclarationsVert = [];

        // * remove struct injection points and add uniform in fragment
        for (let i = 0; i < this._structUniformNamesIndicesFrag.length; i += 1)
        {
            const index = this._structUniformNamesIndicesFrag[i];
            const uniDeclarationString = "UNI " + this._uniforms[index]._structName + " " + this._uniforms[index]._structUniformName + ";" + nl;

            if (!this._uniDeclarationsFrag.includes(uniDeclarationString))
            {
                const injectionString = "{{INJECTION_POINT_STRUCT_" + this._uniforms[index]._structName + "}}";

                structStrFrag = structStrFrag.replace(injectionString, "");
                structStrFrag += uniDeclarationString;

                this._uniDeclarationsFrag.push(uniDeclarationString);
            }
        }

        // * remove struct injection points and add uniform in vertex
        for (let i = 0; i < this._structUniformNamesIndicesVert.length; i += 1)
        {
            const index = this._structUniformNamesIndicesVert[i];
            const uniDeclarationString = "UNI " + this._uniforms[index]._structName + " " + this._uniforms[index]._structUniformName + ";" + nl;

            if (!this._uniDeclarationsVert.includes(uniDeclarationString))
            {
                const injectionString = "{{INJECTION_POINT_STRUCT_" + this._uniforms[index]._structName + "}}";

                structStrVert = structStrVert.replace(injectionString, "");
                structStrVert += uniDeclarationString;
                this._uniDeclarationsVert.push(uniDeclarationString);
            }
        }

        return [structStrVert, structStrFrag];
    }

    _getAttrSrc(attr, firstLevel)
    {
        const r = {};
        if (attr.name && attr.type)
        {
            r.srcHeadVert = "";
            if (!firstLevel) r.srcHeadVert += "#ifndef ATTRIB_" + attr.name + nl;
            r.srcHeadVert += "#define ATTRIB_" + attr.name + nl;
            r.srcHeadVert += "IN " + attr.type + " " + attr.name + ";" + nl;
            if (!firstLevel) r.srcHeadVert += "#endif" + nl;

            if (attr.nameFrag)
            {
                r.srcHeadVert += "";
                if (!firstLevel) r.srcHeadVert += "#ifndef ATTRIB_" + attr.nameFrag + nl;
                r.srcHeadVert += "#define ATTRIB_" + attr.nameFrag + nl;
                r.srcHeadVert += "OUT " + attr.type + " " + attr.nameFrag + ";" + nl;
                if (!firstLevel) r.srcHeadVert += "#endif" + nl;

                r.srcVert = "" + nl + attr.nameFrag + "=" + attr.name + ";";

                r.srcHeadFrag = "";
                if (!firstLevel) r.srcHeadFrag += "#ifndef ATTRIB_" + attr.nameFrag + nl;
                r.srcHeadFrag += "#define ATTRIB_" + attr.nameFrag + nl;
                r.srcHeadFrag += "IN " + attr.type + " " + attr.nameFrag + ";" + nl;
                if (!firstLevel) r.srcHeadFrag += "#endif" + nl;
            }
        }
        return r;
    }

    compile()
    {
        if (this._cgl.aborted) return;
        const startTime = performance.now();

        this._cgl.profileData.profileShaderCompiles++;
        this._cgl.profileData.profileShaderCompileName = this._name + " [" + this._compileReason + "]";

        let extensionString = "";
        if (this._extensions)
            for (let i = 0; i < this._extensions.length; i++)
                extensionString += "#extension " + this._extensions[i] + " : enable" + nl;

        let definesStr = "";
        if (this._defines.length) definesStr = "\n// cgl generated" + nl;
        for (let i = 0; i < this._defines.length; i++)
            definesStr += "#define " + this._defines[i][0] + " " + this._defines[i][1] + "" + nl;

        const structStrings = this.createStructUniforms();
        this._cgl.profileData.addHeavyEvent("shader compile", this._name + " [" + this._compileReason + "]");
        this._compileReason = "";

        if (this._uniforms)
        {
            // * we create an array of the uniform names to check our indices & an array to save them
            const uniNames = this._uniforms.map((uni) => { return uni._name; });
            const indicesToRemove = [];

            // * we go through our uniforms and check if the same name is contained somewhere further in the array
            // * if so, we add the current index to be removed later
            for (let i = 0; i < this._uniforms.length; i++)
            {
                const uni = this._uniforms[i];
                const nextIndex = uniNames.indexOf(uni._name, i + 1);
                if (nextIndex > -1) indicesToRemove.push(i);
            }

            // * after that, we go through the uniforms backwards (so we keep the order) and remove the indices
            // * also, we reset the locations of all the other valid uniforms
            for (let j = this._uniforms.length - 1; j >= 0; j -= 1)
            {
                if (indicesToRemove.includes(j)) this._uniforms.splice(j, 1);
                else this._uniforms[j].resetLoc();
            }
        }

        this._cgl.printError("uniform resets");

        this._compileCount++;
        if (this.hasTextureUniforms()) definesStr += "#define HAS_TEXTURES" + nl;

        let vs = "";
        let fs = "";

        if (!this.srcFrag)
        {
            this._log.warn("[cgl shader] has no fragment source!", this._name, this);
            this.srcVert = getDefaultVertexShader();
            this.srcFrag = getDefaultFragmentShader();
        }

        vs = "#version 300 es"
            + nl + "// "
            + nl + "// vertex shader " + this._name
            + nl + "// "
            + nl + "precision " + this.precision + " float;"
            + nl + "precision " + this.precision + " sampler2D;"
            + nl + ""
            + nl + "#define WEBGL2"
            + nl + "#define texture2D texture"
            + nl + "#define UNI uniform"
            + nl + "#define IN in"
            + nl + "#define OUT out"
            + nl;

        fs = "#version 300 es"
            + nl + "// "
            + nl + "// fragment shader " + this._name
            + nl + "// "
            + nl + "precision " + this.precision + " float;"
            + nl + "precision " + this.precision + " sampler2D;"
            + nl + ""
            + nl + "#define WEBGL2"
            + nl + "#define texture2D texture"
            + nl + "#define IN in"
            + nl + "#define OUT out"
            + nl + "#define UNI uniform"
            + nl + "{{DRAWBUFFER}}"

            + nl;

        let uniformsStrVert = "\n// cgl generated" + nl;
        let uniformsStrFrag = "\n// cgl generated" + nl;

        fs += "\n// active mods: --------------- ";
        vs += "\n// active mods: --------------- ";

        let foundModsFrag = false;
        let foundModsVert = false;
        for (let i = 0; i < this._moduleNames.length; i++)
        {
            for (let j = 0; j < this._modules.length; j++)
            {
                if (this._modules[j].name == this._moduleNames[i])
                {
                    if (this._modules[j].srcBodyFrag || this._modules[j].srcHeadFrag)
                    {
                        foundModsFrag = true;
                        fs += "\n// " + i + "." + j + ". " + this._modules[j].title + " (" + this._modules[j].name + ")";
                    }
                    if (this._modules[j].srcBodyVert || this._modules[j].srcHeadVert)
                    {
                        vs += "\n// " + i + "." + j + ". " + this._modules[j].title + " (" + this._modules[j].name + ")";
                        foundModsVert = true;
                    }
                }
            }
        }
        if (!foundModsVert)fs += "\n// no mods used...";
        if (!foundModsFrag)fs += "\n// no mods used...";
        fs += "\n";
        vs += "\n";

        for (let i = 0; i < this._uniforms.length; i++)
        {
            if (this._uniforms[i].shaderType && !this._uniforms[i].isStructMember())
            {
                let uniStr = "";
                if (!this._uniforms[i].getGlslTypeString())uniStr += "// ";
                uniStr += "UNI " + this._uniforms[i].getGlslTypeString() + " " + this._uniforms[i].getName();
                let comment = "";
                if (this._uniforms[i].comment) comment = " // " + this._uniforms[i].comment;

                if (this._uniforms[i].shaderType == "vert" || this._uniforms[i].shaderType == "both")
                    if (!this.srcVert.includes(uniStr) && !this.srcVert.includes("uniform " + this._uniforms[i].getGlslTypeString() + " " + this._uniforms[i].getName()))
                        uniformsStrVert += uniStr + ";" + comment + nl;

                if (this._uniforms[i].shaderType == "frag" || this._uniforms[i].shaderType == "both")
                    if (!this.srcFrag.includes(uniStr) && !this.srcFrag.includes("uniform " + this._uniforms[i].getGlslTypeString() + " " + this._uniforms[i].getName()))
                        uniformsStrFrag += uniStr + ";" + comment + nl;
            }
        }

        let countUniFrag = 0;
        let countUniVert = 0;
        for (let i = 0; i < this._uniforms.length; i++)
        {
            if (this._uniforms[i].shaderType && !this._uniforms[i].isStructMember())
            {
                if (this._uniforms[i].shaderType == "vert" || this._uniforms[i].shaderType == "both") countUniVert++;
                if (this._uniforms[i].shaderType == "frag" || this._uniforms[i].shaderType == "both") countUniFrag++;
            }
        }
        if (countUniFrag >= this._cgl.maxUniformsFrag) this._log.warn("[cgl_shader] num uniforms frag: " + countUniFrag + " / " + this._cgl.maxUniformsFrag);
        if (countUniVert >= this._cgl.maxUniformsVert) this._log.warn("[cgl_shader] num uniforms vert: " + countUniVert + " / " + this._cgl.maxUniformsVert);

        if (!fs.includes("precision")) fs = "precision " + this.precision + " float;" + nl + fs;
        if (!vs.includes("precision")) vs = "precision " + this.precision + " float;" + nl + vs;
        if (/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent))
        {
            fs += "#define MOBILE" + nl;
            vs += "#define MOBILE" + nl;
        }
        vs = extensionString + vs + definesStr + structStrings[0] + uniformsStrVert + "\n// -- \n" + this.srcVert;
        fs = extensionString + fs + definesStr + structStrings[1] + uniformsStrFrag + "\n// -- \n" + this.srcFrag;

        let srcHeadVert = "";
        let srcHeadFrag = "";

        this._modules.sort(function (a, b)
        {
            return a.priority || 0 - b.priority || 0;
        });

        let addedAttribs = false;

        for (let i = 0; i < this._moduleNames.length; i++)
        {
            let srcVert = "";
            let srcFrag = "";

            if (!addedAttribs)
            {
                addedAttribs = true;

                for (let k = 0; k < this._attributes.length; k++)
                {
                    const r = this._getAttrSrc(this._attributes[k], true);
                    if (r.srcHeadVert)srcHeadVert += r.srcHeadVert;
                    if (r.srcVert)srcVert += r.srcVert;
                    if (r.srcHeadFrag)srcHeadFrag += r.srcHeadFrag;
                }
            }

            for (let j = 0; j < this._modules.length; j++)
            {
                const mod = this._modules[j];
                if (mod.name == this._moduleNames[i])
                {
                    srcHeadVert += "\n//---- MOD: group:" + mod.group + ": idx:" + j + " - prfx:" + mod.prefix + " - " + mod.title + " ------\n";
                    srcHeadFrag += "\n//---- MOD: group:" + mod.group + ": idx:" + j + " - prfx:" + mod.prefix + " - " + mod.title + " ------\n";

                    srcVert += "\n\n//---- MOD: " + mod.title + " / " + mod.priority + " ------\n";
                    srcFrag += "\n\n//---- MOD: " + mod.title + " / " + mod.priority + " ------\n";

                    if (mod.attributes)
                        for (let k = 0; k < mod.attributes.length; k++)
                        {
                            const r = this._getAttrSrc(mod.attributes[k], false);
                            if (r.srcHeadVert)srcHeadVert += r.srcHeadVert;
                            if (r.srcVert)srcVert += r.srcVert;
                            if (r.srcHeadFrag)srcHeadFrag += r.srcHeadFrag;
                        }

                    srcHeadVert += mod.srcHeadVert || "";
                    srcHeadFrag += mod.srcHeadFrag || "";
                    srcVert += mod.srcBodyVert || "";
                    srcFrag += mod.srcBodyFrag || "";

                    srcHeadVert += "\n//---- end mod ------\n";
                    srcHeadFrag += "\n//---- end mod ------\n";

                    srcVert += "\n//---- end mod ------\n";
                    srcFrag += "\n//---- end mod ------\n";

                    srcVert = srcVert.replace(/{{mod}}/g, mod.prefix);
                    srcFrag = srcFrag.replace(/{{mod}}/g, mod.prefix);
                    srcHeadVert = srcHeadVert.replace(/{{mod}}/g, mod.prefix);
                    srcHeadFrag = srcHeadFrag.replace(/{{mod}}/g, mod.prefix);

                    srcVert = srcVert.replace(/MOD_/g, mod.prefix);
                    srcFrag = srcFrag.replace(/MOD_/g, mod.prefix);
                    srcHeadVert = srcHeadVert.replace(/MOD_/g, mod.prefix);
                    srcHeadFrag = srcHeadFrag.replace(/MOD_/g, mod.prefix);
                }
            }

            vs = vs.replace("{{" + this._moduleNames[i] + "}}", srcVert);
            fs = fs.replace("{{" + this._moduleNames[i] + "}}", srcFrag);
        }

        vs = vs.replace("{{MODULES_HEAD}}", srcHeadVert);
        fs = fs.replace("{{MODULES_HEAD}}", srcHeadFrag);

        vs = this._addLibs(vs);
        fs = this._addLibs(fs);

        // SETUP draw buffers / multi texture render targets

        let drawBufferStr = "";
        for (let i = 0; i < 16; i++)
            if (fs.includes("outColor" + i)) this._drawBuffers[i] = true;

        if (this._drawBuffers.length == 1)
        {
            drawBufferStr = "out vec4 outColor;" + nl;
            drawBufferStr += "#define gl_FragColor outColor" + nl;
        }
        else
        {
            drawBufferStr += "#define MULTI_COLORTARGETS" + nl;
            drawBufferStr += "vec4 outColor;" + nl;

            let count = 0;
            for (let i = 0; i < this._drawBuffers.length; i++)
            {
                if (count == 0) drawBufferStr += "#define gl_FragColor outColor" + i + "" + nl;
                drawBufferStr += "layout(location = " + i + ") out vec4 outColor" + i + ";" + nl;
                count++;
            }
        }

        fs = fs.replace("{{DRAWBUFFER}}", drawBufferStr);
        // //////

        if (!this._program)
        {
            this._program = this._createProgram(vs, fs);
        }
        else
        {
            // this.vshader=createShader(vs, gl.VERTEX_SHADER, this.vshader );
            // this.fshader=createShader(fs, gl.FRAGMENT_SHADER, this.fshader );
            // linkProgram(program);
            this._program = this._createProgram(vs, fs);

            this._projMatrixUniform = null;

            for (let i = 0; i < this._uniforms.length; i++) this._uniforms[i].resetLoc();
        }

        this.finalShaderFrag = fs;
        this.finalShaderVert = vs;

        MESH.lastMesh = null;
        MESH.lastShader = null;

        this._countMissingUniforms = 0;
        this._needsRecompile = false;
        this.lastCompile = (0,external_CABLES_namespaceObject.now)();

        this._cgl.profileData.shaderCompileTime += performance.now() - startTime;
    }

    bind()
    {
        if (!this._isValid || this._cgl.aborted) return;

        MESH.lastShader = this;

        if (!this._program || this.needsRecompile()) this.compile();
        if (!this._isValid) return;

        if (!this._projMatrixUniform && !this.ignoreMissingUniforms)
        {
            this._countMissingUniforms++;
            // if (this._countMissingUniforms == 10)this._log.log("stopping getlocation of missing uniforms...", this._name);
            if (this._countMissingUniforms < 10)
            {
                this._projMatrixUniform = this._cgl.gl.getUniformLocation(this._program, CONSTANTS.SHADER.SHADERVAR_UNI_PROJMAT);
                this._attrVertexPos = this._cgl.glGetAttribLocation(this._program, CONSTANTS.SHADER.SHADERVAR_VERTEX_POSITION);
                this._mvMatrixUniform = this._cgl.gl.getUniformLocation(this._program, "mvMatrix");
                this._vMatrixUniform = this._cgl.gl.getUniformLocation(this._program, CONSTANTS.SHADER.SHADERVAR_UNI_VIEWMAT);
                this._mMatrixUniform = this._cgl.gl.getUniformLocation(this._program, CONSTANTS.SHADER.SHADERVAR_UNI_MODELMAT);
                this._camPosUniform = this._cgl.gl.getUniformLocation(this._program, CONSTANTS.SHADER.SHADERVAR_UNI_VIEWPOS);
                this._normalMatrixUniform = this._cgl.gl.getUniformLocation(this._program, CONSTANTS.SHADER.SHADERVAR_UNI_NORMALMAT);
                this._inverseViewMatrixUniform = this._cgl.gl.getUniformLocation(this._program, CONSTANTS.SHADER.SHADERVAR_UNI_INVVIEWMAT);
                this._inverseProjMatrixUniform = this._cgl.gl.getUniformLocation(this._program, CONSTANTS.SHADER.SHADERVAR_UNI_INVPROJMAT);
                this._materialIdUniform = this._cgl.gl.getUniformLocation(this._program, CONSTANTS.SHADER.SHADERVAR_UNI_MATERIALID);
                this._objectIdUniform = this._cgl.gl.getUniformLocation(this._program, CONSTANTS.SHADER.SHADERVAR_UNI_OBJECTID);

                for (let i = 0; i < this._uniforms.length; i++) this._uniforms[i].needsUpdate = true;
            }
        }

        if (this._cgl.currentProgram != this._program)
        {
            this._cgl.profileData.profileShaderBinds++;
            this._cgl.gl.useProgram(this._program);
            this._cgl.currentProgram = this._program;
        }

        for (let i = 0; i < this._uniforms.length; i++)
            if (this._uniforms[i].needsUpdate) this._uniforms[i].updateValue();

        if (this._pMatrixState != this._cgl.getProjectionMatrixStateCount())
        {
            this._pMatrixState = this._cgl.getProjectionMatrixStateCount();
            this._cgl.gl.uniformMatrix4fv(this._projMatrixUniform, false, this._cgl.pMatrix);
            this._cgl.profileData.profileMVPMatrixCount++;
        }

        if (this._objectIdUniform)
            this._cgl.gl.uniform1f(this._objectIdUniform, ++this._cgl.tempData.objectIdCounter);

        if (this._materialIdUniform)
            this._cgl.gl.uniform1f(this._materialIdUniform, this._materialId);

        if (this._vMatrixUniform)
        {
            if (this._vMatrixState != this._cgl.getViewMatrixStateCount())
            {
                this._cgl.gl.uniformMatrix4fv(this._vMatrixUniform, false, this._cgl.vMatrix);
                this._cgl.profileData.profileMVPMatrixCount++;
                this._vMatrixState = this._cgl.getViewMatrixStateCount();

                if (this._inverseViewMatrixUniform)
                {
                    external_CABLES_GLMatrix_namespaceObject.mat4.invert(this._tempInverseViewMatrix, this._cgl.vMatrix);
                    this._cgl.gl.uniformMatrix4fv(this._inverseViewMatrixUniform, false, this._tempInverseViewMatrix);
                    this._cgl.profileData.profileMVPMatrixCount++;
                }
                if (this._inverseProjMatrixUniform)
                {
                    external_CABLES_GLMatrix_namespaceObject.mat4.invert(this._tempInverseProjMatrix, this._cgl.pMatrix);
                    this._cgl.gl.uniformMatrix4fv(this._inverseProjMatrixUniform, false, this._tempInverseProjMatrix);
                    this._cgl.profileData.profileMVPMatrixCount++;
                }
            }
            this._cgl.gl.uniformMatrix4fv(this._mMatrixUniform, false, this._cgl.mMatrix);
            this._cgl.profileData.profileMVPMatrixCount++;

            if (this._camPosUniform)
            {
                external_CABLES_GLMatrix_namespaceObject.mat4.invert(this._tempCamPosMatrix, this._cgl.vMatrix);
                this._cgl.gl.uniform3f(this._camPosUniform, this._tempCamPosMatrix[12], this._tempCamPosMatrix[13], this._tempCamPosMatrix[14]);
                this._cgl.profileData.profileMVPMatrixCount++;
            }
        }
        else
        {
            // mvmatrix deprecated....
            const tempmv = external_CABLES_GLMatrix_namespaceObject.mat4.create();

            external_CABLES_GLMatrix_namespaceObject.mat4.mul(tempmv, this._cgl.vMatrix, this._cgl.mMatrix);
            this._cgl.gl.uniformMatrix4fv(this._mvMatrixUniform, false, tempmv);
            this._cgl.profileData.profileMVPMatrixCount++;
        }

        if (this._normalMatrixUniform)
        {
            // mat4.mul(this._tempNormalMatrix, this._cgl.vMatrix, this._cgl.mMatrix);
            external_CABLES_GLMatrix_namespaceObject.mat4.invert(this._tempNormalMatrix, this._cgl.mMatrix);
            external_CABLES_GLMatrix_namespaceObject.mat4.transpose(this._tempNormalMatrix, this._tempNormalMatrix);

            this._cgl.gl.uniformMatrix4fv(this._normalMatrixUniform, false, this._tempNormalMatrix);
            this._cgl.profileData.profileMVPMatrixCount++;
        }

        for (let i = 0; i < this._libs.length; i++)
        {
            if (this._libs[i].onBind) this._libs[i].onBind.bind(this._libs[i])(this._cgl, this);
        }

        this._bindTextures();

        return this._isValid;
    }

    unBind()
    {
    }

    dispose()
    {

        if (this._program && this._cgl && this._cgl.gl) this._cgl.gl.deleteProgram(this._program);
        this._program = null;
    }

    setDrawBuffers(arr)
    {
        this._log.warn("useless drawbuffers...?!");
    }

    getUniforms()
    {
        return this._uniforms;
    }

    getUniform(name)
    {
        for (let i = 0; i < this._uniforms.length; i++)
            if (this._uniforms[i].getName() == name)
                return this._uniforms[i];
        return null;
    }

    removeAllUniforms()
    {
        this._uniforms = [];
        // for (let i = 0; i < this._uniforms.length; i++)
        //     this.removeUniform(this._uniforms[i].name);
    }

    _addUniform(uni)
    {
        this._uniforms.push(uni);
        this.setWhyCompile("add uniform " + name);
    }

    /**
     * add a uniform to the fragment shader
     * @param {String} type ['f','t', etc]
     * @param {String} name
     * @param {any} valueOrPort value or port
     * @param p2
     * @param p3
     * @param p4
     * @returns {Uniform}
     */
    addUniformFrag(type, name, valueOrPort, p2, p3, p4)
    {
        const uni = new Uniform(this, type, name, valueOrPort, p2, p3, p4);
        uni.shaderType = "frag";
        return uni;
    }

    /**
     * add a uniform to the vertex shader
     * @param {String} type ['f','t', etc]
     * @param {String} name
     * @param {any} valueOrPort value or port
     * @param p2
     * @param p3
     * @param p4
     * @returns {Uniform}
     */
    addUniformVert(type, name, valueOrPort, p2, p3, p4)
    {
        const uni = new Uniform(this, type, name, valueOrPort, p2, p3, p4);
        uni.shaderType = "vert";
        return uni;
    }

    /**
     * add a uniform to both shaders
     * @param {String} type ['f','t', etc]
     * @param {String} name
     * @param {any} valueOrPort value or port
     * @param p2
     * @param p3
     * @param p4
     * @returns {Uniform}
     */
    addUniformBoth(type, name, valueOrPort, p2, p3, p4)
    {
        const uni = new Uniform(this, type, name, valueOrPort, p2, p3, p4);
        uni.shaderType = "both";
        return uni;
    }

    /**
     * add a struct & its uniforms to the fragment shader
     * @param {String} structName name of the struct, i.e.: LightStruct
     * @param {String} uniformName name of the struct uniform in the shader, i.e.: lightUni
     * @param {Array} members array of objects containing the struct members. see example for structure

     * @returns {Object}
     * @example
     * const shader = new CGL.Shader(cgl, 'MinimalMaterial');
     * shader.setSource(attachments.shader_vert, attachments.shader_frag);
     * shader.addUniformStructFrag("Light", "uniformLight", [
     * { "type": "3f", "name": "position", "v1": null },
     * { "type": "4f", "name": "color", "v1": inR, v2: inG, v3: inB, v4: inAlpha }
     * ]);
     */
    addUniformStructFrag(structName, uniformName, members)
    {
        const uniforms = {};

        if (!members) return uniforms;

        for (let i = 0; i < members.length; i += 1)
        {
            const member = members[i];
            if (!this.hasUniform(uniformName + "." + member.name))
            {
                const uni = new Uniform(this, member.type, uniformName + "." + member.name, member.v1, member.v2, member.v3, member.v4, uniformName, structName, member.name);
                uni.shaderType = "frag";
                uniforms[uniformName + "." + member.name] = uni;
            }
        }

        return uniforms;
    }

    /**
     * add a struct & its uniforms to the vertex shader
     * @param {String} structName name of the struct, i.e.: LightStruct
     * @param {String} uniformName name of the struct uniform in the shader, i.e.: lightUni
     * @param {Array} members array of objects containing the struct members. see example for structure
     * @returns {object}
     * @example
     * const shader = new CGL.Shader(cgl, 'MinimalMaterial');
     * shader.setSource(attachments.shader_vert, attachments.shader_frag);
     * shader.addUniformStructVert("Light", "uniformLight", [
     * { "type": "3f", "name": "position", "v1": null },
     * { "type": "4f", "name": "color", "v1": inR, v2: inG, v3: inB, v4: inAlpha }
     * ]);
     */
    addUniformStructVert(structName, uniformName, members)
    {
        const uniforms = {};

        if (!members) return uniforms;

        for (let i = 0; i < members.length; i += 1)
        {
            const member = members[i];
            if (!this.hasUniform(uniformName + "." + member.name))
            {
                const uni = new Uniform(this, member.type, uniformName + "." + member.name, member.v1, member.v2, member.v3, member.v4, uniformName, structName, member.name);
                uni.shaderType = "vert";
                uniforms[uniformName + "." + member.name] = uni;
            }
        }

        return uniforms;
    }

    /**
     * add a struct & its uniforms to the both shaders. PLEASE NOTE: it is not possible to add the same struct to both shaders when it contains ANY integer members.
     * @param {String} structName name of the struct, i.e.: LightStruct
     * @param {String} uniformName name of the struct uniform in the shader, i.e.: lightUni
     * @param {Array} members array of objects containing the struct members. see example for structure

     * @returns {Object}
     * @example
     * const shader = new CGL.Shader(cgl, 'MinimalMaterial');
     * shader.setSource(attachments.shader_vert, attachments.shader_frag);
     * shader.addUniformStructBoth("Light", "uniformLight", [
     * { "type": "3f", "name": "position", "v1": null },
     * { "type": "4f", "name": "color", "v1": inR, v2: inG, v3: inB, v4: inAlpha }
     * ]);
     */
    addUniformStructBoth(structName, uniformName, members)
    {
        const uniforms = {};

        if (!members) return uniforms;

        for (let i = 0; i < members.length; i += 1)
        {
            const member = members[i];
            if ((member.type === "2i" || member.type === "i" || member.type === "3i"))
                this._log.error("Adding an integer struct member to both shaders can potentially error. Please use different structs for each shader. Error occured in struct:", structName, " with member:", member.name, " of type:", member.type, ".");
            if (!this.hasUniform(uniformName + "." + member.name))
            {
                const uni = new Uniform(this, member.type, uniformName + "." + member.name, member.v1, member.v2, member.v3, member.v4, uniformName, structName, member.name);
                uni.shaderType = "both";
                uniforms[uniformName + "." + member.name] = uni;
            }
        }

        return uniforms;
    }

    /**
     * @param {String} vstr
     * @param {String} fstr
     */
    _createProgram(vstr, fstr)
    {
        this._cgl.printError("before _createprogram");

        const program = this._cgl.gl.createProgram();

        this.vshader = CglShader.createShader(this._cgl, vstr, this._cgl.gl.VERTEX_SHADER, this);
        this.fshader = CglShader.createShader(this._cgl, fstr, this._cgl.gl.FRAGMENT_SHADER, this);

        if (this.vshader && this.fshader)
        {
            this._cgl.gl.attachShader(program, this.vshader);
            this._cgl.gl.attachShader(program, this.fshader);

            this._linkProgram(program, vstr, fstr);
        }
        else
        {
            this._isValid = false;
            this._cgl.printError("shader _createProgram");
            this._log.error("could not link shaderprogram");
            return null;
        }

        this._cgl.printError("shader _createProgram");
        return program;
    }

    hasErrors()
    {
        return this._hasErrors;
    }

    /**
     * @param {any} program
     * @param {string} vstr
     * @param {string} fstr
     */
    _linkProgram(program, vstr, fstr)
    {
        this._cgl.printError("before _linkprogram");

        if (this._feedBackNames.length > 0)
        {
            this._cgl.gl.transformFeedbackVaryings(program, this._feedBackNames, this._cgl.gl.SEPARATE_ATTRIBS);
            // INTERLEAVED_ATTRIBS
            // SEPARATE_ATTRIBS
        }

        this._cgl.gl.linkProgram(program);
        this._cgl.printError("gl.linkprogram");
        this._isValid = true;
        this._hasErrors = false;

        if (this._cgl.patch.config.glValidateShader !== false)
        {
            this._cgl.gl.validateProgram(program);

            if (!this._cgl.gl.getProgramParameter(program, this._cgl.gl.VALIDATE_STATUS))
            {
                // validation failed
                this._log.log("shaderprogram validation failed...");

                this._cgl.gl.getProgramInfoLog(program);
            }

            if (!this._cgl.gl.getProgramParameter(program, this._cgl.gl.LINK_STATUS))
            {
                this._hasErrors = true;

                const infoLogFrag = this._cgl.gl.getShaderInfoLog(this.fshader);
                const infoLogVert = this._cgl.gl.getShaderInfoLog(this.vshader);

                if (this.logError)
                    this._log.error(this._name + " shader linking fail...");
                else
                    this._log.warn(this._name + " shader linking fail...");

                if (infoLogFrag) this._log.warn(this._cgl.gl.getShaderInfoLog(this.fshader));
                if (infoLogVert) this._log.warn(this._cgl.gl.getShaderInfoLog(this.vshader));

                this._cgl.gl.getProgramInfoLog(program);
                if (!CABLES.UI) this._log.log(this);
                this._isValid = false;

                this._cgl.printError("shader link err");
            }
        }
    }

    getProgram()
    {
        return this._program;
    }

    /**
     * @param {any[]} names
     */
    setFeedbackNames(names)
    {
        this.setWhyCompile("setFeedbackNames");
        this._feedBackNames = names;
    }

    /**
      * adds attribute definition to shader header without colliding with other shader modules...
     * when attrFrag is defined, vertex shader will output this attribute to the fragment shader
     * @param {Object} attr {type:x,name:x,[nameFrag:x]}
     * @return {Object}
     */
    addAttribute(attr)
    {
        for (let i = 0; i < this._attributes.length; i++)
        {
            if (this._attributes[i].name == attr.name && this._attributes[i].nameFrag == attr.nameFrag) return;
        }
        this._attributes.push(attr);

        this.setWhyCompile("addAttribute");
    }

    bindTextures()
    {
        this._bindTextures();
    }

    _bindTextures()
    {
        if (this._textureStackTex.length > this._cgl.maxTextureUnits)
        {
            this._log.warn("[shader._bindTextures] too many textures bound", this._textureStackTex.length + "/" + this._cgl.maxTextureUnits);
        }

        // for (let i = this._textureStackTex.length + 1; i < this._cgl.maxTextureUnits; i++) this._cgl.setTexture(i, null);

        for (let i = 0; i < this._textureStackTex.length; i++)
        {
            // this._log.log(this._textureStackTex.length, i);
            if (!this._textureStackTex[i] && !this._textureStackTexCgl[i])
            {
                this._log.warn("no texture for pushtexture", this._name);
            }
            else
            {
                let t = this._textureStackTex[i];
                if (this._textureStackTexCgl[i])
                {
                    t = this._textureStackTexCgl[i].tex || CGL.Texture.getEmptyTexture(this._cgl).tex;
                }

                let bindOk = true;

                if (!this._textureStackUni[i])
                {
                    // throw(new Error('no uniform given to texturestack'));
                    this._log.warn("no uniform for pushtexture", this._name);
                    bindOk = this._cgl.setTexture(i, t, this._textureStackType[i]);
                }
                else
                {
                    this._textureStackUni[i].setValue(i);
                    bindOk = this._cgl.setTexture(i, t, this._textureStackType[i]);

                    // this._log.log(bindOk, i, t, this._textureStackType[i]);
                }
                if (!bindOk) this._log.warn("tex bind failed", this.getName(), this._textureStackUni[i]);
            }
        }
    }

    /**
     * @param {Uniform} uni
     * @param {Texture} tex
     */
    setUniformTexture(uni, tex)
    {
        tex = tex || Texture.getTempTexture(this._cgl);
        for (let i = 0; i < this._textureStackUni.length; i++)
            if (this._textureStackUni[i] == uni)
            {
                const old = this._textureStackTex[i] || this._textureStackTexCgl[i];
                if (tex.hasOwnProperty("tex"))
                {
                    this._textureStackTexCgl[i] = tex;
                    this._textureStackTex[i] = null;
                }
                else
                {
                    this._textureStackTexCgl[i] = null;
                    this._textureStackTex[i] = tex;
                }

                // this._textureStackTex[i] = tex;
                // this._cgl.setTexture(i, tex, this._textureStackType[i]);
                return old;
            }
        return null;
    }

    /**
     * push a texture on the stack. those textures will be bound when binding the shader. texture slots are automatically set
     * @param {Uniform} uniform texture uniform
     * @param {Texture} t texture
     * @param {number} type texture type, can be ignored when TEXTURE_2D
     */
    pushTexture(uniform, t, type)
    {
        if (!uniform)
        {
            // this._log.log("pushtexture: no uniform given to texturestack", "shader:"+this._name,uniform,t,type);
            return;
        }
        if (!t)
        {
            // if(uniform)this._log.warn("pushtexture: no tex","shader:"+this._name," uniform:"+uniform.name);
            return;
        }
        if (!t.hasOwnProperty("tex") && !(t instanceof WebGLTexture))
        {
            this._log.warn(new Error("invalid texture").stack);

            this._log.warn("[cgl_shader] invalid texture...", t);
            return;
        }

        this._textureStackUni.push(uniform);

        if (t.hasOwnProperty("tex"))
        {
            this._textureStackTexCgl.push(t);
            this._textureStackTex.push(null);
        }
        else
        {
            this._textureStackTexCgl.push(null);
            this._textureStackTex.push(t);
        }

        this._textureStackType.push(type);
    }

    /**
     * pop last texture
     */
    popTexture()
    {
        this._textureStackUni.pop();
        this._textureStackTex.pop();
        this._textureStackTexCgl.pop();
        this._textureStackType.pop();
    }

    /**
     * pop all textures
     */
    popTextures()
    {
        this._textureStackTex.length =
        this._textureStackTexCgl.length =
        this._textureStackType.length =
        this._textureStackUni.length = 0;
    }

    getMaterialId()
    {
        return this._materialId;
    }

    getInfo()
    {
        const info = {};
        info.name = this._name;
        // info.modules = JSON.parse(JSON.stringify(this._modules));
        // info.defines = JSON.parse(JSON.stringify(this._defines));
        info.defines = this.getDefines();
        info.hasErrors = this.hasErrors();

        return info;
    }

    getDefaultFragmentShader(r, g, b, a)
    {
        return getDefaultFragmentShader(r, g, b, a);
    }

    getDefaultVertexShader()
    {
        return getDefaultVertexShader();
    }
}

// --------------------------

CglShader.getDefaultVertexShader = getDefaultVertexShader;
CglShader.getDefaultFragmentShader = getDefaultFragmentShader;

CglShader.getErrorFragmentShader = function ()
{
    return ""
        + nl + "void main()"
        + nl + "{"
        + nl + "   float g=mod((gl_FragCoord.y+gl_FragCoord.x),50.0)/50.0;"
        + nl + "   g= step(0.1,g);"
        + nl + "   outColor = vec4( g+0.5, 0.0, 0.0, 1.0);"
        + nl + "}";
};

/**
 * @param {CglContext} cgl
 * @param {String} str
 * @param {number} type
 * @param {CglShader} cglShader
 * @returns {CglShader}
 */
CglShader.createShader = function (cgl, str, type, cglShader)
{
    if (cgl.aborted) return;

    const shader = cgl.gl.createShader(type);
    cgl.gl.shaderSource(shader, str);
    cgl.gl.compileShader(shader);

    if (!cgl.gl.getShaderParameter(shader, cgl.gl.COMPILE_STATUS))
    {
        cglShader.error = { "str": str, "infoLog": cgl.gl.getShaderInfoLog(shader) };

        if (CABLES.UI) gui.emitEvent("ShaderError", cglShader);

        if (!cglShader.error.infoLog)
        {
            cglShader._log.warn("empty shader info log", this._name);
            return;
        }
        cglShader.setSource(CglShader.getDefaultVertexShader(), CglShader.getErrorFragmentShader());
    }
    return shader;
};



;// CONCATENATED MODULE: ./src/corelibs/cgl/cgl_utils.js
/**
 * @namespace CGL
 */

/**
 * multiply to get radians from degree, e.g. `360 * CGL.DEG2RAD`
 * @const {Number}
 * @memberof CGL
 * @static
 */
const cgl_utils_DEG2RAD = Math.PI / 180.0;

/**
 * to get degrees from radians, e.g. `3.14 * CGL.RAD2DEG`
 * @const {number}
 * @memberof CGL
 */
const cgl_utils_RAD2DEG = 180.0 / Math.PI;

const onLoadingAssetsFinished = null; // deprecated / remove later

/**
 * get normalized mouse wheel delta (including browser specific adjustment)
 * @function getWheelDelta
 * @static
 * @memberof CGL
 * @param {MouseEvent} event
 * @return {Number} normalized delta
 */
const isWindows = window.navigator.userAgent.includes("Windows");
const getWheelDelta_ = function (event)
{
    let normalized;
    if (event.wheelDelta)
    {
        // chrome
        normalized = (event.wheelDelta % 120) - 0 == -0 ? event.wheelDelta / 120 : event.wheelDelta / 30;
        normalized *= -1.5;
        if (isWindows) normalized *= 2;
    }
    else
    {
        // firefox
        let d = event.deltaY;
        if (event.shiftKey) d = event.deltaX;
        const rawAmmount = d || event.detail;
        normalized = -(rawAmmount % 3 ? rawAmmount * 10 : rawAmmount / 3);
        normalized *= -3;
    }

    if (normalized > 20) normalized = 20;
    if (normalized < -20) normalized = -20;

    return normalized;
};

const getWheelSpeed = getWheelDelta_;
const getWheelDelta = getWheelDelta_;

;// CONCATENATED MODULE: ./src/corelibs/cgl/cgl_profiledata.js
class ProfileData
{
    constructor(cgl)
    {
        this._cgl = cgl;
        this._lastTime = 0;
        this.pause = false;
        this.profileUniformCount = 0;
        this.profileShaderBinds = 0;
        this.profileUniformCount = 0;
        this.profileShaderCompiles = 0;
        this.profileVideosPlaying = 0;
        this.profileMVPMatrixCount = 0;
        this.profileEffectBuffercreate = 0;
        this.profileShaderGetUniform = 0;
        this.profileFrameBuffercreate = 0;
        this.profileMeshSetGeom = 0;
        this.profileTextureNew = 0;
        this.profileGenMipMap = 0;
        this.profileOnAnimFrameOps = 0;

        this.profileFencedPixelRead = 0;
        this.profileMainloopMs = 0;
        this.profileMeshDraw = 0;
        this.profileTextureEffect = 0;
        this.profileTexPreviews = 0;
        this.shaderCompileTime = 0;
        this.profileMeshNumElements = 0;
        this.profileMeshAttributes = 0;
        this.profileSingleMeshAttribute = [];
        this.heavyEvents = [];

        this.doProfileGlQuery = false;
        this.glQueryData = {};
        this.counts = {};
    }

    clear()
    {
        this.counts = {};
        this.profileSingleMeshAttribute = {};
        this.profileMeshAttributes = 0;
        this.profileUniformCount = 0;
        this.profileShaderGetUniform = 0;
        this.profileShaderCompiles = 0;
        this.profileShaderBinds = 0;
        this.profileTextureResize = 0;
        this.profileFrameBuffercreate = 0;
        this.profileEffectBuffercreate = 0;
        this.profileTextureDelete = 0;
        this.profileMeshSetGeom = 0;
        this.profileVideosPlaying = 0;
        this.profileMVPMatrixCount = 0;
        this.profileNonTypedAttrib = 0;
        this.profileNonTypedAttribNames = "";
        this.profileTextureNew = 0;
        this.profileGenMipMap = 0;
        this.profileFramebuffer = 0;
        this.profileMeshDraw = 0;
        this.profileTextureEffect = 0;
        this.profileTexPreviews = 0;
        this.profileMeshNumElements = 0;
        this.profileFencedPixelRead = 0;
    }

    clearGlQuery()
    {
        for (let i in this.glQueryData)
        {
            if (!this.glQueryData[i].lastClear || performance.now() - this.glQueryData[i].lastClear > 1000)
            {
                this.glQueryData[i].time = this.glQueryData[i]._times / this.glQueryData[i]._numcount;
                this.glQueryData[i].num = this.glQueryData[i]._numcount;

                this.glQueryData[i]._times = 0;
                this.glQueryData[i]._numcount = 0;
                this.glQueryData[i].lastClear = performance.now();
            }
        }
    }

    /**
     * @param {string} event
     * @param {string} name
     */
    count(event, name)
    {
        this.counts[event] = this.counts[event] || [];
        this.counts[event].push(name);
    }

    /**
     * @param {string} event
     * @param {string} name
     * @param {string} [info]
     */
    addHeavyEvent(event, name, info)
    {
        const e = { "event": event, "name": name, "info": info, "date": performance.now() };
        this.heavyEvents.push(e);
        this._cgl.emitEvent("heavyEvent", e);
    }
}

;// CONCATENATED MODULE: ./src/corelibs/cg/cg_matrixstack.js


class MatrixStack
{
    constructor()
    {
        this._arr = [external_CABLES_GLMatrix_namespaceObject.mat4.create()];
        this._index = 0;
        this.stateCounter = 0;
    }

    /**
     * @param {mat4} m
     */
    push(m)
    {
        this._index++;
        this.stateCounter++;

        if (this._index == this._arr.length)
        {
            const copy = external_CABLES_GLMatrix_namespaceObject.mat4.create();
            this._arr.push(copy);
        }

        external_CABLES_GLMatrix_namespaceObject.mat4.copy(this._arr[this._index], m || this._arr[this._index - 1]);

        return this._arr[this._index];
    }

    pop()
    {
        this.stateCounter++;

        this._index--;
        if (this._index < 0) this._index = 0;

        return this._arr[this._index];
    }

    length()
    {
        return this._index;
    }
}

;// CONCATENATED MODULE: ./src/corelibs/cg/cg_canvas.js


class CgCanvas
{
    hasFocus = false;

    forceAspect = 0;

    /**
     * @param {{ canvasEle: any; cg: any; }} options
     */
    constructor(options)
    {
        this._log = new external_CABLES_SHARED_namespaceObject.Logger("CgCanvas");
        if (!options)
        {
            this._log.error("CgCanvas no options");
        }
        else
        {
            this._canvasEle = options.canvasEle;
        }

        if (!options.cg) this._log.error("CgCanvas options has no cg");
        if (!options.canvasEle) this._log.error("CgCanvas options has no canvasEle");

        this._cg = options.cg;
        this.pixelDensity = 1;
        this.canvasWidth = this.canvasEle.clientWidth;
        this.canvasHeight = this.canvasEle.clientHeight;

        this._oldWidthRp = -1;
        this._oldHeightRp = -1;

        this.setSize(this.canvasWidth, this.canvasHeight);
        this.canvasEle.addEventListener("focus", () => { this.hasFocus = true; });
        this.canvasEle.addEventListener("blur", () => { this.hasFocus = false; });
    }

    get canvasEle() { return this._canvasEle; }

    /**
     * @param {Number} w
     * @param {Number} h
     * @param {any} ignorestyle
     * @returns {any}
     */
    setSize(w, h, ignorestyle = false)
    {
        let offY = 0;
        if (this.forceAspect)
        {
            let nh = w / this.forceAspect;
            if (nh < h)offY = (h - nh) / 2;
            h = nh;
        }

        if (this._oldWidthRp != w * this.pixelDensity || this._oldHeightRp != h * this.pixelDensity)
        {
            this._oldWidthRp = this.canvasEle.width = w * this.pixelDensity;
            this._oldHeightRp = this.canvasEle.height = h * this.pixelDensity;

            if (!ignorestyle)
            {
                this.canvasEle.style.width = w + "px";
                this.canvasEle.style.height = h + "px";
                this.canvasEle.style.marginTop = offY + "px";
            }

            this.updateSize();

            this._cg.emitEvent("resize");
        }
    }

    updateSize()
    {
        this.canvasEle.width = this.canvasWidth = this.canvasEle.clientWidth * this.pixelDensity;
        this.canvasEle.height = this.canvasHeight = this.canvasEle.clientHeight * this.pixelDensity;
    }

    dispose()
    {
        if (this._canvasEle) this._canvasEle.remove();
        this._canvasEle = null;
    }
}

;// CONCATENATED MODULE: ./src/corelibs/cg/cg_fpscounter.js



class FpsCounter extends external_CABLES_SHARED_namespaceObject.Events
{
    constructor()
    {
        super();
        this._timeStartFrame = 0;
        this._timeStartSecond = 0;
        this._fpsCounter = 0;
        this._msCounter = 0;
        this._frameCount = 0;
        this.logFps = false;

        this.stats = { "ms": 0, "fps": 0 };
    }

    get frameCount()
    {
        return this._frameCount;
    }

    startFrame()
    {
        this._timeStartFrame = (0,external_CABLES_namespaceObject.now)();
    }

    endFrame()
    {
        this._frameCount++;
        this._fpsCounter++;

        const timeFrame = (0,external_CABLES_namespaceObject.now)() - this._timeStartFrame;
        this._msCounter += timeFrame;

        if ((0,external_CABLES_namespaceObject.now)() - this._timeStartSecond > 1000) this.endSecond();
    }

    endSecond()
    {
        this.stats.fps = this._fpsCounter;
        this.stats.ms = Math.round(this._msCounter / this._fpsCounter * 100) / 100;

        this.emitEvent("performance", this.stats);
        if (this.logFps)console.log(this.stats);

        // reset
        this._fpsCounter = 0;
        this._msCounter = 0;
        this._timeStartSecond = (0,external_CABLES_namespaceObject.now)();
    }
}

;// CONCATENATED MODULE: ./src/corelibs/cg/cg_context.js








class CgContext extends external_CABLES_SHARED_namespaceObject.Events
{

    static API_UNKNOWN = 0;
    static API_WEBGL = 1;
    static API_WEBGPU = 2;

    static EVENT_RESIZE = "resize";

    gApi = 0;

    /**
     * Description
     * @param {Patch} _patch
     */
    constructor(_patch)
    {
        super();

        this._log = new external_CABLES_SHARED_namespaceObject.Logger("cg_context", { "onError": _patch.config.onError });

        /** @type {object} */
        this.tempData = this.frameStore = this.frameStore || {};
        this.fpsCounter = new FpsCounter();
        this._identView = external_CABLES_GLMatrix_namespaceObject.vec3.create();
        this._ident = external_CABLES_GLMatrix_namespaceObject.vec3.create();
        external_CABLES_GLMatrix_namespaceObject.vec3.set(this._identView, 0, 0, -2);
        external_CABLES_GLMatrix_namespaceObject.vec3.set(this._ident, 0, 0, 0);
        this._onetimeCallbacks = [];
        this.maxTexSize = 2048;
        this._viewPort = [0, 0, 1, 1];
        this._viewPortStack = [];
        this.patch = _patch;
        this.autoReSize = true;

        this.DEPTH_COMPARE_FUNC_NEVER = 0;
        this.DEPTH_COMPARE_FUNC_LESS = 1;
        this.DEPTH_COMPARE_FUNC_EQUAL = 2;
        this.DEPTH_COMPARE_FUNC_LESSEQUAL = 3;
        this.DEPTH_COMPARE_FUNC_GREATER = 4;
        this.DEPTH_COMPARE_FUNC_NOTEQUAL = 5;
        this.DEPTH_COMPARE_FUNC_GREATEREQUAL = 6;
        this.DEPTH_COMPARE_FUNC_ALWAYS = 7;

        this.profileData = new ProfileData(this);

        /**
         * Current projection matrix
         * @memberof Context
         * @instance
         * @type {mat4}
         */
        this.pMatrix = external_CABLES_GLMatrix_namespaceObject.mat4.create();

        /**
         * Current model matrix
         * @memberof Context
         * @instance
         * @type {mat4}
         */
        this.mMatrix = external_CABLES_GLMatrix_namespaceObject.mat4.create();

        /**
         * Current view matrix
         * @memberof Context
         * @instance
         * @type {mat4}
         */
        this.vMatrix = external_CABLES_GLMatrix_namespaceObject.mat4.create();
        this._textureslots = [];

        this._pMatrixStack = new MatrixStack();
        this._mMatrixStack = new MatrixStack();
        this._vMatrixStack = new MatrixStack();

        this.canvasScale = 1;

        external_CABLES_GLMatrix_namespaceObject.mat4.identity(this.mMatrix);
        external_CABLES_GLMatrix_namespaceObject.mat4.identity(this.vMatrix);

        window.matchMedia("screen and (min-resolution: 2dppx)").addEventListener("change", () =>
        {
            this.emitEvent("resize");
        });

    }

    get canvasWidth()
    {
        return this.cgCanvas.canvasWidth;
    }

    get canvasHeight()
    {
        return this.cgCanvas.canvasHeight;
    }

    set pixelDensity(p)
    {
        if (this.cgCanvas.pixelDensity != p)
        {
            this.cgCanvas.pixelDensity = p;
            this.cgCanvas.updateSize();
            this.emitEvent("resize");
        }
    }

    get pixelDensity()
    {
        return this.cgCanvas.pixelDensity;
    }

    getGApiName()
    {
        return ["unknown", "WebGL", "WebGPU"][this.gApi];
    }

    get canvas()
    {
        return this.cgCanvas.canvasEle;
    }

    get viewPort()
    {
        // TODO: add stack...
        return [0, 0, this.canvasWidth, this.canvasHeight];
    }

    /**
     * @param {HTMLElement} canvEle
     */
    setCanvas(canvEle)
    {
        if (this.cgCanvas && canvEle == this.cgCanvas.canvasEle) return;
        if (typeof canvEle === "string") canvEle = document.getElementById(canvEle);

        this.cgCanvas = new CgCanvas({ "canvasEle": canvEle, "cg": this });

        canvEle.parentElement.classList.add("cablesContainer");
        if (this._setCanvas) this._setCanvas(canvEle);

        this.updateSize();
    }

    /**
     * @param {HTMLElement} _canvEle
     */
    _setCanvas(_canvEle)
    {
    }

    updateSize()
    {
        this.cgCanvas.updateSize();
    }

    /**
     * @param {number} w
     * @param {number} h
     * @param {boolean} ignorestyle
     */
    setSize(w, h, ignorestyle = false)
    {
        this.cgCanvas.setSize(w, h, ignorestyle);
    }

    _resizeToWindowSize()
    {
        if (this.autoReSize)
        {
            this.setSize(window.innerWidth, window.innerHeight);
            this.updateSize();
        }
    }

    _resizeToParentSize()
    {
        if (this.autoReSize)
        {
            const p = this.canvas.parentElement;
            if (!p)
            {
                this._log.error("cables: can not resize to container element");
                return;
            }

            this.setSize(p.clientWidth, p.clientHeight);
            this.updateSize();
        }
    }

    setAutoResize(parent)
    {
        window.removeEventListener("resize", this._resizeToWindowSize.bind(this));
        window.removeEventListener("resize", this._resizeToParentSize.bind(this));

        if (parent == "window")
        {
            window.addEventListener("resize", this._resizeToWindowSize.bind(this));
            window.addEventListener("orientationchange", this._resizeToWindowSize.bind(this));
            this._resizeToWindowSize();
        }
        if (parent == "parent")
        {
            window.addEventListener("resize", this._resizeToParentSize.bind(this));
            this._resizeToParentSize();
        }
    }

    /**
     * push a matrix to the projection matrix stack
     * @function pushPMatrix
     * @memberof Context
     * @instance
     */
    pushPMatrix()
    {
        this.pMatrix = this._pMatrixStack.push(this.pMatrix);
    }

    /**
      * pop projection matrix stack
      * @function popPMatrix
      * @memberof Context
      * @instance
      * @returns {mat4} current projectionmatrix
      */
    popPMatrix()
    {
        this.pMatrix = this._pMatrixStack.pop();
        return this.pMatrix;
    }

    getProjectionMatrixStateCount()
    {
        return this._pMatrixStack.stateCounter;
    }

    /**
      * push a matrix to the model matrix stack
      * @function pushModelMatrix
      * @memberof Context
      * @instance
      * @example
      * // see source code of translate op:
      * cgl.pushModelMatrix();
      * mat4.translate(cgl.mMatrix,cgl.mMatrix, vec);
      * trigger.trigger();
      * cgl.popModelMatrix();
      */
    pushModelMatrix()
    {
        this.mMatrix = this._mMatrixStack.push(this.mMatrix);
    }

    /**
      * pop model matrix stack
      * @function popModelMatrix
      * @memberof Context
      * @instance
      * @returns {mat4} current modelmatrix
      */
    popModelMatrix()
    {
        // todo: DEPRECATE
        // if (this._mMatrixStack.length === 0) throw "Invalid modelview popMatrix!";
        this.mMatrix = this._mMatrixStack.pop();
        return this.mMatrix;
    }

    /**
      * get model matrix
      * @function modelMatrix
      * @memberof Context
      * @instance
      * @returns {mat4} current modelmatrix
      */
    modelMatrix()
    {
        return this.mMatrix;
    }

    /**
     * push a matrix to the view matrix stack
     * @function pushviewMatrix
     * @memberof Context
     * @instance
     */
    pushViewMatrix()
    {
        this.vMatrix = this._vMatrixStack.push(this.vMatrix);
    }

    /**
      * pop view matrix stack
      * @function popViewMatrix
      * @memberof Context
      * @instance
      * @returns {mat4} current viewmatrix
      * @function
      */
    popViewMatrix()
    {
        this.vMatrix = this._vMatrixStack.pop();
    }

    getViewMatrixStateCount()
    {
        return this._vMatrixStack.stateCounter;
    }

    /**
     * @param {vec3} identTranslate
     * @param {vec3} identTranslateView
     */
    _startMatrixStacks(identTranslate, identTranslateView)
    {
        identTranslate = identTranslate || this._ident;
        identTranslateView = identTranslateView || this._identView;

        external_CABLES_GLMatrix_namespaceObject.mat4.perspective(this.pMatrix, 45, this.canvasWidth / this.canvasHeight, 0.1, 1000.0);

        external_CABLES_GLMatrix_namespaceObject.mat4.identity(this.mMatrix);
        external_CABLES_GLMatrix_namespaceObject.mat4.identity(this.vMatrix);
        external_CABLES_GLMatrix_namespaceObject.mat4.translate(this.mMatrix, this.mMatrix, identTranslate);
        external_CABLES_GLMatrix_namespaceObject.mat4.translate(this.vMatrix, this.vMatrix, identTranslateView);

        this.pushPMatrix();
        this.pushModelMatrix();
        this.pushViewMatrix();
    }

    _endMatrixStacks()
    {
        this.popViewMatrix();
        this.popModelMatrix();
        this.popPMatrix();
    }

    dispose()
    {
        this.aborted = true;
        if (this.cgCanvas) this.cgCanvas.dispose();
        if (this._dispose) this._dispose();
    }

    _dispose()
    {
    }

    /**
     * @param {any} _op
     */
    shouldDrawHelpers(_op)
    {
        return false;
    }

    /**
     * execute the callback next frame, once
     * @param {function} cb
     */
    addNextFrameOnceCallback(cb)
    {
        if (cb && this._onetimeCallbacks.indexOf(cb) == -1) this._onetimeCallbacks.push(cb);
    }

    _execOneTimeCallbacks()
    {
        if (this._onetimeCallbacks.length > 0)
        {
            for (let i = 0; i < this._onetimeCallbacks.length; i++) this._onetimeCallbacks[i]();
            this._onetimeCallbacks.length = 0;
        }
    }

    /**
     * @param {number} x
     */
    checkTextureSize(x)
    {
        x = x || 1;
        x = Math.floor(x);
        x = Math.min(x, this.maxTexSize);
        x = Math.max(x, 1);
        return x;
    }

    // should be overwritten...
    screenShot(cb, doScreenshotClearAlpha, mimeType, quality)
    {
        console.log("no screenshot function implemented");
    }

    /**
     * @param {string} [filename]
     * @param {function} [cb]
     * @param {number} [pw]
     * @param {number} [ph]
     * @param {boolean} [_noclearalpha]
     */
    saveScreenshot(filename, cb, pw, ph, _noclearalpha)
    {
        this.patch.renderOneFrame();

        let w = this.canvas.clientWidth * this.pixelDensity;
        let h = this.canvas.clientHeight * this.pixelDensity;

        if (pw)
        {
            this.canvas.width = pw;
            w = pw;
        }
        if (ph)
        {
            this.canvas.height = ph;
            h = ph;
        }

        function padLeft(nr, n, str)
        {
            return Array(n - String(nr).length + 1).join(str || "0") + nr;
        }

        const d = new Date();
        const dateStr = "".concat(String(d.getFullYear()) + String(d.getMonth() + 1) + String(d.getDate()), "_").concat(padLeft(d.getHours(), 2)).concat(padLeft(d.getMinutes(), 2)).concat(padLeft(d.getSeconds(), 2));

        if (!filename) filename = "cables_" + dateStr + ".png";
        else filename += ".png";

        this.screenShot((blob) =>
        {
            this.canvas.width = w;
            this.canvas.height = h;

            if (blob)
            {
                const anchor = document.createElement("a");

                anchor.download = filename;
                anchor.href = URL.createObjectURL(blob);

                console.log("scrrenshot");
                setTimeout(function ()
                {
                    anchor.click();
                    if (cb) cb(blob);
                }, 100);
            }
            else
            {
                this._log.log("screenshot: no blob");
            }
        });
    }

    hasFocus()
    {
        return this.cgCanvas.hasFocus;

    }

}

;// CONCATENATED MODULE: ./src/corelibs/cgl/cgl_state.js










const BLENDS = {
    "BLEND_NONE": 0,
    "BLEND_NORMAL": 1,
    "BLEND_ADD": 2,
    "BLEND_SUB": 3,
    "BLEND_MUL": 4,
};

/**
 * cables gl context/state manager
 * @class
 * @namespace external:CGL
 * @hideconstructor
 */
// const Context(_patch)
class CglContext extends CgContext
{

    /**
     * @param {Patch} _patch
     */
    constructor(_patch)
    {
        super(_patch);

        this.gApi = CgContext.API_WEBGL;
        this.aborted = false;

        /** @deprecated */
        this.pushMvMatrix = this.pushModelMatrix; // deprecated and wrong... still used??
        /** @deprecated */
        this.popMvMatrix = this.popmMatrix = this.popModelMatrix;// deprecated and wrong... still used??

        this._log = new external_CABLES_SHARED_namespaceObject.Logger("cgl_context", { "onError": _patch.config.onError });

        this.glVersion = 0;
        this.glUseHalfFloatTex = false;
        this.clearCanvasTransparent = true;
        this.clearCanvasDepth = true;
        this.debugOneFrame = false;
        this.checkGlErrors = false; // true is slow // false should be default...
        this.maxTextureUnits = 0;
        this.maxVaryingVectors = 0;
        this.currentProgram = null;
        this._hadStackError = false;
        this.glSlowRenderer = false;
        this._isSafariCrap = false;

        this.temporaryTexture = null;

        /** @type {WebGL2RenderingContext} */
        this.gl = null;

        this._cursor = "auto";
        this._currentCursor = "";

        this._viewPortStack = [];
        this._glFrameBufferStack = [];
        this._frameBufferStack = [];
        this._shaderStack = [];
        this._stackDepthTest = [];
        this.mainloopOp = null;
        this._stackBlendMode = [];
        this._stackBlendModePremul = [];
        this._stackBlend = [];
        this._stackDepthFunc = [];
        this._stackCullFaceFacing = [];
        this._stackCullFace = [];
        this._stackDepthWrite = [];
        this._stackDepthTest = [];
        this._stackStencil = [];

        this._simpleShader = new CglShader(this, "simpleshader");
        this._simpleShader.setModules(["MODULE_VERTEX_POSITION", "MODULE_COLOR", "MODULE_BEGIN_FRAG", "MODULE_VERTEX_MODELVIEW"]);
        this._simpleShader.setSource(CglShader.getDefaultVertexShader(), CglShader.getDefaultFragmentShader());

        this._currentShader = this._simpleShader;

        this._oldCanvasWidth = -1;
        this._oldCanvasHeight = -1;
        this._enabledExtensions = {};

        this.errorShader = null;
    }

    // set pixelDensity(p)
    // {
    //     this._pixelDensity = p;
    // }

    // get pixelDensity()
    // {
    //     return this._pixelDensity;
    // }

    get viewPort()
    {
        if (this._viewPortStack.length > 3)
        {
            const l = this._viewPortStack.length;

            return [
                this._viewPortStack[l - 4],
                this._viewPortStack[l - 3],
                this._viewPortStack[l - 2],
                this._viewPortStack[l - 1]
            ];
        }
        else
        {
            // workaround pre viewport stack times / or+and initial value...

            return this._viewPort;
        }
    }

    get mvMatrix() // deprecate
    {
        return this.mMatrix;
    }

    set mvMatrix(m) // deprecate
    {
        this.mMatrix = m;
    }

    /**
     * @param {HTMLCanvasElement} canv
     */
    _setCanvas(canv)
    {
        if (!canv) this._log.stack("_setCanvas undef");

        if (!this.patch.config.canvas) this.patch.config.canvas = {};
        if (!this.patch.config.canvas.hasOwnProperty("preserveDrawingBuffer")) this.patch.config.canvas.preserveDrawingBuffer = true;
        if (!this.patch.config.canvas.hasOwnProperty("premultipliedAlpha")) this.patch.config.canvas.premultipliedAlpha = false;
        if (!this.patch.config.canvas.hasOwnProperty("alpha")) this.patch.config.canvas.alpha = false;

        this.patch.config.canvas.stencil = true;

        if (this.patch.config.hasOwnProperty("clearCanvasColor")) this.clearCanvasTransparent = this.patch.config.clearCanvasColor;
        if (this.patch.config.hasOwnProperty("clearCanvasDepth")) this.clearCanvasDepth = this.patch.config.clearCanvasDepth;

        // safari stuff..........
        if (/^((?!chrome|android).)*safari/i.test(navigator.userAgent) && (navigator.userAgent.match(/iPhone/i)))
        {
            this._isSafariCrap = true;
            this.glUseHalfFloatTex = true;
        }

        if (!this.patch.config.canvas.forceWebGl1) this.gl = canv.getContext("webgl2", this.patch.config.canvas);

        if (!this.gl || this.gl.isContextLost())
        {
            this.aborted = true;
            this._log.error("NO_WEBGL", "sorry, could not initialize WebGL. Please check if your Browser supports WebGL or try to restart your browser.");
            return;
        }

        if (this.gl.getParameter(this.gl.VERSION) != "WebGL 1.0")
        {
            this.glVersion = 2;
        }
        else
        {
            this.gl = canv.getContext("webgl", this.patch.config.canvas) || canv.getContext("experimental-webgl", this.patch.config.canvas);
            this.glVersion = 1;

            // safari
            // if (/^((?!chrome|android).)*safari/i.test(navigator.userAgent) && (navigator.userAgent.match(/iPhone/i)))
            // {
            //     this.glUseHalfFloatTex = true;
            // }

            // ios
            // @ts-ignore
            if (/iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream)
            {
                if (!this.patch.config.canvas.hasOwnProperty("powerPreference")) this.patch.config.canvas.powerPreference = "high-performance";
            }

            this.enableExtension("OES_standard_derivatives");
            // this.enableExtension("GL_OES_standard_derivatives");
            const instancingExt = this.enableExtension("ANGLE_instanced_arrays") || this.gl;
            if (instancingExt.vertexAttribDivisorANGLE)
            {
                this.gl.vertexAttribDivisor = instancingExt.vertexAttribDivisorANGLE.bind(instancingExt);
                this.gl.drawElementsInstanced = instancingExt.drawElementsInstancedANGLE.bind(instancingExt);
            }
        }

        const dbgRenderInfo = this.enableExtension("WEBGL_debug_renderer_info");
        if (dbgRenderInfo)
        {
            this.glRenderer = this.gl.getParameter(dbgRenderInfo.UNMASKED_RENDERER_WEBGL);
            if (this.glRenderer === "Google SwiftShader") this.glSlowRenderer = true;
        }

        this.canvas.addEventListener("webglcontextlost", (event) =>
        {
            if (this.aborted) return this._log.warn("[cgl_state] aborted context lost... can be ignored...");
            this._log.error("canvas lost...", event);
            this.emitEvent("webglcontextlost");
            this.aborted = true;
        });

        this.maxAnisotropic = 0;
        if (this.enableExtension("EXT_texture_filter_anisotropic"))
            this.maxAnisotropic = this.gl.getParameter(this.enableExtension("EXT_texture_filter_anisotropic").MAX_TEXTURE_MAX_ANISOTROPY_EXT);

        this.maxVaryingVectors = this.gl.getParameter(this.gl.MAX_VARYING_VECTORS);
        this.maxTextureUnits = this.gl.getParameter(this.gl.MAX_TEXTURE_IMAGE_UNITS);
        this.maxTexSize = this.gl.getParameter(this.gl.MAX_TEXTURE_SIZE);
        this.maxUniformsFrag = this.gl.getParameter(this.gl.MAX_FRAGMENT_UNIFORM_VECTORS);
        this.maxUniformsVert = this.gl.getParameter(this.gl.MAX_VERTEX_UNIFORM_VECTORS);
        this.maxSamples = 0;
        if (this.gl.MAX_SAMPLES) this.maxSamples = this.gl.getParameter(this.gl.MAX_SAMPLES);

        if (this.glVersion == 1)
        {
            this.enableExtension("OES_standard_derivatives");
            const instancingExt = this.enableExtension("ANGLE_instanced_arrays") || this.gl;

            if (instancingExt.vertexAttribDivisorANGLE)
            {
                this.gl.vertexAttribDivisor = instancingExt.vertexAttribDivisorANGLE.bind(instancingExt);
                this.gl.drawElementsInstanced = instancingExt.drawElementsInstancedANGLE.bind(instancingExt);
            }
        }

        this.DEPTH_FUNCS = [
            this.gl.NEVER,
            this.gl.ALWAYS,
            this.gl.LESS,
            this.gl.LEQUAL,
            this.gl.GREATER,
            this.gl.GEQUAL,
            this.gl.EQUAL,
            this.gl.NOTEQUAL
        ];
        this.CULL_MODES = [
            null,
            this.gl.BACK,
            this.gl.FRONT,
            this.gl.FRONT_AND_BACK
        ];
    }

    getInfo()
    {
        return {
            "glVersion": this.glVersion,
            "glRenderer": this.glRenderer,
            "glUseHalfFloatTex": this.glUseHalfFloatTex,
            "maxVaryingVectors": this.maxVaryingVectors,
            "maxTextureUnits": this.maxTextureUnits,
            "maxTexSize": this.maxTexSize,
            "maxUniformsFrag": this.maxUniformsFrag,
            "maxUniformsVert": this.maxUniformsVert,
            "maxSamples": this.maxSamples
        };
    }

    /**
     * @function popViewPort
     * @memberof Context
     * @instance
     * @description pop viewPort stack
     */
    popViewPort()
    {
        this._viewPortStack.pop();
        this._viewPortStack.pop();
        this._viewPortStack.pop();
        this._viewPortStack.pop();

        if (this._viewPortStack.length == 0)
            this.setViewPort(0, 0, this.canvasWidth, this.canvasHeight);
        else
            this.setViewPort(this._viewPortStack[this._viewPort.length - 4], this._viewPortStack[this._viewPort.length - 3], this._viewPortStack[this._viewPort.length - 2], this._viewPortStack[this._viewPort.length - 1]);
    }

    /**
     * @function pushViewPort
     * @memberof Context
     * @instance
     * @description push a new viewport onto stack
     * @param {Number} x
     * @param {Number} y
     * @param {Number} w
     * @param {Number} h
     */

    pushViewPort(x, y, w, h)
    {
        this._viewPortStack.push(x, y, w, h);
        this.setViewPort(x, y, w, h);
    }

    // old
    getViewPort()
    {
        return this._viewPort;
    }

    // old
    resetViewPort()
    {
        this.gl.viewport(this._viewPort[0], this._viewPort[1], this._viewPort[2], this._viewPort[3]);
    }

    // old
    /**
     * @param {number} x
     * @param {number} y
     * @param {number} w
     * @param {number} h
     */
    setViewPort(x, y, w, h)
    {
        this._viewPort[0] = Math.round(x);
        this._viewPort[1] = Math.round(y);
        this._viewPort[2] = Math.round(w);
        this._viewPort[3] = Math.round(h);
        this.gl.viewport(this._viewPort[0], this._viewPort[1], this._viewPort[2], this._viewPort[3]);
    }

    /**
     * @param {function} cb
     * @param {boolean} doScreenshotClearAlpha
     * @param {string} mimeType
     * @param {number} quality
     */
    screenShot(cb, doScreenshotClearAlpha, mimeType, quality)
    {
        if (doScreenshotClearAlpha)
        {
            this.gl.clearColor(1, 1, 1, 1);
            this.gl.colorMask(false, false, false, true);
            this.gl.clear(this.gl.COLOR_BUFFER_BIT);
            this.gl.colorMask(true, true, true, true);
        }

        if (this.canvas && this.canvas.toBlob)
        {
            this.canvas.toBlob(
                (blob) =>
                {
                    if (cb) cb(blob);
                    else this._log.log("no screenshot callback...");
                }, mimeType, quality);
        }
    }

    endFrame()
    {
        if (this.patch.isEditorMode()) CABLES.GL_MARKER.drawMarkerLayer(this);

        this.setPreviousShader();

        if (this._vMatrixStack.length() > 0) this.logStackError("view matrix stack length !=0 at end of rendering...");
        if (this._mMatrixStack.length() > 0) this.logStackError("mvmatrix stack length !=0 at end of rendering...");
        if (this._pMatrixStack.length() > 0) this.logStackError("pmatrix stack length !=0 at end of rendering...");
        if (this._glFrameBufferStack.length > 0) this.logStackError("glFrameBuffer stack length !=0 at end of rendering...");
        if (this._stackDepthTest.length > 0) this.logStackError("depthtest stack length !=0 at end of rendering...");
        if (this._stackDepthWrite.length > 0) this.logStackError("depthwrite stack length !=0 at end of rendering...");
        if (this._stackDepthFunc.length > 0) this.logStackError("depthfunc stack length !=0 at end of rendering...");
        if (this._stackBlend.length > 0) this.logStackError("blend stack length !=0 at end of rendering...");
        if (this._stackBlendMode.length > 0) this.logStackError("blendMode stack length !=0 at end of rendering...");
        if (this._shaderStack.length > 0) this.logStackError("this._shaderStack length !=0 at end of rendering...");
        if (this._stackCullFace.length > 0) this.logStackError("this._stackCullFace length !=0 at end of rendering...");
        if (this._stackCullFaceFacing.length > 0) this.logStackError("this._stackCullFaceFacing length !=0 at end of rendering...");
        if (this._viewPortStack.length > 0) this.logStackError("viewport stack length !=0 at end of rendering...");

        this._frameStarted = false;

        if (this._oldCanvasWidth != this.canvasWidth || this._oldCanvasHeight != this.canvasHeight)
        {
            this._oldCanvasWidth = this.canvasWidth;
            this._oldCanvasHeight = this.canvasHeight;
            this.emitEvent(CgContext.EVENT_RESIZE);
        }

        if (this._cursor != this._currentCursor)
        {
            this._currentCursor = this.canvas.style.cursor = this._cursor;
        }

        this.emitEvent("endframe");

        this.fpsCounter.endFrame();
    }

    logStackError(str)
    {
        if (!this._hadStackError)
        {
            this._hadStackError = true;
            this._log.warn("[" + this.canvas.id + "]: ", str);
        }
    }

    // shader stack
    getShader()
    {
        if (this._currentShader) if (!this.tempData || ((this.tempData.renderOffscreen === true) == this._currentShader.offScreenPass) === true) return this._currentShader;

        for (let i = this._shaderStack.length - 1; i >= 0; i--) if (this._shaderStack[i]) if (this.tempData.renderOffscreen == this._shaderStack[i].offScreenPass) return this._shaderStack[i];
    }

    getDefaultShader()
    {
        return this._simpleShader;
    }

    /**
     * @deprecated
     * @param {Shader} s
     */
    setShader(s)
    {
        this.pushShader(s);
    }

    /**
     * push a shader to the shader stack
     * @function pushShader
     * @memberof Context
     * @instance
     * @param {Shader} shader
     * @function
     */
    pushShader(shader)
    {
        if (this.tempData.forceShaderMods)
        {
            for (let i = 0; i < this.tempData.forceShaderMods.length; i++)
            {
                // if (!currentShader.forcedMod && currentShader != this.tempData.forceShaderMods[i])
                // {
                //     currentShader.forcedMod = this.tempData.forceShaderMods[i];
                shader = this.tempData.forceShaderMods[i].bind(shader, false);
                // }
                // return currentShader;
                // if (this.tempData.forceShaderMods[i].currentShader() && shader != this.tempData.forceShaderMods[i].currentShader().shader)
            }
        }

        this._shaderStack.push(shader);
        this._currentShader = shader;
    }

    popShader()
    {
        this.setPreviousShader();
    }

    /**
     * pop current used shader from shader stack
     * @function popShader
     * @memberof Context
     * @instance
     * @function
     */
    setPreviousShader()
    {
        if (this.tempData.forceShaderMods)
        {
            for (let i = 0; i < this.tempData.forceShaderMods.length; i++)
            {
                // const a =
                this.tempData.forceShaderMods[i].unbind(false);
                // if (a) return;
                // this.popShader();
            }
        }

        if (this._shaderStack.length === 0) throw new Error("Invalid shader stack pop!");
        this._shaderStack.pop();
        this._currentShader = this._shaderStack[this._shaderStack.length - 1];
    }

    /**
     * push a framebuffer to the framebuffer stack
     * @function pushGlFrameBuffer
     * @memberof Context
     * @instance
     * @param {Object} fb framebuffer
     * @function
     */
    pushGlFrameBuffer(fb)
    {
        this._glFrameBufferStack.push(fb);
    }

    /**
     * pop framebuffer stack
     * @function popGlFrameBuffer
     * @memberof Context
     * @instance
     * @returns {Object} current framebuffer or null
     */
    popGlFrameBuffer()
    {
        if (this._glFrameBufferStack.length == 0) return null;
        this._glFrameBufferStack.pop();
        return this._glFrameBufferStack[this._glFrameBufferStack.length - 1];
    }

    /**
     * get current framebuffer
     * @function getCurrentFrameBuffer
     * @memberof Context
     * @instance
     * @returns {Object} current framebuffer or null
     */
    getCurrentGlFrameBuffer()
    {
        if (this._glFrameBufferStack.length === 0) return null;
        return this._glFrameBufferStack[this._glFrameBufferStack.length - 1];
    }

    /**
     * push a framebuffer to the framebuffer stack
     * @function pushGlFrameBuffer
     * @memberof Context
     * @instance
     * @param {Framebuffer2} fb framebuffer
     */
    pushFrameBuffer(fb)
    {
        this._frameBufferStack.push(fb);
    }

    /**
     * pop framebuffer stack
     * @function popFrameBuffer
     * @memberof Context
     * @instance
     * @returns {Framebuffer2} current framebuffer or null
     */
    popFrameBuffer()
    {
        if (this._frameBufferStack.length == 0) return null;
        this._frameBufferStack.pop();
        return this._frameBufferStack[this._frameBufferStack.length - 1];
    }

    /**
     * get current framebuffer
     * @function getCurrentFrameBuffer
     * @memberof Context
     * @instance
     * @returns {Framebuffer2} current framebuffer or null
     */
    getCurrentFrameBuffer()
    {
        if (this._frameBufferStack.length === 0) return null;
        return this._frameBufferStack[this._frameBufferStack.length - 1];
    }

    renderStart(cgl, identTranslate, identTranslateView)
    {
        this.fpsCounter.startFrame();
        this.pushDepthTest(true);
        this.pushDepthWrite(true);
        this.pushDepthFunc(cgl.gl.LEQUAL);
        this.pushCullFaceFacing(cgl.gl.BACK);
        this.pushCullFace(false);

        // if (this.clearCanvasTransparent)
        // {
        //     cgl.gl.clearColor(0, 0, 0, 0);
        //     cgl.gl.clear(cgl.gl.COLOR_BUFFER_BIT);
        // }
        // if (this.clearCanvasDepth) cgl.gl.clear(cgl.gl.DEPTH_BUFFER_BIT);

        cgl.setViewPort(0, 0, cgl.canvasWidth, cgl.canvasHeight);

        this._startMatrixStacks(identTranslate, identTranslateView);

        cgl.pushBlendMode(CONSTANTS.BLEND_MODES.BLEND_NORMAL, false);

        for (let i = 0; i < this._textureslots.length; i++) this._textureslots[i] = null;

        this.pushShader(this._simpleShader);

        this._frameStarted = true;

        this._execOneTimeCallbacks();

        for (let i = 0; i < this._textureslots.length; i++)
        {
            this.gl.activeTexture(this.gl.TEXTURE0 + i);
            this.gl.bindTexture(this.gl.TEXTURE_2D, null);
            this._textureslots[i] = null;
        }

        this.emitEvent("beginFrame");
    }

    /**
     * @param {CglContext} cgl
     */
    renderEnd(cgl)
    {
        this._endMatrixStacks();

        this.popDepthTest();
        this.popDepthWrite();
        this.popDepthFunc();
        this.popCullFaceFacing();
        this.popCullFace();
        this.popBlend();
        this.popBlendMode();

        cgl.endFrame();

        this.emitEvent("endFrame");
    }

    /**
     * @param {number} slot
     */
    getTexture(slot)
    {
        return this._textureslots[slot];
    }

    hasFrameStarted()
    {
        return this._frameStarted;
    }

    /**
     * log warning to console if the rendering of one frame has not been started / handy to check for async problems
     * @function checkFrameStarted
     * @memberof Context
     * @param {string} string
     * @instance
     */
    checkFrameStarted(string)
    {
        if (!this._frameStarted)
        {
            this._log.warn("frame not started " + string);

            Error.stackTraceLimit = 25;
            external_CABLES_namespaceObject.utils.logStack();
            this.patch.printTriggerStack();
        }
    }

    /**
     * @param {number} slot
     * @param {WebGLTexture} t
     * @param {undefined} [type]
     */
    setTexture(slot, t, type)
    {
        this.checkFrameStarted("cgl setTexture");

        if (t === null) t = Texture.getEmptyTexture(this).tex;

        if (this._textureslots[slot] != t)
        {
            this.gl.activeTexture(this.gl.TEXTURE0 + slot);
            this.gl.bindTexture(type || this.gl.TEXTURE_2D, t);
            this._textureslots[slot] = t;
        }

        return true;
    }

    fullScreen()
    {
        if (this.canvas.requestFullscreen) this.canvas.requestFullscreen();
        else if (this.canvas.mozRequestFullScreen) this.canvas.mozRequestFullScreen();
        else if (this.canvas.webkitRequestFullscreen) this.canvas.webkitRequestFullscreen();
        else if (this.canvas.msRequestFullscreen) this.canvas.msRequestFullscreen();
    }

    /**
     * @param {string} [str]
     */
    printError(str)
    {
        if (!this.checkGlErrors) return;
        let found = false;
        let error = this.gl.getError();

        if (error != this.gl.NO_ERROR)
        {
            let errStr = "";
            if (error == this.gl.OUT_OF_MEMORY) errStr = "OUT_OF_MEMORY";
            if (error == this.gl.INVALID_ENUM) errStr = "INVALID_ENUM";
            if (error == this.gl.INVALID_OPERATION) errStr = "INVALID_OPERATION";
            if (error == this.gl.INVALID_FRAMEBUFFER_OPERATION) errStr = "INVALID_FRAMEBUFFER_OPERATION";
            if (error == this.gl.INVALID_VALUE) errStr = "INVALID_VALUE";
            if (error == this.gl.CONTEXT_LOST_WEBGL)
            {
                this.aborted = true;
                errStr = "CONTEXT_LOST_WEBGL";
            }
            if (error == this.gl.NO_ERROR) errStr = "NO_ERROR";

            found = true;

            this._log.warn("gl error [" + this.canvas.id + "]: ", str, error, errStr);

            if (this.canvas.id.includes("glGuiCanvas"))
                if (!this._loggedGlError)
                {
                    this.patch.printTriggerStack();
                    this._log.stack("glerror");
                    this._loggedGlError = true;
                }
        }
        error = this.gl.getError();

        return found;
    }

    _dispose()
    {
        this._simpleShader.dispose();
        this.gl = null;
    }

    // state depthtest

    /**
     * push depth testing enabled state
     * @function pushDepthTest
     * @param {Boolean} enabled
     * @memberof Context
     * @instance
     */

    pushDepthTest(enabled)
    {
        this._stackDepthTest.push(enabled);
        if (!enabled) this.gl.disable(this.gl.DEPTH_TEST);
        else this.gl.enable(this.gl.DEPTH_TEST);
    }

    /**
     * current state of depth testing
     * @function stateCullFace
     * @returns {Boolean} enabled
     * @memberof Context
     * @instance
     */
    stateDepthTest()
    {
        return this._stackDepthTest[this._stackDepthTest.length - 1];
    }

    /**
     * pop depth testing state
     * @function popCullFace
     * @memberof Context
     * @instance
     */
    popDepthTest()
    {
        this._stackDepthTest.pop();

        if (!this._stackDepthTest[this._stackDepthTest.length - 1]) this.gl.disable(this.gl.DEPTH_TEST);
        else this.gl.enable(this.gl.DEPTH_TEST);
    }

    // --------------------------------------
    // state depthwrite

    /**
     * push depth write enabled state
     * @function pushDepthTest
     * @param {Boolean} enabled
     * @memberof Context
     * @instance
     */
    pushDepthWrite(enabled)
    {
        enabled = enabled || false;
        this._stackDepthWrite.push(enabled);
        this.gl.depthMask(enabled);
    }

    /**
     * current state of depth writing
     * @function stateDepthWrite
     * @returns {Boolean} enabled
     * @memberof Context
     * @instance
     */
    stateDepthWrite()
    {
        return this._stackDepthWrite[this._stackDepthWrite.length - 1];
    }

    /**
     * pop depth writing state
     * @function popDepthWrite
     * @memberof Context
     * @instance
     */
    popDepthWrite()
    {
        this._stackDepthWrite.pop();
        this.gl.depthMask(this._stackDepthWrite[this._stackDepthWrite.length - 1] || false);
    }

    // --------------------------------------
    // state CullFace

    /**
     * push face culling face enabled state
     * @function pushCullFace
     * @param {Boolean} enabled
     * @memberof Context
     * @instance
     */
    pushCullFace(enabled)
    {
        this._stackCullFace.push(enabled);

        if (enabled) this.gl.enable(this.gl.CULL_FACE);
        else this.gl.disable(this.gl.CULL_FACE);
    }

    /**
     * current state of face culling
     * @function stateCullFace
     * @returns {Boolean} enabled
     * @memberof Context
     * @instance
     */
    stateCullFace()
    {
        return this._stackCullFace[this._stackCullFace.length - 1];
    }

    /**
     * pop face culling enabled state
     * @function popCullFace
     * @memberof Context
     * @instance
     */
    popCullFace()
    {
        this._stackCullFace.pop();

        if (this._stackCullFace[this._stackCullFace.length - 1]) this.gl.enable(this.gl.CULL_FACE);
        else this.gl.disable(this.gl.CULL_FACE);
    }

    // --------------------------------------
    // state CullFace Facing

    /**
     * push face culling face side
     * @function pushCullFaceFacing
     * @param {Number} face - cgl.gl.FRONT_AND_BACK, cgl.gl.BACK or cgl.gl.FRONT
     * @memberof Context
     * @instance
     */

    pushCullFaceFacing(face)
    {
        this._stackCullFaceFacing.push(face);
        this.gl.cullFace(this._stackCullFaceFacing[this._stackCullFaceFacing.length - 1]);
    }

    /**
     * current state of face culling side
     * @function stateCullFaceFacing
     * @returns {Boolean} enabled
     * @memberof Context
     * @instance
     */
    stateCullFaceFacing()
    {
        return this._stackCullFaceFacing[this._stackCullFaceFacing.length - 1];
    }

    /**
     * pop face culling face side
     * @function popCullFaceFacing
     * @memberof Context
     * @instance
     */
    popCullFaceFacing()
    {
        this._stackCullFaceFacing.pop();
        if (this._stackCullFaceFacing.length > 0) this.gl.cullFace(this._stackCullFaceFacing[this._stackCullFaceFacing.length - 1]);
    }

    // --------------------------------------
    // state depthfunc

    /**
     * enable / disable depth testing
     * like `gl.depthFunc(boolean);`
     * @function pushDepthFunc
     * @memberof Context
     * @instance
     * @param {Boolean} f depthtesting
     */
    pushDepthFunc(f)
    {
        this._stackDepthFunc.push(f);
        this.gl.depthFunc(f);
    }

    /**
     * current state of blend
     * @function stateDepthFunc
     * @memberof Context
     * @instance
     * @returns {Boolean} depth testing enabled/disabled
     */
    stateDepthFunc()
    {
        if (this._stackDepthFunc.length > 0) return this._stackDepthFunc[this._stackDepthFunc.length - 1];
        return false;
    }

    /**
     * pop depth testing and set the previous state
     * @function popDepthFunc
     * @memberof Context
     * @instance
     */
    popDepthFunc()
    {
        this._stackDepthFunc.pop();
        if (this._stackDepthFunc.length > 0) this.gl.depthFunc(this._stackDepthFunc[this._stackDepthFunc.length - 1]);
    }

    // --------------------------------------
    // state blending

    /**
     * enable / disable blend
     * like gl.enable(gl.BLEND); / gl.disable(gl.BLEND);
     * @function pushBlend
     * @memberof Context
     * @instance
     * @param {boolean} b blending
     */
    pushBlend(b)
    {
        this._stackBlend.push(b);
        if (!b) this.gl.disable(this.gl.BLEND);
        else this.gl.enable(this.gl.BLEND);
    }

    /**
     * pop blend state and set the previous state
     * @function popBlend
     * @memberof Context
     * @instance
     */
    popBlend()
    {
        this._stackBlend.pop();

        if (!this._stackBlend[this._stackBlend.length - 1]) this.gl.disable(this.gl.BLEND);
        else this.gl.enable(this.gl.BLEND);
    }

    /**
     * current state of blend
     * @function stateBlend
     * @returns {boolean} blending enabled/disabled
     * @memberof Context
     * @instance
     */
    stateBlend()
    {
        return this._stackBlend[this._stackBlend.length - 1];
    }

    /**
     * push and switch to predefined blendmode (CONSTANTS.BLEND_MODES.BLEND_NONE,CONSTANTS.BLEND_MODES.BLEND_NORMAL,CONSTANTS.BLEND_MODES.BLEND_ADD,CONSTANTS.BLEND_MODES.BLEND_SUB,CONSTANTS.BLEND_MODES.BLEND_MUL)
     * @function pushBlendMode
     * @memberof Context
     * @instance
     * @param {Number} blendMode
     * @param {Boolean} premul premultiplied mode
     */
    pushBlendMode(blendMode, premul)
    {
        this._stackBlendMode.push(blendMode);
        this._stackBlendModePremul.push(premul);

        const n = this._stackBlendMode.length - 1;

        this.pushBlend(this._stackBlendMode[n] !== CONSTANTS.BLEND_MODES.BLEND_NONE);
        this._setBlendMode(this._stackBlendMode[n], this._stackBlendModePremul[n]);
    }

    /**
     * pop predefined blendmode / switch back to previous blendmode
     * @function popBlendMode
     * @memberof Context
     * @instance
     */
    popBlendMode()
    {
        this._stackBlendMode.pop();
        this._stackBlendModePremul.pop();

        const n = this._stackBlendMode.length - 1;

        this.popBlend();

        if (n >= 0) this._setBlendMode(this._stackBlendMode[n], this._stackBlendModePremul[n]);
    }

    // --------------------------------------
    // state stencil

    /**
     * enable / disable stencil testing

    * @function pushStencil
    * @memberof Context
    * @instance
    * @param {Boolean} b enable
    */
    pushStencil(b)
    {
        this._stackStencil.push(b);
        if (!b) this.gl.disable(this.gl.STENCIL_TEST);
        else this.gl.enable(this.gl.STENCIL_TEST);
    }

    /**
     * pop stencil test state and set the previous state
     * @function popStencil
     * @memberof Context
     * @instance
     */
    popStencil()
    {
        this._stackStencil.pop();

        if (!this._stackStencil[this._stackStencil.length - 1]) this.gl.disable(this.gl.STENCIL_TEST);
        else this.gl.enable(this.gl.STENCIL_TEST);
    }

    // --------------------------------------

    glGetAttribLocation(prog, name)
    {
        const l = this.gl.getAttribLocation(prog, name);
        // if (l == -1)
        // {
        //     this._log.warn("get attr loc -1 ", name);
        // }
        return l;
    }

    /**
     * should an op now draw helpermeshes
     * @param {Op} op
     */
    shouldDrawHelpers(op)
    {
        if (this.tempData.shadowPass) return false;
        if (!op.patch.isEditorMode()) return false;
        return gui.shouldDrawOverlay;
    }

    _setBlendMode(blendMode, premul)
    {
        const gl = this.gl;

        if (blendMode == CONSTANTS.BLEND_MODES.BLEND_NONE)
        {
            // this.gl.disable(this.gl.BLEND);
        }
        else if (blendMode == CONSTANTS.BLEND_MODES.BLEND_ADD)
        {
            if (premul)
            {
                gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
                gl.blendFuncSeparate(gl.ONE, gl.ONE, gl.ONE, gl.ONE);
            }
            else
            {
                gl.blendEquation(gl.FUNC_ADD);
                gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
            }
        }
        else if (blendMode == CONSTANTS.BLEND_MODES.BLEND_SUB)
        {
            if (premul)
            {
                gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
                gl.blendFuncSeparate(gl.ZERO, gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ONE_MINUS_SRC_ALPHA);
            }
            else
            {
                gl.blendEquation(gl.FUNC_ADD);
                gl.blendFunc(gl.ZERO, gl.ONE_MINUS_SRC_COLOR);
            }
        }
        else if (blendMode == CONSTANTS.BLEND_MODES.BLEND_MUL)
        {
            if (premul)
            {
                gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
                gl.blendFuncSeparate(gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA);
            }
            else
            {
                gl.blendEquation(gl.FUNC_ADD);
                gl.blendFunc(gl.ZERO, gl.SRC_COLOR);
            }
        }
        else if (blendMode == CONSTANTS.BLEND_MODES.BLEND_NORMAL)
        {
            if (premul)
            {
                gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
                gl.blendFuncSeparate(gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
            }
            else
            {
                gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
                gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
            }
        }
        else
        {
            this._log.log("setblendmode: unknown blendmode");
        }
    }

    /**
     * @param {Geometry} geom
     * @param {CglMeshOptions} options
     */
    createMesh(geom, options)
    {
        if (external_CABLES_namespaceObject.utils.isNumeric(options))options = { "glPrimitive": options }; // old constructor fallback...
        return new Mesh(this, geom, options);
    }

    /**
     * set cursor
     * @function setCursor
     * @memberof Context
     * @instance
     * @param {String} str css cursor string
     */
    setCursor(str)
    {
        this._cursor = str;
    }

    /**
     * enable a webgl extension
     * @function enableExtension
     * @memberof Context
     * @instance
     * @param {String} name extension name
     * @returns {Object} extension object or null
     */
    enableExtension(name)
    {
        if (!this.gl) return null;

        if (this._enabledExtensions.hasOwnProperty(name))
            return this._enabledExtensions[name];

        const o = this.gl.getExtension(name);
        this._enabledExtensions[name] = o;

        if (!o) this._log.warn("[cgl_state] extension not available " + name);

        return o;
    }

    getErrorShader()
    {
        if (this.errorShader) return this.errorShader;

        this.errorShader = new CglShader(this, "errormaterial");
        this.errorShader.setSource(CglShader.getDefaultVertexShader(), CglShader.getErrorFragmentShader());
        return this.errorShader;
    }

}

;// CONCATENATED MODULE: ./src/corelibs/cgl/index.js

















const cgl_CGL = {
    "Framebuffer2": Framebuffer2,
    "Geometry": Geometry,
    "BoundingBox": BoundingBox,
    "Marker": Marker,
    "WirePoint": WirePoint,
    "WireCube": WireCube,
    "MatrixStack": MatrixStack,
    "Mesh": Mesh,
    "MESH": MESH,
    "ShaderLibMods": ShaderLibMods,
    "Shader": CglShader,
    "Uniform": Uniform,
    "MESHES": MESHES,
    "getWheelSpeed": getWheelSpeed,
    "getWheelDelta": getWheelDelta,
    "Context": CglContext,
    "Texture": Texture,
    "TextureEffect": TextureEffect,
    "onLoadingAssetsFinished": onLoadingAssetsFinished,
    "ProfileData": ProfileData,
    "UniColorShader": UniColorShader,
    ...CONSTANTS.BLEND_MODES,
    ...CONSTANTS.SHADER,
    ...CONSTANTS.MATH,
    ...CONSTANTS.BLEND_MODES,
};

window.CABLES = window.CABLES || {};
window.CABLES.CGL = window.CABLES.CGL || cgl_CGL;
window.CGL = window.CGL || cgl_CGL;

/**
 * @param {number} time
 * @param {quat} q
 * @param {Anim} animx
 * @param {Anim} animy
 * @param {Anim} animz
 * @param {Anim} animw
 */
external_CABLES_namespaceObject.Anim.slerpQuaternion = function (time, q, animx, animy, animz, animw)
{
    if (!external_CABLES_namespaceObject.Anim.slerpQuaternion.q1)
    {
        external_CABLES_namespaceObject.Anim.slerpQuaternion.q1 = quat.create();
        external_CABLES_namespaceObject.Anim.slerpQuaternion.q2 = quat.create();
    }

    const i1 = animx.getKeyIndex(time);
    let i2 = i1 + 1;
    if (i2 >= animx.keys.length) i2 = animx.keys.length - 1;

    if (i1 == i2)
    {
        quat.set(q, animx.keys[i1].value, animy.keys[i1].value, animz.keys[i1].value, animw.keys[i1].value);
    }
    else
    {
        const key1Time = animx.keys[i1].time;
        const key2Time = animx.keys[i2].time;
        const perc = (time - key1Time) / (key2Time - key1Time);

        quat.set(external_CABLES_namespaceObject.Anim.slerpQuaternion.q1, animx.keys[i1].value, animy.keys[i1].value, animz.keys[i1].value, animw.keys[i1].value);

        quat.set(external_CABLES_namespaceObject.Anim.slerpQuaternion.q2, animx.keys[i2].value, animy.keys[i2].value, animz.keys[i2].value, animw.keys[i2].value);

        quat.slerp(q, external_CABLES_namespaceObject.Anim.slerpQuaternion.q1, external_CABLES_namespaceObject.Anim.slerpQuaternion.q2, perc);
    }
    return q;
};



;// CONCATENATED MODULE: ./src/corelibs/cgl_copytexture/cgl_copytexture.js


class CopyTexture
{
    constructor(cgl, name, options)
    {
        this.cgl = cgl;

        this._options = options;
        this.fb = null;

        let shader = options.shader;

        this._useDefaultShader = true;
        if (options.shader) this._useDefaultShader = false;

        options.numRenderBuffers = options.numRenderBuffers || 1;

        if (!shader)
        {
            shader = ""
                .endl() + "IN vec2 texCoord;";

            for (let i = 0; i < options.numRenderBuffers; i++)
            {
                shader = shader.endl() + "UNI sampler2D tex" + i + ";".endl();
            }

            shader = shader
                .endl() + "void main()"
                .endl() + "{";

            if (options.numRenderBuffers == 1)
            {
                shader = shader.endl() + "    outColor= texture(tex0,texCoord);".endl();
            }

            else
                for (let i = 0; i < options.numRenderBuffers; i++)
                {
                    shader = shader.endl() + "outColor" + i + " = texture(tex" + i + ",texCoord);".endl();
                }

            shader = shader.endl() + "}";
        }

        const verts = options.vertexShader || ""
            .endl() + "IN vec3 vPosition;"
            .endl() + "IN vec2 attrTexCoord;"

            .endl() + "OUT vec2 texCoord;"

            .endl() + "void main()"
            .endl() + "{"
            .endl() + "   texCoord=attrTexCoord;"
            .endl() + "   gl_Position = vec4(vPosition,  1.0);"
            .endl() + "}";

        this.bgShader = new cgl_CGL.Shader(cgl, "corelib copytexture " + name);
        this.bgShader.setSource(verts, shader);

        if (!options.vertexShader)
            this.bgShader.ignoreMissingUniforms = true;

        new cgl_CGL.Uniform(this.bgShader, "t", "tex", 0);
        new cgl_CGL.Uniform(this.bgShader, "t", "tex1", 1);
        new cgl_CGL.Uniform(this.bgShader, "t", "tex2", 2);
        new cgl_CGL.Uniform(this.bgShader, "t", "tex3", 3);

        this.mesh = cgl_CGL.MESHES.getSimpleRect(this.cgl, "texEffectRect");
    }

    setSize(w, h)
    {
        this._options.width = w;
        this._options.height = h;
    }

    copy(tex, tex1, tex2, tex3, tex4)
    {
        const cgl = this.cgl;
        if (!tex) tex = cgl_CGL.Texture.getEmptyTexture(this.cgl);
        let
            w = this._options.width || tex.width,
            h = this._options.height || tex.height;

        if (this.fb)
        {
            if (w <= 0)w = 8;
            if (h <= 0)h = 8;
            if (this.fb.getWidth() != w || this.fb.getHeight() != h) this.fb.setSize(w, h);
        }
        else
        {
            let filter = cgl_CGL.Texture.FILTER_LINEAR;
            let wrap = cgl_CGL.Texture.WRAP_CLAMP_TO_EDGE;

            if (this._options.isFloatingPointTexture)filter = cgl_CGL.Texture.FILTER_NEAREST;

            if (this._options.hasOwnProperty("filter"))filter = this._options.filter;
            if (this._options.hasOwnProperty("wrap"))wrap = this._options.wrap;

            const options =
                {
                    "isFloatingPointTexture": this._options.isFloatingPointTexture,
                    "pixelFormat": this._options.pixelFormat,
                    "numRenderBuffers": this._options.numRenderBuffers || 1,
                    "filter": filter,
                    "wrap": wrap,
                };

            if (cgl.glVersion == 1) this.fb = new cgl_CGL.Framebuffer(cgl, w, h, options);
            else this.fb = new cgl_CGL.Framebuffer2(cgl, w, h, options);
        }

        cgl.tempData.renderOffscreen = true;
        this.fb.renderStart(cgl);

        cgl.setTexture(0, tex.tex);
        if (tex1) cgl.setTexture(1, tex1.tex);
        if (tex2) cgl.setTexture(2, tex2.tex);
        if (tex3) cgl.setTexture(3, tex3.tex);
        if (tex4) cgl.setTexture(4, tex4.tex);

        cgl.pushShader(this.bgShader);
        this.mesh.render(this.bgShader);
        cgl.popShader();

        this.fb.renderEnd();
        cgl.tempData.renderOffscreen = false;

        return this.fb.getTextureColor();
    }

    dispose()
    {
        if (this.fb) this.fb.dispose();
        if (this.bgShader) this.bgShader.dispose();
        if (this.mesh) this.mesh.dispose();
    }
}

})();

var __webpack_export_target__ = (CGL = typeof CGL === "undefined" ? {} : CGL);
for(var i in __webpack_exports__) __webpack_export_target__[i] = __webpack_exports__[i];
if(__webpack_exports__.__esModule) Object.defineProperty(__webpack_export_target__, "__esModule", { value: true });
/******/ })()
;// end js/cgl_copytexture.js
// start js/cgl_pixelreader.js
/******/ (() => { // webpackBootstrap
/******/ 	// runtime can't be in strict mode because a global variable is assign and maybe created.
/******/ 	// The require scope
/******/ 	var __webpack_require__ = {};
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  PixelReader: () => (/* binding */ PixelReader)
});

;// CONCATENATED MODULE: external "CABLES.SHARED"
const external_CABLES_SHARED_namespaceObject = CABLES.SHARED;
;// CONCATENATED MODULE: ./src/corelibs/cgl_pixelreader/cgl_pixelreader.js


class PixelReader
{
    constructor()
    {
        this._log = new external_CABLES_SHARED_namespaceObject.Logger("LoadingStatus");

        this.pixelData = null;
        this._finishedFence = true;
        this._size = 0;
        this._pbo = null;
    }

    _fence(cgl)
    {
        const gl = cgl.gl;
        this._finishedFence = false;
        return new Promise(function (resolve, reject)
        {
            if (cgl.aborted) return;
            let sync = gl.fenceSync(gl.SYNC_GPU_COMMANDS_COMPLETE, 0);
            if (!sync) return;
            gl.flush(); // Ensure the fence is submitted.

            function check()
            {
                if (cgl.aborted) return;
                const status = gl.clientWaitSync(sync, 0, 0);

                if (status == gl.WAIT_FAILED)
                {
                    console.error("fence wait failed");
                    if (reject) reject();
                }
                else
                if (status == gl.TIMEOUT_EXPIRED)
                {
                    // this._log.log("TIMEOUT_EXPIRED");
                    return setTimeout(check, 0);
                }
                else
                if (status == gl.CONDITION_SATISFIED)
                {
                    // this._log.log("CONDITION_SATISFIED");
                    resolve();
                    gl.deleteSync(sync);
                }
                else if (status == gl.ALREADY_SIGNALED)
                {
                    // this._log.log("already signaled");
                    resolve();
                    gl.deleteSync(sync);
                }
                else
                {
                    this._log.log("unknown fence status", status);
                }
            }

            // setTimeout(check, 3);
            check();
        });
    }

    read(cgl, fb, pixelFormat, x, y, w, h, finishedcb)
    {
        if (CABLES.UI)
            if (!CABLES.UI.loaded || performance.now() - CABLES.UI.loadedTime < 1000) return;

        if (!this._finishedFence) return;

        const gl = cgl.gl;
        let bytesPerItem = 1;

        if (cgl.aborted) return;
        if (!fb) return;

        if (pixelFormat === CGL.Texture.TYPE_FLOAT) pixelFormat = CGL.Texture.PFORMATSTR_RGBA32F;
        // let isFloatingPoint = pixelFormat == CGL.Texture.TYPE_FLOAT; // old parameter was "textureType", now it is pixelformat, keeping this for compatibility...

        let isFloatingPoint = CGL.Texture.isPixelFormatFloat(pixelFormat);

        if (isFloatingPoint)bytesPerItem = 4;
        if (CGL.Texture.isPixelFormatHalfFloat(pixelFormat)) bytesPerItem = 2;

        const pixelInfo = CGL.Texture.setUpGlPixelFormat(cgl, pixelFormat);
        const numItems = pixelInfo.numColorChannels * w * h;

        if (w == 0 || h == 0 || numItems == 0) return;

        if (!this._pixelData || this._size != numItems * bytesPerItem)
        {
            if (bytesPerItem > 1) this._pixelData = new Float32Array(numItems);
            else this._pixelData = new Uint8Array(numItems);

            this._size = numItems * bytesPerItem;
        }

        let channelType = gl.UNSIGNED_BYTE;
        if (bytesPerItem > 1)channelType = gl.FLOAT;

        if (this._size == 0 || !this._pixelData)
        {
            this._log.error("readpixel size 0", this._size, w, h);
            return;
        }

        if (this._finishedFence)
        {
            this._pbo = gl.createBuffer();
            gl.bindBuffer(gl.PIXEL_PACK_BUFFER, this._pbo);
            gl.bufferData(gl.PIXEL_PACK_BUFFER, this._pixelData.byteLength, gl.DYNAMIC_READ);
            gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
            gl.bindBuffer(gl.PIXEL_PACK_BUFFER, this._pbo);
            cgl.profileData.profileFencedPixelRead++;

            if (this._size != numItems * bytesPerItem)
                this._log.error("buffer size invalid", numItems, w, h, bytesPerItem);

            let dataType = pixelInfo.glDataType;
            if (bytesPerItem > 1)dataType = cgl.gl.FLOAT;

            let format = pixelInfo.glDataFormat;
            gl.readPixels(x, y, w, h, format, dataType, 0);

            gl.bindBuffer(gl.PIXEL_PACK_BUFFER, null);
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        }
        let startLength = this._pixelData.byteLength;

        if (this._finishedFence && this._pbo)
            this._fence(cgl).then((error) =>
            {
                this._wasTriggered = false;
                this._finishedFence = true;

                if (!error && this._pixelData && this._pixelData.byteLength == startLength)
                {
                    gl.bindBuffer(gl.PIXEL_PACK_BUFFER, this._pbo);
                    gl.getBufferSubData(gl.PIXEL_PACK_BUFFER, 0, this._pixelData);
                    gl.bindBuffer(gl.PIXEL_PACK_BUFFER, null);

                    if (finishedcb) finishedcb(this._pixelData);
                }
                gl.deleteBuffer(this._pbo);
                this._pbo = null;
            });

        return true;
    }
}

})();

var __webpack_export_target__ = (CGL = typeof CGL === "undefined" ? {} : CGL);
for(var i in __webpack_exports__) __webpack_export_target__[i] = __webpack_exports__[i];
if(__webpack_exports__.__esModule) Object.defineProperty(__webpack_export_target__, "__esModule", { value: true });
/******/ })()
;// end js/cgl_pixelreader.js
